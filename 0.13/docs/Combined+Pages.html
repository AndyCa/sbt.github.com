<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>sbt Reference Manual — Combined Pages</title>
        
        <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/blueprint/grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print"/> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href={ relativeBase + "css/blueprint/ie.css" } type="text/css" media="screen, projection"/>
        <![endif]-->
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_80px_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery.collapse.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/custom.css" type="text/css" media="screen, projection"/>
        
        
      </head>
      <body class="color_scheme-github">
        <a class="page prev nav" href="Contents+in+Depth.html">
            <span class="space">&nbsp;</span>
            <span class="flip arrow">&gt;</span>
          </a>
        <div class="container contentswrapper">
          <div class="span-16 prepend-1 append-1 contents">
            <div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="#sbt+Reference+Manual">sbt Reference Manual</a></div><ol class="toc"> <li><div><a href="#General+Information">General Information</a></div><ol class="toc"> <li><div><a href="#Credits">Credits</a></div></li><li><div><a href="#Community+Plugins">Community Plugins</a></div></li><li><div><a href="#Community+Repository+Policy">Community Repository Policy</a></div></li><li><div><a href="#Bintray+For+Plugins">Bintray For Plugins</a></div></li><li><div><a href="#Setup+Notes">Setup Notes</a></div></li><li><div><a href="#Deploying+to+Sonatype">Deploying to Sonatype</a></div></li><li><div><a href="#Changes">Changes</a></div><ol class="toc"> <li><div><a href="#sbt+0.13.0+Changes">sbt 0.13.0 Changes</a></div></li><li><div><a href="#sbt+0.12.0+Changes">sbt 0.12.0 Changes</a></div></li><li><div><a href="#Older+Changes">Older Changes</a></div></li><li><div><a href="#Migrating+from+0.7+to+0.10%2B">Migrating from 0.7 to 0.10+</a></div></li> </ol></li><li><div><a href="#Contributing+to+sbt">Contributing to sbt</a></div></li> </ol></li><li><div><a href="#Frequently+Asked+Questions">Frequently Asked Questions</a></div><ol class="toc">  </ol></li><li><div><a href="#How+to%E2%80%A6">How to…</a></div><ol class="toc"> <li><div><a href="#Classpaths">Classpaths</a></div></li><li><div><a href="#Customizing+paths">Customizing paths</a></div></li><li><div><a href="#Generating+files">Generating files</a></div></li><li><div><a href="#Inspect+the+build">Inspect the build</a></div></li><li><div><a href="#Interactive+mode">Interactive mode</a></div></li><li><div><a href="#Configure+and+use+logging">Configure and use logging</a></div></li><li><div><a href="#Project+metadata">Project metadata</a></div></li><li><div><a href="#Configure+packaging">Configure packaging</a></div></li><li><div><a href="#Running+commands">Running commands</a></div></li><li><div><a href="#Configure+and+use+Scala">Configure and use Scala</a></div></li><li><div><a href="#Generate+API+documentation">Generate API documentation</a></div></li><li><div><a href="#Triggered+execution">Triggered execution</a></div></li><li><div><a href="#Examples">Examples</a></div><ol class="toc"> <li><div><a href="#.sbt+build+examples">.sbt build examples</a></div></li><li><div><a href="#.scala+build+example">.scala build example</a></div></li><li><div><a href="#Advanced+configurations+example">Advanced configurations example</a></div></li><li><div><a href="#Advanced+command+example">Advanced command example</a></div></li> </ol></li> </ol></li><li><div><a href="#Detailed+Topics">Detailed Topics</a></div><ol class="toc"> <li><div><a href="#Using+sbt">Using sbt</a></div><ol class="toc"> <li><div><a href="#Command+Line+Reference">Command Line Reference</a></div></li><li><div><a href="#Console+Project">Console Project</a></div></li><li><div><a href="#Cross-building">Cross-building</a></div></li><li><div><a href="#Interacting+with+the+Configuration+System">Interacting with the Configuration System</a></div></li><li><div><a href="#Triggered+Execution">Triggered Execution</a></div></li><li><div><a href="#Scripts%2C+REPL%2C+and+Dependencies">Scripts, REPL, and Dependencies</a></div></li><li><div><a href="#Understanding+Incremental+Recompilation">Understanding Incremental Recompilation</a></div></li> </ol></li><li><div><a href="#Configuration">Configuration</a></div><ol class="toc"> <li><div><a href="#Classpaths%2C+sources%2C+and+resources">Classpaths, sources, and resources</a></div></li><li><div><a href="#Compiler+Plugin+Support">Compiler Plugin Support</a></div></li><li><div><a href="#Configuring+Scala">Configuring Scala</a></div></li><li><div><a href="#Forking">Forking</a></div></li><li><div><a href="#Global+Settings">Global Settings</a></div></li><li><div><a href="#Java+Sources">Java Sources</a></div></li><li><div><a href="#Mapping+Files">Mapping Files</a></div></li><li><div><a href="#Local+Scala">Local Scala</a></div></li><li><div><a href="#Macro+Projects">Macro Projects</a></div></li><li><div><a href="#Paths">Paths</a></div></li><li><div><a href="#Parallel+Execution">Parallel Execution</a></div></li><li><div><a href="#External+Processes">External Processes</a></div></li><li><div><a href="#Running+Project+Code">Running Project Code</a></div></li><li><div><a href="#Testing">Testing</a></div></li> </ol></li><li><div><a href="#Dependency+Management">Dependency Management</a></div><ol class="toc"> <li><div><a href="#Artifacts">Artifacts</a></div></li><li><div><a href="#Dependency+Management+Flow">Dependency Management Flow</a></div></li><li><div><a href="#Library+Management">Library Management</a></div></li><li><div><a href="#Proxy+Repositories">Proxy Repositories</a></div></li><li><div><a href="#Publishing">Publishing</a></div></li><li><div><a href="#Resolvers">Resolvers</a></div></li><li><div><a href="#Update+Report">Update Report</a></div></li> </ol></li><li><div><a href="#Tasks+and+Commands">Tasks and Commands</a></div><ol class="toc"> <li><div><a href="#Tasks">Tasks</a></div></li><li><div><a href="#Input+Tasks">Input Tasks</a></div></li><li><div><a href="#Commands">Commands</a></div></li><li><div><a href="#Parsing+and+tab+completion">Parsing and tab completion</a></div></li><li><div><a href="#State+and+actions">State and actions</a></div></li><li><div><a href="#Tasks%2FSettings%3A+Motivation">Tasks/Settings: Motivation</a></div></li> </ol></li><li><div><a href="#Plugins+and+Best+Practices">Plugins and Best Practices</a></div><ol class="toc"> <li><div><a href="#General+Best+Practices">General Best Practices</a></div></li><li><div><a href="#Plugins">Plugins</a></div></li><li><div><a href="#Plugins+Best+Practices">Plugins Best Practices</a></div></li> </ol></li><li><div><a href="#Sbt+Launcher">Sbt Launcher</a></div><ol class="toc"> <li><div><a href="#Getting+Started+with+the+Sbt+Launcher">Getting Started with the Sbt Launcher</a></div></li><li><div><a href="#Sbt+Launcher+Architecture">Sbt Launcher Architecture</a></div></li><li><div><a href="#Sbt+Launcher+Configuration">Sbt Launcher Configuration</a></div></li> </ol></li> </ol></li><li><div><a href="#Developer%E2%80%99s+Guide">Developer’s Guide</a></div><ol class="toc"> <li><div><a href="#Core+Principles">Core Principles</a></div></li><li><div><a href="#Settings+Core">Settings Core</a></div></li><li><div><a href="#Setting+Initialization">Setting Initialization</a></div></li><li><div><a href="#Build+Loaders">Build Loaders</a></div></li><li><div><a href="#Creating+Command+Line+Applications+Using+sbt">Creating Command Line Applications Using sbt</a></div></li><li><div><a href="#Nightly+Builds">Nightly Builds</a></div></li> </ol></li><li><div><a href="#Index">Index</a></div></li> </ol></div></div><h1 id="sbt+Reference+Manual">sbt Reference Manual<a href="#sbt+Reference+Manual" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><p>sbt is a build tool for Scala, Java, and
<a href="https://github.com/d40cht/sbt-cpp">more</a>. It requires Java 1.6 or
later.
</p><h3 id="Install">Install<a href="#Install" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See <a href="../tutorial/Setup.html">Installing sbt</a> for the setup instructions.
</p><h3 id="Getting+Started">Getting Started<a href="#Getting+Started" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To get started, <em>please read</em> the
<a href="../tutorial/index.html">Getting Started Guide</a>. You will save
yourself a <em>lot</em> of time if you have the right understanding of the big
picture up-front.
All documentation may be found via the table of contents included at the end of every page.
</p><p>Use <a href="http://stackoverflow.com/tags/sbt">Stack Overflow</a> for
questions. Use the <a href="https://groups.google.com/d/forum/sbt-dev">sbt-dev mailing list</a> for discussing sbt
development. Use <a href="https://twitter.com/scala_sbt">@scala_sbt</a> for questions and discussions.
</p><h3 id="Features+of+sbt">Features of sbt<a href="#Features+of+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Little or no configuration required for simple projects
</li><li>Scala-based <a href="../tutorial/Basic-Def.html">build definition</a> that can
use the full flexibility of Scala code
</li><li>Accurate incremental recompilation using information extracted from
the compiler
</li><li>Continuous compilation and testing with
<a href="Triggered-Execution.html">triggered execution</a>
</li><li>Packages and publishes jars
</li><li>Generates documentation with scaladoc
</li><li>Supports mixed Scala/<a href="Java-Sources.html">Java</a> projects
</li><li>Supports <a href="Testing.html">testing</a> with ScalaCheck,
specs, and ScalaTest. JUnit is supported by a plugin.
</li><li>Starts the Scala REPL with project classes and dependencies on the
classpath
</li><li>Modularization supported with
<a href="../tutorial/Multi-Project.html">sub-projects</a>
</li><li>External project support (list a git repository as a dependency!)
</li><li><a href="Parallel-Execution.html">Parallel task execution</a>,
including parallel test execution
</li><li><a href="../tutorial/Library-Dependencies.html">Library management support</a>:
inline declarations, external Ivy or Maven configuration files, or
manual management
</li></ul><h3 id="Also">Also<a href="#Also" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This documentation can be forked
on <a href="https://github.com/sbt/website/">GitHub</a>. Feel free to make
corrections and add documentation.
</p><p>Documentation for 0.7.x has been
<a href="http://www.scala-sbt.org/0.7.7/docs/home.html">archived here</a>. This
documentation applies to sbt 0.13.5.
</p><p>See also the <a href="../api/index.html">API Documentation</a>,
<a href="../sxr/index.html">SXR Documentation</a>, and the
<a href="Name-Index.html">index of names and types</a>.
</p><h2 id="General+Information">General Information<a href="#General+Information" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has project “meta-information” such as
where to get help, find source code and how to contribute.
</p><h2 id="Credits">Credits<a href="#Credits" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>See the
<a href="https://github.com/sbt/sbt/graphs/contributors">sbt contributors on GitHub</a>
and
<a href="https://github.com/sbt?tab=members">sbt GitHub organization members</a>.
</p><p>Additionally, these people have contributed ideas, documentation, or
code to sbt but are not recorded in either of the above:
</p><ul><li>Josh Cough
</li><li>Nolan Darilek
</li><li>Nathan Hamblen
</li><li>Ismael Juma
</li><li>Viktor Klang
</li><li>David R. MacIver
</li><li>Ross McDonald
</li><li>Andrew O’Malley
</li><li>Jorge Ortiz
</li><li>Mikko Peltonen
</li><li>Ray Racine
</li><li>Stuart Roebuck
</li><li>Harshad RJ
</li><li>Tony Sloane
</li><li>Seth Tisue
</li><li>Francisco Treacy
</li><li>Vesa Vilhonen
</li></ul><h2 id="Community+Plugins">Community Plugins<a href="#Community+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="sbt+Organization">sbt Organization<a href="#sbt+Organization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <a href="http://github.com/sbt">sbt organization</a> is available for use by
any sbt plugin. Developers who contribute their plugins into the
community organization will still retain control over their repository
and its access. The goal of the sbt organization is to organize sbt
software into one central location.
</p><p>A side benefit to using the sbt organization for projects is that you
can use gh-pages to host websites in the http://scala-sbt.org domain.
</p><h3 id="Community+Ivy+Repository">Community Ivy Repository<a href="#Community+Ivy+Repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><a href="http://www.typesafe.com">Typesafe</a> has provided a freely available
<a href="http://repo.scala-sbt.org/scalasbt">Ivy Repository</a> for sbt projects
to use. This ivy repository is mirrored from the freely available
<a href="http://bintray.com">Bintray service</a>.
If you’d like to submit your plugin, please follow these instructions:
<a href="Bintray-For-Plugins.html">Bintray For Plugins</a>.
</p><h3 id="Available+Plugins">Available Plugins<a href="#Available+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Please feel free to
<a href="https://github.com/sbt/website/pulls">submit a pull request</a> that adds
your plugin to the list.
</p><h4 id="Plugins+for+IDEs">Plugins for IDEs<a href="#Plugins+for+IDEs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>IntelliJ IDEA
</li><li>sbt Plugin to generate IDEA project configuration:
<a href="https://github.com/mpeltonen/sbt-idea">https://github.com/mpeltonen/sbt-idea</a>
</li><li>IDEA Plugin to embed an sbt Console into the IDE:
<a href="https://github.com/orfjackal/idea-sbt-plugin">https://github.com/orfjackal/idea-sbt-plugin</a>
</li><li>Netbeans: <a href="https://github.com/remeniuk/sbt-netbeans-plugin">https://github.com/remeniuk/sbt-netbeans-plugin</a>
</li><li>Eclipse: <a href="https://github.com/typesafehub/sbteclipse">https://github.com/typesafehub/sbteclipse</a>
</li><li>Sublime Text: <a href="https://github.com/orrsella/sbt-sublime">https://github.com/orrsella/sbt-sublime</a>
</li><li>Ensime: <a href="https://github.com/aemoncannon/ensime-sbt-cmd">https://github.com/aemoncannon/ensime-sbt-cmd</a>
</li><li>sbt-mode for Emacs: <a href="https://github.com/hvesalai/sbt-mode">https://github.com/hvesalai/sbt-mode</a>
</li><li>sbt-ctags (manage library dependency sources for vim, emacs,
sublime) <a href="https://github.com/kalmanb/sbt-ctags">https://github.com/kalmanb/sbt-ctags</a>
</li></ul><h4 id="Web+Plugins">Web Plugins<a href="#Web+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>xsbt-web-plugin:
<a href="https://github.com/JamesEarlDouglas/xsbt-web-plugin">https://github.com/JamesEarlDouglas/xsbt-web-plugin</a>
</li><li>xsbt-webstart: <a href="https://github.com/ritschwumm/xsbt-webstart">https://github.com/ritschwumm/xsbt-webstart</a>
</li><li>sbt-appengine: <a href="https://github.com/sbt/sbt-appengine">https://github.com/sbt/sbt-appengine</a>
</li><li>sbt-gwt-plugin: <a href="https://github.com/thunderklaus/sbt-gwt-plugin">https://github.com/thunderklaus/sbt-gwt-plugin</a>
</li><li>sbt-cloudbees-plugin:
<a href="https://github.com/timperrett/sbt-cloudbees-plugin">https://github.com/timperrett/sbt-cloudbees-plugin</a>
</li><li>sbt-jelastic-deploy:
<a href="https://github.com/casualjim/sbt-jelastic-deploy">https://github.com/casualjim/sbt-jelastic-deploy</a>
</li></ul><h3 id="Test+plugins">Test plugins<a href="#Test+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>junit<em>xml</em>listener: <a href="https://github.com/ijuma/junit_xml_listener">https://github.com/ijuma/junit_xml_listener</a>
</li><li>sbt-growl-plugin: <a href="https://github.com/softprops/sbt-growl-plugin">https://github.com/softprops/sbt-growl-plugin</a>
</li><li>sbt-teamcity-test-reporting-plugin:
<a href="https://github.com/guardian/sbt-teamcity-test-reporting-plugin">https://github.com/guardian/sbt-teamcity-test-reporting-plugin</a>
</li><li>xsbt-cucumber-plugin:
<a href="https://github.com/skipoleschris/xsbt-cucumber-plugin">https://github.com/skipoleschris/xsbt-cucumber-plugin</a>
</li><li>sbt-multi-jvm: <a href="https://github.com/typesafehub/sbt-multi-jvm">https://github.com/typesafehub/sbt-multi-jvm</a>
</li><li>sbt-testng-interface: <a href="https://github.com/sbt/sbt-testng-interface">https://github.com/sbt/sbt-testng-interface</a>
</li><li>schoir (Distributed testing plugin):
<a href="https://github.com/typesafehub/schoir">https://github.com/typesafehub/schoir</a>
</li></ul><h4 id="Static+Code+Analysis+plugins">Static Code Analysis plugins<a href="#Static+Code+Analysis+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>cpd4sbt: <a href="https://github.com/sbt/cpd4sbt">https://github.com/sbt/cpd4sbt</a> (copy/paste detection,
works for Scala, too)
</li><li>findbugs4sbt: <a href="https://github.com/sbt/findbugs4sbt">https://github.com/sbt/findbugs4sbt</a> (FindBugs only
supports Java projects atm)
</li><li>scalastyle: <a href="https://github.com/scalastyle/scalastyle-sbt-plugin">https://github.com/scalastyle/scalastyle-sbt-plugin</a>
(Scalastyle - static code checker for Scala)
</li><li>sbt-stats: <a href="https://github.com/orrsella/sbt-stats">https://github.com/orrsella/sbt-stats</a> (simple,
extensible source code statistics)
</li></ul><h4 id="One+jar+plugins">One jar plugins<a href="#One+jar+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-assembly: <a href="https://github.com/sbt/sbt-assembly">https://github.com/sbt/sbt-assembly</a>
</li><li>xsbt-proguard-plugin:
<a href="https://github.com/adamw/xsbt-proguard-plugin">https://github.com/adamw/xsbt-proguard-plugin</a>
</li><li>sbt-deploy: <a href="https://github.com/reaktor/sbt-deploy">https://github.com/reaktor/sbt-deploy</a>
</li><li>sbt-appbundle (os x standalone):
<a href="https://github.com/sbt/sbt-appbundle">https://github.com/sbt/sbt-appbundle</a>
</li><li>sbt-onejar (Packages your project using One-JAR™):
<a href="https://github.com/sbt/sbt-onejar">https://github.com/sbt/sbt-onejar</a>
</li></ul><h4 id="Frontend+development+plugins">Frontend development plugins<a href="#Frontend+development+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>coffeescripted-sbt:
<a href="https://github.com/softprops/coffeescripted-sbt">https://github.com/softprops/coffeescripted-sbt</a>
</li><li>less-sbt (for less-1.3.0): <a href="https://github.com/softprops/less-sbt">https://github.com/softprops/less-sbt</a>
</li><li>sbt-less-plugin (it uses less-1.3.0):
<a href="https://github.com/btd/sbt-less-plugin">https://github.com/btd/sbt-less-plugin</a>
</li><li>sbt-emberjs: <a href="https://github.com/stefri/sbt-emberjs">https://github.com/stefri/sbt-emberjs</a>
</li><li>sbt-closure: <a href="https://github.com/eltimn/sbt-closure">https://github.com/eltimn/sbt-closure</a>
</li><li>sbt-imagej: <a href="https://github.com/jpsacha/sbt-imagej">https://github.com/jpsacha/sbt-imagej</a>
</li><li>sbt-yui-compressor:
<a href="https://github.com/indrajitr/sbt-yui-compressor">https://github.com/indrajitr/sbt-yui-compressor</a>
</li><li>sbt-requirejs: <a href="https://github.com/scalatra/sbt-requirejs">https://github.com/scalatra/sbt-requirejs</a>
</li><li>sbt-vaadin-plugin:
<a href="https://github.com/henrikerola/sbt-vaadin-plugin">https://github.com/henrikerola/sbt-vaadin-plugin</a>
</li></ul><h4 id="Game+development+plugins">Game development plugins<a href="#Game+development+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-lwjgl-plugin (Light Weight Java Game Library):
<a href="https://github.com/philcali/sbt-lwjgl-plugin">https://github.com/philcali/sbt-lwjgl-plugin</a>
</li><li>sbt-scage-plugin (Scala Game Engine):
<a href="https://github.com/mvallerie/sbt-scage-plugin">https://github.com/mvallerie/sbt-scage-plugin</a>
</li></ul><h4 id="Release+plugins">Release plugins<a href="#Release+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-aether-plugin (Published artifacts using Sonatype Aether):
<a href="https://github.com/arktekk/sbt-aether-deploy">https://github.com/arktekk/sbt-aether-deploy</a>
</li><li>posterous-sbt: <a href="https://github.com/n8han/posterous-sbt">https://github.com/n8han/posterous-sbt</a>
</li><li>sbt-signer-plugin: <a href="https://github.com/rossabaker/sbt-signer-plugin">https://github.com/rossabaker/sbt-signer-plugin</a>
</li><li>sbt-izpack (generates IzPack an installer):
<a href="http://software.clapper.org/sbt-izpack/">http://software.clapper.org/sbt-izpack/</a>
</li><li>sbt-ghpages-plugin (publishes generated site and api):
<a href="https://github.com/jsuereth/xsbt-ghpages-plugin">https://github.com/jsuereth/xsbt-ghpages-plugin</a>
</li><li>sbt-pgp (PGP signing plugin, can generate keys too):
<a href="https://github.com/sbt/sbt-pgp">https://github.com/sbt/sbt-pgp</a>
</li><li>sbt-release (customizable release process):
<a href="https://github.com/sbt/sbt-release">https://github.com/sbt/sbt-release</a>
</li><li>sbt-unique-version (emulates unique snapshots):
<a href="https://github.com/sbt/sbt-unique-version">https://github.com/sbt/sbt-unique-version</a>
</li><li>sbt-install4j: <a href="https://github.com/jpsacha/sbt-install4j">https://github.com/jpsacha/sbt-install4j</a>
</li><li>sbt-pack (generates packages with dependent jars and launch
scripts): <a href="https://github.com/xerial/sbt-pack">https://github.com/xerial/sbt-pack</a>
</li><li>sbt-start-script: <a href="https://github.com/sbt/sbt-start-script">https://github.com/sbt/sbt-start-script</a>
</li><li>sbt-native-packager: <a href="https://github.com/sbt/sbt-native-packager">https://github.com/sbt/sbt-native-packager</a>
</li><li>sbt-sonatype-plugin (releases to Sonatype Nexus repository)
<a href="https://github.com/xerial/sbt-sonatype">https://github.com/xerial/sbt-sonatype</a>
</li><li>xitrum-package (collects dependency .jar files for standalone Scala
programs): <a href="https://github.com/ngocdaothanh/xitrum-package">https://github.com/ngocdaothanh/xitrum-package</a>
</li></ul><h4 id="System+plugins">System plugins<a href="#System+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-sh (executes shell commands):
<a href="https://github.com/steppenwells/sbt-sh">https://github.com/steppenwells/sbt-sh</a>
</li><li>cronish-sbt (interval sbt / shell command execution):
<a href="https://github.com/philcali/cronish-sbt">https://github.com/philcali/cronish-sbt</a>
</li><li>git (executes git commands): <a href="https://github.com/sbt/sbt-git">https://github.com/sbt/sbt-git</a>
</li><li>svn (execute svn commands): <a href="https://github.com/xuwei-k/sbtsvn">https://github.com/xuwei-k/sbtsvn</a>
</li><li>sbt-groll (sbt plugin to navigate the Git history):
<a href="https://github.com/sbt/sbt-groll">https://github.com/sbt/sbt-groll</a>
</li><li>sbt-twt (twitter processor for sbt):
<a href="https://github.com/sbt/sbt-twt">https://github.com/sbt/sbt-twt</a>
</li></ul><h4 id="Code+generator+plugins">Code generator plugins<a href="#Code+generator+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-scalabuff (Google Protocol Buffers with native scala suppport
thru ScalaBuff): <a href="https://github.com/sbt/sbt-scalabuff">https://github.com/sbt/sbt-scalabuff</a>
</li><li>sbt-fmpp (FreeMarker Scala/Java Templating):
<a href="https://github.com/sbt/sbt-fmpp">https://github.com/sbt/sbt-fmpp</a>
</li><li>sbt-scalaxb (XSD and WSDL binding):
<a href="https://github.com/eed3si9n/scalaxb">https://github.com/eed3si9n/scalaxb</a>
</li><li>sbt-protobuf (Google Protocol Buffers):
<a href="https://github.com/sbt/sbt-protobuf">https://github.com/sbt/sbt-protobuf</a>
</li><li>sbt-avro (Apache Avro): <a href="https://github.com/cavorite/sbt-avro">https://github.com/cavorite/sbt-avro</a>
</li><li>sbt-xjc (XSD binding, using
<a href="http://download.oracle.com/javase/6/docs/technotes/tools/share/xjc.html">JAXB XJC</a> ):
<a href="https://github.com/sbt/sbt-xjc">https://github.com/sbt/sbt-xjc</a>
</li><li>xsbt-scalate-generate (Generate/Precompile Scalate Templates):
<a href="https://github.com/backchatio/xsbt-scalate-generate">https://github.com/backchatio/xsbt-scalate-generate</a>
</li><li>sbt-antlr (Generate Java source code based on ANTLR3 grammars):
<a href="https://github.com/stefri/sbt-antlr">https://github.com/stefri/sbt-antlr</a>
</li><li>sbt-antlr4 (Antlr4 runner for generating Java source code):
<a href="https://github.com/ihji/sbt-antlr4">https://github.com/ihji/sbt-antlr4</a>
</li><li>xsbt-reflect (Generate Scala source code for project name and
version): <a href="https://github.com/ritschwumm/xsbt-reflect">https://github.com/ritschwumm/xsbt-reflect</a>
</li><li>sbt-buildinfo (Generate Scala source for any settings):
<a href="https://github.com/sbt/sbt-buildinfo">https://github.com/sbt/sbt-buildinfo</a>
</li><li>lifty (Brings scaffolding to sbt): <a href="https://github.com/lifty/lifty">https://github.com/lifty/lifty</a>
</li><li>sbt-thrift (Thrift Code Generation):
<a href="https://github.com/bigtoast/sbt-thrift">https://github.com/bigtoast/sbt-thrift</a>
</li><li>xsbt-hginfo (Generate Scala source code for Mercurial repository
information):
<a href="https://bitbucket.org/lukas_pustina/xsbt-hginfo">https://bitbucket.org/lukas_pustina/xsbt-hginfo</a>
</li><li>sbt-scalashim (Generate Scala shim like <code>sys.error</code>):
<a href="https://github.com/sbt/sbt-scalashim">https://github.com/sbt/sbt-scalashim</a>
</li><li>sbtend (Generate Java source code from
<a href="http://www.eclipse.org/xtend/">xtend</a> ):
<a href="https://github.com/xuwei-k/sbtend">https://github.com/xuwei-k/sbtend</a>
</li><li>sbt-boilerplate (generating scala.Tuple/Function related boilerplate
code): <a href="https://github.com/sbt/sbt-boilerplate">https://github.com/sbt/sbt-boilerplate</a>
</li><li>sbt-fxml (Generates controller classes for JavaFX FXML files):
<a href="https://bitbucket.org/phdoerfler/sbt-fxml">https://bitbucket.org/phdoerfler/sbt-fxml</a>
</li></ul><h4 id="Database+plugins">Database plugins<a href="#Database+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>flyway-sbt (Flyway - The agile database migration framework):
<a href="http://flywaydb.org/getstarted/firststeps/sbt.html">http://flywaydb.org/getstarted/firststeps/sbt.html</a>
</li><li>sbt-liquibase (Liquibase RDBMS database migrations):
<a href="https://github.com/bigtoast/sbt-liquibase">https://github.com/bigtoast/sbt-liquibase</a>
</li><li>sbt-dbdeploy (dbdeploy, a database change management tool):
<a href="https://github.com/mr-ken/sbt-dbdeploy">https://github.com/mr-ken/sbt-dbdeploy</a>
</li></ul><h4 id="Documentation+plugins">Documentation plugins<a href="#Documentation+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-lwm (Convert lightweight markup files, e.g., Markdown and
Textile, to HTML): <a href="http://software.clapper.org/sbt-lwm/">http://software.clapper.org/sbt-lwm/</a>
</li><li>sbt-site (Site generation for SBT):
<a href="https://github.com/sbt/sbt-site">https://github.com/sbt/sbt-site</a>
</li><li>Laika (Template-based site generation, Markdown, reStructuredText,
no external tools): <a href="http://planet42.github.io/Laika/">http://planet42.github.io/Laika/</a>
</li><li>literator-plugin (Converts sources into markdown documents):
<a href="https://github.com/laughedelic/literator">https://github.com/laughedelic/literator</a>
</li></ul><h4 id="Library+dependency+plugins">Library dependency plugins<a href="#Library+dependency+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>ls-sbt (An sbt interface for ls.implicit.ly):
<a href="https://github.com/softprops/ls">https://github.com/softprops/ls</a>
</li><li>sbt-dependency-graph (Creates a graphml file of the dependency
tree): <a href="https://github.com/jrudolph/sbt-dependency-graph">https://github.com/jrudolph/sbt-dependency-graph</a>
</li><li>sbt-dirty-money (Cleans Ivy2 cache):
<a href="https://github.com/sbt/sbt-dirty-money">https://github.com/sbt/sbt-dirty-money</a>
</li><li>sbt-updates (Checks Maven repos for dependency updates):
<a href="https://github.com/rtimush/sbt-updates">https://github.com/rtimush/sbt-updates</a>
</li></ul><h4 id="Utility+plugins">Utility plugins<a href="#Utility+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>jot (Write down your ideas lest you forget them)
<a href="https://github.com/softprops/jot">https://github.com/softprops/jot</a>
</li><li>np (Dead simple new project directory generation):
<a href="https://github.com/softprops/np">https://github.com/softprops/np</a>
</li><li>npt (Creates new project skeletons based on templates):
<a href="https://github.com/reikje/npt">https://github.com/reikje/npt</a>
</li><li>sbt-editsource (A poor man’s <em>sed</em>(1), for sbt):
<a href="http://software.clapper.org/sbt-editsource/">http://software.clapper.org/sbt-editsource/</a>
</li><li>sbt-cross-building (Simplifies building your plugins for multiple
versions of sbt): <a href="https://github.com/jrudolph/sbt-cross-building">https://github.com/jrudolph/sbt-cross-building</a>
</li><li>sbt-revolver (Triggered restart, hot reloading):
<a href="https://github.com/spray/sbt-revolver">https://github.com/spray/sbt-revolver</a>
</li><li>sbt-scalaedit (Open and upgrade ScalaEdit (text editor)):
<a href="https://github.com/kjellwinblad/sbt-scalaedit-plugin">https://github.com/kjellwinblad/sbt-scalaedit-plugin</a>
</li><li>sbt-man (Looks up scaladoc): <a href="https://github.com/sbt/sbt-man">https://github.com/sbt/sbt-man</a>
</li><li>sbt-taglist (Looks for TODO-tags in the sources):
<a href="https://github.com/johanandren/sbt-taglist">https://github.com/johanandren/sbt-taglist</a>
</li><li>migration-manager:
<a href="https://github.com/typesafehub/migration-manager">https://github.com/typesafehub/migration-manager</a>
</li><li>sbt-scalariform (adding support for source code formatting using
Scalariform): <a href="https://github.com/sbt/sbt-scalariform">https://github.com/sbt/sbt-scalariform</a>
</li><li>sbt-aspectj: <a href="https://github.com/sbt/sbt-aspectj">https://github.com/sbt/sbt-aspectj</a>
</li><li>sbt-properties: <a href="https://github.com/sbt/sbt-properties">https://github.com/sbt/sbt-properties</a>
</li><li>sbt-multi-publish (publish to more than one repository
simultaneously):
<a href="https://github.com/davidharcombe/sbt-multi-publish">https://github.com/davidharcombe/sbt-multi-publish</a>
</li><li>sbt-about-plugins (shows some details about plugins loaded):
<a href="https://github.com/jozic/sbt-about-plugins">https://github.com/jozic/sbt-about-plugins</a>
</li><li>sbt-one-log (make Log dependency easy):
<a href="https://github.com/zavakid/sbt-one-log">https://github.com/zavakid/sbt-one-log</a>
</li></ul><h4 id="Code+coverage+plugins">Code coverage plugins<a href="#Code+coverage+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt-scct: <a href="https://github.com/dvc94ch/sbt-scct">https://github.com/dvc94ch/sbt-scct</a>
</li><li>sbt-scoverage: <a href="https://github.com/scoverage/sbt-scoverage">https://github.com/scoverage/sbt-scoverage</a>
</li><li>jacoco4sbt: <a href="https://github.com/sbt/jacoco4sbt">https://github.com/sbt/jacoco4sbt</a>
</li><li>xsbt-coveralls-plugin:
<a href="https://github.com/theon/xsbt-coveralls-plugin">https://github.com/theon/xsbt-coveralls-plugin</a>
</li></ul><h4 id="Android+plugin">Android plugin<a href="#Android+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>android-plugin: <a href="https://github.com/jberkel/android-plugin">https://github.com/jberkel/android-plugin</a>
</li><li>android-sdk-plugin: <a href="https://github.com/pfn/android-sdk-plugin">https://github.com/pfn/android-sdk-plugin</a>
</li></ul><h4 id="Build+interoperability+plugins">Build interoperability plugins<a href="#Build+interoperability+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>ant4sbt: <a href="https://github.com/sbt/ant4sbt">https://github.com/sbt/ant4sbt</a>
</li></ul><h4 id="OSGi+plugin">OSGi plugin<a href="#OSGi+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbtosgi: <a href="https://github.com/typesafehub/sbtosgi">https://github.com/typesafehub/sbtosgi</a>
</li></ul><h4 id="Plugin+bundles">Plugin bundles<a href="#Plugin+bundles" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>tl-os-sbt-plugins (Version, Release, and Package Management, Play 2.0 and Git utilities) :
<a href="https://github.com/trafficland/tl-os-sbt-plugins">https://github.com/trafficland/tl-os-sbt-plugins</a>
</li></ul><h2 id="Community+Repository+Policy">Community Repository Policy<a href="#Community+Repository+Policy" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The community repository has the following guideline for artifacts
published to it:
</p><ol><li>All published artifacts are the authors own work or have an
appropriate license which grants distribution rights.
</li><li>All published artifacts come from open source projects, that have an
open patch acceptance policy.
</li><li>All published artifacts are placed under an organization in a DNS
domain for which you have the permission to use or are an owner
(scala-sbt.org is available for sbt plugins).
</li><li>All published artifacts are signed by a committer of the project
(coming soon).
</li></ol><h2 id="Bintray+For+Plugins">Bintray For Plugins<a href="#Bintray+For+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><strong>This is currently in Beta mode.</strong>
</p><p>sbt hosts their community plugin repository on
<a href="http://bintray.com/sbt">Bintray</a>.
Bintray is a repository hosting site, similar to github, which allows users to contribute their own
plugins, while sbt can aggregate them together in a common repository.
</p><p>This document walks you through the means to create your own repository
for hosting your sbt plugins and then linking them into the sbt shared
repository. This will make your plugins available for all sbt users
without additonal configuration (besides declaring a dependency on your
plugin).
</p><p>To do this, we need to perform the following steps:
</p><h3 id="Create+an+account+on+Bintray">Create an account on Bintray<a href="#Create+an+account+on+Bintray" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>First, go to <a href="http://bintray.com">http://bintray.com</a>. Click on the sign in link on the top
left, and then the sign up button.
</p><ul><li>Note: If you had an account on repo.scala-sbt.org previous, please use
the same email address when you create this account.*
</li></ul><h3 id="Create+a+repository+for+your+sbt+plugins">Create a repository for your sbt plugins<a href="#Create+a+repository+for+your+sbt+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now, we’ll create a repository to host our personal sbt plugins. In
bintray, create a generic repository called <code>sbt-plugins</code>.
</p><p>First, go to your user page and click on the <code>new repository</code> link:
</p><img src="files/bintray-new-repo-link.png" style="width: 100%; height: 100%">
<p>You should see the following dialog:
</p><img src="files/bintray-new-repo-dialog.png" style="width: 100%; height: 100%">
<p>Fill it out similarly to the above image, the settings are:
</p><ul><li>Name:   sbt-plugins
</li><li>Type:   Generic
</li><li>Desc:   My sbt plugins
</li><li>Tags:   sbt
</li></ul><p>Once this is done, you can begin to configure your sbt-plugins to
publish to bintray.
</p><h3 id="Add+the+bintray-sbt+plugin+to+your+build.">Add the bintray-sbt plugin to your build.<a href="#Add+the+bintray-sbt+plugin+to+your+build." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>First, add the bintray-sbt to your plugin build.
</p><p>First, create a <code>project/bintray.sbt</code> file
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(
  &quot;bintray-sbt-plugin-releases&quot;,
   url(&quot;http://dl.bintray.com/content/sbt/sbt-plugin-releases&quot;))(
       Resolver.ivyStylePatterns)

addSbtPlugin(&quot;me.lessis&quot; % &quot;bintray-sbt&quot; % &quot;0.1.1&quot;)
</code></pre><p>Next, a make sure your <code>build.sbt</code> file has the following settings :
</p><pre><code class="prettyprint lang-scala">import bintray.Keys._

sbtPlugin := true

name := &quot;&lt;YOUR PLUGIN HERE&gt;&quot;

organization := &quot;&lt;INSERT YOUR ORG HERE&gt;&quot;

version := &quot;&lt;YOUR PLUGIN VERSION HERE&gt;&quot;

publishMavenStyle := false

bintrayPublishSettings

repository in bintray := &quot;sbt-plugins&quot;

// This is an example.  bintray-sbt requires licenses to be specified 
// (using a canonical name).
licenses += (&quot;Apache-2.0&quot;, url(&quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;))

bintrayOrganization in bintray := None
</code></pre><p>Make sure your project has a valid license specified, as well as unique
name and organization.
</p><h3 id="Make+a+release">Make a release<a href="#Make+a+release" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><blockquote><ul><li>Note: bintray does not support snapshots. We recommend using
<a href="https://github.com/sbt/sbt-git#versioning-with-git">git-revisions supplied by the sbt-git plugin</a>*.
</li></ul></blockquote><p>Once your build is configured, open the sbt console in your build and run
</p><pre><code class="">sbt&gt; publish
</code></pre><p>The plugin will ask you for your credentials. If you don’t know where
they are, you can find them on <a href="http://bintray.com">Bintray</a>.
</p><ol><li>Login to the website with your credentials.
</li><li>Click on your username
</li><li>Click on edit profile
</li><li>Click on API Key
</li></ol><p>This will get you your password. The bintray-sbt plugin will save your
API key for future use.
</p><ul><li>NOTE: We have to do this before we can link our package to the sbt
org.*
</li></ul><h3 id="Linking+your+package+to+the+sbt+organization">Linking your package to the sbt organization<a href="#Linking+your+package+to+the+sbt+organization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now that your plugin is packaged on bintray, you can include it in the
community sbt repository. To do so, go to the
<a href="https://bintray.com/sbt/sbt-plugin-releases">Community sbt repository</a>
screen.
</p><ol><li>Click the green <code>include my package</code> button and select your plugin.
<img src="files/bintray-include-my-package.png" style="width: 100%; height: 100%">
</li><li>Search for your plugin by name and click on the link.
<img src="files/bintray-link-plugin-search.png" style="width: 100%; height: 100%">
</li><li>Your request should be automatically filled out, just click send
<img src="files/bintray-include-package-form.png" style="width: 100%; height: 100%">
</li><li>Shortly, one of the sbt repository admins will approve your link
request.
</li></ol><p>From here on, any releases of your plugin will automatically appear in
the community sbt repository. Congratulations and thank you so much for
your contributions!
</p><h3 id="Linking+your+package+to+the+sbt+organization+%28sbt+org+admins%29">Linking your package to the sbt organization (sbt org admins)<a href="#Linking+your+package+to+the+sbt+organization+%28sbt+org+admins%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you’re a member of the sbt organization on bintray, you can link your
package to the sbt organization, but via a different means. To do so,
first navigate to the plugin you wish to include and click on the link
button:
</p><img src="files/bintray-org-member-link-button.png" style="width: 100%; height: 100%">
<p>After clicking this you should see a link like the following:
</p><img src="files/bintray-org-member-link-dialog.png" style="width: 100%; height: 100%">
<p>Click on the <code>sbt/sbt-plugin-releases</code> repository and you’re done! Any
future releases will be included in the sbt-plugin repository.
</p><h3 id="Summary">Summary<a href="#Summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>After setting up the repository, all new releases will automatically be
included the sbt-plugin-releases repository, available for all users.
When you create a new plugin, after the initial release you’ll have to
link it to the sbt community repository, but the rest of the setup
should already be completed. Thanks for you contributions and happy
hacking.
</p><h2 id="Setup+Notes">Setup Notes<a href="#Setup+Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Some notes on how to set up your <code>sbt</code> script.
</p><h3 id="Do+not+put++on+your+classpath.">Do not put <code>sbt-launch.jar</code> on your classpath.<a href="#Do+not+put++on+your+classpath." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Do <em>not</em> put <code>sbt-launch.jar</code> in your <code>$SCALA_HOME/lib</code> directory, your
project’s <code>lib</code> directory, or anywhere it will be put on a classpath. It
isn’t a library.
</p><h3 id="Terminal+encoding">Terminal encoding<a href="#Terminal+encoding" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The character encoding used by your terminal may differ from Java’s
default encoding for your platform. In this case, you will need to add
the option <code>-Dfile.encoding=&lt;encoding&gt;</code> in your <code>sbt</code> script to set the
encoding, which might look like:
</p><pre><code class="">java -Dfile.encoding=UTF8
</code></pre><h3 id="JVM+heap%2C+permgen%2C+and+stack+sizes">JVM heap, permgen, and stack sizes<a href="#JVM+heap%2C+permgen%2C+and+stack+sizes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you find yourself running out of permgen space or your workstation is
low on memory, adjust the JVM configuration as you would for any
application. For example a common set of memory-related options is:
</p><pre><code class="">java -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256m
</code></pre><h3 id="Boot+directory">Boot directory<a href="#Boot+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>sbt-launch.jar</code> is just a bootstrap; the actual meat of sbt, and the
Scala compiler and standard library, are downloaded to the shared
directory <code>$HOME/.sbt/boot/</code>.
</p><p>To change the location of this directory, set the <code>sbt.boot.directory</code>
system property in your <code>sbt</code> script. A relative path will be resolved
against the current working directory, which can be useful if you want
to avoid sharing the boot directory between projects. For example, the
following uses the pre-0.11 style of putting the boot directory in
<code>project/boot/</code>:
</p><pre><code class="">java -Dsbt.boot.directory=project/boot/
</code></pre><h3 id="HTTP%2FHTTPS%2FFTP+Proxy">HTTP/HTTPS/FTP Proxy<a href="#HTTP%2FHTTPS%2FFTP+Proxy" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>On Unix, sbt will pick up any HTTP, HTTPS, or FTP proxy settings from
the standard <code>http_proxy</code>, <code>https_proxy</code>, and <code>ftp_proxy</code> environment
variables. If you are behind a proxy requiring authentication, your
<code>sbt</code> script must also pass flags to set the <code>http.proxyUser</code> and
<code>http.proxyPassword</code> properties for HTTP, <code>ftp.proxyUser</code> and
<code>ftp.proxyPassword</code> properties for FTP, or <code>https.proxyUser</code> and
<code>https.proxyPassword</code> properties for HTTPS.
</p><p>For example,
</p><pre><code class="">java -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre><p>On Windows, your script should set properties for proxy host, port, and
if applicable, username and password. For example, for HTTP:
</p><pre><code class="">java -Dhttp.proxyHost=myproxy -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword
</code></pre><p>Replace <code>http</code> with <code>https</code> or <code>ftp</code> in the above command line to
configure HTTPS or FTP.
</p><h2 id="Deploying+to+Sonatype">Deploying to Sonatype<a href="#Deploying+to+Sonatype" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Deploying to sonatype is easy! Just follow these simple steps:
</p><h3 id="First+-+PGP+Signatures">First - PGP Signatures<a href="#First+-+PGP+Signatures" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You’ll need to PGP sign your artifacts for the Sonatype repository.
Don’t worry, there’s a
<a href="http://scala-sbt.org/sbt-pgp">plugin for that</a>.
Follow the instructions for the plugin and you’ll have PGP signed artifacts in no
time.
</p><blockquote><ul><li>Note: The plugin is a jvm-only solution to generate PGP keys and sign
artifacts. It can work with the GPG command line tool, but the command
line is not needed.*
</li></ul></blockquote><p>If your PGP key has not yet been distributed to the keyserver pool,
i.e., you’ve just generated it, you’ll need to publish it. You can do so
using the <a href="http://scala-sbt.org/sbt-pgp">sbt-pgp</a> plugin:
</p><pre><code class="">pgp-cmd send-key keyname hkp://pool.sks-keyservers.net/
</code></pre><p>(where keyname is the name, email address used when creating the key or
hexadecimal identifier for the key.)
</p><p>If you see no output from sbt-pgp then the key name specified was not
found.
</p><h3 id="Second+-+Maven+Publishing+Settings">Second - Maven Publishing Settings<a href="#Second+-+Maven+Publishing+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To publish to a maven repository, you’ll need to configure a few
settings so that the correct metadata is generated.
</p><pre><code class="prettyprint lang-scala">publishMavenStyle := true
</code></pre><p>is used to ensure POMs are generated and pushed. Next, you have to set
up the repositories you wish to push too. Luckily, Sonatype’s OSSRH uses
the same URLs for everyone:
</p><pre><code class="prettyprint lang-scala">publishTo := {
  val nexus = &quot;https://oss.sonatype.org/&quot;
  if (isSnapshot.value)
    Some(&quot;snapshots&quot; at nexus + &quot;content/repositories/snapshots&quot;)
  else
    Some(&quot;releases&quot;  at nexus + &quot;service/local/staging/deploy/maven2&quot;)
}
</code></pre><p>Another good idea is to not publish your test artifacts (this is the
default):
</p><pre><code class="prettyprint lang-scala">publishArtifact in Test := false
</code></pre><h3 id="Third+-+POM+Metadata">Third - POM Metadata<a href="#Third+-+POM+Metadata" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now, we want to control what’s available in the <code>pom.xml</code> file. This
file describes our project in the maven repository and is used by
indexing services for search and discover. This means it’s important
that <code>pom.xml</code> should have all information we wish to advertise as well
as required info!
</p><p>First, let’s make sure no repositories show up in the POM file. To
publish on maven-central, all <em>required</em> artifacts must also be hosted
on maven central. However, sometimes we have optional dependencies for
special features. If that’s the case, let’s remove the repositories for
optional dependencies in our artifact:
</p><pre><code class="prettyprint lang-scala">pomIncludeRepository := { _ =&gt; false }
</code></pre><p>Next, the POM metadata that isn’t generated by sbt must be added. This
is done through the <code>pomExtra</code> configuration option:
</p><pre><code class="prettyprint lang-scala">pomExtra := (
  &lt;url&gt;http://jsuereth.com/scala-arm&lt;/url&gt;
  &lt;licenses&gt;
    &lt;license&gt;
      &lt;name&gt;BSD-style&lt;/name&gt;
      &lt;url&gt;http://www.opensource.org/licenses/bsd-license.php&lt;/url&gt;
      &lt;distribution&gt;repo&lt;/distribution&gt;
    &lt;/license&gt;
  &lt;/licenses&gt;
  &lt;scm&gt;
    &lt;url&gt;git@github.com:jsuereth/scala-arm.git&lt;/url&gt;
    &lt;connection&gt;scm:git:git@github.com:jsuereth/scala-arm.git&lt;/connection&gt;
  &lt;/scm&gt;
  &lt;developers&gt;
    &lt;developer&gt;
      &lt;id&gt;jsuereth&lt;/id&gt;
      &lt;name&gt;Josh Suereth&lt;/name&gt;
      &lt;url&gt;http://jsuereth.com&lt;/url&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;)
</code></pre><p>Specifically, the <code>url</code>, <code>license</code>, <code>scm.url</code>, <code>scm.connection</code> and
<code>developer</code> sections are required. The above is an example from the
<a href="http://jsuereth.com/scala-arm">scala-arm</a> project.
</p><blockquote><p><em>Note</em> that sbt will automatically inject <code>licenses</code> and <code>url</code> nodes if
they are already present in your build file. Thus an alternative to the
above <code>pomExtra</code> is to include the following entries:
</p></blockquote><pre><code class="prettyprint lang-scala">licenses := Seq(&quot;BSD-style&quot; -&gt; url(&quot;http://www.opensource.org/licenses/bsd-license.php&quot;))

homepage := Some(url(&quot;http://jsuereth.com/scala-arm&quot;))
</code></pre><p>This might be advantageous if those keys are used also by other plugins
(e.g. <code>ls</code>). You <strong>cannot use both</strong> the sbt <code>licenses</code> key and the
<code>licenses</code> section in <code>pomExtra</code> at the same time, as this will produce
duplicate entries in the final POM file, leading to a rejection in
Sonatype’s staging process.
</p><ul><li>The full format of a pom.xml file is
<a href="http://maven.apache.org/pom.html">outlined here</a>.*
</li></ul><h3 id="Fourth+-+Adding+credentials">Fourth - Adding credentials<a href="#Fourth+-+Adding+credentials" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The credentials for your Sonatype OSSRH account need to be added
somewhere. Common convention is a <code>~/.sbt/0.13/sonatype.sbt</code> file
with the following:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(&quot;Sonatype Nexus Repository Manager&quot;,
                           &quot;oss.sonatype.org&quot;,
                           &quot;&lt;your username&gt;&quot;,
                           &quot;&lt;your password&gt;&quot;)
</code></pre><blockquote><ul><li>Note: The first two strings must be
<code>&quot;Sonatype Nexus Repository Manager&quot;</code> and <code>&quot;oss.sonatype.org&quot;</code> for Ivy
to use the credentials.*
</li></ul></blockquote><h3 id="Finally+-+Publish">Finally - Publish<a href="#Finally+-+Publish" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt, run <code>publishSigned</code> and you should see something like the
following:
</p><pre><code class="">&gt; publishSigned
Please enter your PGP passphrase&gt; ***********
[info] Packaging /home/josh/projects/typesafe/scala-arm/target/scala-2.9.1/scala-arm_2.9.1-1.2.jar ...
[info] Wrote /home/josh/projects/typesafe/scala-arm/target/scala-2.9.1/scala-arm_2.9.1-1.2.pom
[info] Packaging /home/josh/projects/typesafe/scala-arm/target/scala-2.9.1/scala-arm_2.9.1-1.2-javadoc.jar ...
[info] Packaging /home/josh/projects/typesafe/scala-arm/target/scala-2.9.1/scala-arm_2.9.1-1.2-sources.jar ...
[info] :: delivering :: com.jsuereth#scala-arm_2.9.1;1.2 :: 1.2 :: release :: Mon Jan 23 13:16:57 EST 2012
[info] Done packaging.
[info] Done packaging.
[info] Done packaging.
[info]  delivering ivy file to /home/josh/projects/typesafe/scala-arm/target/scala-2.9.1/ivy-1.2.xml
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2-sources.jar
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2-javadoc.jar.asc
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2-sources.jar.asc
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2.jar
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2.jar.asc
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2.pom.asc
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2.pom
[info]  published scala-arm_2.9.1 to https://oss.sonatype.org/service/local/staging/deploy/maven2/com/jsuereth/scala-arm_2.9.1/1.2/scala-arm_2.9.1-1.2-javadoc.jar
[success] Total time: 9 s, completed Jan 23, 2012 1:17:03 PM
</code></pre><p>After publishing you have to follow the
<a href="https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt">Release workflow of nexus</a>.
<a href="https://github.com/xerial/sbt-sonatype">sbt-sonatype plugin</a> allows
the release workflow procedures to be performed directly from sbt.
</p><blockquote><ul><li>Note: Staged releases allow testing across large projects of
independent releases before pushing the full project.*
</li></ul></blockquote><blockquote><p><em>Note:</em> An error message of <code>PGPException: checksum mismatch at 0 of 20</code>
indicates that you got the passphrase wrong. We have found at least on
OS X that there may be issues with characters outside the 7-bit ASCII
range (e.g. Umlauts). If you are absolutely sure that you typed the
right phrase and the error doesn’t disappear, try changing the
passphrase.
</p></blockquote><h3 id="Summary">Summary<a href="#Summary" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To get your project hosted on Sonatype (and Maven Central), you will
need to:
</p><ul><li>Have GPG key pair, with published public key,
</li><li>An sbt file with your Sonatype credentials <em>that is not pushed to
the VCS</em>,
</li><li>Add the <a href="http://scala-sbt.org/sbt-pgp">sbt-pgp plugin</a> to sign
the artefacts,
</li><li>Modify <code>build.sbt</code> with the required elements in the generated POM.
</li></ul><p>Starting with a project that is not being published, you’ll need to
install GPG, generate and publish your key. Swtiching to sbt, you’ll
then need to:
</p><h4 id="%7E%2F.sbt%2Fsonatype.sbt">~/.sbt/sonatype.sbt<a href="#%7E%2F.sbt%2Fsonatype.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This file (kept <em>outside the VCS</em>) contains the Sonatype credentials
settings:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(&quot;Sonatype Nexus Repository Manager&quot;,
                           &quot;oss.sonatype.org&quot;,
                           &quot;your-sonatype-username&quot;,
                           &quot;your-sonatype-password&quot;)
</code></pre><h4 id="%7E%2F.sbt%2Fplugins%2Fgpg.sbt">~/.sbt/plugins/gpg.sbt<a href="#%7E%2F.sbt%2Fplugins%2Fgpg.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <a href="http://scala-sbt.org/sbt-pgp">sbt-pgp plugin</a> allows you to sign
and publish your artefacts by running <code>publishSigned</code> in sbt:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-pgp&quot; % &quot;0.8&quot;)
</code></pre><h4 id="build.sbt">build.sbt<a href="#build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Finally, you’ll need to tweak the generated POM in your <code>build.sbt</code>. The
tweaks include specifying the project’s authors, URL, SCM and many
others:
</p><pre><code class="prettyprint lang-scala">publishTo := {
  val nexus = &quot;https://oss.sonatype.org/&quot;
  if (isSnapshot.value)
    Some(&quot;snapshots&quot; at nexus + &quot;content/repositories/snapshots&quot;)
  else
    Some(&quot;releases&quot; at nexus + &quot;service/local/staging/deploy/maven2&quot;)
}

publishMavenStyle := true

publishArtifact in Test := false

pomIncludeRepository := { _ =&gt; false }

pomExtra := (
  &lt;url&gt;http://your.project.url&lt;/url&gt;
  &lt;licenses&gt;
    &lt;license&gt;
      &lt;name&gt;BSD-style&lt;/name&gt;
      &lt;url&gt;http://www.opensource.org/licenses/bsd-license.php&lt;/url&gt;
      &lt;distribution&gt;repo&lt;/distribution&gt;
    &lt;/license&gt;
  &lt;/licenses&gt;
  &lt;scm&gt;
    &lt;url&gt;git@github.com:your-account/your-project.git&lt;/url&gt;
    &lt;connection&gt;scm:git:git@github.com:your-account/your-project.git&lt;/connection&gt;
  &lt;/scm&gt;
  &lt;developers&gt;
    &lt;developer&gt;
      &lt;id&gt;you&lt;/id&gt;
      &lt;name&gt;Your Name&lt;/name&gt;
      &lt;url&gt;http://your.url&lt;/url&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;
)
</code></pre><h2 id="Changes">Changes<a href="#Changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="0.13.5-RC1+to+0.13.5-RC2">0.13.5-RC1 to 0.13.5-RC2<a href="#0.13.5-RC1+to+0.13.5-RC2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixes auto plugins not detecting <code>object autoImport</code>. (gh-1314)
</li></ul><h3 id="0.13.2+to+0.13.5">0.13.2 to 0.13.5<a href="#0.13.2+to+0.13.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>The Scala version for sbt and sbt plugins is now 2.10.4. This is a
compatible version bump.
</li><li>Added a new setting <code>testResultLogger</code> to allow customisation of
logging of test results. (gh-1225)
</li><li>When <code>test</code> is run and there are no tests available, omit logging
output. Especially useful for aggregate modules. <code>test-only</code> et al
unaffected. (gh-1185)
</li><li>sbt now uses minor-patch version of ivy 2.4
(org.scala-sbt.ivy:ivy:2.4.0-sbt-<git sha>)
</li><li><code>sbt.Plugin</code> deprecated in favor of <code>sbt.AutoPlugin</code>
</li><li>name-hashing incremental compiler now supports scala macros.
</li><li><code>testResultLogger</code> is now configured.
</li><li>sbt-server hooks for task cancellation.
</li><li>Add <code>JUnitXmlReportPlugin</code> which generates junit-xml-reports for all
tests.
</li></ul><h3 id="0.13.1+to+0.13.2">0.13.1 to 0.13.2<a href="#0.13.1+to+0.13.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Adding new name-hashing feature to incremental compiler. Alters how
scala dependencies are tracked, reducing number of recompiles
necessary.
</li><li>Added the ability to launch servers via the sbt-launcher.
</li><li>Added <code>.previous</code> feature on tasks which can load the pervious
value.
</li><li>Added an <code>all</code> command which can run more than tasks in parallel.
</li><li>Exposed the ‘overwrite’ flags from ivy. Added warning if overwriting
a release version.
</li><li>Improve the error message when credentials are not found in Ivy.
</li><li>Improve task macros to handle more scala constructs.
</li><li>Fix <code>last</code> and <code>export</code> tasks to read from the correct stream.
</li><li>Fix issue where ivy’s <code>.+</code> dependency ranges were not correctly
translated to maven.
</li><li>Override security manager to ignore file permissions (performance
issue)
</li><li>2.11 compatibility fixes
</li><li>Launcher can now handle ivy’s <code>.+</code> revisions.
</li><li>SessionSettings now correctly overwrite existing settings.
</li><li>Adding a simple Logic system for inclusionary/dependency logic of
plugins.
</li><li>Improve build hooks for <code>LoggerReporter</code> and <code>TaskProgress</code>.
</li><li>Serialize incremental compiler analysis into text-file format.
</li><li>Issue a warning when generating Paths and separate already exists in
the path.
</li><li>Migrate to Ivy 2.3.0-final.
</li><li>Docs: Use bintray as default repository host
</li><li>Docs: improved docs on test groups.
</li><li>Docs: updated documentation on the Launcher.
</li><li>Docs: started architecture document.
</li></ul><h3 id="0.13.0+to+0.13.1">0.13.0 to 0.13.1<a href="#0.13.0+to+0.13.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>The Scala version for sbt and sbt plugins is now 2.10.3. This is a
compatible version bump.
</li><li>New method <code>toTask</code> on <code>Initialize[InputTask[T]]</code> to apply the full
input and get a plain task out.
</li><li>Improved performance of <code>inspect tree</code>
</li><li>Work around various issues with Maven local repositories, including
resolving -SNAPSHOTs from them. (gh-321)
</li><li>Better representation of no cross-version suffix in suffix conflict
error message: now shows <code>&lt;none&gt;</code> instead of just <code>_</code>
</li><li><code>TrapExit</code> support for multiple, concurrent managed applications.
Now enabled by default for all <code>run</code>-like tasks. (gh-831)
</li><li>Add minimal support for class file formats 51.0, 52.0 in incremental
compiler. (gh-842)
</li><li>Allow main class to be non-public. (gh-883)
</li><li>Convert <code>-classpath</code> to <code>CLASSPATH</code> when forking on Windows and
length exceeds a heuristic maximum. (gh-755)
</li><li><code>scalacOptions</code> for <code>.scala</code> build definitions are now also used for
<code>.sbt</code> files
</li><li><code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code> commands to set log level and
<code>--error</code>, … to set the level before the project is loaded.
(gh-806)
</li><li><code>sLog</code> settings that provides a <code>Logger</code> for use by settings.
(gh-806)
</li><li>Early commands: any command prefixed with <code>--</code> gets moved before
other commands on startup and doesn’t force sbt into batch mode.
</li><li>Deprecate internal <code>-</code>, <code>--</code>, and <code>---</code> commands in favor of <code>onFailure</code>,
<code>sbtClearOnFailure</code>, and <code>resumeFromFailure</code>.
</li><li><code>makePom</code> no longer generates <code>&lt;type&gt;</code> elements for standard
classifiers. (gh-728)
</li><li>Fix many instances of the Turkish i bug.
</li><li>Read https+ftp proxy environment variables into system properties
where Java will use them. (gh-886)
</li><li>The <code>Process</code> methods that are redirection-like no longer discard
the exit code of the input. This addresses an inconsistency with
<code>Fork</code>, where using the <code>CustomOutput</code> <code>OutputStrategy</code> makes the
exit code always zero.
</li><li>Recover from failed <code>reload</code> command in the scripted sbt handler.
</li><li>Parse external <code>pom.xml</code> with <code>CustomPomParser</code> to handle multiple
definitions. (gh-758)
</li><li>Improve key collision error message (gh-877)
</li><li>Display the source position of an undefined setting.
</li><li>Respect the <code>-nowarn</code> option when compiling Scala sources.
</li><li>Improve forked test debugging by listing tests run by sbt in debug
output. (gh-868)
</li><li>Fix scaladoc cache to track changes to <code>-doc-root-content</code> (gh-837)
</li><li>Incremental compiler: Internal refactoring in preparation for
name-hashing (gh-936)
</li><li>Incremental compiler: improved cache loading/saving speed by
internal file names (gh-931)
</li><li>Docs: many contributed miscellaneous fixes and additions
</li><li>Docs: link to page source now at the bottom of the page
</li><li>Docs: sitemap now automatically generated
</li><li>Docs: custom
role enables links from a key name in the docs to the val in <a href="../sxr/sbt/Keys.scala">Keys</a>
</li><li>Docs: restore sxr support and fix links to sxr’d sources. (gh-863)
</li></ul><h3 id="0.12.4+to+0.13.0">0.12.4 to 0.13.0<a href="#0.12.4+to+0.13.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The changes for 0.13.0 are listed on a separate page. See
<a href="ChangeSummary_0.13.0.html">sbt 0.13.0 changes</a>.
</p><h2 id="sbt+0.13.0+Changes">sbt 0.13.0 Changes<a href="#sbt+0.13.0+Changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Overview">Overview<a href="#Overview" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Features%2C+fixes%2C+changes+with+compatibility+implications">Features, fixes, changes with compatibility implications<a href="#Features%2C+fixes%2C+changes+with+compatibility+implications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Moved to Scala 2.10 for sbt and build definitions.
</li><li>Support for plugin configuration in <code>project/plugins/</code> has been
removed. It was deprecated since 0.11.2.
</li><li>Dropped support for tab completing the right side of a setting for
the <code>set</code> command. The new task macros make this tab completion
obsolete.
</li><li>The convention for keys is now camelCase only. Details below.
</li><li>Fixed the default classifier for tests to be <code>tests</code> for proper
Maven compatibility.
</li><li>The global settings and plugins directories are now versioned.
Global settings go in <code>~/.sbt/0.13/</code> and global plugins in
<code>~/.sbt/0.13/plugins/</code> by default. Explicit overrides, such as via
the <code>sbt.global.base</code> system property, are still respected. (gh-735)
</li><li>sbt no longer canonicalizes files passed to scalac. (gh-723)
</li><li>sbt now enforces that each project must have a unique <code>target</code>
directory.
</li><li>sbt no longer overrides the Scala version in dependencies. This
allows independent configurations to depend on different Scala
versions and treats Scala dependencies other than scala-library as
normal dependencies. However, it can result in resolved versions
other than <code>scalaVersion</code> for those other Scala libraries.
</li><li>JLine is now configured differently for Cygwin. See
<a href="../tutorial/Setup.html">Installing sbt</a>.
</li><li>Jline and Ansi codes work better on Windows now. CI servers might
have to explictly disable Ansi codes via <code>-Dsbt.log.format=false</code>.
</li><li>JLine now tries to respect <code>~/.inputrc</code>.
</li><li>Forked tests and runs now use the project’s base directory as the
current working directory.
</li><li><code>compileInputs</code> is now defined in <code>(Compile,compile)</code> instead of
just <code>Compile</code>
</li><li>The result of running tests is now
<a href="../api/#sbt.Tests$$Output">Tests.Output</a>.
</li></ul><h4 id="Features">Features<a href="#Features" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Use the repositories in boot.properties as the default project
resolvers. Add <code>bootOnly</code> to a repository in boot.properties to
specify that it should not be used by projects by default. (Josh S.,
gh-608)
</li><li>Support vals and defs in .sbt files. Details below.
</li><li>Support defining Projects in .sbt files: vals of type Project are
added to the Build. Details below.
</li><li>New syntax for settings, tasks, and input tasks. Details below.
</li><li><p>Automatically link to external API scaladocs of dependencies by
setting <code>autoAPIMappings := true</code>. This requires at least Scala
</p><ol><li>10.1 and for dependencies to define <code>apiURL</code> for their scaladoc
location. Mappings may be manually added to the <code>apiMappings</code> task
as well.
</li></ol></li><li>Support setting Scala home directory temporary using the switch
command: <code>++ scala-version=/path/to/scala/home</code>. The scala-version
part is optional, but is used as the version for any managed
dependencies.
</li><li>Add <code>publishM2</code> task for publishing to <code>~/.m2/repository</code>. (gh-485)
</li><li>Use a default root project aggregating all projects if no root is
defined. (gh-697)
</li><li>New API for getting tasks and settings from multiple projects and
configurations. See the new section
<a href="Tasks.html#multiple-scopes">getting values from multiple scopes</a>.
</li><li>Enhanced test interface for better support of test framework
features. (Details pending.)
</li><li><p><code>export</code> command
</p><blockquote><ul><li>For tasks, prints the contents of the ‘export’ stream. By
convention, this should be the equivalent command line(s)
representation. compile, doc, and console show the approximate
command lines for their execution. Classpath tasks print the
classpath string suitable for passing as an option.
</li><li>For settings, directly prints the value of a setting instead
of going through the logger
</li></ul></blockquote></li></ul><h4 id="Fixes">Fixes<a href="#Fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>sbt no longer tries to warn on dependency conflicts. Configure a
<a href="Library-Management.html#conflict-management">conflict manager</a> instead. (gh-709)
</li><li>Run test Cleanup and Setup when forking. The test ClassLoader is not
available because it is in another jvm.
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Run the API extraction phase after the compiler’s <code>pickler</code> phase
instead of <code>typer</code> to allow compiler plugins after <code>typer</code>. (Adriaan
M., gh-609)
</li><li>Record defining source position of settings. <code>inspect</code> shows the
definition location of all settings contributing to a defined value.
</li><li>Allow the root project to be specified explicitly in
<code>Build.rootProject</code>.
</li><li>Tasks that need a directory for storing cache information can now
use the <code>cacheDirectory</code> method on <code>streams</code>. This supersedes the
<code>cacheDirectory</code> setting.
</li><li>The environment variables used when forking <code>run</code> and <code>test</code> may be
set via <code>envVars</code>, which is a <code>Task[Map[String,String]]</code>. (gh-665)
</li><li>Restore class files after an unsuccessful compilation. This is
useful when an error occurs in a later incremental step that
requires a fix in the originally changed files.
</li><li>Better auto-generated IDs for default projects. (gh-554)
</li><li>Fork run directly with ‘java’ to avoid additional class loader from
‘scala’ command. (gh-702)
</li><li>Make autoCompilerPlugins support compiler plugins defined in a
internal dependency (only if <code>exportJars := true</code> due to scalac
limitations)
</li><li>Track ancestors of non-private templates and use this information to
require fewer, smaller intermediate incremental compilation steps.
</li><li><code>autoCompilerPlugins</code> now supports compiler plugins defined in a
internal dependency. The plugin project must define
<code>exportJars := true</code>. Depend on the plugin with
<code>...dependsOn(... % Configurations.CompilerPlugin)</code>.
</li><li>Add utilities for debugging API representation extracted by the
incremental compiler. (Grzegorz K., gh-677, gh-793)
</li><li><code>consoleProject</code> unifies the syntax for getting the value of a
setting and executing a task. See
<a href="Console-Project.html">Console Project</a>.
</li></ul><h4 id="Other">Other<a href="#Other" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>The source layout for the sbt project itself follows the package
name to accommodate to Eclipse users. (Grzegorz K., gh-613)
</li></ul><h3 id="Details+of+major+changes">Details of major changes<a href="#Details+of+major+changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="camelCase+Key+names">camelCase Key names<a href="#camelCase+Key+names" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The convention for key names is now camelCase only instead of camelCase
for Scala identifiers and hyphenated, lower-case on the command line.
camelCase is accepted for existing hyphenated key names and the
hyphenated form will still be accepted on the command line for those
existing tasks and settings declared with hyphenated names. Only
camelCase will be shown for tab completion, however.
</p><h4 id="New+key+definition+methods">New key definition methods<a href="#New+key+definition+methods" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There are new methods that help avoid duplicating key names by declaring
keys as:
</p><pre><code class="prettyprint lang-scala">val myTask = taskKey[Int](&quot;A (required) description of myTask.&quot;)
</code></pre><p>The name will be picked up from the val identifier by the implementation
of the taskKey macro so there is no reflection needed or runtime
overhead. Note that a description is mandatory and the method <code>taskKey</code>
begins with a lowercase <code>t</code>. Similar methods exist for keys for settings
and input tasks: <code>settingKey</code> and <code>inputKey</code>.
</p><h4 id="New+task%2Fsetting+syntax">New task/setting syntax<a href="#New+task%2Fsetting+syntax" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>First, the old syntax is still supported with the intention of allowing
conversion to the new syntax at your leisure. There may be some
incompatibilities and some may be unavoidable, but please report any
issues you have with an existing build.
</p><p>The new syntax is implemented by making <code>:=</code>, <code>+=</code>, and <code>++=</code> macros and
making these the only required assignment methods. To refer to the value
of other settings or tasks, use the <code>value</code> method on settings and
tasks. This method is a stub that is removed at compile time by the
macro, which will translate the implementation of the task/setting to
the old syntax.
</p><p>For example, the following declares a dependency on <code>scala-reflect</code>
using the value of the <code>scalaVersion</code> setting:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value
</code></pre><p>The <code>value</code> method is only allowed within a call to <code>:=</code>, <code>+=</code>, or
<code>++=</code>. To construct a setting or task outside of these methods, use
<code>Def.task</code> or <code>Def.setting</code>. For example,
</p><pre><code class="prettyprint lang-scala">val reflectDep = Def.setting { &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value }

libraryDependencies += reflectDep.value   
</code></pre><p>A similar method <code>parsed</code> is defined on <code>Parser[T]</code>,
<code>Initialize[Parser[T]]</code> (a setting that provides a parser), and
<code>Initialize[State =&gt; Parser[T]]</code> (a setting that uses the current
<code>State</code> to provide a <code>Parser[T]</code>. This method can be used when defining
an input task to get the result of user input.
</p><pre><code class="prettyprint lang-scala">myInputTask := {
     // Define the parser, which is the standard space-delimited arguments parser.
   val args = Def.spaceDelimited(&quot;&lt;args&gt;&quot;).parsed
     // Demonstrates using a setting value and a task result:
   println(&quot;Project name: &quot; + name.value)
   println(&quot;Classpath: &quot; + (fullClasspath in Compile).value.map(_.file))
   println(&quot;Arguments:&quot;)
   for(arg &lt;- args) println(&quot;  &quot; + arg)
}
</code></pre><p>For details, see <a href="Input-Tasks.html">Input Tasks</a>.
</p><p>To expect a task to fail and get the failing exception, use the
<code>failure</code> method instead of <code>value</code>. This provides an <code>Incomplete</code>
value, which wraps the exception. To get the result of a task whether or
not it succeeds, use <code>result</code>, which provides a <code>Result[T]</code>.
</p><p>Dynamic settings and tasks (<code>flatMap</code>) have been cleaned up. Use the
<code>Def.taskDyn</code> and <code>Def.settingDyn</code> methods to define them (better name
suggestions welcome). These methods expect the result to be a task and
setting, respectively.
</p><h4 id=".sbt+format+enhancements">.sbt format enhancements<a href="#.sbt+format+enhancements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>vals and defs are now allowed in .sbt files. They must follow the same
rules as settings concerning blank lines, although multiple definitions
may be grouped together. For example,
</p><pre><code class="prettyprint lang-scala">val n = &quot;widgets&quot;
val o = &quot;org.example&quot;

name := n

organization := o
</code></pre><p>All definitions are compiled before settings, but it will probably be
best practice to put definitions together. Currently, the visibility of
definitions is restricted to the .sbt file it is defined in. They are
not visible in <code>consoleProject</code> or the <code>set</code> command at this time,
either. Use Scala files in <code>project/</code> for visibility in all .sbt files.
</p><p>vals of type <code>Project</code> are added to the <code>Build</code> so that multi-project
builds can be defined entirely in .sbt files now. For example,
</p><pre><code class="prettyprint lang-scala">lazy val a = Project(&quot;a&quot;, file(&quot;a&quot;)).dependsOn(b)

lazy val b = Project(&quot;b&quot;, file(&quot;sub&quot;)).settings(
   version := &quot;1.0&quot;
)
</code></pre><p>Currently, it only makes sense to defines these in the root project’s
.sbt files.
</p><p>A shorthand for defining Projects is provided by a new macro called
<code>project</code>. This requires the constructed Project to be directly assigned
to a <code>val</code>. The name of this val is used for the project ID and base
directory. The base directory can be changed with the <code>in</code> method. The
previous example can also be written as:
</p><pre><code class="prettyprint lang-scala">lazy val a = project.dependsOn(b)

lazy val b = project in file(&quot;sub&quot;) settings(
  version := &quot;1.0&quot;
)
</code></pre><p>This macro is also available for use in Scala files.
</p><h4 id="Control+over+automatically+added+settings">Control over automatically added settings<a href="#Control+over+automatically+added+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt loads settings from a few places in addition to the settings
explicitly defined by the <code>Project.settings</code> field. These include
plugins, global settings, and .sbt files. The new <code>Project.autoSettings</code>
method configures these sources: whether to include them for the project
and in what order.
</p><p><code>Project.autoSettings</code> accepts a sequence of values of type
<code>AddSettings</code>. Instances of <code>AddSettings</code> are constructed from methods
in the <code>AddSettings</code> companion object. The configurable settings are
per-user settings (from <code>~/.sbt</code>, for example), settings from .sbt files,
and plugin settings (project-level only). The order in which these
instances are provided to <code>autoSettings</code> determines the order in which
they are appended to the settings explicitly provided in
<code>Project.settings</code>.
</p><p>For .sbt files, <code>AddSettings.defaultSbtFiles</code> adds the settings from all
.sbt files in the project’s base directory as usual. The alternative
method <code>AddSettings.sbtFiles</code> accepts a sequence of <code>Files</code> that will be
loaded according to the standard .sbt format. Relative files are
resolved against the project’s base directory.
</p><p>Plugin settings may be included on a per-Plugin basis by using the
<code>AddSettings.plugins</code> method and passing a <code>Plugin =&gt; Boolean</code>. The
settings controlled here are only the automatic per-project settings.
Per-build and global settings will always be included. Settings that
plugins require to be manually added still need to be added manually.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">import AddSettings._

lazy val root = Project(&quot;root&quot;, file(&quot;.&quot;)) autoSettings(
   userSettings, allPlugins, sbtFiles(file(&quot;explicit/a.txt&quot;))
)

lazy val sub = Project(&quot;sub&quot;, file(&quot;Sub&quot;)) autoSettings(
   defaultSbtFiles, plugins(includePlugin)
)

def includePlugin(p: Plugin): Boolean =
   p.getClass.getName.startsWith(&quot;org.example.&quot;)
</code></pre><h4 id="Resolving+Scala+dependencies">Resolving Scala dependencies<a href="#Resolving+Scala+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Scala dependencies (like scala-library and scala-compiler) are now
resolved via the normal <code>update</code> task. This means:
</p><blockquote><ol><li>Scala jars won’t be copied to the boot directory, except for those
needed to run sbt.
</li><li>Scala SNAPSHOTs behave like normal SNAPSHOTs. In particular,
running update will properly re-resolve the dynamic revision.
</li><li>Scala jars are resolved using the same repositories and
configuration as other dependencies.
</li><li>Scala dependencies are not resolved via update when scalaHome is
set, but are instead obtained from the configured directory.
</li><li>The Scala version for sbt will still be resolved via the
repositories configured for the launcher.
</li></ol></blockquote><p>sbt still needs access to the compiler and its dependencies in order to
run <code>compile</code>, <code>console</code>, and other Scala-based tasks. So, the Scala
compiler jar and dependencies (like scala-reflect.jar and
scala-library.jar) are defined and resolved in the <code>scala-tool</code>
configuration (unless <code>scalaHome</code> is defined). By default, this
configuration and the dependencies in it are automatically added by sbt.
This occurs even when dependencies are configured in a <code>pom.xml</code> or
<code>ivy.xml</code> and so it means that the version of Scala defined for your
project must be resolvable by the resolvers configured for your project.
</p><p>If you need to manually configure where sbt gets the Scala compiler and
library used for compilation, the REPL, and other Scala tasks, do one of
the following:
</p><blockquote><ol><li>Set scalaHome to use the existing Scala jars in a specific
directory. If autoScalaLibrary is true, the library jar found here
will be added to the (unmanaged) classpath.
</li><li>Set managedScalaInstance := false and explicitly define
scalaInstance, which is of type ScalaInstance. This defines the
compiler, library, and other jars comprising Scala. If
autoScalaLibrary is true, the library jar from the defined
ScalaInstance will be added to the (unmanaged) classpath.
</li></ol></blockquote><p>The <a href="Configuring-Scala.html">Configuring Scala</a> page provides full details.
</p><h2 id="sbt+0.12.0+Changes">sbt 0.12.0 Changes<a href="#sbt+0.12.0+Changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h4 id="Features%2C+fixes%2C+changes+with+compatibility+implications">Features, fixes, changes with compatibility implications<a href="#Features%2C+fixes%2C+changes+with+compatibility+implications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>The cross versioning convention has changed for Scala versions 2.10
and later as well as for sbt plugins.
</li><li>When invoked directly, ‘update’ will always perform an update
(gh-335)
</li><li>The sbt plugins repository is added by default for plugins and
plugin definitions. gh-380
</li><li>Plugin configuration directory precedence has changed (see details
section below)
</li><li>Source dependencies have been fixed, but the fix required changes
(see details section below)
</li><li>Aggregation has changed to be more flexible (see details section
below)
</li><li>Task axis syntax has changed from key(for task) to task::key (see
details section below)
</li><li>The organization for sbt has to changed to <code>org.scala-sbt</code> (was:
org.scala-tools.sbt). This affects users of the scripted plugin in
particular.
</li><li><code>artifactName</code> type has changed to
<code>(ScalaVersion, Artifact, ModuleID) =&gt; String</code>
</li><li><code>javacOptions</code> is now a task
</li><li><code>session save</code> overwrites settings in <code>build.sbt</code> (when
appropriate). gh-369
</li><li>scala-library.jar is now required to be on the classpath in order to
compile Scala code. See the scala-library.jar section at the bottom
of the page for details.
</li></ul><h4 id="Features">Features<a href="#Features" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Support for forking tests (gh-415)
</li><li><code>test-quick</code> (see details section below)
</li><li>Support globally overriding repositories (gh-472)
</li><li>Added <code>print-warnings</code> task that will print unchecked and
deprecation warnings from the previous compilation without needing
to recompile (Scala 2.10+ only)
</li><li>Support for loading an ivy settings file from a URL.
</li><li><code>projects add/remove &lt;URI&gt;</code> for temporarily working with other
builds
</li><li>Enhanced control over parallel execution (see details section below)
</li><li><code>inspect tree &lt;key&gt;</code> for calling <code>inspect</code> command recursively
(gh-274)
</li></ul><h4 id="Fixes">Fixes<a href="#Fixes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Delete a symlink and not its contents when recursively deleting a
directory.
</li><li>Fix detection of ancestors for java sources
</li><li>Fix the resolvers used for <code>update-sbt-classifiers</code> (gh-304)
</li><li>Fix auto-imports of plugins (gh-412)
</li><li>Argument quoting (see details section below)
</li><li>Properly reset JLine after being stopped by Ctrl+z (unix only).
gh-394
</li></ul><h4 id="Improvements">Improvements<a href="#Improvements" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>The launcher can launch all released sbt versions back to 0.7.0.
</li><li>A more refined hint to run ‘last’ is given when a stack trace is
suppressed.
</li><li>Use java 7 Redirect.INHERIT to inherit input stream of subprocess
(gh-462,gh-327). This should fix issues when forking interactive
programs. (@vigdorchik)
</li><li>Mirror ivy ‘force’ attribute (gh-361)
</li><li>Various improvements to <code>help</code> and <code>tasks</code> commands as well as new
settings command (gh-315)
</li><li>Bump jsch version to 0.1.46. (gh-403)
</li><li>Improved help commands: <code>help</code>, <code>tasks</code>, <code>settings</code>.
</li><li>Bump to JLine 1.0 (see details section below)
</li><li>Global repository setting (see details section below)
</li><li>Other fixes/improvements: gh-368, gh-377, gh-378, gh-386, gh-387,
gh-388, gh-389
</li></ul><h4 id="Experimental+or+In-progress">Experimental or In-progress<a href="#Experimental+or+In-progress" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>API for embedding incremental compilation. This interface is subject
to change, but already being used in <a href="https://github.com/davidB/scala-maven-plugin/tree/feature/sbt-inc">a branch of the
scala-maven-plugin</a>.
</li><li>Experimental support for keeping the Scala compiler resident. Enable
by passing -Dsbt.resident.limit=n to sbt, where n is an integer
indicating the maximum number of compilers to keep around.
</li><li>The <a href="Howto.html">Howto pages</a> on the
<a href="http://www.scala-sbt.org">new site</a> are at least readable now. There
is more content to write and more formatting improvements are
needed, so <a href="https://github.com/sbt/sbt.github.com">pull requests are
welcome</a>.
</li></ul><h3 id="Details+of+major+changes+from+0.11.2+to+0.12.0">Details of major changes from 0.11.2 to 0.12.0<a href="#Details+of+major+changes+from+0.11.2+to+0.12.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Plugin+configuration+directory">Plugin configuration directory<a href="#Plugin+configuration+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In 0.11.0, plugin configuration moved from <code>project/plugins/</code> to just
<code>project/</code>, with <code>project/plugins/</code> being deprecated. Only 0.11.2 had a
deprecation message, but in all of 0.11.x, the presence of the old style
<code>project/plugins/</code> directory took precedence over the new style. In
0.12.0, the new style takes precedence. Support for the old style won’t
be removed until 0.13.0.
</p><ol><li>Ideally, a project should ensure there is never a conflict. Both
styles are still supported; only the behavior when there is a
conflict has changed.
</li><li>In practice, switching from an older branch of a project to a new
branch would often leave an empty project/plugins/ directory that
would cause the old style to be used, despite there being no
configuration there.
</li><li>Therefore, the intention is that this change is strictly an
improvement for projects transitioning to the new style and isn’t
noticed by other projects.
</li></ol><h4 id="Parsing+task+axis">Parsing task axis<a href="#Parsing+task+axis" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is an important change related to parsing the task axis for
settings and tasks that fixes gh-202
</p><ol><li>The syntax before 0.12 has been <code>{build}project/config:key(for task)</code>
</li><li>The proposed (and implemented) change for 0.12 is
<code>{build}project/config:task::key</code>
</li><li>By moving the task axis before the key, it allows for easier
discovery (via tab completion) of keys in plugins.
</li><li>It is not planned to support the old syntax.
</li></ol><h4 id="Aggregation">Aggregation<a href="#Aggregation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Aggregation has been made more flexible. This is along the direction
that has been previously discussed on the mailing list.
</p><ol><li>Before 0.12, a setting was parsed according to the current project
and only the exact setting parsed was aggregated.
</li><li>Also, tab completion did not account for aggregation.
</li><li>This meant that if the setting/task didn’t exist on the current
project, parsing failed even if an aggregated project contained the
setting/task.
</li><li>Additionally, if compile:package existed for the current project,
<code>*:package</code> existed for an aggregated project, and the user requested
‘package’ to run (without specifying the configuration), <code>*:package</code>
wouldn’t be run on the aggregated project (because it isn’t the same
as the <code>compile:package</code> key that existed on the current project).
</li><li><p>In 0.12, both of these situations result in the aggregated settings
being selected. For example,
</p><ol><li>Consider a project <code>root</code> that aggregates a subproject <code>sub</code>.
</li><li><code>root</code> defines <code>*:package</code>.
</li><li><code>sub</code> defines <code>compile:package</code> and <code>compile:compile</code>.
</li><li>Running <code>root/package</code> will run <code>root/*:package</code> and
<code>sub/compile:package</code>
</li><li>Running <code>root/compile</code> will run <code>sub/compile:compile</code>
</li></ol></li><li>This change was made possible in part by the change to task axis
parsing.
</li></ol><h4 id="Parallel+Execution">Parallel Execution<a href="#Parallel+Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Fine control over parallel execution is supported as described here:
<a href="Parallel-Execution.html">Parallel Execution</a>.
</p><ol><li>The default behavior should be the same as before, including the
parallelExecution settings.
</li><li>The new capabilities of the system should otherwise be considered
experimental.
</li><li>Therefore, <code>parallelExecution</code> won’t be deprecated at this time.
</li></ol><h4 id="Source+dependencies">Source dependencies<a href="#Source+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A fix for issue gh-329 is included in 0.12.0. This fix ensures that only
one version of a plugin is loaded across all projects. There are two
parts to this.
</p><ol><li>The version of a plugin is fixed by the first build to load it. In
particular, the plugin version used in the root build (the one in
which sbt is started in) always overrides the version used in
dependencies.
</li><li>Plugins from all builds are loaded in the same class loader.
</li></ol><p>Additionally, Sanjin’s patches to add support for hg and svn URIs are
included.
</p><ol><li>sbt uses subversion to retrieve URIs beginning with <code>svn</code> or
svn+ssh. An optional fragment identifies a specific revision to
checkout.
</li><li>Because a URI for mercurial doesn’t have a mercurial-specific
scheme, sbt requires the URI to be prefixed with hg: to identify it
as a mercurial repository.
</li><li>Also, URIs that end with <code>.git</code> are now handled properly.
</li></ol><h4 id="Cross+building">Cross building<a href="#Cross+building" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The cross version suffix is shortened to only include the major and
minor version for Scala versions starting with the 2.10 series and for
sbt versions starting with the 0.12 series. For example, <code>sbinary_2.10</code>
for a normal library or <code>sbt-plugin_2.10_0.12</code> for an sbt plugin. This
requires forward and backward binary compatibility across incremental
releases for both Scala and sbt.
</p><ol><li><p>This change has been a long time coming, but it requires everyone
publishing an open source project to switch to 0.12 to publish for
</p><ol><li>10 or adjust the cross versioned prefix in their builds
appropriately.
</li></ol></li><li>Obviously, using 0.12 to publish a library for 2.10 requires 0.12.0
to be released before projects publish for 2.10.
</li><li>There is now the concept of a binary version. This is a subset of
the full version string that represents binary compatibility. That
is, equal binary versions implies binary compatibility. All Scala
versions prior to 2.10 use the full version for the binary version
to reflect previous sbt behavior. For 2.10 and later, the binary
version is <code>&lt;major&gt;.&lt;minor&gt;</code>.
</li><li>The cross version behavior for published artifacts is configured by
the crossVersion setting. It can be configured for dependencies by
using the cross method on ModuleID or by the traditional %%
dependency construction variant. By default, a dependency has cross
versioning disabled when constructed with a single % and uses the
binary Scala version when constructed with %%.
</li><li>The artifactName function now accepts a type ScalaVersion as its
first argument instead of a String. The full type is now
(ScalaVersion, ModuleID, Artifact) =&gt; String. ScalaVersion contains
both the full Scala version (such as 2.10.0) as well as the binary
Scala version (such as 2.10).
</li><li>The flexible version mapping added by Indrajit has been merged into
the cross method and the %% variants accepting more than one
argument have been deprecated. See <a href="Cross-Build.html">Cross Build</a> for
details.
</li></ol><h4 id="Global+repository+setting">Global repository setting<a href="#Global+repository+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Define the repositories to use by putting a standalone <code>[repositories]</code>
section (see the <a href="Sbt-Launcher.html">sbt Launcher</a> page) in
<code>~/.sbt/repositories</code> and pass <code>-Dsbt.override.build.repos=true</code> to sbt.
Only the repositories in that file will be used by the launcher for
retrieving sbt and Scala and by sbt when retrieving project
dependencies. (@jsuereth)
</p><h4 id="test-quick">test-quick<a href="#test-quick" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>test-quick</code> (gh-393) runs the tests specified as arguments (or all
tests if no arguments are given) that:
</p><ol><li>have not been run yet OR
</li><li>failed the last time they were run OR
</li><li>had any transitive dependencies recompiled since the last successful
run
</li></ol><h4 id="Argument+quoting">Argument quoting<a href="#Argument+quoting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Argument quoting (gh-396) from the intereactive mode works like Scala
string literals.
</p><ol><li><code>&gt; command &quot;arg with spaces,\n escapes interpreted&quot;</code>
</li><li><code>&gt; command &quot;&quot;&quot;arg with spaces,\n escapes not interpreted&quot;&quot;&quot;</code>
</li><li>For the first variant, note that paths on Windows use backslashes
and need to be escaped (). Alternatively, use the second
variant, which does not interpret escapes.
</li><li>For using either variant in batch mode, note that a shell will
generally require the double quotes themselves to be escaped.
</li></ol><h3 id="scala-library.jar">scala-library.jar<a href="#scala-library.jar" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt versions prior to 0.12.0 provided the location of scala-library.jar
to scalac even if scala-library.jar wasn’t on the classpath. This
allowed compiling Scala code without scala-library as a dependency, for
example, but this was a misfeature. Instead, the Scala library should be
declared as <code>provided</code>:
</p><pre><code class="prettyprint lang-scala">// Don't automatically add the scala-library dependency
// in the 'compile' configuration
autoScalaLibrary := false

libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-library&quot; % &quot;2.9.2&quot; % &quot;provided&quot;
</code></pre><h2 id="Older+Changes">Older Changes<a href="#Older+Changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="0.12.3+to+0.12.4">0.12.3 to 0.12.4<a href="#0.12.3+to+0.12.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Work around URI problems with encoding and resolving. (gh-725)
</li><li>Allow -cp argument to <code>apply</code> command to be quoted. (gh-724)
</li><li>Make <code>sbtBinaryVersion</code> use the new approach for 0.13 and later to
support cross-building plugins.
</li><li>Pull <code>sbtDependency</code> version from <code>sbtVersion</code> to facilitate
cross-building plugins.
</li><li>Proper support for stashing on-failure handlers. (gh-732)
</li><li>Include files with zip extension in unmanaged jars. (gh-750)
</li><li>Only add automatically detected plugins to options once. (gh-757)
</li><li>Properly handle failure in a multi-command that includes <code>reload</code>.
(gh-732)
</li><li>Fix unsynchronized caching of Scala class loaders that could result
in Scala classes being loaded in multiple class loaders.
</li><li>Incremental compiler: remove resident compiler code (wasn’t used and
was a compatibility liability)
</li><li>Incremental compiler: properly track <code>abstract override</code> modifier.
(gh-726)
</li><li>Incremental compiler: do not normalize types in the api extraction
phase. (gh-736)
</li><li>Ivy cache: account for <code>localOnly</code> when cache subclass overrides
<code>isChanging</code>
</li><li>Ivy cache: fix corruption when developing sbt or sbt plugins.
(gh-768)
</li><li>Ivy cache: invalidate when artifact download fails to avoid locking
into bad resolver. (gh-760)
</li><li>Ivy cache: use publication date from metadata instead of original
file’s last modified time when deleting out of date artifacts.
(gh-764)
</li></ul><h3 id="0.12.2+to+0.12.3">0.12.2 to 0.12.3<a href="#0.12.2+to+0.12.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Allow <code>cleanKeepFiles</code> to contain directories
</li><li>Disable Ivy debug-level logging for performance. (gh-635)
</li><li>Invalidate artifacts not recorded in the original metadata when a
module marked as changing changes. (gh-637, gh-641)
</li><li>Ivy Artifact needs wildcard configuration added if no explicit ones
are defined. (gh-439)
</li><li>Right precedence of sbt.boot.properties lookup, handle qualifier
correctly. (gh-651)
</li><li>Mark the tests failed exception as having already provided feedback.
</li><li>Handle exceptions not caught by the test framework when forking.
(gh-653)
</li><li>Support <code>reload plugins</code> after ignoring a failure to load a project.
</li><li>Workaround for os deadlock detection at the process level. (gh-650)
</li><li>Fix for dependency on class file corresponding to a package.
(Grzegorz K., gh-620)
</li><li>Fix incremental compilation problem with package objects inheriting
from invalidated sources in a subpackage.
</li><li>Use Ivy’s default name for the resolution report so that links to
other configurations work.
</li><li>Include jars from java.ext.dirs in incremental classpath. (gh-678)
</li><li>Multi-line prompt text offset issue (Jibbers42, gh-625)
</li><li>Added <code>xml:space=&quot;preserve&quot;</code> attribute to extraDependencyAttributes
XML Block for publishing poms for plugins dependent on other plugins
(Brendan M., gh-645)
</li><li>Tag the actual test task and not a later task. (gh-692)
</li><li>Make exclude-classifiers per-user instead of per-build. (gh-634)
</li><li>Load global plugins in their own class loader and replace the base
loader with that. (gh-272)
</li><li>Demote the default conflict warnings to the debug level. These will
be removed completely in 0.13. (gh-709)
</li><li>Fix Ivy cache issues when multiple resolvers are involved. (gh-704)
</li></ul><h3 id="0.12.1+to+0.12.2">0.12.1 to 0.12.2<a href="#0.12.1+to+0.12.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Support -Yrangepos. (Lex S., gh-607)
</li><li>Only make one call to test frameworks per test name. (gh-520)
</li><li>Add <code>-cp</code> option to the <code>apply</code> method to make adding commands from
an external program easier.
</li><li>Stable representation of refinement typerefs. This fixes unnecessary
recompilations in some cases. (Adriaan M., gh-610)
</li><li>Disable aggregation for <code>run-main</code>. (gh-606)
</li><li>Concurrent restrictions: Untagged should be set based on the task’s
tags, not the tags of all tasks.
</li><li>When preserving the last modified time of files, convert negative
values to 0
</li><li>Use <code>java.lang.Throwable.setStackTrace</code> when sending exceptions back
from forked tests. (Eugene V., gh-543)
</li><li>Don’t merge dependencies with mismatched transitive/force/changing
values. (gh-582)
</li><li>Filter out null parent files when deleting empty directories.
(Eugene V., gh-589)
</li><li>Work around File constructor not accepting URIs for UNC paths.
(gh-564)
</li><li>Split ForkTests react() out to workaround SI-6526 (avoids a
stackoverflow in some forked test situations)
</li><li>Maven-style ivy repo support in the launcher config (Eric B.,
gh-585)
</li><li>Compare external binaries with canonical files (nau, gh-584)
</li><li>Call System.exit after the main thread is finished. (Eugene V.,
gh-565)
</li><li>Abort running tests on the first failure to communicate results back
to the main process. (Eugene V., gh-557)
</li><li>Don’t let the right side of the alias command fail the parse.
(gh-572)
</li><li>API extraction: handle any type that is annotated, not just the
spec’d simple type. (gh-559)
</li><li>Don’t try to look up the class file for a package. (gh-620)
</li></ul><h3 id="0.12.0+to+0.12.1">0.12.0 to 0.12.1<a href="#0.12.0+to+0.12.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Dependency management fixes:
</p><ul><li>Merge multiple dependency definitions for the same ID. Workaround
for gh-468, gh-285, gh-419, gh-480.
</li><li>Don’t write section of pom if scope is ‘compile’.
</li><li>Ability to properly match on artifact type. Fixes gh-507 (Thomas).
</li><li>Force <code>update</code> to run on changes to last modified time of artifacts
or cached descriptor (part of fix for gh-532). It may also fix
issues when working with multiple local projects via ‘publish-local’
and binary dependencies.
</li><li>Per-project resolution cache that deletes cached files before
update. Notes:
</li></ul><blockquote><ul><li>The resolution cache differs from the repository cache and does
not contain dependency metadata or artifacts.
</li><li>The resolution cache contains the generated ivy files, properties,
and resolve reports for the project.
</li><li>There will no longer be individual files directly in
<code>~/.ivy2/cache/</code>
</li><li>Resolve reports are now in target/resolution-cache/reports/,
viewable with a browser.
</li><li>Cache location includes extra attributes so that cross builds of a
plugin do not overwrite each other. Fixes gh-532.
</li></ul></blockquote><p>Three stage incremental compilation:
</p><ul><li>As before, the first step recompiles sources that were edited (or
otherwise directly invalidated).
</li><li>The second step recompiles sources from the first step whose API has
changed, their direct dependencies, and sources forming a cycle with
these sources.
</li><li>The third step recompiles transitive dependencies of sources from
the second step whose API changed.
</li><li>Code relying mainly on composition should see decreased compilation
times with this approach.
</li><li>Code with deep inheritance hierarchies and large cycles between
sources may take longer to compile.
</li><li><code>last compile</code> will show cycles that were processed in step 2.
Reducing large cycles of sources shown here may decrease compile
times.
</li></ul><p>Miscellaneous fixes and improvements:
</p><ul><li>Various test forking fixes. Fixes gh-512, gh-515.
</li><li>Proper isolation of build definition classes. Fixes gh-536, gh-511.
</li><li><code>orbit</code> packaging should be handled like a standard jar. Fixes
gh-499.
</li><li>In <code>IO.copyFile</code>, limit maximum size transferred via NIO. Fixes
gh-491.
</li><li>Add OSX JNI library extension in <code>includeFilter</code> by default. Fixes
gh-500. (Indrajit)
</li><li>Translate <code>show x y</code> into <code>;show x ;show y</code> . Fixes gh-495.
</li><li>Clean up temporary directory on exit. Fixes gh-502.
</li><li><code>set</code> prints the scopes+keys it defines and affects.
</li><li>Tab completion for <code>set</code> (experimental).
</li><li>Report file name when an error occurs while opening a corrupt zip
file in incremental compilation code. (James)
</li><li>Defer opening logging output files until an actual write. Helps
reduce number of open file descriptors.
</li><li>Back all console loggers by a common console interface that merges
(overwrites) consecutive Resolving xxxx … lines when ansi codes
are enabled (as first done by Play).
</li></ul><p>Forward-compatible-only change (not present in 0.12.0):
</p><ul><li><code>sourcesInBase</code> setting controls whether sources in base directory
are included. Fixes gh-494.
</li></ul><h3 id="0.11.3+to+0.12.0">0.11.3 to 0.12.0<a href="#0.11.3+to+0.12.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The changes for 0.12.0 are listed on a separate page. See
<a href="ChangeSummary_0.12.0.html">sbt 0.12.0 changes</a>.
</p><h3 id="0.11.2+to+0.11.3">0.11.2 to 0.11.3<a href="#0.11.2+to+0.11.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Dropping scala-tools.org:
</p><ul><li>The sbt group ID is changed to <code>org.scala-sbt</code> (from
org.scala-tools.sbt). This means you must use a 0.11.3 launcher to
launch 0.11.3.
</li><li>The convenience objects <code>ScalaToolsReleases</code> and ScalaToolsSnapshots
now point to https://oss.sonatype.org/content/repositories/releases
and …/snapshots
</li><li>The launcher no longer includes <code>scala-tools.org</code> repositories by
default and instead uses the Sonatype OSS snapshots repository for
Scala snapshots.
</li><li><p>The <code>scala-tools.org</code> releases repository is no longer included as
an application repository by default. The Sonatype OSS repository is
</p><p><em>not</em> included by default in its place.
</p></li></ul><p>Other fixes:
</p><ul><li>Compiler interface works with 2.10
</li><li><code>maxErrors</code> setting is no longer ignored
</li><li>Correct test count. gh-372 (Eugene)
</li><li>Fix file descriptor leak in process library (Daniel)
</li><li>Buffer url input stream returned by Using. gh-437
</li><li>Jsch version bumped to 0.1.46. gh-403
</li><li>JUnit test detection handles ancestors properly (Indrajit)
</li><li>Avoid unnecessarily re-resolving plugins. gh-368
</li><li>Substitute variables in explicit version strings and custom
repository definitions in launcher configuration
</li><li>Support setting sbt.version from system property, which overrides
setting in a properties file. gh-354
</li><li>Minor improvements to command/key suggestions
</li></ul><h3 id="0.11.1+to+0.11.2">0.11.1 to 0.11.2<a href="#0.11.1+to+0.11.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Notable behavior change:
</p><ul><li>The local Maven repository has been removed from the launcher’s list
of default repositories, which is used for obtaining sbt and Scala
dependencies. This is motivated by the high probability that
including this repository was causing the various problems some
users have with the launcher not finding some dependencies (gh-217).
</li></ul><p>Fixes:
</p><ul><li>gh-257 Fix invalid classifiers in pom generation (Indrajit)
</li><li>gh-255 Fix scripted plugin descriptor (Artyom)
</li><li>Fix forking git on windows (Stefan, Josh)
</li><li>gh-261 Fix whitespace handling for semicolon-separated commands
</li><li>gh-263 Fix handling of dependencies with an explicit URL
</li><li>gh-272 Show deprecation message for <code>project/plugins/</code>
</li></ul><h3 id="0.11.0+to+0.11.1">0.11.0 to 0.11.1<a href="#0.11.0+to+0.11.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Breaking change:
</p><ul><li>The scripted plugin is now in the <code>sbt</code> package so that it can be
used from a named package
</li></ul><p>Notable behavior change:
</p><ul><li>By default, there is more logging during update: one line per
dependency resolved and two lines per dependency downloaded. This is
to address the appearance that sbt hangs on larger ‘update’s.
</li></ul><p>Fixes and improvements:
</p><ul><li>Show help for a key with <code>help &lt;key&gt;</code>
</li><li>gh-21 Reduced memory and time overhead of incremental recompilation
with signature hash based approach.
</li><li>Rotate global log so that only output since last prompt is displayed
for last
</li><li>gh-169 Add support for exclusions with excludeAll and exclude
methods on ModuleID. (Indrajit)
</li><li>gh-235 Checksums configurable for launcher
</li><li>gh-246 Invalidate <code>update</code> when <code>update</code> is invalidated for an
internal project dependency
</li><li>gh-138 Include plugin sources and docs in <code>update-sbt-classifiers</code>
</li><li>gh-219 Add cleanupCommands setting to specify commands to run before
interpreter exits
</li><li>gh-46 Fix regression in caching missing classifiers for
<code>update-classifiers</code> and <code>update-sbt-classifiers</code>.
</li><li>gh-228 Set <code>connectInput</code> to true to connect standard input to
forked run
</li><li>gh-229 Limited task execution interruption using ctrl+c
</li><li>gh-220 Properly record source dependencies from separate compilation
runs in the same step.
</li><li>gh-214 Better default behavior for classpathConfiguration for
external Ivy files
</li><li>gh-212 Fix transitive plugin dependencies.
</li><li>gh-222 Generate section in make-pom. (Jan)
</li><li>Build resolvers, loaders, and transformers.
</li><li>Allow project dependencies to be modified by a setting
(buildDependencies) but with the restriction that new builds cannot
be introduced.
</li><li>gh-174, gh-196, gh-201, gh-204, gh-207, gh-208, gh-226, gh-224,
gh-253
</li></ul><h3 id="0.10.1+to+0.11.0">0.10.1 to 0.11.0<a href="#0.10.1+to+0.11.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Major Improvements:
</p><ul><li>Move to 2.9.1 for project definitions and plugins
</li><li>Drop support for 2.7
</li><li>Settings overhaul, mainly to make API documentation more usable
</li><li>Support using native libraries in <code>run</code> and <code>test</code> (but not console,
for example)
</li><li><p>Automatic plugin cross-versioning. Use
</p><pre><code>addSbtPlugin(&quot;group&quot; % &quot;name&quot; % &quot;version&quot;)
</code></pre><p>in project/plugins.sbt instead of <code>libraryDependencies += ...</code> See
[Plugins][Plugins] for details
</p></li></ul><p>Fixes and Improvements:
</p><ul><li>Display all undefined settings at once, instead of only the first
one
</li><li>Deprecate separate <code>classpathFilter</code>, <code>defaultExcludes</code>, and
sourceFilter keys in favor of includeFilter and excludeFilter
explicitly scoped by unmanagedSources, unmanagedResources, or
unmanagedJars as appropriate (Indrajit)
</li><li>Default to using shared boot directory in <code>~/.sbt/boot/</code>
</li><li>Can put contents of <code>project/plugins/</code> directly in <code>project/</code>
instead. Will likely deprecate plugins/ directory
</li><li>Key display is context sensitive. For example, in a single project,
the build and project axes will not be displayed
</li><li>gh-114, gh-118, gh-121, gh-132, gh-135, gh-157: Various settings and
error message improvements
</li><li>gh-115: Support configuring checksums separately for <code>publish</code> and
<code>update</code>
</li><li>gh-118: Add <code>about</code> command
</li><li>gh-118, gh-131: Improve <code>last</code> command. Aggregate <code>last &lt;task&gt;</code> and
display all recent output for <code>last</code>
</li><li>gh-120: Support read-only external file projects (Fred)
</li><li>gh-128: Add <code>skip</code> setting to override recompilation change
detection
</li><li>gh-139: Improvements to pom generation (Indrajit)
</li><li>gh-140, gh-145: Add standard manifest attributes to binary and
source jars (Indrajit)
</li><li>Allow sources used for <code>doc</code> generation to be different from sources
for <code>compile</code>
</li><li>gh-156: Made <code>package</code> an alias for <code>package-bin</code>
</li><li>gh-162: handling of optional dependencies in pom generation
</li></ul><h3 id="0.10.0+to+0.10.1">0.10.0 to 0.10.1<a href="#0.10.0+to+0.10.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Some of the more visible changes:
</p><ul><li>Support “provided” as a valid configuration for inter-project
dependencies gh-53
</li><li>Try out some better error messages for build.sbt in a few common
situations gh-58
</li><li>Drop “Incomplete tasks …” line from error messages. gh-32
</li><li>Better handling of javac logging. gc-74
</li><li>Warn when reload discards session settings
</li><li>Cache failing classifiers, making ‘update-classifiers’ a practical
replacement for withSources()
</li><li>Global settings may be provided in <code>~/.sbt/build.sbt</code> gh-52
</li><li>No need to define <code>&quot;sbtPlugin := true&quot;</code> in <code>project/plugins/</code> or
<code>~/.sbt/plugins/</code>
</li><li>Provide statistics and list of evicted modules in UpdateReport
</li><li>Scope use of ‘transitive-classifiers’ by ‘update-sbt-classifiers’
and ‘update-classifiers’ for separate configuration.
</li><li>Default project ID includes a hash of base directory to avoid
collisions in simple cases.
</li><li>’extra-loggers’ setting to make it easier to add loggers
</li><li>Associate ModuleID, Artifact and Configuration with a classpath
entry (moduleID, artifact, and configuration keys). gh-41
</li><li>Put httpclient on Ivy’s classpath, which seems to speed up ‘update’.
</li></ul><h3 id="0.7.7+to+0.10.0">0.7.7 to 0.10.0<a href="#0.7.7+to+0.10.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><strong>Major redesign, only prominent changes listed.</strong>
</p><ul><li>Project definitions in Scala 2.8.1
</li><li>New configuration system: See <a href="Basic-Def-Examples.html">.sbt build example</a>,
<a href="../tutorial/Full-Def.html">.scala build defnition</a> and <a href="../tutorial/Basic-Def.html">.sbt build definition</a>.
</li><li>New task engine: <a href="Tasks.html">Tasks</a>
</li><li>New multiple project support: <a href="../tutorial/Full-Def.html">.scala build defnition</a>
</li><li>More aggressive incremental recompilation for both Java and Scala
sources
</li><li>Merged plugins and processors into improved plugins system:
<a href="Plugins.html">Plugins</a>
</li><li><a href="https://github.com/JamesEarlDouglas/xsbt-web-plugin">Web application</a>
and webstart support moved to plugins instead of core features
</li><li>Fixed all of the issues in (Google Code) issue #44
</li><li>Managed dependencies automatically updated when configuration
changes
</li><li><code>update-sbt-classifiers</code> and <code>update-classifiers</code> tasks for
retrieving sources and/or javadocs for dependencies, transitively
</li><li>Improved [artifact handling and configuration][Attifacts]
</li><li>Tab completion parser combinators for commands and input tasks:
<a href="Commands.html">Commands</a>
</li><li>No project creation prompts anymore
</li><li>Moved to GitHub: <a href="http://github.com/harrah/xsbt">http://github.com/harrah/xsbt</a>
</li></ul><h3 id="0.7.5+to+0.7.7">0.7.5 to 0.7.7<a href="#0.7.5+to+0.7.7" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Workaround for Scala issue
<a href="http://lampsvn.epfl.ch/trac/scala/ticket/4426">#4426</a>
</li><li>Fix issue 156
</li></ul><h3 id="0.7.4+to+0.7.5">0.7.4 to 0.7.5<a href="#0.7.4+to+0.7.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Joonas’s update to work with Jetty 7.1 logging API changes.
</li><li>Updated to work with Jetty 7.2 WebAppClassLoader binary
incompatibility (issue 129).
</li><li>Provide application and boot classpaths to tests and ‘run’ning code
according to <a href="http://gist.github.com/404272">http://gist.github.com/404272</a>
</li><li>Fix <code>provided</code> configuration. It is no longer included on the
classpath of dependent projects.
</li><li>Scala 2.8.1 is the default version used when starting a new project.
</li><li>Updated to
<a href="http://ant.apache.org/ivy/history/2.2.0/release-notes.html">Ivy 2.2.0</a>.
</li><li>Trond’s patches that allow configuring
<a href="http://github.com/sbt/sbt/commit/5e41a47f50e6">jetty-env.xml</a> and
<a href="http://github.com/sbt/sbt/commit/030e2ee91bac0">webdefault.xml</a>
</li><li>Doug’s <a href="http://github.com/sbt/sbt/commit/aa75ecf7055db">patch</a> to
make ‘projects’ command show an asterisk next to current project
</li><li>Fixed issue 122
</li><li>Implemented issue 118
</li><li>Patch from Viktor and Ross for issue 123
</li><li>(RC1) Patch from Jorge for issue 100
</li><li>(RC1) Fix <code>&lt;packaging&gt;</code> type
</li></ul><h3 id="0.7.3+to+0.7.4">0.7.3 to 0.7.4<a href="#0.7.3+to+0.7.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>prefix continuous compilation with run number for better feedback
when logging level is ‘warn’
</li><li>Added <code>pomIncludeRepository(repo: MavenRepository): Boolean</code> that
can be overridden to exclude local repositories by default
</li><li>Added <code>pomPostProcess(pom: Node): Node</code> to make advanced
manipulation of the default pom easier (pomExtra already covers
basic cases)
</li><li>Added <code>reset</code> command to reset JLine terminal. This needs to be run
after suspending and then resuming sbt.
</li><li>Installer plugin is now a proper subproject of sbt.
</li><li>Plugins can now only be Scala sources. BND should be usable in a
plugin now.
</li><li>More accurate detection of invalid test names. Invalid test names
now generate an error and prevent the test action from running
instead of just logging a warning.
</li><li>Fix issue with using 2.8.0.RC1 compiler in tests.
</li><li>Precompile compiler interface against 2.8.0.RC2
</li><li>Add <code>consoleOptions</code> for specifying options to the console. It
defaults to compileOptions.
</li><li>Properly support sftp/ssh repositories using key-based
authentication. See the updated section of the
<a href="Resolvers.html">Resolvers</a> page.
</li><li><code>def ivyUpdateLogging = UpdateLogging.DownloadOnly | Full | Quiet</code>.
Default is DownloadOnly. Full will log metadata resolution and
provide a final summary.
</li><li><code>offline</code> property for disabling checking for newer dynamic
revisions (like -SNAPSHOT). This allows working offline with remote
snapshots. Not honored for plugins yet.
</li><li>History commands: <code>!!, !?string, !-n, !n, !string, !:n, !:</code> Run ! to
see help.
</li><li>New section in launcher configuration <code>[ivy]</code> with a single label
cache-directory. Specify this to change the cache location used by
the launcher.
</li><li>New label <code>classifiers</code> under <code>[app]</code> to specify classifiers of
additional artifacts to retrieve for the application.
</li><li>Honor <code>-Xfatal-warnings</code> option added to compiler in 2.8.0.RC2.
</li><li>Make <code>scaladocTask</code> a <code>fileTask</code> so that it runs only when
index.html is older than some input source.
</li><li>Made it easier to create default <code>test-*</code> tasks with different
options
</li><li>Sort input source files for consistency, addressing scalac’s issues
with source file ordering.
</li><li><p>Derive Java source file from name of class file when no SourceFile
attribute is present in the class file. Improves tracking when
</p><ul><li>g:none option is used.
</li></ul></li><li>Fix <code>FileUtilities.unzip</code> to be tail-recursive again.
</li></ul><h3 id="0.7.2+to+0.7.3">0.7.2 to 0.7.3<a href="#0.7.2+to+0.7.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed issue with scala.library.jar not being on javac’s classpath
</li><li>Fixed buffered logging for parallel execution
</li><li>Fixed <code>test-*</code> tab completion being permanently set on first
completion
</li><li>Works with Scala 2.8 trunk again.
</li><li>Launcher: Maven local repository excluded when the Scala version is
a snapshot. This should fix issues with out of date Scala snapshots.
</li><li>The compiler interface is precompiled against common Scala versions
(for this release, 2.7.7 and 2.8.0.Beta1).
</li><li>Added <code>PathFinder.distinct</code>
</li><li>Running multiple commands at once at the interactive prompt is now
supported. Prefix each command with ’;’.
</li><li>Run and return the output of a process as a String with <code>!!</code> or as a
(blocking) Stream[String] with lines.
</li><li>Java tests + Annotation detection
</li><li>Test frameworks can now specify annotation fingerprints. Specify the
names of annotations and sbt discovers classes with the annotations
on it or one of its methods. Use version 0.5 of the test-interface.
</li><li>Detect subclasses and annotations in Java sources (really, their
class files)
</li><li>Discovered is new root of hierarchy representing discovered
subclasses + annotations. TestDefinition no longer fulfills this
role.
</li><li><code>TestDefinition</code> is modified to be name+<code>Fingerprint</code> and represents
a runnable test. It need not be Discovered, but could be file-based
in the future, for example.
</li><li>Replaced testDefinitionClassNames method with <code>fingerprints</code> in
CompileConfiguration.
</li><li>Added foundAnnotation to <code>AnalysisCallback</code>
</li><li>Added <code>Runner2</code>, <code>Fingerprint</code>, <code>AnnotationFingerprint</code>, and
SubclassFingerprint to the test-interface. Existing test frameworks
should still work. Implement Runner2 to use fingerprints other than
SubclassFingerprint.
</li></ul><h3 id="0.7.1+to+0.7.2">0.7.1 to 0.7.2<a href="#0.7.1+to+0.7.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>Process.apply</code> no longer uses <code>CommandParser</code>. This should fix
issues with the android-plugin.
</li><li>Added <code>sbt.impl.Arguments</code> for parsing a command like a normal
action (for Processors)
</li><li>Arguments are passed to <code>javac</code> using an argument file (<code>@</code>)
</li><li><p>Added <code>webappUnmanaged: PathFinder</code> method to DefaultWebProject.
Paths selected by this PathFinder will not be pruned by
prepare-webapp and will not be packaged by package. For example, to
exclude the GAE datastore directory:
</p><pre><code class="prettyprint lang-scala">override def webappUnmanaged =     (temporaryWarPath / &quot;WEB-INF&quot; / &quot;appengine-generated&quot; ***)
</code></pre></li><li>Added some String generation methods to <code>PathFinder</code>: <code>toString</code> for
debugging and absString and relativeString for joining the absolute
(relative) paths by the platform separator.
</li><li>Made tab completors lazier to reduce startup time.
</li><li>Fixed <code>console-project</code> for custom subprojects
</li><li><code>Processor</code> split into <code>Processor</code>/<code>BasicProcessor</code>. Processor
provides high level of integration with command processing.
BasicProcessor operates on a Project but does not affect command
processing.
</li><li>Can now use <code>Launcher</code> externally, including launching <code>sbt</code> outside
of the official jar. This means a Project can now be created from
tests.
</li><li>Works with Scala 2.8 trunk
</li><li>Fixed logging level behavior on subprojects.
</li><li>All sbt code is now at <a href="http://github.com/harrah/xsbt">http://github.com/harrah/xsbt</a> in one
project.
</li></ul><h3 id="0.7.0+to+0.7.1">0.7.0 to 0.7.1<a href="#0.7.0+to+0.7.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed Jetty 7 support to work with JRebel
</li><li>Fixed make-pom to generate valid dependencies section
</li></ul><h3 id="0.5.6+to+0.7.0">0.5.6 to 0.7.0<a href="#0.5.6+to+0.7.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Unifed batch and interactive commands. All commands that can be
executed at interactive prompt can be run from the command line. To
run commands and then enter interactive prompt, make the last
command ‘shell’.
</li><li>Properly track certain types of synthetic classes, such as for
comprehension with &gt;30 clauses, during compilation.
</li><li>Jetty 7 support
</li><li>Allow launcher in the project root directory or the <code>lib</code> directory.
The jar name must have the form ‘sbt-launch.jar’ in order to be
excluded from the classpath.
</li><li>Stack trace detail can be controlled with <code>'on'</code>, <code>'off'</code>, ‘nosbt’,
or an integer level. ‘nosbt’ means to show stack frames up to the
first sbt method. An integer level denotes the number of frames to
show for each cause. This feature is courtesty of Tony Sloane.
</li><li>New action ‘test-run’ method that is analogous to ‘run’, but for
test classes.
</li><li>New action ‘clean-plugins’ task that clears built plugins (useful
for plugin development).
</li><li>Can provide commands from a file with new command: <code>&lt;filename</code>
</li><li>Can provide commands over loopback interface with new command: <code>&lt;port</code>
</li><li>Scala version handling has been completely redone.
</li><li>The version of Scala used to run sbt (currently 2.7.7) is decoupled
from the version used to build the project.
</li><li>Changing between Scala versions on the fly is done with the command:
<code>++&lt;version&gt;</code>
</li><li>Cross-building is quicker. The project definition does not need to
be recompiled against each version in the cross-build anymore.
</li><li>Scala versions are specified in a space-delimited list in the
build.scala.versions property.
</li><li>Dependency management:
</li><li><code>make-pom</code> task now uses custom pom generation code instead of Ivy’s
pom writer.
</li><li>Basic support for writing out Maven-style repositories to the pom
</li><li>Override the ‘pomExtra’ method to provide XML (<code>scala.xml.NodeSeq</code>)
to insert directly into the generated pom.
</li><li>Complete control over repositories is now possible by overriding
ivyRepositories.
</li><li>The interface to Ivy can be used directly.
</li><li>Test framework support is now done through a uniform test interface.
Implications:
</li><li>New versions of specs, ScalaCheck, and ScalaTest are supported as
soon as they are released.
</li><li>Support is better, since the test framework authors provide the
implementation.
</li><li>Arguments can be passed to the test framework. For example: {{{ &gt;
test-only your.test — -a -b -c }}}
</li><li>Can provide custom task start and end delimiters by defining the
system properties sbt.start.delimiter and sbt.end.delimiter.
</li><li>Revamped launcher that can launch Scala applications, not just sbt
</li><li>Provide a configuration file to the launcher and it can download the
application and its dependencies from a repository and run it.
</li><li>sbt’s configuration can be customized. For example,
</li><li>The <code>sbt</code> version to use in projects can be fixed, instead of read
from project/build.properties.
</li><li>The default values used to create a new project can be changed.
</li><li>The repositories used to fetch <code>sbt</code> and its dependencies, including
Scala, can be configured.
</li><li>The location <code>sbt</code> is retrieved to is configurable. For example,
/home/user/.ivy2/sbt/ could be used instead of project/boot/.
</li></ul><h3 id="0.5.5+to+0.5.6">0.5.5 to 0.5.6<a href="#0.5.5+to+0.5.6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Support specs specifications defined as classes
</li><li>Fix specs support for 1.6
</li><li>Support ScalaTest 1.0
</li><li>Support ScalaCheck 1.6
</li><li>Remove remaining uses of structural types
</li></ul><h3 id="0.5.4+to+0.5.5">0.5.4 to 0.5.5<a href="#0.5.4+to+0.5.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed problem with classifier support and the corresponding test
</li><li>No longer need <code>&quot;-&gt;default&quot;</code> in configurations (automatically
mapped).
</li><li>Can specify a specific nightly of Scala 2.8 to use (for example:
<code>2.8.0-20090910.003346-+</code>)
</li><li>Experimental support for searching for project
(<code>-Dsbt.boot.search=none | only | root-first | nearest</code>)
</li><li>Fix issue where last path component of local repository was dropped
if it did not exist.
</li><li>Added support for configuring repositories on a per-module basis.
</li><li>Unified batch-style and interactive-style commands. All commands
that were previously interactive-only should be available
batch-style. ‘reboot’ does not pick up changes to ‘scala.version’
properly, however.
</li></ul><h3 id="0.5.2+to+0.5.4">0.5.2 to 0.5.4<a href="#0.5.2+to+0.5.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Many logging related changes and fixes. Added <code>FilterLogger</code> and
cleaned up interaction between Logger, scripted testing, and the
builder projects. This included removing the recordingDepth hack
from Logger. Logger buffering is now enabled/disabled per thread.
</li><li>Fix <code>compileOptions</code> being fixed after the first compile
</li><li>Minor fixes to output directory checking
</li><li>Added <code>defaultLoggingLevel</code> method for setting the initial level of
a project’s Logger
</li><li>Cleaned up internal approach to adding extra default configurations
like plugin
</li><li>Added <code>syncPathsTask</code> for synchronizing paths to a target directory
</li><li>Allow multiple instances of Jetty (new <code>jettyRunTasks</code> can be
defined with different ports)
</li><li><code>jettyRunTask</code> accepts configuration in a single configuration
wrapper object instead of many parameters
</li><li>Fix web application class loading (issue #35) by using
jettyClasspath=testClasspath—-jettyRunClasspath for loading Jetty.
A better way would be to have a jetty configuration and have
jettyClasspath=managedClasspath(’jetty’), but this maintains
compatibility.
</li><li>Copy resources to <code>target/resources</code> and <code>target/test-resources</code>
using copyResources and copyTestResources tasks. Properly include
all resources in web applications and classpaths (issue #36).
mainResources and testResources are now the definitive methods for
getting resources.
</li><li>Updated for 2.8 (<code>sbt</code> now compiles against September 11, 2009
nightly build of Scala)
</li><li>Fixed issue with position of <code>^</code> in compile errors
</li><li>Changed order of repositories (local, shared, Maven Central, user,
Scala Tools)
</li><li>Added Maven Central to resolvers used to find Scala library/compiler
in launcher
</li><li>Fixed problem that prevented detecting user-specified subclasses
</li><li>Fixed exit code returned when exception thrown in main thread for
TrapExit
</li><li><p>Added <code>javap</code> task to <code>DefaultProject</code>. It has tab completion on
compiled project classes and the run classpath is passed to javap so
that library classes are available. Examples: :
</p><pre><code>&gt; javap your.Clazz
&gt; javap -c scala.List
</code></pre></li><li><p>Added <code>exec</code> task. Mixin <code>Exec</code> to project definition to use. This
forks the command following exec. Examples: :
</p><pre><code>&gt; exec echo Hi
&gt; exec find src/main/scala -iname *.scala -exec wc -l {} ;
</code></pre></li><li><p>Added <code>sh</code> task for users with a unix-style shell available (runs
<code>/bin/sh -c &lt;arguments&gt;</code>). Mixin Exec to project definition to use.
Example: :
</p><pre><code class="">&gt; sh find src/main/scala -iname *.scala | xargs cat | wc -l
</code></pre></li><li>Proper dependency graph actions (previously was an unsupported
prototype): graph-src and graph-pkg for source dependency graph and
quasi-package dependency graph (based on source directories and
source dependencies)
</li><li>Improved Ivy-related code to not load unnecessary default settings
</li><li>Fixed issue #39 (sources were not relative in src package)
</li><li>Implemented issue #38 (<code>InstallProject</code> with ‘install’ task)
</li><li>Vesa’s patch for configuring the output of forked Scala/Java and
processes
</li><li>Don’t buffer logging of forked <code>run</code> by default
</li><li>Check <code>Project.terminateWatch</code> to determine if triggered execution
should stop for a given keypress.
</li><li>Terminate triggered execution only on ‘enter’ by default
(previously, any keypress stopped it)
</li><li>Fixed issue #41 (parent project should not declare jar artifact)
</li><li>Fixed issue #42 (search parent directories for <code>ivysettings.xml</code>)
</li><li><p>Added support for extra attributes with Ivy. Use
extra(key -&gt; value) on ModuleIDs and Artifacts. To define for a
project’s ID: :
</p><pre><code class="prettyprint lang-scala">override def projectID = super.projectID extra(key -&gt; value)
</code></pre><p>To specify in a dependency: :
</p><pre><code class="prettyprint lang-scala">val dep = normalID extra(key -&gt; value)
</code></pre></li></ul><h3 id="0.5.1+to+0.5.2">0.5.1 to 0.5.2<a href="#0.5.1+to+0.5.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed problem where dependencies of <code>sbt</code> plugins were not on the
compile classpath
</li><li>Added <code>execTask</code> that runs an <code>sbt.ProcessBuilder</code> when invoked
</li><li>Added implicit conversion from <code>scala.xml.Elem</code> to
sbt.ProcessBuilder that takes the element’s text content, trims it,
and splits it around whitespace to obtain the command.
</li><li>Processes can now redirect standard input (see run with Boolean
argument or <code>!&lt;</code> operator on ProcessBuilder), off by default
</li><li>Made scripted framework a plugin and scripted tests now go in
src/sbt-test by default
</li><li>Can define and use an sbt test framework extension in a project
</li><li>Fixed <code>run</code> action swallowing exceptions
</li><li>Fixed tab completion for method tasks for multi-project builds
</li><li>Check that tasks in <code>compoundTask</code> do not reference static tasks
</li><li>Make <code>toString</code> of <code>Path</code>s in subprojects relative to root project
directory
</li><li><code>crossScalaVersions</code> is now inherited from parent if not specified
</li><li>Added <code>scala-library.jar</code> to the <code>javac</code> classpath
</li><li>Project dependencies are added to published <code>ivy.xml</code>
</li><li>Added dependency tracking for Java sources using classfile parsing
(with the usual limitations)
</li><li><p>Added <code>Process.cat</code> that will send contents of <code>URL</code>s and Files to
standard output. Alternatively, cat can be used on a single URL or
File. Example: :
</p><pre><code class="prettyprint lang-scala">import java.net.URL
import java.io.File
val spde = new URL(&quot;http://technically.us/spde/About&quot;)
val dispatch = new URL(&quot;http://databinder.net/dispatch/About&quot;)
val build = new File(&quot;project/build.properties&quot;)
cat(spde, dispatch, build) #| &quot;grep -i scala&quot; !
</code></pre></li></ul><h3 id="0.4.6+to+0.5%2F0.5.1">0.4.6 to 0.5/0.5.1<a href="#0.4.6+to+0.5%2F0.5.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed <code>ScalaTest</code> framework dropping stack traces
</li><li>Publish only public configurations by default
</li><li>Loader now adds <code>.m2/repository</code> for downloading Scala jars
</li><li>Can now fork the compiler and runner and the runner can use a
different working directory.
</li><li>Maximum compiler errors shown is now configurable
</li><li>Fixed rebuilding and republishing released versions of <code>sbt</code> against
new Scala versions (attempt #2)
</li><li>Fixed snapshot reversion handling (Ivy needs changing pattern set on
cache, apparently)
</li><li>Fixed handling of default configuration when useMavenConfiguration
is true
</li><li>Cleanup on Environment, Analysis, Conditional, <code>MapUtilities</code>, and
more…
</li><li>Tests for Environment, source dependencies, library dependency
management, and more…
</li><li>Dependency management and multiple Scala versions
</li><li>Experimental plugin for producing project bootstrapper in a
self-extracting jar
</li><li>Added ability to directly specify <code>URL</code> to use for dependency with
the from(url: URL) method defined on ModuleID
</li><li>Fixed issue #30
</li><li>Support cross-building with <code>+</code> when running batch actions
</li><li>Additional flattening for project definitions: sources can go either
in project/build/src (recursively) or project/build (flat)
</li><li>Fixed manual <code>reboot</code> not changing the version of Scala when it is
manually set
</li><li>Fixed tab completion for cross-building
</li><li>Fixed a class loading issue with web applications
</li></ul><h3 id="0.4.5+to+0.4.6">0.4.5 to 0.4.6<a href="#0.4.5+to+0.4.6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Publishing to ssh/sftp/filesystem repository supported
</li><li>Exception traces are printed by default
</li><li>Fixed warning message about no <code>Class-Path</code> attribute from showing
up for run
</li><li>Fixed <code>package-project</code> operation
</li><li>Fixed <code>Path.fromFile</code>
</li><li>Fixed issue with external process output being lost when sent to a
BufferedLogger with parallelExecution enabled.
</li><li>Preserve history across <code>clean</code>
</li><li>Fixed issue with making relative path in jar with wrong separator
</li><li>Added cross-build functionality (prefix action with <code>+</code>).
</li><li>Added methods <code>scalaLibraryJar</code> and <code>scalaCompilerJar</code> to
FileUtilities
</li><li>Include project dependencies for <code>deliver</code>/<code>publish</code>
</li><li>Add Scala dependencies for <code>make-pom</code>/<code>deliver</code>/<code>publish</code>, which
requires these to depend on package
</li><li>Properly add compiler jar to run/test classpaths when main sources
depend on it
</li><li><code>TestFramework</code> root <code>ClassLoader</code> filters compiler classes used by
sbt, which is required for projects using the compiler.
</li><li>Better access to dependencies:
</li><li><code>mainDependencies</code> and <code>testDependencies</code> provide an analysis of the
dependencies of your code as determined during compilation
</li><li><code>scalaJars</code> is deprecated, use <code>mainDependencies.scalaJars</code> instead
(provides a PathFinder, which is generally more useful)
</li><li>Added <code>jettyPort</code> method to <code>DefaultWebProject</code>.
</li><li>Fixed <code>package-project</code> to exclude <code>project/boot</code> and
project/build/target
</li><li>Support specs 1.5.0 for Scala 2.7.4 version.
</li><li>Parallelization at the subtask level
</li><li>Parallel test execution at the suite/specification level.
</li></ul><h3 id="0.4.3+to+0.4.5">0.4.3 to 0.4.5<a href="#0.4.3+to+0.4.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Sorted out repository situation in loader
</li><li>Added support for <code>http_proxy</code> environment variable
</li><li>Added <code>download</code> method from Nathan to <code>FileUtilities</code> to retrieve
the contents of a URL.
</li><li>Added special support for compiler plugins, see
<a href="Compiler-Plugins.html">compiler plugins support</a> page.
</li><li><code>reload</code> command in scripted tests will now properly handle
success/failure
</li><li>Very basic support for Java sources: Java sources under
src/main/java and src/test/java will be compiled.
</li><li><code>parallelExecution</code> defaults to value in parent project if there is
one.
</li><li>Added ‘console-project’ that enters the Scala interpreter with the
current Project bound to the variable project.
</li><li>The default Ivy cache manager is now configured with useOrigin=true
so that it doesn’t cache artifacts from the local filesystem.
</li><li>For users building from trunk, if a project specifies a version of
sbt that ends in -SNAPSHOT, the loader will update sbt every time it
starts up. The trunk version of sbt will always end in -SNAPSHOT
now.
</li><li>Added automatic detection of classes with main methods for use when
mainClass is not explicitly specified in the project definition. If
exactly one main class is detected, it is used for run and package.
If multiple main classes are detected, the user is prompted for
which one to use for run. For package, no Main-Class attribute is
automatically added and a warning is printed.
</li><li>Updated build to cross-compile against Scala 2.7.4.
</li><li>Fixed <code>proguard</code> task in <code>sbt</code>’s project definition
</li><li>Added <code>manifestClassPath</code> method that accepts the value for the
Class-Path attribute
</li><li>Added <code>PackageOption</code> called <code>ManifestAttributes</code> that accepts
(java.util.jar.Attributes.Name, String) or (String, String) pairs
and adds them to the main manifest attributes
</li><li>Fixed some situations where characters would not be echoed at
prompts other than main prompt.
</li><li>Fixed issue #20 (use <code>http_proxy</code> environment variable)
</li><li>Implemented issue #21 (native process wrapper)
</li><li>Fixed issue #22 (rebuilding and republishing released versions of
sbt against new Scala versions, specifically Scala 2.7.4)
</li><li>Implemented issue #23 (inherit inline repositories declared in
parent project)
</li></ul><h3 id="0.4+to+0.4.3">0.4 to 0.4.3<a href="#0.4+to+0.4.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Direct dependencies on Scala libraries are checked for version
equality with scala.version
</li><li>Transitive dependencies on <code>scala-library</code> and <code>scala-compiler</code> are
filtered
</li><li>They are fixed by <code>scala.version</code> and provided on the classpath by
sbt
</li><li>To access them, use the <code>scalaJars</code> method,
classOf[ScalaObject].getProtectionDomain.getCodeSource, or
mainCompileConditional.analysis.allExternals
</li><li>The configurations checked/filtered as described above are
configurable. Nonstandard configurations are not checked by default.
</li><li>Version of <code>sbt</code> and Scala printed on startup
</li><li>Launcher asks if you want to try a different version if <code>sbt</code> or
Scala could not be retrieved.
</li><li>After changing <code>scala.version</code> or <code>sbt.version</code> with <code>set</code>, note is
printed that reboot is required.
</li><li>Moved managed dependency actions to <code>BasicManagedProject</code> (update is
now available on ParentProject)
</li><li>Cleaned up <code>sbt</code>’s build so that you just need to do <code>update</code> and
full-build to build from source. The trunk version of sbt will be
available for use from the loader.
</li><li>The loader is now a subproject.
</li><li>For development, you’ll still want the usual actions (such as
package) for the main builder and proguard to build the loader.
</li><li>Fixed analysis plugin improperly including traits/abstract classes
in subclass search
</li><li><code>ScalaProject</code>s already had everything required to be parent
projects: flipped the switch to enable it
</li><li>Proper method task support in scripted tests (<code>package</code> group tests
rightly pass again)
</li><li>Improved tests in loader that check that all necessary libraries
were downloaded properly
</li></ul><h3 id="0.3.7+to+0.4">0.3.7 to 0.4<a href="#0.3.7+to+0.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed issue with <code>build.properties</code> being unnecessarily updated in
sub-projects when loading.
</li><li>Added method to compute the SHA-1 hash of a <code>String</code>
</li><li>Added pack200 methods
</li><li>Added initial process interface
</li><li>Added initial webstart support
</li><li>Added gzip methods
</li><li>Added <code>sleep</code> and <code>newer</code> commands to scripted testing.
</li><li>Scripted tests now test the version of <code>sbt</code> being built instead of
the version doing the building.
</li><li><code>testResources</code> is put on the test classpath instead of
testResourcesPath
</li><li>Added <code>jetty-restart</code>, which does <code>jetty-stop</code> and then jetty-run
</li><li>Added automatic reloading of default web application
</li><li>Changed packaging behaviors (still likely to change)
</li><li>Inline configurations now allowed (can be used with configurations
in inline XML)
</li><li>Split out some code related to managed dependencies from
BasicScalaProject to new class BasicManagedProject
</li><li>Can specify that maven-like configurations should be automatically
declared
</li><li>Fixed problem with nested modules being detected as tests
</li><li><code>testResources</code>, <code>integrationTestResources</code>, and mainResources
should now be added to appropriate classpaths
</li><li>Added project organization as a property that defaults to inheriting
from the parent project.
</li><li>Project creation now prompts for the organization.
</li><li>Added method tasks, which are top-level actions with parameters.
</li><li>Made <code>help</code>, <code>actions</code>, and <code>methods</code> commands available to
batch-style invocation.
</li><li>Applied Mikko’s two fixes for webstart and fixed problem with
pack200+sign. Also, fixed nonstandard behavior when gzip enabled.
</li><li>Added <code>control</code> method to <code>Logger</code> for action lifecycle logging
</li><li>Made standard logging level convenience methods final
</li><li>Made <code>BufferedLogger</code> have a per-actor buffer instead of a global
buffer
</li><li>Added a <code>SynchronizedLogger</code> and a <code>MultiLogger</code> (intended to be
used with the yet unwritten FileLogger)
</li><li>Changed method of atomic logging to be a method <code>logAll</code> accepting
List[LogEvent] instead of doSynchronized
</li><li>Improved action lifecycle logging
</li><li>Parallel logging now provides immediate feedback about starting an
action
</li><li>General cleanup, including removing unused classes and methods and
reducing dependencies between classes
</li><li><code>run</code> is now a method task that accepts options to pass to the main
method (runOptions has been removed, runTask is no longer
interactive, and run no longer starts a console if mainClass is
undefined)
</li><li>Major task execution changes:
</li><li>Tasks automatically have implicit dependencies on tasks with the
same name in dependent projects
</li><li>Implicit dependencies on interactive tasks are ignored, explicit
dependencies produce an error
</li><li>Interactive tasks must be executed directly on the project on which
they are defined
</li><li>Method tasks accept input arguments (<code>Array[String]</code>) and
dynamically create the task to run
</li><li>Tasks can depend on tasks in other projects
</li><li>Tasks are run in parallel breadth-first style
</li><li>Added <code>test-only</code> method task, which restricts the tests to run to
only those passed as arguments.
</li><li>Added <code>test-failed</code> method task, which restricts the tests to run.
First, only tests passed as arguments are run. If no tests are
passed, no filtering is done. Then, only tests that failed the
previous run are run.
</li><li>Added <code>test-quick</code> method task, which restricts the tests to run.
First, only tests passed as arguments are run. If no tests are
passed, no filtering is done. Then, only tests that failed the
previous run or had a dependency change are run.
</li><li>Added launcher that allows declaring version of sbt/scala to build
project with.
</li><li>Added tab completion with <code>~</code>
</li><li>Added basic tab completion for method tasks, including <code>test-*</code>
</li><li>Changed default pack options to be the default options of
Pack200.Packer
</li><li>Fixed <code>~</code> behavior when action doesn’t exist
</li></ul><h3 id="0.3.6+to+0.3.7">0.3.6 to 0.3.7<a href="#0.3.6+to+0.3.7" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Improved classpath methods
</li><li>Refactored various features into separate project traits
</li><li><code>ParentProject</code> can now specify dependencies
</li><li>Support for <code>optional</code> scope
</li><li>More API documentation
</li><li>Test resource paths provided on classpath for testing
</li><li>Added some missing read methods in <code>FileUtilities</code>
</li><li>Added scripted test framework
</li><li>Change detection using hashes of files
</li><li>Fixed problem with manifests not being generated (bug #14)
</li><li>Fixed issue with scala-tools repository not being included by
default (again)
</li><li>Added option to set ivy cache location (mainly for testing)
</li><li>trace is no longer a logging level but a flag enabling/disabling
stack traces
</li><li>Project.loadProject and related methods now accept a Logger to use
</li><li>Made hidden files and files that start with <code>'.'</code> excluded by
default (<code>'.*'</code> is required because subversion seems to not mark <code>.svn</code>
directories hidden on Windows)
</li><li>Implemented exit codes
</li><li>Added continuous compilation command <code>cc</code>
</li></ul><h3 id="0.3.5+to+0.3.6">0.3.5 to 0.3.6<a href="#0.3.5+to+0.3.6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed bug #12.
</li><li>Compiled with 2.7.2.
</li></ul><h3 id="0.3.2+to+0.3.5">0.3.2 to 0.3.5<a href="#0.3.2+to+0.3.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed bug #11.
</li><li>Fixed problem with dependencies where source jars would be used
instead of binary jars.
</li><li>Fixed scala-tools not being used by default for inline
configurations.
</li><li>Small dependency management error message correction
</li><li>Slight refactoring for specifying whether scala-tools releases gets
added to configured resolvers
</li><li>Separated repository/dependency overriding so that repositories can
be specified inline for use with ivy.xml or pom.xml files
</li><li>Added ability to specify Ivy XML configuration in Scala.
</li><li>Added <code>clean-cache</code> action for deleting Ivy’s cache
</li><li>Some initial work towards accessing a resource directory from tests
</li><li>Initial tests for <code>Path</code>
</li><li>Some additional <code>FileUtilities</code> methods, some <code>FileUtilities</code> method
adjustments and some initial tests for FileUtilities
</li><li>A basic framework for testing <code>ReflectUtilities</code>, not run by default
because of run time
</li><li>Minor cleanup to <code>Path</code> and added non-empty check to path components
</li><li>Catch additional exceptions in <code>TestFramework</code>
</li><li>Added <code>copyTask</code> task creation method.
</li><li>Added <code>jetty-run</code> action and added ability to package war files.
</li><li>Added <code>jetty-stop</code> action.
</li><li>Added <code>console-quick</code> action that is the same as <code>console</code> but
doesn’t compile sources first.
</li><li>Moved some custom <code>ClassLoader</code>s to <code>ClasspathUtilities</code> and
improved a check.
</li><li>Added ability to specify hooks to call before <code>sbt</code> shuts down.
</li><li>Added <code>zip</code>, <code>unzip</code> methods to <code>FileUtilities</code>
</li><li>Added <code>append</code> equivalents to <code>write*</code> methods in FileUtilites
</li><li>Added first draft of integration testing
</li><li>Added batch command <code>compile-stats</code>
</li><li>Added methods to create tasks that have basic conditional execution
based on declared sources/products of the task
</li><li>Added <code>newerThan</code> and <code>olderThan</code> methods to <code>Path</code>
</li><li>Added <code>reload</code> action to reread the project definition without
losing the performance benefits of an already running jvm
</li><li>Added <code>help</code> action to tab completion
</li><li>Added handling of (effectively empty) scala source files that create
no class files: they are always interpreted as modified.
</li><li>Added prompt to retry project loading if compilation fails
</li><li><code>package</code> action now uses <code>fileTask</code> so that it only executes if
files are out of date
</li><li>fixed <code>ScalaTest</code> framework wrapper so that it fails the <code>test</code>
action if tests fail
</li><li>Inline dependencies can now specify configurations
</li></ul><h3 id="0.3.1+to+0.3.2">0.3.1 to 0.3.2<a href="#0.3.1+to+0.3.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Compiled jar with Java 1.5.
</li></ul><h3 id="0.3+to+0.3.1">0.3 to 0.3.1<a href="#0.3+to+0.3.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed bugs #8, #9, and #10.
</li></ul><h3 id="0.2.3+to+0.3">0.2.3 to 0.3<a href="#0.2.3+to+0.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Version change only for first release.
</li></ul><h3 id="0.2.2+to+0.2.3">0.2.2 to 0.2.3<a href="#0.2.2+to+0.2.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Added tests for <code>Dag</code>, <code>NameFilter</code>, <code>Version</code>
</li><li>Fixed handling of trailing <code>*</code>s in <code>GlobFilter</code> and added some
error-checking for control characters, which Pattern doesn’t seem to
like
</li><li>Fixed <code>Analysis.allProducts</code> implementation
</li><li>It previously returned the sources instead of the generated classes
</li><li>Will only affect the count of classes (it should be correct now) and
the debugging of missed classes (erroneously listed classes as
missed)
</li><li>Made some implied preconditions on <code>BasicVersion</code> and OpaqueVersion
explicit
</li><li>Made increment version behavior in <code>ScalaProject</code> easier to overload
</li><li>Added <code>Seq[..Option]</code> alternative to <code>...Option*</code> for tasks
</li><li>Documentation generation fixed to use latest value of version
</li><li>Fixed <code>BasicVersion.incrementMicro</code>
</li><li>Fixed test class loading so that <code>sbt</code> can test the version of sbt
being developed (previously, the classes from the executing version
of sbt were tested)
</li></ul><h3 id="0.2.1+to+0.2.2">0.2.1 to 0.2.2<a href="#0.2.1+to+0.2.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Package name is now a call-by-name parameter for the package action
</li><li>Fixed release action calling compile multiple times
</li></ul><h3 id="0.2.0+to+0.2.1">0.2.0 to 0.2.1<a href="#0.2.0+to+0.2.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Added some action descriptions
</li><li>jar name now comes from normalized name (lowercased and spaces to
dashes)
</li><li>Some cleanups related to creating filters
</li><li>Path should only ‘get’ itself if the underlying file exists to be
consistent with other PathFinders
</li><li>Added <code>---</code> operator for <code>PathFinder</code> that excludes paths from the
PathFinder argument
</li><li>Removed <code>***</code> operator on <code>PathFinder</code>
</li><li><code>**</code> operator on <code>PathFinder</code> matches all descendents or self that
match the NameFilter argument
</li><li>The above should fix bug <code>#6</code>
</li><li>Added version increment and release actions.
</li><li>Can now build sbt with sbt. Build scripts <code>build</code> and <code>clean</code> will
still exist.
</li></ul><h3 id="0.1.9+to+0.2.0">0.1.9 to 0.2.0<a href="#0.1.9+to+0.2.0" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Implemented typed properties and access to system properties
</li><li>Renamed <code>metadata</code> directory to <code>project</code>
</li><li>Information previously in <code>info</code> file now obtained by properties:
</li><li><code>info.name --&gt; name</code>
</li><li><code>info.currentVersion --&gt; version</code>
</li><li>Concrete <code>Project</code> subclasses should have a constructor that accepts
a single argument of type ProjectInfo (argument
dependencies: Iterable[Project] has been merged into ProjectInfo)
</li></ul><h3 id="0.1.8+to+0.1.9">0.1.8 to 0.1.9<a href="#0.1.8+to+0.1.9" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Better default implementation of <code>allSources</code>.
</li><li>Generate warning if two jars on classpath have the same name.
</li><li>Upgraded to specs 1.4.0
</li><li>Upgraded to <code>ScalaCheck</code> 1.5
</li><li>Changed some update options to be final vals instead of objects.
</li><li>Added some more API documentation.
</li><li>Removed release action.
</li><li>Split compilation into separate main and test compilations.
</li><li>A failure in a <code>ScalaTest</code> run now fails the test action.
</li><li>Implemented reporters for <code>compile/scaladoc</code>, <code>ScalaTest</code>,
ScalaCheck, and specs that delegate to the appropriate sbt.Logger.
</li></ul><h3 id="0.1.7+to+0.1.8">0.1.7 to 0.1.8<a href="#0.1.7+to+0.1.8" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Improved configuring of tests to exclude.
</li><li>Simplified version handling.
</li><li>Task <code>&amp;&amp;</code> operator properly handles dependencies of tasks it
combines.
</li><li>Changed method of inline library dependency declarations to be
simpler.
</li><li>Better handling of errors in parallel execution.
</li></ul><h3 id="0.1.6+to+0.1.7">0.1.6 to 0.1.7<a href="#0.1.6+to+0.1.7" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Added graph action to generate dot files (for graphiz) from
dependency information (work in progress).
</li><li>Options are now passed to tasks as varargs.
</li><li>Redesigned <code>Path</code> properly, including <code>PathFinder</code> returning a
Set[Path] now instead of Iterable[Path].
</li><li>Moved paths out of <code>ScalaProject</code> and into <code>BasicProjectPaths</code> to
keep path definitions separate from task definitions.
</li><li>Added initial support for managing third-party libraries through the
update task, which must be explicitly called (it is not a dependency
of compile or any other task). This is experimental, undocumented,
and known to be incomplete.
</li><li>Parallel execution implementation at the project level, disabled by
default. To enable, add:
scala  override def parallelExecution = true to your project
definition. In order for logging to make sense, all project logging
is buffered until the project is finished executing. Still to be
done is some sort of notification of project execution (which ones
are currently executing, how many remain)
</li><li><code>run</code> and <code>console</code> are now specified as “interactive” actions,
which means they are only executed on the project in which they are
defined when called directly, and not on all dependencies. Their
dependencies are still run on dependent projects.
</li><li>Generalized conditional tasks a bit. Of note is that analysis is no
longer required to be in metadata/analysis, but is now in
target/analysis by default.
</li><li>Message now displayed when project definition is recompiled on
startup
</li><li>Project no longer inherits from Logger, but now has a log member.
</li><li>Dependencies passed to <code>project</code> are checked for null (may help with
errors related to initialization/circular dependencies)
</li><li>Task dependencies are checked for null
</li><li>Projects in a multi-project configuration are checked to ensure that
output paths are different (check can be disabled)
</li><li>Made <code>update</code> task globally synchronized because Ivy is not
thread-safe.
</li><li>Generalized test framework, directly invoking frameworks now (used
reflection before).
</li><li>Moved license files to licenses/
</li><li>Added support for <code>specs</code> and some support for <code>ScalaTest</code> (the test
action doesn’t fail if ScalaTest tests fail).
</li><li>Added <code>specs</code>, <code>ScalaCheck</code>, <code>ScalaTest</code> jars to lib/
</li><li>These are now required for compilation, but are optional at runtime.
</li><li>Added the appropriate licenses and notices.
</li><li>Options for <code>update</code> action are now taken from updateOptions member.
</li><li>Fixed <code>SbtManager</code> inline dependency manager to work properly.
</li><li>Improved Ivy configuration handling (not compiled with test
dependencies yet though).
</li><li>Added case class implementation of <code>SbtManager</code> called
SimpleManager.
</li><li>Project definitions not specifying dependencies can now use just a
single argument constructor.
</li></ul><h3 id="0.1.5+to+0.1.6">0.1.5 to 0.1.6<a href="#0.1.5+to+0.1.6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>run</code> and <code>console</code> handle <code>System.exit</code> and multiple threads in
user code under certain circumstances (see
<a href="Running-Project-Code.html">running project code</a>).
</li></ul><h3 id="0.1.4+to+0.1.5">0.1.4 to 0.1.5<a href="#0.1.4+to+0.1.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Generalized interface with plugin (see Analysis Callback)
</li><li>Split out task implementations and paths from <code>Project</code> to
ScalaProject
</li><li>Subproject support (changed required project constructor signature:
see sbt/DefaultProject.scala)
</li><li>Can specify dependencies between projects
</li><li>Execute tasks across multiple projects
</li><li>Classpath of all dependencies included when compiling
</li><li>Proper inter-project source dependency handling
</li><li>Can change to a project in an interactive session to work only on
that project (and its dependencies)
</li><li>External dependency handling
</li><li>Tracks non-source dependencies (compiled classes and jars)
</li><li>Requires each class to be provided by exactly one classpath element
(This means you cannot have two versions of the same class on the
classpath, e.g. from two versions of a library)
</li><li>Changes in a project propagate the right source recompilations in
dependent projects
</li><li>Consequences:
</li><li>Recompilation when changing java/scala version
</li><li>Recompilation when upgrading libraries (again, as indicated in the
second point, situations where you have library-1.0.jar and
library-2.0.jar on the classpath at the same time are not handled
predictably. Replacing library-1.0.jar with library-2.0.jar should
work as expected.)
</li><li>Changing sbt version will recompile project definitions
</li></ul><h3 id="0.1.3+to+0.1.4">0.1.3 to 0.1.4<a href="#0.1.3+to+0.1.4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Autodetection of Project definitions.
</li><li>Simple tab completion/history in an interactive session with JLine
</li><li>Added descriptions for most actions
</li></ul><h3 id="0.1.2+to+0.1.3">0.1.2 to 0.1.3<a href="#0.1.2+to+0.1.3" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Dependency management between tasks and auto-discovery tasks.
</li><li>Should work on Windows.
</li></ul><h3 id="0.1.1+to+0.1.2">0.1.1 to 0.1.2<a href="#0.1.1+to+0.1.2" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Should compile/build on Java 1.5
</li><li>Fixed run action implementation to include scala library on
classpath
</li><li>Made project configuration easier
</li></ul><h3 id="0.1+to+0.1.1">0.1 to 0.1.1<a href="#0.1+to+0.1.1" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>Fixed handling of source files without a package
</li><li>Added easy project setup
</li></ul><h2 id="Migrating+from+0.7+to+0.10%2B">Migrating from 0.7 to 0.10+<a href="#Migrating+from+0.7+to+0.10%2B" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The assumption here is that you are familiar with sbt 0.7 but new to sbt
0.13.5.
</p><p>sbt 0.13.5’s many new capabilities can be a bit overwhelming, but
this page should help you migrate to 0.13.5 with a minimum of fuss.
</p><h3 id="Why+move+to+0.13.5%3F">Why move to 0.13.5?<a href="#Why+move+to+0.13.5%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Faster builds (because it is smarter at re-compiling only what it
must)
</li><li>Easier configuration. For simple projects a single <code>build.sbt</code> file
in your root directory is easier to create than
project/build/MyProject.scala was.
</li><li>No more <code>lib_managed</code> directory, reducing disk usage and avoiding
backup and version control hassles.
</li><li><code>update</code> is now much faster and it’s invoked automatically by sbt.
</li><li>Terser output. (Yet you can ask for more details if something goes
wrong.)
</li></ol><h4 id="Step+1%3A+Read+the+Getting+Started+Guide+for+sbt+0.13.5">Step 1: Read the Getting Started Guide for sbt 0.13.5<a href="#Step+1%3A+Read+the+Getting+Started+Guide+for+sbt+0.13.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Reading the <a href="../tutorial/index.html">Getting Started Guide</a> will
probably save you a lot of confusion.
</p><h4 id="Step+2%3A+Install+sbt+0.13.5">Step 2: Install sbt 0.13.5<a href="#Step+2%3A+Install+sbt+0.13.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Download sbt 0.13.5 as described on
<a href="../tutorial/Setup.html">the setup page</a>.
</p><p>You can run 0.13.5 the same way that you run 0.7.x, either simply:
</p><pre><code class="">$ java -jar sbt-launch.jar
</code></pre><p>Or (as most users do) with a shell script, as described on
<a href="../tutorial/Setup.html">the setup page</a>.
</p><p>For more details see
<a href="../tutorial/Setup.html">the setup page</a>.
</p><h4 id="Step+3%3A+A+technique+for+switching+an+existing+project">Step 3: A technique for switching an existing project<a href="#Step+3%3A+A+technique+for+switching+an+existing+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Here is a technique for switching an existing project to 0.13.5 while
retaining the ability to switch back again at will. Some builds, such as
those with subprojects, are not suited for this technique, but if you
learn how to transition a simple project it will help you do a more
complex one next.
</p><h3 id="Preserve++for+0.7.x+project">Preserve <code>project/</code> for 0.7.x project<a href="#Preserve++for+0.7.x+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Rename your <code>project/</code> directory to something like <code>project-old</code>. This
will hide it from sbt 0.13.5 but keep it in case you want to switch
back to 0.7.x.
</p><h3 id="Create++for+0.13.5">Create <code>build.sbt</code> for 0.13.5<a href="#Create++for+0.13.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Create a <code>build.sbt</code> file in the root directory of your project. See
<a href="../tutorial/Basic-Def.html">.sbt build definition</a> in the Getting
Started Guide, and for <a href="Basic-Def-Examples.html">simple examples</a>.
If you have a simple project
then converting your existing project file to this format is largely a
matter of re-writing your dependencies and maven archive declarations in
a modified yet familiar syntax.
</p><p>This <code>build.sbt</code> file combines aspects of the old
<code>project/build/ProjectName.scala</code> and <code>build.properties</code> files. It looks
like a property file, yet contains Scala code in a special format.
</p><p>A <code>build.properties</code> file like:
</p><pre><code class="">#Project properties
#Fri Jan 07 15:34:00 GMT 2011
project.organization=org.myproject
project.name=My Project
sbt.version=0.7.7
project.version=1.0
def.scala.version=2.7.7
build.scala.versions=2.8.1
project.initialize=false
</code></pre><p>Now becomes part of your <code>build.sbt</code> file with lines like:
</p><pre><code class="prettyprint lang-scala">name := &quot;My Project&quot;

version := &quot;1.0&quot;

organization := &quot;org.myproject&quot;

scalaVersion := &quot;2.9.2&quot;
</code></pre><p>Currently, a <code>project/build.properties</code> is still needed to explicitly
select the sbt version. For example:
</p><h3 id="Run+sbt+0.13.5">Run sbt 0.13.5<a href="#Run+sbt+0.13.5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Now launch sbt. If you’re lucky it works and you’re done. For help
debugging, see below.
</p><h3 id="Switching+back+to+sbt+0.7.x">Switching back to sbt 0.7.x<a href="#Switching+back+to+sbt+0.7.x" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you get stuck and want to switch back, you can leave your <code>build.sbt</code>
file alone. sbt 0.7.x will not understand or notice it. Just rename your
0.13.5 <code>project</code> directory to something like <code>project10</code> and rename
the backup of your old project from <code>project-old</code> to <code>project</code> again.
</p><h4 id="FAQs">FAQs<a href="#FAQs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There’s a section in the <a href="Faq.html">FAQ</a> about migration from 0.7 that
covers several other important points.
</p><h2 id="Contributing+to+sbt">Contributing to sbt<a href="#Contributing+to+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Below is a running list of potential areas of contribution. This list
may become out of date quickly, so you may want to check on the
<a href="https://groups.google.com/d/forum/sbt-dev">sbt-dev mailing list</a> if you are interested in a specific topic.
</p><ol><li><p>There are plenty of possible visualization and analysis
opportunities.
</p><ul><li><p>’compile’ produces an Analysis of the source code containing
</p><ul><li>Source dependencies
</li><li>Inter-project source dependencies
</li><li>Binary dependencies (jars + class files)
</li><li>data structure representing the
<a href="https://github.com/sbt/sbt/tree/0.13/interface">API</a> of the
source code There is some code already for generating dot
files that isn’t hooked up, but graphing dependencies and
inheritance relationships is a general area of work.
</li></ul></li><li>’update’ produces an [Update Report][Update-Report] mapping
Configuration/ModuleID/Artifact to the retrieved File
</li><li>Ivy produces more detailed XML reports on dependencies. These
come with an XSL stylesheet to view them, but this does not
scale to large numbers of dependencies. Working on this is
pretty straightforward: the XML files are created in <code>~/.ivy2</code>
and the <code>.xsl</code> and <code>.css</code> are there as well, so you don’t even need
to work with sbt. Other approaches described in <a href="https://groups.google.com/group/simple-build-tool/browse_thread/thread/7761f8b2ce51f02c/129064ea836c9baf">the email
thread</a>
</li><li>Tasks are a combination of static and dynamic graphs and it
would be useful to view the graph of a run
</li><li>Settings are a static graph and there is code to generate the
dot files, but isn’t hooked up anywhere.
</li></ul></li><li>There is support for dependencies on external projects, like on
GitHub. To be more useful, this should support being able to update
the dependencies. It is also easy to extend this to other ways of
retrieving projects. Support for svn and hg was a recent
contribution, for example.
</li><li>Dependency management: see <a href="https://github.com/adept-dm/adept">adept</a>
</li><li>If you like parsers, sbt commands and input tasks are written using
custom parser combinators that provide tab completion and error
handling. Among other things, the efficiency could be improved.
</li><li>The javap task hasn’t been reintegrated
</li><li>Implement enhanced 0.11-style warn/debug/info/error/trace commands.
Currently, you set it like any other setting:
</li></ol><pre><code class="">set logLevel := Level.Warn
</code></pre><blockquote><p>or
:   set logLevel in Test := Level.Warn
</p><p>You could make commands that wrap this, like:
</p></blockquote><pre><code class="">warn test:run
</code></pre><p>Also, trace is currently an integer, but should really be an abstract
data type.
</p><p>​7. Each sbt version has more aggressive incremental compilation and
reproducing bugs can be difficult. It would be helpful to have a mode
that generates a diff between successive compilations and records the
options passed to scalac. This could be replayed or inspected to try to
find the cause.
</p><h3 id="Documentation">Documentation<a href="#Documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>There’s a lot to do with this documentation. If you check it out
from git, there’s a directory called Dormant with some content that
needs going through.
</li><li>the main page mentions external project references (e.g.
to a git repo) but doesn’t have anything to link to that explains
how to use those.
</li><li>API docs are much needed.
</li><li>Find useful answers or types/methods/values in the other docs, and
pull references to them up into /faq or /Name-Index so people can
find the docs. In general the /faq should feel a bit more like a
bunch of pointers into the regular docs, rather than an alternative
to the docs.
</li><li><p>A lot of the pages could probably have better names, and/or little
</p><p>2-4 word blurbs to the right of them in the sidebar.
</p></li></ol><h2 id="Frequently+Asked+Questions">Frequently Asked Questions<a href="#Frequently+Asked+Questions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Project+Information">Project Information<a href="#Project+Information" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+do+I+get+help%3F">How do I get help?<a href="#How+do+I+get+help%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Please use <a href="http://stackoverflow.com/tags/sbt">Stack Overflow</a> for questions. Use the
<a href="https://groups.google.com/d/forum/sbt-dev">sbt-dev mailing list</a> for comments and discussions about sbt
development.
</p><ul><li>Please state the problem or question clearly and provide enough
context. Code examples and build transcripts are often useful when
appropriately edited.
</li><li>Providing small, reproducible examples is a good way to get help
quickly.
</li><li>Include relevant information such as the version of sbt and Scala
being used.
</li></ul><h4 id="How+do+I+report+a+bug%3F">How do I report a bug?<a href="#How+do+I+report+a+bug%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Please use the <a href="https://github.com/sbt/sbt/issues">issue tracker</a> to
report confirmed bugs. Do not use it to ask questions or to determine if
something is a bug.
</p><h4 id="How+can+I+help%3F">How can I help?<a href="#How+can+I+help%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>Answer questions on <a href="http://stackoverflow.com/tags/sbt">Stack Overflow</a>.
</li><li>Fix mistakes that you notice on the wiki.
</li><li>Make <a href="https://github.com/sbt/sbt/issues">bug reports</a> that are
clear and reproducible.
</li><li>Discuss development on the <a href="https://groups.google.com/d/forum/sbt-dev">sbt-dev mailing list</a>.
</li><li>Fix issues that affect you. <a href="http://help.github.com/fork-a-repo/">Fork, fix, and submit a pull request</a>.
</li><li>Implement features that are important to you.
See <a href="Contributing-to-sbt.html">Contributing to sbt</a> for more details.
</li></ul><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="My+last+command+didn%E2%80%99t+work+but+I+can%E2%80%99t+see+an+explanation.+Why%3F">My last command didn’t work but I can’t see an explanation. Why?<a href="#My+last+command+didn%E2%80%99t+work+but+I+can%E2%80%99t+see+an+explanation.+Why%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 0.13.5 by default suppresses most stack traces and debugging
information. It has the nice side effect of giving you less noise on
screen, but as a newcomer it can leave you lost for explanation. To see
the previous output of a command at a higher verbosity, type
<code>last &lt;task&gt;</code> where <code>&lt;task&gt;</code> is the task that failed or that you want to
view detailed output for. For example, if you find that your <code>update</code>
fails to load all the dependencies as you expect you can enter:
</p><pre><code class="">&gt; last update
</code></pre><p>and it will display the full output from the last run of the <code>update</code>
command.
</p><h4 id="How+do+I+disable+ansi+codes+in+the+output%3F">How do I disable ansi codes in the output?<a href="#How+do+I+disable+ansi+codes+in+the+output%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Sometimes sbt doesn’t detect that ansi codes aren’t supported and you
get output that looks like:
</p><pre><code class="">[0m[ [0minfo [0m]  [0mSet current project to root
</code></pre><p>or ansi codes are supported but you want to disable colored output. To
completely disable ansi codes, set the <code>sbt.log.format</code> system property
to <code>false</code>. For example,
</p><h4 id="How+can+I+start+a+Scala+interpreter+%28REPL%29+with+sbt+project+configuration+%28dependencies%2C+etc.%29%3F">How can I start a Scala interpreter (REPL) with sbt project configuration (dependencies, etc.)?<a href="#How+can+I+start+a+Scala+interpreter+%28REPL%29+with+sbt+project+configuration+%28dependencies%2C+etc.%29%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You may run <code>sbt console</code>.
</p><h3 id="Build+definitions">Build definitions<a href="#Build+definitions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="What+are+the+%2C+%2C+and++methods%3F">What are the <code>:=</code>, <code>+=</code>, and <code>++=</code> methods?<a href="#What+are+the+%2C+%2C+and++methods%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These are methods on keys used to construct a <code>Setting</code> or a <code>Task</code>. The
Getting Started Guide covers all these methods, see
<a href="../tutorial/Basic-Def.html">.sbt build definition</a> and
<a href="../tutorial/More-About-Settings.html">more kinds of setting</a> for
example.
</p><h4 id="What+is+the++method%3F">What is the <code>%</code> method?<a href="#What+is+the++method%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It’s used to create a <code>ModuleID</code> from strings, when specifying managed
dependencies. Read the Getting Started Guide about
<a href="../tutorial/Library-Dependencies.html">library dependencies</a>.
</p><h4 id="What+is+%2C+%2C+%E2%80%A6%3F">What is <code>ModuleID</code>, <code>Project</code>, …?<a href="#What+is+%2C+%2C+%E2%80%A6%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To figure out an unknown type or method, have a look at the
<a href="../tutorial/index.html">Getting Started Guide</a> if you have not. Also
try the <a href="Name-Index.html">index</a> of commonly used methods, values, and
types, the <a href="../api/">API Documentation</a> and the
<a href="../sxr/">hyperlinked sources</a>.
</p><h4 id="How+do+I+add+files+to+a+jar+package%3F">How do I add files to a jar package?<a href="#How+do+I+add+files+to+a+jar+package%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The files included in an artifact are configured by default by a task
<code>mappings</code> that is scoped by the relevant package task. The <code>mappings</code>
task returns a sequence <code>Seq[(File,String)]</code> of mappings from the file
to include to the path within the jar. See
<a href="Mapping-Files.html">mapping files</a> for details on creating these mappings.
</p><p>For example, to add generated sources to the packaged source artifact:
</p><pre><code class="prettyprint lang-scala">mappings in (Compile, packageSrc) ++= {
  import Path.{flat, relativeTo}
  val base = (sourceManaged in Compile).value
  val srcs = (managedSources in Compile).value
  srcs x (relativeTo(base) | flat)
}
</code></pre><p>This takes sources from the <code>managedSources</code> task and relativizes them
against the <code>managedSource</code> base directory, falling back to a flattened
mapping. If a source generation task doesn’t write the sources to the
<code>managedSource</code> directory, the mapping function would have to be
adjusted to try relativizing against additional directories or something
more appropriate for the generator.
</p><h4 id="How+can+I+generate+source+code+or+resources%3F">How can I generate source code or resources?<a href="#How+can+I+generate+source+code+or+resources%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Howto-Generating-Files.html">Generating Files</a>.
</p><h4 id="How+can+a+task+avoid+redoing+work+if+the+input+files+are+unchanged%3F">How can a task avoid redoing work if the input files are unchanged?<a href="#How+can+a+task+avoid+redoing+work+if+the+input+files+are+unchanged%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is basic support for only doing work when input files have changed
or when the outputs haven’t been generated yet. This support is
primitive and subject to change.
</p><p>The relevant methods are two overloaded methods called
<a href="../api/sbt/FileFunction$.html">FileFunction.cached</a>. Each requires a
directory in which to store cached data. Sample usage is:
</p><pre><code class="prettyprint lang-scala">// define a task that takes some inputs
//   and generates files in an output directory
myTask := {
  // wraps a function taskImpl in an uptodate check
  //   taskImpl takes the input files, the output directory,
  //   generates the output files and returns the set of generated files
  val cachedFun = FileFunction.cached(cacheDirectory.value / &quot;my-task&quot;) { (in: Set[File]) =&gt;
    taskImpl(in, target.value) : Set[File]
  }
  // Applies the cached function to the inputs files
  cachedFun(inputs.value)
}
</code></pre><p>There are two additional arguments for the first parameter list that
allow the file tracking style to be explicitly specified. By default,
the input tracking style is <code>FilesInfo.lastModified</code>, based on a file’s
last modified time, and the output tracking style is <code>FilesInfo.exists</code>,
based only on whether the file exists. The other available style is
<code>FilesInfo.hash</code>, which tracks a file based on a hash of its contents.
See the <a href="../api/sbt/FilesInfo$.html">FilesInfo API</a> for details.
</p><p>A more advanced version of <code>FileFunction.cached</code> passes a data structure
of type <a href="../api/sbt/ChangeReport.html">ChangeReport</a> describing the
changes to input and output files since the last evaluation. This
version of <code>cached</code> also expects the set of files generated as output to
be the result of the evaluated function.
</p><h3 id="Extending+sbt">Extending sbt<a href="#Extending+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+can+I+add+a+new+configuration%3F">How can I add a new configuration?<a href="#How+can+I+add+a+new+configuration%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following example demonstrates adding a new set of compilation
settings and tasks to a new configuration called <code>samples</code>. The sources
for this configuration go in <code>src/samples/scala/</code>. Unspecified settings
delegate to those defined for the <code>compile</code> configuration. For example,
if <code>scalacOptions</code> are not overridden for <code>samples</code>, the options for the
main sources are used.
</p><p>Options specific to <code>samples</code> may be declared like:
</p><pre><code class="prettyprint lang-scala">scalacOptions in Samples += &quot;-deprecation&quot;
</code></pre><p>This uses the main options as base options because of <code>+=</code>. Use <code>:=</code> to
ignore the main options:
</p><pre><code class="prettyprint lang-scala">scalacOptions in Samples := &quot;-deprecation&quot; :: Nil
</code></pre><p>The example adds all of the usual compilation related settings and tasks
to <code>samples</code>:
</p><pre><code class="">samples:run
samples:runMain
samples:compile
samples:console
samples:consoleQuick
samples:scalacOptions
samples:fullClasspath
samples:package
samples:packageSrc
...
</code></pre><h4 id="How+do+I+add+a+test+configuration%3F">How do I add a test configuration?<a href="#How+do+I+add+a+test+configuration%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See the <a href="Testing.html#additional-test-configurations">Additional test configurations</a> section of
<a href="Testing.html">Testing</a>.
</p><h4 id="How+can+I+create+a+custom+run+task%2C+in+addition+to+%3F">How can I create a custom run task, in addition to <code>run</code>?<a href="#How+can+I+create+a+custom+run+task%2C+in+addition+to+%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This answer is extracted from a
<a href="http://groups.google.com/group/simple-build-tool/browse_thread/thread/4c28ee5b7e18b46a/">mailing list discussion</a>.
</p><p>Read the Getting Started Guide up to
<a href="../tutorial/Custom-Settings.html">custom settings</a> for background.
</p><p>A basic run task is created by:
</p><pre><code class="prettyprint lang-scala">lazy val myRunTask = taskKey[Unit](&quot;A custom run task.&quot;)

// this can go either in a `build.sbt` or the settings member
//   of a Project in a full configuration
fullRunTask(myRunTask, Test, &quot;foo.Foo&quot;, &quot;arg1&quot;, &quot;arg2&quot;)
</code></pre><p>If you want to be able to supply arguments on the command line, replace
<code>TaskKey</code> with <code>InputKey</code> and <code>fullRunTask</code> with <code>fullRunInputTask</code>. The
<code>Test</code> part can be replaced with another configuration, such as
<code>Compile</code>, to use that configuration’s classpath.
</p><p>This run task can be configured individually by specifying the task key
in the scope. For example:
</p><pre><code class="prettyprint lang-scala">fork in myRunTask := true

javaOptions in myRunTask += &quot;-Xmx6144m&quot;
</code></pre><h4 id="How+should+I+express+a+dependency+on+an+outside+tool+such+as+proguard%3F">How should I express a dependency on an outside tool such as proguard?<a href="#How+should+I+express+a+dependency+on+an+outside+tool+such+as+proguard%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Tool dependencies are used to implement a task and are not needed by
project source code. These dependencies can be declared in their own
configuration and classpaths. These are the steps:
</p><ol><li>Define a new <a href="Library-Management.html#ivy-configurations">configuration</a>.
</li><li>Declare the tool
<a href="Library-Management.html">dependencies</a> in that
configuration.
</li><li>Define a classpath that pulls the dependencies from the
<a href="Update-Report.html">Update Report</a> produced by <code>update</code>.
</li><li>Use the classpath to implement the task.
</li></ol><p>As an example, consider a <code>proguard</code> task. This task needs the ProGuard
jars in order to run the tool. First, define and add the new
configuration:
</p><pre><code class="prettyprint lang-scala">val ProguardConfig = config(&quot;proguard&quot;) hide

ivyConfigurations += ProguardConfig
</code></pre><p>Then,
</p><pre><code class="prettyprint lang-scala">// Add proguard as a dependency in the custom configuration.
//  This keeps it separate from project dependencies.
libraryDependencies +=
   &quot;net.sf.proguard&quot; % &quot;proguard&quot; % &quot;4.4&quot; % ProguardConfig.name

// Extract the dependencies from the UpdateReport.
managedClasspath in proguard := {
    // these are the types of artifacts to include
    val artifactTypes: Set[String] = (classpathTypes in proguard).value
    Classpaths.managedJars(proguardConfig, artifactTypes, update.value)
}

// Use the dependencies in a task, typically by putting them
//  in a ClassLoader and reflectively calling an appropriate
//  method.
proguard := {
    val cp: Seq[File] = (managedClasspath in proguard).value
  // ... do something with , which includes proguard ...
}
</code></pre><p>Defining the intermediate classpath is optional, but it can be useful
for debugging or if it needs to be used by multiple tasks. It is also
possible to specify artifact types inline. This alternative <code>proguard</code>
task would look like:
</p><pre><code class="prettyprint lang-scala">proguard := {
   val artifactTypes = Set(&quot;jar&quot;)
    val cp: Seq[File] =
      Classpaths.managedJars(proguardConfig, artifactTypes, update.value)
  // ... do something with , which includes proguard ...
}
</code></pre><h4 id="How+would+I+change+sbt%E2%80%99s+classpath+dynamically%3F">How would I change sbt’s classpath dynamically?<a href="#How+would+I+change+sbt%E2%80%99s+classpath+dynamically%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>It is possible to register additional jars that will be placed on sbt’s
classpath (since version 0.10.1). Through
<a href="../api/sbt/State$.html">State</a>, it is possible to obtain a
<a href="../api/xsbti/ComponentProvider.html">xsbti.ComponentProvider</a>, which
manages application components. Components are groups of files in the
<code>~/.sbt/boot/</code> directory and, in this case, the application is sbt. In
addition to the base classpath, components in the “extra” component are
included on sbt’s classpath.
</p><p>(Note: the additional components on an application’s classpath are
declared by the <code>components</code> property in the <code>[main]</code> section of the
launcher configuration file <code>boot.properties</code>.)
</p><p>Because these components are added to the <code>~/.sbt/boot/</code> directory and
<code>~/.sbt/boot/</code> may be read-only, this can fail. In this case, the user
has generally intentionally set sbt up this way, so error recovery is
not typically necessary (just a short error message explaining the
situation.)
</p><h4 id="Example+of+dynamic+classpath+augmentation">Example of dynamic classpath augmentation<a href="#Example+of+dynamic+classpath+augmentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following code can be used where a <code>State =&gt; State</code> is required,
such as in the <code>onLoad</code> setting (described below) or in a
<a href="Commands.html">command</a>. It adds some files to the “extra”
component and reloads sbt if they were not already added. Note that
reloading will drop the user’s session state.
</p><pre><code class="prettyprint lang-scala">def augment(extra: Seq[File])(s: State): State = {
    // Get the component provider
  val cs: xsbti.ComponentProvider = s.configuration.provider.components()

    // Adds the files in 'extra' to the &quot;extra&quot; component
    //   under an exclusive machine-wide lock.
    //   The returned value is 'true' if files were actually copied and 'false'
    //   if the target files already exists (based on name only).
  val copied: Boolean = s.locked(cs.lockFile, cs.addToComponent(&quot;extra&quot;, extra.toArray))

    // If files were copied, reload so that we use the new classpath.
  if(copied) s.reload else s
}
</code></pre><h4 id="How+can+I+take+action+when+the+project+is+loaded+or+unloaded%3F">How can I take action when the project is loaded or unloaded?<a href="#How+can+I+take+action+when+the+project+is+loaded+or+unloaded%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The single, global setting <code>onLoad</code> is of type <code>State =&gt; State</code> (see
<a href="Build-State.html">State and Actions</a>) and is executed once, after all projects are
built and loaded. There is a similar hook <code>onUnload</code> for when a project
is unloaded. Project unloading typically occurs as a result of a
<code>reload</code> command or a <code>set</code> command. Because the <code>onLoad</code> and <code>onUnload</code>
hooks are global, modifying this setting typically involves composing a
new function with the previous value. The following example shows the
basic structure of defining <code>onLoad</code>:
</p><pre><code class="prettyprint lang-scala">// Compose our new function 'f' with the existing transformation.
{
  val f: State =&gt; State = ...
  onLoad in Global := {
    val previous = (onLoad in Global).value
    f compose previous
  }
}
</code></pre><h4 id="Example+of+project+load%2Funload+hooks">Example of project load/unload hooks<a href="#Example+of+project+load%2Funload+hooks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following example maintains a count of the number of times a project
has been loaded and prints that number:
</p><pre><code class="prettyprint lang-scala">{
  // the key for the current count
  val key = AttributeKey[Int](&quot;loadCount&quot;)
  // the State transformer
  val f = (s: State) =&gt; {
    val previous = s get key getOrElse 0
    println(&quot;Project load count: &quot; + previous)
    s.put(key, previous + 1)
  }
  onLoad in Global := {
    val previous = (onLoad in Global).value
    f compose previous
  }
}
</code></pre><h3 id="Errors">Errors<a href="#Errors" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="On+project+load%2C+%E2%80%9CReference+to+uninitialized+setting%E2%80%9C">On project load, “Reference to uninitialized setting“<a href="#On+project+load%2C+%E2%80%9CReference+to+uninitialized+setting%E2%80%9C" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Setting initializers are executed in order. If the initialization of a
setting depends on other settings that has not been initialized, sbt
will stop loading.
</p><p>In this example, we try to append a library to <code>libraryDependencies</code>
before it is initialized with an empty sequence.
</p><pre><code class="prettyprint lang-scala">object MyBuild extends Build {
  val root = Project(id = &quot;root&quot;, base = file(&quot;.&quot;),
    settings = Seq(
      libraryDependencies += &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;1.4&quot; % &quot;test&quot;
    )
  ).disablePlugins(plugins.IvyModule)
}
</code></pre><p>To correct this, include the IvyModule plugin settings, which includes
<code>libraryDependencies := Seq()</code>. So, we just drop the explicit disabling.
</p><pre><code class="prettyprint lang-scala">object MyBuild extends Build {
  val root = Project(id = &quot;root&quot;, base = file(&quot;.&quot;),
    settings = Seq(
      libraryDependencies += &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;1.4&quot; % &quot;test&quot;
    )
  )
}
</code></pre><p>A more subtle variation of this error occurs when using
<a href="../tutorial/Scopes.html">scoped settings</a>.
</p><pre><code class="prettyprint lang-scala">// error: Reference to uninitialized setting
settings = Seq(
  libraryDependencies += &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;1.2&quot; % &quot;test&quot;,
  fullClasspath := fullClasspath.value.filterNot(_.data.name.contains(&quot;commons-io&quot;))
)
</code></pre><p>This setting varies between the test and compile scopes. The solution is
use the scoped setting, both as the input to the initializer, and the
setting that we update.
</p><pre><code class="prettyprint lang-scala">fullClasspath in Compile := (fullClasspath in Compile).value.filterNot(_.data.name.contains(&quot;commons-io&quot;))
</code></pre><h3 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+do+I+resolve+a+checksum+error%3F">How do I resolve a checksum error?<a href="#How+do+I+resolve+a+checksum+error%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This error occurs when the published checksum, such as a sha1 or md5
hash, differs from the checksum computed for a downloaded artifact, such
as a jar or pom.xml. An example of such an error is:
</p><pre><code class="">[warn]  problem while downloading module descriptor:
http://repo1.maven.org/maven2/commons-fileupload/commons-fileupload/1.2.2/commons-fileupload-1.2.2.pom:
invalid sha1: expected=ad3fda4adc95eb0d061341228cc94845ddb9a6fe computed=0ce5d4a03b07c8b00ab60252e5cacdc708a4e6d8 (1070ms)
</code></pre><p>The invalid checksum should generally be reported to the repository
owner (as
<a href="https://issues.sonatype.org/browse/MVNCENTRAL-46">was done</a> for the
above error). In the meantime, you can temporarily disable checking with
the following setting:
</p><pre><code class="prettyprint lang-scala">checksums in update := Nil
</code></pre><p>See <a href="Library-Management.html">library management</a> for details.
</p><h4 id="I%E2%80%99ve+added+a+plugin%2C+and+now+my+cross-compilations+fail%21">I’ve added a plugin, and now my cross-compilations fail!<a href="#I%E2%80%99ve+added+a+plugin%2C+and+now+my+cross-compilations+fail%21" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This problem crops up frequently. Plugins are only published for the
Scala version that sbt uses (currently, 2.9.1). You can still <em>use</em>
plugins during cross-compilation, because sbt only looks for a 2.9.1
version of the plugin.
</p><p><strong>… unless you specify the plugin in the wrong place!</strong>
</p><p>A typical mistake is to put global plugin definitions in
<code>~/.sbt/plugins.sbt</code>. <strong>THIS IS WRONG.</strong> <code>.sbt</code> files in <code>~/.sbt</code> are
loaded for <em>each</em> build—that is, for <em>each</em> cross-compilation. So, if
you build for Scala 2.9.0, sbt will try to find a version of the plugin
that’s compiled for 2.9.0—and it usually won’t. That’s because it
doesn’t <em>know</em> the dependency is a plugin.
</p><p>To tell sbt that the dependency is an sbt plugin, make sure you define
your global plugins in a <code>.sbt</code> file in <code>~/.sbt/plugins/</code>. sbt knows
that files in <code>~/.sbt/plugins</code> are only to be used by sbt itself, not as
part of the general build definition. If you define your plugins in a
file under <em>that</em> directory, they won’t foul up your cross-compilations.
Any file name ending in <code>.sbt</code> will do, but most people use
<code>~/.sbt/plugins/build.sbt</code> or <code>~/.sbt/plugins/plugins.sbt</code>.
</p><h3 id="Miscellaneous">Miscellaneous<a href="#Miscellaneous" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+do+I+use+the+Scala+interpreter+in+my+code%3F">How do I use the Scala interpreter in my code?<a href="#How+do+I+use+the+Scala+interpreter+in+my+code%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt runs tests in the same JVM as sbt itself and Scala classes are not
in the same class loader as the application classes. Therefore, when
using the Scala interpreter, it is important to set it up properly to
avoid an error message like:
</p><pre><code class="">Failed to initialize compiler: class scala.runtime.VolatileBooleanRef not found.
** Note that as of 2.8 scala does not assume use of the java classpath.
** For the old behavior pass -usejavacp to scala, or if using a Settings
** object programmatically, settings.usejavacp.value = true.
</code></pre><p>The key is to initialize the Settings for the interpreter using
<em>embeddedDefaults</em>. For example:
</p><pre><code class="prettyprint lang-scala"> val settings = new Settings
 settings.embeddedDefaults[MyType]
 val interpreter = new Interpreter(settings, ...)
</code></pre><p>Here, MyType is a representative class that should be included on the
interpreter’s classpath and in its application class loader. For more
background, see the
<a href="https://gist.github.com/404272">original proposal</a> that resulted in
<em>embeddedDefaults</em> being added.
</p><p>Similarly, use a representative class as the type argument when using
the <em>break</em> and <em>breakIf</em> methods of <em>ILoop</em>, as in the following
example:
</p><pre><code class="prettyprint lang-scala">def x(a: Int, b: Int) = {
  import scala.tools.nsc.interpreter.ILoop
  ILoop.breakIf[MyType](a != b, &quot;a&quot; -&gt; a, &quot;b&quot; -&gt; b )
}
</code></pre><h3 id="0.7+to+0.10%2B+Migration">0.7 to 0.10+ Migration<a href="#0.7+to+0.10%2B+Migration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="How+do+I+migrate+from+0.7+to+0.10%2B%3F">How do I migrate from 0.7 to 0.10+?<a href="#How+do+I+migrate+from+0.7+to+0.10%2B%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See the
<a href="Migrating-from-sbt-07x.html">migration page</a>
first and then the following questions.
</p><h4 id="Where+has+0.7%E2%80%99s++gone%3F">Where has 0.7’s <code>lib_managed</code> gone?<a href="#Where+has+0.7%E2%80%99s++gone%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, sbt 0.13.5 loads managed libraries from your ivy cache
without copying them to a <code>lib_managed</code> directory. This fixes some bugs
with the previous solution and keeps your project directory small. If
you want to insulate your builds from the ivy cache being cleared, set
<code>retrieveManaged := true</code> and the dependencies will be copied to
<code>lib_managed</code> as a build-local cache (while avoiding the issues of
<code>lib_managed</code> in 0.7.x).
</p><p>This does mean that existing solutions for sharing libraries with your
favoured IDE may not work. There are 0.13.5 plugins for IDEs being
developed:
</p><ul><li><a href="https://github.com/mpeltonen/sbt-idea">IntelliJ IDEA</a>
</li><li><a href="https://github.com/remeniuk/sbt-netbeans-plugin">Netbeans</a>
</li><li><a href="https://github.com/typesafehub/sbteclipse">Eclipse</a>
</li></ul><h4 id="What+are+the+commands+I+can+use+in+0.13.5+vs.+0.7%3F">What are the commands I can use in 0.13.5 vs. 0.7?<a href="#What+are+the+commands+I+can+use+in+0.13.5+vs.+0.7%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For a list of commands, run <code>help</code>. For details on a specific command,
run <code>help &lt;command&gt;</code>. To view a list of tasks defined on the current
project, run <code>tasks</code>. Alternatively, see the
<a href="../tutorial/Running.html">Running</a> page in the Getting Started Guide
for descriptions of common commands and tasks.
</p><p>If in doubt start by just trying the old command as it may just work.
The built in TAB completion will also assist you, so you can just press
TAB at the beginning of a line and see what you get.
</p><p>The following commands work pretty much as in 0.7 out of the box:
</p><pre><code class="">reload
update
compile
test
testOnly
publishLocal
exit
</code></pre><h4 id="Why+have+the+resolved+dependencies+in+a+multi-module+project+changed+since+0.7%3F">Why have the resolved dependencies in a multi-module project changed since 0.7?<a href="#Why+have+the+resolved+dependencies+in+a+multi-module+project+changed+since+0.7%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt 0.10 fixes a flaw in how dependencies get resolved in multi-module
projects. This change ensures that only one version of a library appears
on a classpath.
</p><p>Use <code>last update</code> to view the debugging output for the last <code>update</code>
run. Use <code>show update</code> to view a summary of files comprising managed
classpaths.
</p><h3 id="My+tests+all+run+really+fast+but+some+are+broken+that+weren%E2%80%99t+in+0.7%21">My tests all run really fast but some are broken that weren’t in 0.7!<a href="#My+tests+all+run+really+fast+but+some+are+broken+that+weren%E2%80%99t+in+0.7%21" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Be aware that compilation and tests run in parallel by default in sbt
0.13.5. If your test code isn’t thread-safe then you may want to
change this behaviour by adding one of the following to your
<code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">// Execute tests in the current project serially.
// Tests from other projects may still run concurrently.
parallelExecution in Test := false

// Execute everything serially (including compilation and tests)
parallelExecution := false
</code></pre><h4 id="What+happened+to+the+web+development+and+Web+Start+support+since+0.7%3F">What happened to the web development and Web Start support since 0.7?<a href="#What+happened+to+the+web+development+and+Web+Start+support+since+0.7%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Web application support was split out into a plugin. See the
<a href="https://github.com/JamesEarlDouglas/xsbt-web-plugin">xsbt-web-plugin</a>
project.
</p><p>For an early version of an xsbt Web Start plugin, visit the
<a href="https://github.com/ritschwumm/xsbt-webstart">xsbt-webstart</a> project.
</p><h4 id="How+are+inter-project+dependencies+different+in+0.13.5+vs.+0.7%3F">How are inter-project dependencies different in 0.13.5 vs. 0.7?<a href="#How+are+inter-project+dependencies+different+in+0.13.5+vs.+0.7%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In 0.13.5, there are three types of project dependencies (classpath,
execution, and configuration) and they are independently defined. These
were combined in a single dependency type in 0.7.x. A declaration like:
</p><pre><code class="prettyprint lang-scala">lazy val a = project(&quot;a&quot;, &quot;A&quot;)
lazy val b = project(&quot;b&quot;, &quot;B&quot;, a)
</code></pre><p>meant that the <code>B</code> project had a classpath and execution dependency on
<code>A</code> and <code>A</code> had a configuration dependency on <code>B</code>. Specifically, in
0.7.x:
</p><ol><li>Classpath: Classpaths for <code>A</code> were available on the appropriate
classpath for B.
</li><li>Execution: A task executed on <code>B</code> would be executed on <code>A</code> first.
</li><li>Configuration: For some settings, if they were not overridden in A,
they would default to the value provided in B.
</li></ol><p>In 0.13.5, declare the specific type of dependency you want. Read
about <a href="../tutorial/Multi-Project.html">multi-project builds</a> in the
Getting Started Guide for details.
</p><h4 id="Where+did+class%2Fobject+X+go+since+0.7%3F">Where did class/object X go since 0.7?<a href="#Where+did+class%2Fobject+X+go+since+0.7%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><table>
  <tr>
    <th>0.7</th>
    <th>0.13.5</th>
  </tr>

  <tr>
    <td><a href="http://simple-build-tool.googlecode.com/svn/artifacts/latest/api/sbt/FileUtilities$object.html">FileUtilities</a></td>
    <td><a href="../api/sbt/IO$.html)">IO</a></td>
  </tr>

  <tr>
    <td><a href="http://simple-build-tool.googlecode.com/svn/artifacts/latest/api/sbt/Path.html">Path class</a> and
    <a href="http://simple-build-tool.googlecode.com/svn/artifacts/latest/api/sbt/Path$.html">object</a></td>
    <td>
      <a href="../api/sbt/Path$.html">Path object</a>, <tt>File</tt>,
      <a href="../api/sbt/RichFile.html">RichFile</a>

    </td>
  </tr>

  <tr>
    <td><a href="http://simple-build-tool.googlecode.com/svn/artifacts/latest/api/sbt/PathFinder.html">PathFinder class</a></td>
    <td>
      <tt>Seq[File]</tt>, 
      <a href="../api/sbt/PathFinder.html)">PathFinder class</a>,
      <a href="../api/sbt/PathFinder$.html">PathFinder object</a>
    </td>
  </tr>
</table><h4 id="Where+can+I+find+plugins+for+0.13.5%3F">Where can I find plugins for 0.13.5?<a href="#Where+can+I+find+plugins+for+0.13.5%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Community-Plugins.html">Community Plugins</a> for a list of currently available
plugins.
</p><h2 id="How+to%E2%80%A6">How to…<a href="#How+to%E2%80%A6" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>See <a href="Contents+in+Depth.html">Detailed Table of Contents</a> for the list of all the how-tos.
</p><h2 id="Classpaths">Classpaths<a href="#Classpaths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="classpath-types"></a><h3 id="Include+a+new+type+of+managed+artifact+on+the+classpath%2C+such+as">Include a new type of managed artifact on the classpath, such as <code>mar</code><a href="#Include+a+new+type+of+managed+artifact+on+the+classpath%2C+such+as" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>classpathTypes</code> setting controls the types of managed artifacts
that are included on the classpath by default. To add a new type, such
as <code>mar</code>,
</p><pre><code class="prettyprint lang-scala">classpathTypes += &quot;mar&quot;
</code></pre><a name="get-compile-classpath"></a><h3 id="Get+the+classpath+used+for+compilation">Get the classpath used for compilation<a href="#Get+the+classpath+used+for+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See the default types included by running <code>show classpathTypes</code> at the
sbt prompt.
</p><p>The <code>dependencyClasspath</code> task scoped to <code>Compile</code> provides the
classpath to use for compilation. Its type is <code>Seq[Attributed[File]]</code>,
which means that each entry carries additional metadata. The <code>files</code>
method provides just the raw <code>Seq[File]</code> for the classpath. For example,
to use the files for the compilation classpath in another task, :
</p><pre><code class="prettyprint lang-scala">example := {
  val cp: Seq[File] = (dependencyClasspath in Compile).value.files
  ...
}
</code></pre><blockquote><p><strong>Note</strong>: This classpath does not include the class directory, which may be
necessary for compilation in some situations.
</p></blockquote><a name="get-runtime-classpath"></a><h3 id="Get+the+runtime+classpath%2C+including+the+project%E2%80%99s+compiled+classes">Get the runtime classpath, including the project’s compiled classes<a href="#Get+the+runtime+classpath%2C+including+the+project%E2%80%99s+compiled+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fullClasspath</code> task provides a classpath including both the
dependencies and the products of project. For the runtime classpath,
this means the main resources and compiled classes for the project as
well as all runtime dependencies.
</p><p>The type of a classpath is <code>Seq[Attributed[File]]</code>, which means that
each entry carries additional metadata. The <code>files</code> method provides just
the raw <code>Seq[File]</code> for the classpath. For example, to use the files for
the runtime classpath in another task, :
</p><pre><code class="prettyprint lang-scala">example := {
  val cp: Seq[File] = (fullClasspath in Runtime).value.files
  ...
}
</code></pre><a name="get-test-classpath"></a><h3 id="Get+the+test+classpath%2C+including+the+project%E2%80%99s+compiled+test+classes">Get the test classpath, including the project’s compiled test classes<a href="#Get+the+test+classpath%2C+including+the+project%E2%80%99s+compiled+test+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fullClasspath</code> task provides a classpath including both the
dependencies and the products of a project. For the test classpath, this
includes the main and test resources and compiled classes for the
project as well as all dependencies for testing.
</p><p>The type of a classpath is <code>Seq[Attributed[File]]</code>, which means that
each entry carries additional metadata. The <code>files</code> method provides just
the raw <code>Seq[File]</code> for the classpath. For example, to use the files for
the test classpath in another task, :
</p><pre><code class="prettyprint lang-scala">example := {
  val cp: Seq[File] = (fullClasspath in Test).value.files
  ...
}
</code></pre><a name="export-jars"></a><h3 id="Use+packaged+jars+on+classpaths+instead+of+class+directories">Use packaged jars on classpaths instead of class directories<a href="#Use+packaged+jars+on+classpaths+instead+of+class+directories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, <code>fullClasspath</code> includes a directory containing class files
and resources for a project. This in turn means that tasks like
<code>compile</code>, <code>test</code>, and <code>run</code> have these class directories on their
classpath. To use the packaged artifact (such as a jar) instead,
configure <code>exportJars</code> :
</p><pre><code class="prettyprint lang-scala">exportJars := true
</code></pre><p>This will use the result of <code>packageBin</code> on the classpath instead of the
class directory.
</p><blockquote><p><strong>Note</strong>: Specifically, fullClasspath is the concatentation of
dependencyClasspath and exportedProducts. When exportJars is true,
exportedProducts is the output of packageBin. When exportJars is
false, exportedProducts is just products, which is by default the
directory containing class files and resources.
</p></blockquote><a name="managed-jars-in-config"></a><h3 id="Get+all+managed+jars+for+a+configuration">Get all managed jars for a configuration<a href="#Get+all+managed+jars+for+a+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The result of the <code>update</code> task has type
<a href="Update-Report.html">UpdateReport</a>, which contains the
results of dependency resolution. This can be used to extract the files
for specific types of artifacts in a specific configuration. For
example, to get the jars and zips of dependencies in the <code>Compile</code>
configuration, :
</p><pre><code class="prettyprint lang-scala">example := {
   val artifactTypes = Set(&quot;jar&quot;, &quot;zip&quot;)
   val files: Seq[File] =
      Classpaths.managedJars(Compile, artifactTypes, update.value)
   ...
}
</code></pre><a name="classpath-files"></a><h3 id="Get+the+files+included+in+a+classpath">Get the files included in a classpath<a href="#Get+the+files+included+in+a+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A classpath has type <code>Seq[Attributed[File]]</code>, which means that each
entry carries additional metadata. The <code>files</code> method provides just the
raw <code>Seq[File]</code> for the classpath. For example, :
</p><pre><code class="prettyprint lang-scala">val cp: Seq[Attributed[File]] = ...
val files: Seq[File] = cp.files
</code></pre><a name="classpath-entry-module"></a><h3 id="Get+the+module+and+artifact+that+produced+a+classpath+entry">Get the module and artifact that produced a classpath entry<a href="#Get+the+module+and+artifact+that+produced+a+classpath+entry" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A classpath has type <code>Seq[Attributed[File]]</code>, which means that each
entry carries additional metadata. This metadata is in the form of an
<a href="../api/sbt/AttributeMap.html">AttributeMap</a>. Useful keys for
entries in the map are <code>artifact.key</code>, <code>module.key</code>, and <code>analysis</code>. For
example,
</p><pre><code class="prettyprint lang-scala">val classpath: Seq[Attributed[File]] = ???
for(entry &lt;- classpath) yield {
   val art: Option[Artifact] = entry.get(artifact.key)
   val mod: Option[ModuleID] = entry.get(module.key)
   val an: Option[inc.Analysis] = entry.get(analysis)
   ...
}
</code></pre><blockquote><p><strong>Note</strong>: Entries may not have some or all metadata. Only entries from source
dependencies, such as internal projects, have an incremental
compilation <a href="../api/sbt/inc/Analysis.html">Analysis</a>. Only entries
for managed dependencies have an
<a href="../api/sbt/Artifact.html">Artifact</a> and
<a href="../api/sbt/ModuleID.html">ModuleID</a>.
</p></blockquote><h2 id="Customizing+paths">Customizing paths<a href="#Customizing+paths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes how to modify the default source, resource, and
library directories and what files get included from them.
</p><a name="scala-source-directory"></a><h3 id="Change+the+default+Scala+source+directory">Change the default Scala source directory<a href="#Change+the+default+Scala+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the main Scala sources is by default
<code>src/main/scala</code>. For test Scala sources, it is <code>src/test/scala</code>. To
change this, modify <code>scalaSource</code> in the <code>Compile</code> (for main sources) or
<code>Test</code> (for test sources). For example,
</p><pre><code class="prettyprint lang-scala">scalaSource in Compile := baseDirectory.value / &quot;src&quot;

scalaSource in Test := baseDirectory.value / &quot;test-src&quot;
</code></pre><blockquote><p><strong>Note</strong>: The Scala source directory can be the same as the Java source
directory.
</p></blockquote><a name="java-source-directory"></a><h3 id="Change+the+default+Java+source+directory">Change the default Java source directory<a href="#Change+the+default+Java+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the main Java sources is by default
<code>src/main/java</code>. For test Java sources, it is <code>src/test/java</code>. To change
this, modify <code>javaSource</code> in the <code>Compile</code> (for main sources) or <code>Test</code>
(for test sources).
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">javaSource in Compile := baseDirectory.value / &quot;src&quot;

javaSource in Test := baseDirectory.value / &quot;test-src&quot;
</code></pre><blockquote><p><strong>Note</strong>: The Scala source directory can be the same as the Java source
directory.
</p></blockquote><a name="resource-directory"></a><h3 id="Change+the+default+resource+directory">Change the default resource directory<a href="#Change+the+default+resource+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the main resources is by default
<code>src/main/resources</code>. For test resources, it is <code>src/test/resources</code>. To
change this, modify <code>resourceDirectory</code> in either the <code>Compile</code> or
<code>Test</code> configuration.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">resourceDirectory in Compile := baseDirectory.value / &quot;resources&quot;

resourceDirectory in Test := baseDirectory.value / &quot;test-resources&quot;
</code></pre><a name="unmanaged-base-directory"></a><h3 id="Change+the+default+%28unmanaged%29+library+directory">Change the default (unmanaged) library directory<a href="#Change+the+default+%28unmanaged%29+library+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The directory that contains the unmanaged libraries is by default
<code>lib/</code>. To change this, modify <code>unmanagedBase</code>. This setting can be
changed at the project level or in the <code>Compile</code>, <code>Runtime</code>, or <code>Test</code>
configurations.
</p><p>When defined without a configuration, the directory is the default
directory for all configurations. For example, the following declares
<code>jars/</code> as containing libraries:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value / &quot;jars&quot;
</code></pre><p>When set for <code>Compile</code>, <code>Runtime</code>, or <code>Test</code>, <code>unmanagedBase</code> is the
directory containing libraries for that configuration, overriding the
default. For example, the following declares <code>lib/main/</code> to contain jars
only for <code>Compile</code> and not for running or testing: :
</p><pre><code class="prettyprint lang-scala">unmanagedBase in Compile := baseDirectory.value / &quot;lib&quot; / &quot;main&quot;
</code></pre><a name="disable-base-sources"></a><h3 id="Disable+using+the+project%E2%80%99s+base+directory+as+a+source+directory">Disable using the project’s base directory as a source directory<a href="#Disable+using+the+project%E2%80%99s+base+directory+as+a+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt includes <code>.scala</code> files from the project’s base
directory as main source files. To disable this, configure
<code>sourcesInBase</code>:
</p><pre><code class="prettyprint lang-scala">sourcesInBase := false
</code></pre><a name="add-source-directory"></a><h3 id="Add+an+additional+source+directory">Add an additional source directory<a href="#Add+an+additional+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt collects <code>sources</code> from <code>unmanagedSourceDirectories</code>, which by
default consists of <code>scalaSource</code> and <code>javaSource</code>. Add a directory to
<code>unmanagedSourceDirectories</code> in the appropriate configuration to add a
source directory. For example, to add <code>extra-src</code> to be an additional
directory containing main sources,
</p><pre><code class="prettyprint lang-scala">unmanagedSourceDirectories in Compile += baseDirectory.value / &quot;extra-src&quot;
</code></pre><blockquote><p><strong>Note</strong>: This directory should only contain unmanaged sources, which are
sources that are manually created and managed. See
[Generating Files][Howto-Generating-Files] for working with automatically generated sources.
</p></blockquote><a name="add-resource-directory"></a><h3 id="Add+an+additional+resource+directory">Add an additional resource directory<a href="#Add+an+additional+resource+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt collects <code>resources</code> from <code>unmanagedResourceDirectories</code>, which by
default consists of <code>resourceDirectory</code>. Add a directory to
<code>unmanagedResourceDirectories</code> in the appropriate configuration to add
another resource directory. For example, to add <code>extra-resources</code> to be
an additional directory containing main resources,
</p><pre><code class="prettyprint lang-scala">unmanagedResourceDirectories in Compile += baseDirectory.value / &quot;extra-resources&quot;
</code></pre><blockquote><p><strong>Note</strong>: This directory should only contain unmanaged resources, which are
resources that are manually created and managed. See
[Generating Files][Howto-Generating-Files] for working with automatically generated
resources.
</p></blockquote><a name="source-include-filter"></a><h3 id="Include%2Fexclude+files+in+the+source+directory">Include/exclude files in the source directory<a href="#Include%2Fexclude+files+in+the+source+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When sbt traverses <code>unmanagedSourceDirectories</code> for sources, it only
includes directories and files that match <code>includeFilter</code> and do not
match <code>excludeFilter</code>. <code>includeFilter</code> and <code>excludeFilter</code> have type
<code>java.io.FileFilter</code> and sbt
<a href="Paths.html#file-filter">provides some useful combinators</a> for constructing a
<code>FileFilter</code>. For example, in addition to the default hidden files
exclusion, the following also ignores files containing <code>impl</code> in their
name,
</p><pre><code class="prettyprint lang-scala">excludeFilter in unmanagedSources := HiddenFileFilter || &quot;*impl*&quot;
</code></pre><p>To have different filters for main and test libraries, configure
<code>Compile</code> and <code>Test</code> separately:
</p><pre><code class="prettyprint lang-scala">includeFilter in (Compile, unmanagedSources) := &quot;*.scala&quot; || &quot;*.java&quot;

includeFilter in (Test, unmanagedSources) := HiddenFileFilter || &quot;*impl*&quot;
</code></pre><blockquote><p><strong>Note</strong>: By default, sbt includes <code>.scala</code> and <code>.java</code> sources, excluding hidden
files.
</p></blockquote><a name="resource-include-filter"></a><h3 id="Include%2Fexclude+files+in+the+resource+directory">Include/exclude files in the resource directory<a href="#Include%2Fexclude+files+in+the+resource+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When sbt traverses <code>unmanagedResourceDirectories</code> for resources, it only
includes directories and files that match <code>includeFilter</code> and do not
match <code>excludeFilter</code>. <code>includeFilter</code> and <code>excludeFilter</code> have type
<code>java.io.FileFilter</code> and sbt
<a href="Paths.html#file-filter">provides some useful combinators</a> for constructing a
<code>FileFilter</code>. For example, in addition to the default hidden files
exclusion, the following also ignores files containing <code>impl</code> in their
name,
</p><pre><code class="prettyprint lang-scala">excludeFilter in unmanagedSources := HiddenFileFilter || &quot;*impl*&quot;
</code></pre><p>To have different filters for main and test libraries, configure
<code>Compile</code> and <code>Test</code> separately:
</p><pre><code class="prettyprint lang-scala">includeFilter in (Compile, unmanagedSources) := &quot;*.txt&quot;

includeFilter in (Test, unmanagedSources) := &quot;*.html&quot;
</code></pre><blockquote><p><strong>Note</strong>: By default, sbt includes all files that are not hidden.
</p></blockquote><a name="lib-include-filter"></a><h3 id="Include+only+certain+%28unmanaged%29+libraries">Include only certain (unmanaged) libraries<a href="#Include+only+certain+%28unmanaged%29+libraries" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When sbt traverses <code>unmanagedBase</code> for resources, it only includes
directories and files that match <code>includeFilter</code> and do not match
<code>excludeFilter</code>. <code>includeFilter</code> and <code>excludeFilter</code> have type
<code>java.io.FileFilter</code> and sbt
<a href="Paths.html#file-filter">provides some useful combinators</a> for constructing a
<code>FileFilter</code>. For example, in addition to the default hidden files
exclusion, the following also ignores zips,
</p><pre><code class="prettyprint lang-scala">excludeFilter in unmanagedJars := HiddenFileFilter || &quot;*.zip&quot;
</code></pre><p>To have different filters for main and test libraries, configure
<code>Compile</code> and <code>Test</code> separately:
</p><pre><code class="prettyprint lang-scala">includeFilter in (Compile, unmanagedJars) := &quot;*.jar&quot;

includeFilter in (Test, unmanagedJars) := &quot;*.jar&quot; || &quot;*.zip&quot;
</code></pre><blockquote><p><strong>Note</strong>: By default, sbt includes jars, zips, and native dynamic libraries,
excluding hidden files.
</p></blockquote><h2 id="Generating+files">Generating files<a href="#Generating+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt provides standard hooks for adding source and resource generation
tasks.
</p><a name="sources"></a><h3 id="Generate+sources">Generate sources<a href="#Generate+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A source generation task should generate sources in a subdirectory of
<code>sourceManaged</code> and return a sequence of files generated. The signature
of a source generation function (that becomes a basis for a task) is
usually as follows:
</p><pre><code class="prettyprint lang-scala">def makeSomeSources(base: File): Seq[File]
</code></pre><p>The key to add the task to is called <code>sourceGenerators</code>. Because we want
to add the task, and not the value after its execution, we use
<code>taskValue</code> instead of the usual <code>value</code>. <code>sourceGenerators</code> should be
scoped according to whether the generated files are main (<code>Compile</code>) or
test (<code>Test</code>) sources. This basic structure looks like:
</p><pre><code class="prettyprint lang-scala">sourceGenerators in Compile += &lt;task of type Seq[File]&gt;.taskValue
</code></pre><p>For example, assuming a method
<code>def makeSomeSources(base: File): Seq[File]</code>,
</p><pre><code class="prettyprint lang-scala">sourceGenerators in Compile += Def.task {
  makeSomeSources((sourceManaged in Compile).value / &quot;demo&quot;)
}.taskValue
</code></pre><p>As a specific example, the following source generator generates
<code>Test.scala</code> application object that once executed, prints <code>&quot;Hi&quot;</code> to the
console:
</p><pre><code class="prettyprint lang-scala">sourceGenerators in Compile += Def.task {
  val file = (sourceManaged in Compile).value / &quot;demo&quot; / &quot;Test.scala&quot;
  IO.write(file, &quot;&quot;&quot;object Test extends App { println(&quot;Hi&quot;) }&quot;&quot;&quot;)
  Seq(file)
}.taskValue
</code></pre><p>Executing <code>run</code> will print <code>&quot;Hi&quot;</code>.
</p><pre><code class="">&gt; run
[info] Running Test
Hi
</code></pre><p>Change <code>Compile</code> to <code>Test</code> to make it a test source. For efficiency, you
would only want to generate sources when necessary and not every run.
</p><p>By default, generated sources are not included in the packaged source
artifact. To do so, add them as you would other mappings. See
<a href="Howto-Configure-Packaging.html#modify-package-contents">Adding files to a package</a>. A source
generator can return both Java and Scala sources mixed together in the
same sequence. They will be distinguished by their extension later.
</p><a name="resources"></a><h3 id="Generate+resources">Generate resources<a href="#Generate+resources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A resource generation task should generate resources in a subdirectory
of <code>resourceManaged</code> and return a sequence of files generated. Like a
source generation function, the signature of a resource generation
function (that becomes a basis for a task) is usually as follows:
</p><pre><code class="prettyprint lang-scala">def makeSomeResources(base: File): Seq[File]
</code></pre><p>The key to add the task to is called <code>resourceGenerators</code>. Because we
want to add the task, and not the value after its execution, we use
<code>taskValue</code> instead of the usual <code>value</code>. It should be scoped according
to whether the generated files are main (<code>Compile</code>) or test (<code>Test</code>)
resources. This basic structure looks like:
</p><pre><code class="prettyprint lang-scala">resourceGenerators in Compile += &lt;task of type Seq[File]&gt;.taskValue
</code></pre><p>For example, assuming a method
<code>def makeSomeResources(base: File): Seq[File]</code>,
</p><pre><code class="prettyprint lang-scala">resourceGenerators in Compile += Def.task {
  makeSomeResources((resourceManaged in Compile).value / &quot;demo&quot;)
}.taskValue
</code></pre><p>As a specific example, the following generates a properties file
<code>myapp.properties</code> containing the application name and version:
</p><pre><code class="prettyprint lang-scala">resourceGenerators in Compile += Def.task {
  val file = (resourceManaged in Compile).value / &quot;demo&quot; / &quot;myapp.properties&quot;
  val contents = &quot;name=%s\nversion=%s&quot;.format(name.value,version.value)
  IO.write(file, contents)
  Seq(file)
}.taskValue
</code></pre><p>Change <code>Compile</code> to <code>Test</code> to make it a test resource. Normally, you
would only want to generate resources when necessary and not every run.
</p><p>By default, generated resources are not included in the packaged source
artifact. To do so, add them as you would other mappings. See
<a href="Howto-Configure-Packaging.html#modify-package-contents">Adding files to a package</a>.
</p><h2 id="Inspect+the+build">Inspect the build<a href="#Inspect+the+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="taskhelp"></a><h3 id="Show+or+search+help+for+a+command%2C+task%2C+or+setting">Show or search help for a command, task, or setting<a href="#Show+or+search+help+for+a+command%2C+task%2C+or+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>help</code> command is used to show available commands and search the
help for commands, tasks, or settings. If run without arguments, <code>help</code>
lists the available commands.
</p><pre><code class="">&gt; help

  help                         Displays this help message or prints detailed help on 
                                  requested commands (run 'help &lt;command&gt;').
  about                        Displays basic information about sbt and the build.
  reload                       (Re)loads the project in the current directory
  ...

&gt; help compile
</code></pre><p>If the argument passed to <code>help</code> is the name of an existing command,
setting or task, the help for that entity is displayed. Otherwise, the
argument is interpreted as a regular expression that is used to search
the help of all commands, settings and tasks.
</p><p>The <code>tasks</code> command is like <code>help</code>, but operates only on tasks.
Similarly, the <code>settings</code> command only operates on settings.
</p><p>See also <code>help help</code>, <code>help tasks</code>, and <code>help settings</code>.
</p><a name="listtasks"></a><h3 id="List+available+tasks">List available tasks<a href="#List+available+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>tasks</code> command, without arguments, lists the most commonly used
tasks. It can take a regular expression to search task names and
descriptions. The verbosity can be increased to show or search less
commonly used tasks. See <code>help tasks</code> for details.
</p><p>The <code>settings</code> command, without arguments, lists the most commonly used
settings. It can take a regular expression to search setting names and
descriptions. The verbosity can be increased to show or search less
commonly used settings. See <code>help settings</code> for details.
</p><a name="listsettings"></a><h3 id="List+available+settings">List available settings<a href="#List+available+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>inspect</code> command displays several pieces of information about a
given setting or task, including the dependencies of a task/setting as
well as the tasks/settings that depend on the it. For example,
</p><pre><code class="">&gt; inspect test:compile
...
[info] Dependencies:
[info]  test:compile::compileInputs
[info]  test:compile::streams
[info] Reverse dependencies:
[info]  test:definedTestNames
[info]  test:definedSbtPlugins
[info]  test:printWarnings
[info]  test:discoveredMainClasses
[info]  test:definedTests
[info]  test:exportedProducts
[info]  test:products
...
</code></pre><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="taskdependencytree"></a><h3 id="Display+tree+of+setting%2Ftask+dependencies">Display tree of setting/task dependencies<a href="#Display+tree+of+setting%2Ftask+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to displaying immediate forward and reverse dependencies as
described in the previous section, the <code>inspect</code> command can display the
full dependency tree for a task or setting. For example,
</p><pre><code class="">&gt; inspect tree clean
[info] *:clean = Task[Unit]
[info]   +-*:cleanFiles = List(&lt;project&gt;/lib_managed, &lt;project&gt;/target)
[info]   | +-{.}/*:managedDirectory = lib_managed
[info]   | +-*:target = target
[info]   |   +-*:baseDirectory = &lt;project&gt;
[info]   |     +-*:thisProject = Project(id: demo, base: &lt;project&gt;, ...
[info]   |     
[info]   +-*:cleanKeepFiles = List(&lt;project&gt;/target/.history)
[info]     +-*:history = Some(&lt;project&gt;/target/.history)
...
</code></pre><p>For each task, <code>inspect tree</code> show the type of the value generated by
the task. For a setting, the <code>toString</code> of the setting is displayed. See
the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details on the
<code>inspect</code> command.
</p><a name="description"></a><h3 id="Display+the+description+and+type+of+a+setting+or+task">Display the description and type of a setting or task<a href="#Display+the+description+and+type+of+a+setting+or+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>While the <code>help</code>, <code>settings</code>, and <code>tasks</code> commands display a description
of a task, the <code>inspect</code> command also shows the type of a setting or
task and the value of a setting. For example:
</p><pre><code class="">&gt; inspect update
[info] Task: sbt.UpdateReport
[info] Description:
[info]  Resolves and optionally retrieves dependencies, producing a report.
...
</code></pre><pre><code class="">&gt; inspect scalaVersion
[info] Setting: java.lang.String = 2.9.2
[info] Description:
[info]  The version of Scala used for building.
...
</code></pre><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="delegates"></a><h3 id="Display+the+delegation+chain+of+a+setting+or+task">Display the delegation chain of a setting or task<a href="#Display+the+delegation+chain+of+a+setting+or+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="related"></a><h3 id="Display+related+settings+or+tasks">Display related settings or tasks<a href="#Display+related+settings+or+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>inspect</code> command can help find scopes where a setting or task is
defined. The following example shows that different options may be
specified to the Scala for testing and API documentation generation.
</p><pre><code class="">&gt; inspect scalacOptions
...
[info] Related:
[info]  compile:doc::scalacOptions
[info]  test:scalacOptions
[info]  */*:scalacOptions
[info]  test:doc::scalacOptions
</code></pre><p>See the <a href="Inspecting-Settings.html">Inspecting Settings</a> page for details.
</p><a name="projects"></a><h3 id="Show+the+list+of+projects+and+builds">Show the list of projects and builds<a href="#Show+the+list+of+projects+and+builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>projects</code> command displays the currently loaded projects. The
projects are grouped by their enclosing build and the current project is
indicated by an asterisk. For example,
</p><pre><code class="">&gt; projects
[info] In file:/home/user/demo/
[info]   * parent
[info]     sub
[info] In file:/home/user/dep/
[info]     sample
</code></pre><a name="session"></a><h3 id="Show+the+current+session+%28temporary%29+settings">Show the current session (temporary) settings<a href="#Show+the+current+session+%28temporary%29+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>session list</code> displays the settings that have been added at the command
line for the current project. For example,
</p><pre><code class="">&gt; session list
  1. maxErrors := 5
  2. scalacOptions += &quot;-explaintypes&quot;
</code></pre><p><code>session list-all</code> displays the settings added for all projects. For
details, see <code>help session</code>.
</p><a name="about"></a><h3 id="Show+basic+information+about+sbt+and+the+current+build">Show basic information about sbt and the current build<a href="#Show+basic+information+about+sbt+and+the+current+build" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">&gt; about
[info] This is sbt 0.12.0
[info] The current project is {file:~/code/sbt.github.com/}default
[info] The current project is built against Scala 2.9.2
[info] Available Plugins: com.jsuereth.ghpages.GhPages, com.jsuereth.git.GitPlugin, com.jsuereth.sbtsite.SitePlugin
[info] sbt, sbt plugins, and build definitions are using Scala 2.9.2
</code></pre><a name="value"></a><h3 id="Show+the+value+of+a+setting">Show the value of a setting<a href="#Show+the+value+of+a+setting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>inspect</code> command shows the value of a setting as part of its
output, but the <code>show</code> command is dedicated to this job. It shows the
output of the setting provided as an argument. For example,
</p><pre><code class="">&gt; show organization
[info] com.github.sbt 
</code></pre><p>The <code>show</code> command also works for tasks, described next.
</p><a name="result"></a><h3 id="Show+the+result+of+executing+a+task">Show the result of executing a task<a href="#Show+the+result+of+executing+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">&gt; show update
... &lt;output of update&gt; ...
[info] Update report:
[info]  Resolve time: 122 ms, Download time: 5 ms, Download size: 0 bytes
[info]  compile:
[info]      org.scala-lang:scala-library:2.9.2: ...
</code></pre><p>The <code>show</code> command will execute the task provided as an argument and
then print the result. Note that this is different from the behavior of
the <code>inspect</code> command (described in other sections), which does not
execute a task and thus can only display its type and not its generated
value.
</p><pre><code class="">&gt; show compile:dependencyClasspath
...
[info] ArrayBuffer(Attributed(~/.sbt/0.12.0/boot/scala-2.9.2/lib/scala-library.jar))
</code></pre><a name="classpath"></a><h3 id="Show+the+classpath+used+for+compilation+or+testing">Show the classpath used for compilation or testing<a href="#Show+the+classpath+used+for+compilation+or+testing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>For the test classpath,
</p><pre><code class="">&gt; show test:dependencyClasspath
...
[info] ArrayBuffer(Attributed(~/code/sbt.github.com/target/scala-2.9.2/classes), Attributed(~/.sbt/0.12.0/boot/scala-2.9.2/lib/scala-library.jar), Attributed(~/.ivy2/cache/junit/junit/jars/junit-4.8.2.jar))
</code></pre><a name="applications"></a><h3 id="Show+the+main+classes+detected+in+a+project">Show the main classes detected in a project<a href="#Show+the+main+classes+detected+in+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt detects the classes with public, static main methods for use by the
<code>run</code> method and to tab-complete the <code>runMain</code> method. The
<code>discoveredMainClasses</code> task does this discovery and provides as its
result the list of class names. For example, the following shows the
main classes discovered in the main sources:
</p><pre><code class="">&gt; show compile:discoveredMainClasses
... &lt;runs compile if out of date&gt; ...
[info] List(org.example.Main)
</code></pre><a name="tests"></a><h3 id="Show+the+test+classes+detected+in+a+project">Show the test classes detected in a project<a href="#Show+the+test+classes+detected+in+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt detects tests according to fingerprints provided by test frameworks.
The <code>definedTestNames</code> task provides as its result the list of test
names detected in this way. For example,
</p><pre><code class="">&gt; show test:definedTestNames
... &lt; runs test:compile if out of date &gt; ...
[info] List(org.example.TestA, org.example.TestB)
</code></pre><h2 id="Interactive+mode">Interactive mode<a href="#Interactive+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="basic_completion"></a><h3 id="Use+tab+completion">Use tab completion<a href="#Use+tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt’s interactive mode is started when no commands are
provided on the command line or when the <code>shell</code> command is invoked.
</p><p>As the name suggests, tab completion is invoked by hitting the tab key.
Suggestions are provided that can complete the text entered to the left
of the current cursor position. Any part of the suggestion that is
unambiguous is automatically appended to the current text. Commands
typically support tab completion for most of their syntax.
</p><p>As an example, entering <code>tes</code> and hitting tab:
</p><pre><code class="">&gt; tes&lt;TAB&gt;
</code></pre><p>results in sbt appending a <code>t</code>:
</p><pre><code class="">&gt; test
</code></pre><p>To get further completions, hit tab again:
</p><pre><code class="">&gt; test&lt;TAB&gt;
testFrameworks   testListeners    testLoader       testOnly         testOptions      test:
</code></pre><p>Now, there is more than one possibility for the next character, so sbt
prints the available options. We will select <code>testOnly</code> and get more
suggestions by entering the rest of the command and hitting tab twice:
</p><pre><code class="">&gt; testOnly&lt;TAB&gt;&lt;TAB&gt;
--                      sbt.DagSpecification    sbt.EmptyRelationTest   sbt.KeyTest             sbt.RelationTest        sbt.SettingsTest
</code></pre><p>The first tab inserts an unambiguous space and the second suggests names
of tests to run. The suggestion of <code>--</code> is for the separator between
test names and options provided to the test framework. The other
suggestions are names of test classes for one of sbt’s modules. Test
name suggestions require tests to be compiled first. If tests have been
added, renamed, or removed since the last test compilation, the
completions will be out of date until another successful compile.
</p><a name="verbose_completion"></a><h3 id="Show+more+tab+completion+suggestions">Show more tab completion suggestions<a href="#Show+more+tab+completion+suggestions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Some commands have different levels of completion. Hitting tab multiple
times increases the verbosity of completions. (Presently, this feature
is only used by the <code>set</code> command.)
</p><a name="show_keybindings"></a><h3 id="Show+JLine+keybindings">Show JLine keybindings<a href="#Show+JLine+keybindings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Both the Scala and sbt command prompts use JLine for interaction. The
Scala REPL contains a <code>:keybindings</code> command to show many of the
keybindings used for JLine. For sbt, this can be used by running one of
the <code>console</code> commands (<code>console</code>, <code>consoleQuick</code>, or <code>consoleProject</code>)
and then running <code>:keybindings</code>. For example:
</p><pre><code class="">&gt; consoleProject
[info] Starting scala interpreter...
...
scala&gt; :keybindings
Reading jline properties for default key bindings.
Accuracy not guaranteed: treat this as a guideline only.

1 CTRL-A: move to the beginning of the line
2 CTRL-B: move to the previous character
...
</code></pre><a name="change_keybindings"></a><h3 id="Modify+the+default+JLine+keybindings">Modify the default JLine keybindings<a href="#Modify+the+default+JLine+keybindings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>JLine, used by both Scala and sbt, uses a configuration file for many of
its keybindings. The location of this file can be changed with the
system property <code>jline.keybindings</code>. The default keybindings file is
included in the sbt launcher and may be used as a starting point for
customization.
</p><a name="prompt"></a><h3 id="Configure+the+prompt+string">Configure the prompt string<a href="#Configure+the+prompt+string" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt only displays <code>&gt;</code> to prompt for a command. This can be
changed through the <code>shellPrompt</code> setting, which has type
<code>State =&gt; String</code>. <a href="Build-State.html">State</a> contains all state
for sbt and thus provides access to all build information for use in the
prompt string.
</p><p>Examples:
</p><pre><code class="prettyprint lang-scala">// set the prompt (for this build) to include the project id.
shellPrompt in ThisBuild := { state =&gt; Project.extract(state).currentRef.project + &quot;&gt; &quot; }

// set the prompt (for the current project) to include the username
shellPrompt := { state =&gt; System.getProperty(&quot;user.name&quot;) + &quot;&gt; &quot; }
</code></pre><a name="history"></a><h3 id="Use+history">Use history<a href="#Use+history" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Interactive mode remembers history even if you exit sbt and restart it.
The simplest way to access history is to press the up arrow key to cycle
through previously entered commands. Use <code>Ctrl+r</code> to incrementally
search history backwards. The following commands are supported:
</p><ul><li><code>!</code> Show history command help.
</li><li><code>!!</code> Execute the previous command again.
</li><li><code>!:</code> Show all previous commands.
</li><li><code>!:n</code> Show the last n commands.
</li><li><code>!n</code> Execute the command with index <code>n</code>, as shown by the <code>!:</code>
command.
</li><li><code>!-n</code> Execute the nth command before this one.
</li><li><code>!string</code> Execute the most recent command starting with ‘string’
</li><li><code>!?string</code> Execute the most recent command containing ‘string’
</li></ul><a name="history_file"></a><h3 id="Change+the+location+of+the+interactive+history+file">Change the location of the interactive history file<a href="#Change+the+location+of+the+interactive+history+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, interactive history is stored in the <code>target/</code> directory for
the current project (but is not removed by a <code>clean</code>). History is thus
separate for each subproject. The location can be changed with the
<code>historyPath</code> setting, which has type <code>Option[File]</code>. For example,
history can be stored in the root directory for the project instead of
the output directory:
</p><pre><code class="prettyprint lang-scala">historyPath := Some(baseDirectory.value / &quot;.history&quot;)
</code></pre><p>The history path needs to be set for each project, since sbt will use
the value of <code>historyPath</code> for the current project (as selected by the
<code>project</code> command).
</p><a name="share_history"></a><h3 id="Use+the+same+history+for+all+projects">Use the same history for all projects<a href="#Use+the+same+history+for+all+projects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The previous section describes how to configure the location of the
history file. This setting can be used to share the interactive history
among all projects in a build instead of using a different history for
each project. The way this is done is to set <code>historyPath</code> to be the
same file, such as a file in the root project’s <code>target/</code> directory:
</p><pre><code class="prettyprint lang-scala">historyPath :=
  Some( (target in LocalRootProject).value / &quot;.history&quot;)
</code></pre><p>The <code>in LocalRootProject</code> part means to get the output directory for the
root project for the build.
</p><a name="disable_history"></a><h3 id="Disable+interactive+history">Disable interactive history<a href="#Disable+interactive+history" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If, for whatever reason, you want to disable history, set <code>historyPath</code>
to <code>None</code> in each project it should be disabled in:
</p><pre><code class="">&gt; historyPath := None
</code></pre><a name="pre_commands"></a><h3 id="Run+commands+before+entering+interactive+mode">Run commands before entering interactive mode<a href="#Run+commands+before+entering+interactive+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Interactive mode is implemented by the <code>shell</code> command. By default, the
<code>shell</code> command is run if no commands are provided to sbt on the command
line. To run commands before entering interactive mode, specify them on
the command line followed by <code>shell</code>. For example,
</p><pre><code class="">$ sbt clean compile shell
</code></pre><p>This runs <code>clean</code> and then <code>compile</code> before entering the interactive
prompt. If either <code>clean</code> or <code>compile</code> fails, sbt will exit without
going to the prompt. To enter the prompt whether or not these initial
commands succeed, prepend <code>-shell</code>, which means to run <code>shell</code> if any
command fails. For example,
</p><pre><code class="">$ sbt -shell clean compile shell
</code></pre><h2 id="Configure+and+use+logging">Configure and use logging<a href="#Configure+and+use+logging" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="last"></a><h3 id="View+the+logging+output+of+the+previously+executed+command">View the logging output of the previously executed command<a href="#View+the+logging+output+of+the+previously+executed+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When a command is run, more detailed logging output is sent to a file
than to the screen (by default). This output can be recalled for the
command just executed by running <code>last</code>.
</p><p>For example, the output of <code>run</code> when the sources are uptodate is:
</p><pre><code class="">&gt; run
[info] Running A
Hi!
[success] Total time: 0 s, completed Feb 25, 2012 1:00:00 PM
</code></pre><p>The details of this execution can be recalled by running <code>last</code>:
</p><pre><code class="">&gt; last
[debug] Running task... Cancelable: false, max worker threads: 4, check cycles: false
[debug]
[debug] Initial source changes:
[debug]     removed:Set()
[debug]     added: Set()
[debug]     modified: Set()
[debug] Removed products: Set()
[debug] Modified external sources: Set()
[debug] Modified binary dependencies: Set()
[debug] Initial directly invalidated sources: Set()
[debug]
[debug] Sources indirectly invalidated by:
[debug]     product: Set()
[debug]     binary dep: Set()
[debug]     external source: Set()
[debug] Initially invalidated: Set()
[debug] Copy resource mappings:
[debug]
[info] Running A
[debug] Starting sandboxed run...
[debug] Waiting for threads to exit or System.exit to be called.
[debug]   Classpath:
[debug]     /tmp/e/target/scala-2.9.2/classes
[debug]     /tmp/e/.sbt/0.12.0/boot/scala-2.9.2/lib/scala-library.jar
[debug] Waiting for thread runMain to exit
[debug]     Thread runMain exited.
[debug] Interrupting remaining threads (should be all daemons).
[debug] Sandboxed run complete..
[debug] Exited with code 0
[success] Total time: 0 s, completed Jan 1, 2012 1:00:00 PM
</code></pre><p>Configuration of the logging level for the console and for the backing
file are described in following sections.
</p><a name="tasklast"></a><h3 id="View+the+previous+logging+output+of+a+specific+task">View the previous logging output of a specific task<a href="#View+the+previous+logging+output+of+a+specific+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When a task is run, more detailed logging output is sent to a file than
to the screen (by default). This output can be recalled for a specific
task by running <code>last &lt;task&gt;</code>. For example, the first time <code>compile</code> is
run, output might look like:
</p><pre><code class="">&gt; compile
[info] Updating {file:/.../demo/}example...
[info] Resolving org.scala-lang#scala-library;2.9.2 ...
[info] Done updating.
[info] Compiling 1 Scala source to .../demo/target/scala-2.9.2/classes...
[success] Total time: 0 s, completed Jun 1, 2012 1:11:11 PM
</code></pre><p>The output indicates that both dependency resolution and compilation
were performed. The detailed output of each of these may be recalled
individually. For example,
</p><pre><code class="">&gt; last compile
[debug]
[debug] Initial source changes:
[debug]     removed:Set()
[debug]     added: Set(/home/mark/tmp/a/b/A.scala)
[debug]     modified: Set()
...
</code></pre><p>and:
</p><pre><code class="">&gt; last update
[info] Updating {file:/.../demo/}example...
[debug] post 1.3 ivy file: using exact as default matcher
[debug] :: resolving dependencies :: example#example_2.9.2;0.1-SNAPSHOT
[debug]     confs: [compile, runtime, test, provided, optional, compile-internal, runtime-internal, test-internal, plugin, sources, docs, pom]
[debug]     validate = true
[debug]     refresh = false
[debug] resolving dependencies for configuration 'compile'
...
</code></pre><a name="printwarnings"></a><h3 id="Show+warnings+from+the+previous+compilation">Show warnings from the previous compilation<a href="#Show+warnings+from+the+previous+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Scala compiler does not print the full details of warnings by
default. Compiling code that uses the deprecated <code>error</code> method from
Predef might generate the following output:
</p><pre><code class="">&gt; compile
[info] Compiling 1 Scala source to &lt;...&gt;/classes...
[warn] there were 1 deprecation warnings; re-run with -deprecation for details
[warn] one warning found
</code></pre><p>The details aren’t provided, so it is necessary to add <code>-deprecation</code> to
the options passed to the compiler (<code>scalacOptions</code>) and recompile. An
alternative when using Scala 2.10 and later is to run <code>printWarnings</code>.
This task will display all warnings from the previous compilation. For
example,
</p><pre><code class="">&gt; printWarnings
[warn] A.scala:2: method error in object Predef is deprecated: Use sys.error(message) instead
[warn]  def x = error(&quot;Failed.&quot;)
[warn]          ^
</code></pre><a name="level"></a><h3 id="Change+the+logging+level+globally">Change the logging level globally<a href="#Change+the+logging+level+globally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The quickest way to change logging levels is by using the <code>error</code>,
<code>warn</code>, <code>info</code>, or <code>debug</code> commands. These set the default logging level
for commands and tasks. For example,
</p><pre><code class="">&gt; warn
</code></pre><p>will by default show only warnings and errors. To set the logging level
before any commands are executed on startup, use <code>--</code> before the logging
level. For example,
</p><pre><code class="">$ sbt --warn
&gt; compile
[warn] there were 2 feature warning(s); re-run with -feature for details
[warn] one warning found
[success] Total time: 4 s, completed ...
&gt;
</code></pre><p>The logging level can be overridden at a finer granularity, which is
described next.
</p><a name="tasklevel"></a><h3 id="Change+the+logging+level+for+a+specific+task%2C+configuration%2C+or+project">Change the logging level for a specific task, configuration, or project<a href="#Change+the+logging+level+for+a+specific+task%2C+configuration%2C+or+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The amount of logging is controlled by the <code>logLevel</code> setting, which
takes values from the <code>Level</code> enumeration. Valid values are <code>Error</code>,
<code>Warn</code>, <code>Info</code>, and <code>Debug</code> in order of increasing verbosity. The
logging level may be configured globally, as described in the previous
section, or it may be applied to a specific project, configuration, or
task. For example, to change the logging level for compilation to only
show warnings and errors:
</p><pre><code class="prettyprint lang-scala">&gt; set logLevel in compile := Level.Warn
</code></pre><p>To enable debug logging for all tasks in the current project,
</p><pre><code class="prettyprint lang-scala">&gt; set logLevel := Level.Warn
</code></pre><p>A common scenario is that after running a task, you notice that you need
more information than was shown by default. A <code>logLevel</code> based solution
typically requires changing the logging level and running a task again.
However, there are two cases where this is unnecessary. First, warnings
from a previous compilation may be displayed using <code>printWarnings</code> for
the main sources or <code>test:printWarnings</code> for test sources. Second,
output from the previous execution is available either for a single task
or for in its entirety. See the section on
<a href="#printwarnings">printWarnings</a> and the sections on
<a href="#last">previous output</a>.
</p><a name="trace"></a><h3 id="Configure+printing+of+stack+traces">Configure printing of stack traces<a href="#Configure+printing+of+stack+traces" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt hides the stack trace of most exceptions thrown during
execution. It prints a message that indicates how to display the
exception. However, you may want to show more of stack traces by
default.
</p><p>The setting to configure is <code>traceLevel</code>, which is a setting with an Int
value. When <code>traceLevel</code> is set to a negative value, no stack traces are
shown. When it is zero, the stack trace is displayed up to the first sbt
stack frame. When positive, the stack trace is shown up to that many
stack frames.
</p><p>For example, the following configures sbt to show stack traces up to the
first sbt frame:
</p><pre><code class="prettyprint lang-scala">&gt; set every traceLevel := 0
</code></pre><p>The <code>every</code> part means to override the setting in all scopes. To change
the trace printing behavior for a single project, configuration, or
task, scope <code>traceLevel</code> appropriately:
</p><pre><code class="prettyprint lang-scala">&gt; set traceLevel in Test := 5
&gt; set traceLevel in update := 0
&gt; set traceLevel in ThisProject := -1
</code></pre><a name="nobuffer"></a><h3 id="Print+the+output+of+tests+immediately+instead+of+buffering">Print the output of tests immediately instead of buffering<a href="#Print+the+output+of+tests+immediately+instead+of+buffering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt buffers the logging output of a test until the whole
class finishes. This is so that output does not get mixed up when
executing in parallel. To disable buffering, set the <code>logBuffered</code>
setting to false:
</p><pre><code class="prettyprint lang-scala">logBuffered := false
</code></pre><a name="custom"></a><h3 id="Add+a+custom+logger">Add a custom logger<a href="#Add+a+custom+logger" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The setting <code>extraLoggers</code> can be used to add custom loggers. A custom
logger should implement [AbstractLogger]. <code>extraLoggers</code> is a function
<code>ScopedKey[_] =&gt; Seq[AbstractLogger]</code>. This means that it can provide
different logging based on the task that requests the logger.
</p><pre><code class="prettyprint lang-scala">extraLoggers := {
  val currentFunction = extraLoggers.value
    (key: ScopedKey[_]) =&gt; {
        myCustomLogger(key) +: currentFunction(key)
    }
}
</code></pre><p>Here, we take the current function <code>currentFunction</code> for the setting and
provide a new function. The new function prepends our custom logger to
the ones provided by the old function.
</p><a name="log"></a><h3 id="Log+messages+in+a+task">Log messages in a task<a href="#Log+messages+in+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The special task <code>streams</code> provides per-task logging and I/O via a
<a href="../api/#sbt.std.Streams">Streams</a> instance. To log, a task uses
the <code>log</code> member from the <code>streams</code> task:
</p><pre><code class="prettyprint lang-scala">myTask := {
  val log = streams.value.log
  log.warn(&quot;A warning.&quot;)
}
</code></pre><h2 id="Project+metadata">Project metadata<a href="#Project+metadata" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="name"></a><h3 id="Set+the+project+name">Set the project name<a href="#Set+the+project+name" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A project should define <code>name</code> and <code>version</code>. These will be used in
various parts of the build, such as the names of generated artifacts.
Projects that are published to a repository should also override
<code>organization</code>.
</p><pre><code class="prettyprint lang-scala">name := &quot;Your project name&quot;
</code></pre><p>For published projects, this name is normalized to be suitable for use
as an artifact name and dependency ID. This normalized name is stored in
<code>normalizedName</code>.
</p><a name="version"></a><h3 id="Set+the+project+version">Set the project version<a href="#Set+the+project+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">version := &quot;1.0&quot;
</code></pre><a name="organization"></a><h3 id="Set+the+project+organization">Set the project organization<a href="#Set+the+project+organization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">organization := &quot;org.example&quot;
</code></pre><p>By convention, this is a reverse domain name that you own, typically one
specific to your project. It is used as a namespace for projects.
</p><p>A full/formal name can be defined in the <code>organizationName</code> setting.
This is used in the generated pom.xml. If the organization has a web
site, it may be set in the <code>organizationHomepage</code> setting. For example:
</p><pre><code class="prettyprint lang-scala">organizationName := &quot;Example, Inc.&quot;

organizationHomepage := Some(url(&quot;http://example.org&quot;))
</code></pre><a name="other"></a><h3 id="Set+the+project%E2%80%99s+homepage+and+other+metadata">Set the project’s homepage and other metadata<a href="#Set+the+project%E2%80%99s+homepage+and+other+metadata" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="prettyprint lang-scala">homepage := Some(url(&quot;http://scala-sbt.org&quot;))

startYear := Some(2008)

description := &quot;A build tool for Scala.&quot;

licenses += &quot;GPLv2&quot; -&gt; url(&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;)
</code></pre><h2 id="Configure+packaging">Configure packaging<a href="#Configure+packaging" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="export"></a><h3 id="Use+the+packaged+jar+on+classpaths+instead+of+class+directory">Use the packaged jar on classpaths instead of class directory<a href="#Use+the+packaged+jar+on+classpaths+instead+of+class+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, a project exports a directory containing its resources and
compiled class files. Set <code>exportJars</code> to true to export the packaged
jar instead. For example,
</p><pre><code class="prettyprint lang-scala">exportJars := true
</code></pre><p>The jar will be used by <code>run</code>, <code>test</code>, <code>console</code>, and other tasks that
use the full classpath.
</p><a name="manifest"></a><h3 id="Add+manifest+attributes">Add manifest attributes<a href="#Add+manifest+attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, sbt constructs a manifest for the binary package from
settings such as <code>organization</code> and <code>mainClass</code>. Additional attributes
may be added to the <code>packageOptions</code> setting scoped by the configuration
and package task.
</p><p>Main attributes may be added with <code>Package.ManifestAttributes</code>. There
are two variants of this method, once that accepts repeated arguments
that map an attribute of type <code>java.util.jar.Attributes.Name</code> to a
String value and other that maps attribute names (type String) to the
String value.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">packageOptions in (Compile, packageBin) += 
  Package.ManifestAttributes( java.util.jar.Attributes.Name.SEALED -&gt; &quot;true&quot; )
</code></pre><p>Other attributes may be added with <code>Package.JarManifest</code>.
</p><pre><code class="prettyprint lang-scala">packageOptions in (Compile, packageBin) +=  {
  import java.util.jar.{Attributes, Manifest}
  val manifest = new Manifest
  manifest.getAttributes(&quot;foo/bar/&quot;).put(Attributes.Name.SEALED, &quot;false&quot;)
  Package.JarManifest( manifest )
}
</code></pre><p>Or, to read the manifest from a file:
</p><pre><code class="prettyprint lang-scala">packageOptions in (Compile, packageBin) +=  {
  val manifest = Using.fileInputStream( in =&gt; new java.util.jar.Manifest(in) )
  Package.JarManifest( manifest )
}
</code></pre><a name="name"></a><h3 id="Change+the+file+name+of+a+package">Change the file name of a package<a href="#Change+the+file+name+of+a+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>artifactName</code> setting controls the name of generated packages. See
the <a href="Artifacts.html">Artifacts</a> page for details.
</p><a name="contents"></a><h3 id="Modify+the+contents+of+the+package">Modify the contents of the package<a href="#Modify+the+contents+of+the+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The contents of a package are defined by the <code>mappings</code> task, of type
<code>Seq[(File,String)]</code>. The <code>mappings</code> task is a sequence of mappings from
a file to include in the package to the path in the package. See
<a href="Mapping-Files.html">Mapping Files</a> for convenience functions for
generating these mappings. For example, to add the file <code>in/example.txt</code>
to the main binary jar with the path “out/example.txt”,
</p><pre><code class="prettyprint lang-scala">mappings in (Compile, packageBin) += {
  (baseDirectory.value / &quot;in&quot; / &quot;example.txt&quot;) -&gt; &quot;out/example.txt&quot;
}
</code></pre><p>Note that <code>mappings</code> is scoped by the configuration and the specific
package task. For example, the mappings for the test source package are
defined by the <code>mappings in (Test, packageSrc)</code> task.
</p><h2 id="Running+commands">Running commands<a href="#Running+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="batch"></a><h3 id="Pass+arguments+to+a+command+or+task+in+batch+mode">Pass arguments to a command or task in batch mode<a href="#Pass+arguments+to+a+command+or+task+in+batch+mode" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt interprets each command line argument provided to it as a command
together with the command’s arguments. Therefore, to run a command that
takes arguments in batch mode, quote the command and its arguments. For
example,
</p><pre><code class="">$ sbt 'project X' clean '~ compile'
</code></pre><a name="multi"></a><h3 id="Provide+multiple+commands+to+run+consecutively">Provide multiple commands to run consecutively<a href="#Provide+multiple+commands+to+run+consecutively" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Multiple commands can be scheduled at once by prefixing each command
with a semicolon. This is useful for specifying multiple commands where
a single command string is accepted. For example, the syntax for
triggered execution is <code>~ &lt;command&gt;</code>. To have more than one command run
for each triggering, use semicolons. For example, the following runs
<code>clean</code> and then <code>compile</code> each time a source file changes:
</p><pre><code class="">&gt; ~ ;clean;compile
</code></pre><a name="read"></a><h3 id="Read+commands+from+a+file">Read commands from a file<a href="#Read+commands+from+a+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>&lt;</code> command reads commands from the files provided to it as
arguments. Run <code>help &lt;</code> at the sbt prompt for details.
</p><a name="alias"></a><h3 id="Define+an+alias+for+a+command+or+task">Define an alias for a command or task<a href="#Define+an+alias+for+a+command+or+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>alias</code> command defines, removes, and displays aliases for commands.
Run <code>help alias</code> at the sbt prompt for details.
</p><p>Example usage:
</p><pre><code class="">&gt; alias a=about
&gt; alias
    a = about    
&gt; a
[info] This is sbt ...
&gt; alias a=
&gt; alias
&gt; a
[error] Not a valid command: a ...
</code></pre><a name="eval"></a><h3 id="Quickly+evaluate+a+Scala+expression">Quickly evaluate a Scala expression<a href="#Quickly+evaluate+a+Scala+expression" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>eval</code> command compiles and runs the Scala expression passed to it
as an argument. The result is printed along with its type. For example,
</p><pre><code class="">&gt; eval 2+2
4: Int
</code></pre><p>Variables defined by an <code>eval</code> are not visible to subsequent <code>eval</code>s,
although changes to system properties persist and affect the JVM that is
running sbt. Use the Scala REPL (<code>console</code> and related commands) for
full support for evaluating Scala code interactively.
</p><h2 id="Configure+and+use+Scala">Configure and use Scala<a href="#Configure+and+use+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="version"></a><h3 id="Set+the+Scala+version+used+for+building+the+project">Set the Scala version used for building the project<a href="#Set+the+Scala+version+used+for+building+the+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>scalaVersion</code> configures the version of Scala used for compilation.
By default, sbt also adds a dependency on the Scala library with this
version. See the next section for how to disable this automatic
dependency. If the Scala version is not specified, the version sbt was
built against is used. It is recommended to explicitly specify the
version of Scala.
</p><p>For example, to set the Scala version to “2.11.1”,
</p><pre><code class="prettyprint lang-scala">scalaVersion := &quot;2.11.1&quot;
</code></pre><a name="noauto"></a><h3 id="Disable+the+automatic+dependency+on+the+Scala+library">Disable the automatic dependency on the Scala library<a href="#Disable+the+automatic+dependency+on+the+Scala+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt adds a dependency on the Scala standard library by default. To
disable this behavior, set the <code>autoScalaLibrary</code> setting to false.
</p><pre><code class="prettyprint lang-scala">autoScalaLibrary := false
</code></pre><a name="temporary"></a><h3 id="Temporarily+switch+to+a+different+Scala+version">Temporarily switch to a different Scala version<a href="#Temporarily+switch+to+a+different+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To set the Scala version in all scopes to a specific value, use the <code>++</code>
command. For example, to temporarily use Scala 2.10.4, run:
</p><pre><code class="">&gt; ++ 2.10.4
</code></pre><a name="local"></a><h3 id="Use+a+local+Scala+installation+for+building+a+project">Use a local Scala installation for building a project<a href="#Use+a+local+Scala+installation+for+building+a+project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Defining the <code>scalaHome</code> setting with the path to the Scala home
directory will use that Scala installation. sbt still requires
<code>scalaVersion</code> to be set when a local Scala version is used. For
example,
</p><pre><code class="prettyprint lang-scala">scalaVersion := &quot;2.10.0-local&quot;

scalaHome := Some(file(&quot;/path/to/scala/home/&quot;))
</code></pre><a name="cross"></a><h3 id="Build+a+project+against+multiple+Scala+versions">Build a project against multiple Scala versions<a href="#Build+a+project+against+multiple+Scala+versions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>See <a href="Cross-Build.html">cross building</a>.
</p><a name="consoleQuick"></a><h3 id="Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+on+the+classpath%2C+but+not+the+compiled+project+classes">Enter the Scala REPL with a project’s dependencies on the classpath, but not the compiled project classes<a href="#Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+on+the+classpath%2C+but+not+the+compiled+project+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>consoleQuick</code> action retrieves dependencies and puts them on the
classpath of the Scala REPL. The project’s sources are not compiled, but
sources of any source dependencies are compiled. To enter the REPL with
test dependencies on the classpath but without compiling test sources,
run <code>test:consoleQuick</code>. This will force compilation of main sources.
</p><a name="console"></a><h3 id="Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+and+compiled+code+on+the+classpath">Enter the Scala REPL with a project’s dependencies and compiled code on the classpath<a href="#Enter+the+Scala+REPL+with+a+project%E2%80%99s+dependencies+and+compiled+code+on+the+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>console</code> action retrieves dependencies and compiles sources and
puts them on the classpath of the Scala REPL. To enter the REPL with
test dependencies and compiled test sources on the classpath, run
<code>test:console</code>.
</p><a name="consoleProject"></a><h3 id="Enter+the+Scala+REPL+with+plugins+and+the+build+definition+on+the+classpath">Enter the Scala REPL with plugins and the build definition on the classpath<a href="#Enter+the+Scala+REPL+with+plugins+and+the+build+definition+on+the+classpath" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><pre><code class="">&gt; consoleProject
</code></pre><p>For details, see the <a href="Console-Project.html">consoleProject</a>
page.
</p><a name="initial"></a><h3 id="Define+the+initial+commands+evaluated+when+entering+the+Scala+REPL">Define the initial commands evaluated when entering the Scala REPL<a href="#Define+the+initial+commands+evaluated+when+entering+the+Scala+REPL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>initialCommands in console</code> to set the initial statements to
evaluate when <code>console</code> and <code>consoleQuick</code> are run. To configure
<code>consoleQuick</code> separately, use <code>initialCommands in consoleQuick</code>. For
example,
</p><pre><code class="prettyprint lang-scala">initialCommands in console := &quot;&quot;&quot;println(&quot;Hello from console&quot;)&quot;&quot;&quot;

initialCommands in consoleQuick := &quot;&quot;&quot;println(&quot;Hello from consoleQuick&quot;)&quot;&quot;&quot;
</code></pre><p>The <code>consoleProject</code> command is configured separately by
<code>initialCommands in consoleProject</code>. It does not use the value from
<code>initialCommands in console</code> by default. For example,
</p><pre><code class="prettyprint lang-scala">initialCommands in consoleProject := &quot;&quot;&quot;println(&quot;Hello from consoleProject&quot;)&quot;&quot;&quot;
</code></pre><a name="cleanup"></a><h3 id="Define+the+commands+evaluated+when+exiting+the+Scala+REPL">Define the commands evaluated when exiting the Scala REPL<a href="#Define+the+commands+evaluated+when+exiting+the+Scala+REPL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>cleanupCommands in console</code> to set the statements to evaluate after
exiting the Scala REPL started by <code>console</code> and <code>consoleQuick</code>. To
configure <code>consoleQuick</code> separately, use
<code>cleanupCommands in consoleQuick</code>. For example,
</p><pre><code class="prettyprint lang-scala">cleanupCommands in console := &quot;&quot;&quot;println(&quot;Bye from console&quot;)&quot;&quot;&quot;

cleanupCommands in consoleQuick := &quot;&quot;&quot;println(&quot;Bye from consoleQuick&quot;)&quot;&quot;&quot;
</code></pre><p>The <code>consoleProject</code> command is configured separately by
<code>cleanupCommands in consoleProject</code>. It does not use the value from
<code>cleanupCommands in console</code> by default. For example,
</p><pre><code class="prettyprint lang-scala">cleanupCommands in consoleProject := &quot;&quot;&quot;println(&quot;Bye from consoleProject&quot;)&quot;&quot;&quot;
</code></pre><a name="embed"></a><h3 id="Use+the+Scala+REPL+from+project+code">Use the Scala REPL from project code<a href="#Use+the+Scala+REPL+from+project+code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt runs tests in the same JVM as sbt itself and Scala classes are not
in the same class loader as the application classes. This is also the
case in <code>console</code> and when <code>run</code> is not forked. Therefore, when using
the Scala interpreter, it is important to set it up properly to avoid an
error message like:
</p><pre><code class="">Failed to initialize compiler: class scala.runtime.VolatileBooleanRef not found.
** Note that as of 2.8 scala does not assume use of the java classpath.
** For the old behavior pass -usejavacp to scala, or if using a Settings
** object programmatically, settings.usejavacp.value = true.
</code></pre><p>The key is to initialize the Settings for the interpreter using
<em>embeddedDefaults</em>. For example:
</p><pre><code class="prettyprint lang-scala">val settings = new Settings
settings.embeddedDefaults[MyType]
val interpreter = new Interpreter(settings, ...)
</code></pre><p>Here, <code>MyType</code> is a representative class that should be included on the
interpreter’s classpath and in its application class loader. For more
background, see the
<a href="https://gist.github.com/404272">original proposal</a> that resulted in
<em>embeddedDefaults</em> being added.
</p><p>Similarly, use a representative class as the type argument when using
the <em>break</em> and <em>breakIf</em> methods of <em>ILoop</em>, as in the following
example:
</p><pre><code class="prettyprint lang-scala">def x(a: Int, b: Int) = {
  import scala.tools.nsc.interpreter.ILoop
  ILoop.breakIf[MyType](a != b, &quot;a&quot; -&gt; a, &quot;b&quot; -&gt; b )
}
</code></pre><h2 id="Generate+API+documentation">Generate API documentation<a href="#Generate+API+documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="generate-javadoc-or-scaladoc"></a><h3 id="Select+javadoc+or+scaladoc">Select javadoc or scaladoc<a href="#Select+javadoc+or+scaladoc" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt will run <code>javadoc</code> if there are only Java sources in the project. If
there are any Scala sources, sbt will run <code>scaladoc</code>. (This situation
results from <code>scaladoc</code> not processing Javadoc comments in Java sources
nor linking to Javadoc.)
</p><a name="definitive-doc-options"></a><h3 id="Set+the+options+used+for+generating+scaladoc+independently+of+compilation">Set the options used for generating scaladoc independently of compilation<a href="#Set+the+options+used+for+generating+scaladoc+independently+of+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>scalacOptions</code> to the <code>doc</code> task to configure <code>scaladoc</code>. Use
<code>:=</code> to definitively set the options without appending to the options
for <code>compile</code>. Scope to <code>Compile</code> for main sources or to <code>Test</code> for test
sources. For example,
</p><pre><code class="prettyprint lang-scala">scalacOptions in (Compile,doc) := Seq(&quot;-groups&quot;, &quot;-implicits&quot;)
</code></pre><a name="additional-doc-options"></a><h3 id="Add+options+for+scaladoc+to+the+compilation+options">Add options for scaladoc to the compilation options<a href="#Add+options+for+scaladoc+to+the+compilation+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>scalacOptions</code> to the <code>doc</code> task to configure <code>scaladoc</code>. Use
<code>+=</code> or <code>++=</code> to append options to the base options. To append a single
option, use <code>+=</code>. To append a <code>Seq[String]</code>, use <code>++=</code>. Scope to
<code>Compile</code> for main sources or to <code>Test</code> for test sources. For example,
</p><pre><code class="prettyprint lang-scala">scalacOptions in (Compile,doc) ++= Seq(&quot;-groups&quot;, &quot;-implicits&quot;)
</code></pre><a name="definitive-javadoc-options"></a><h3 id="Set+the+options+used+for+generating+javadoc+independently+of+compilation">Set the options used for generating javadoc independently of compilation<a href="#Set+the+options+used+for+generating+javadoc+independently+of+compilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>javacOptions</code> to the <code>doc</code> task to configure <code>javadoc</code>. Use <code>:=</code>
to definitively set the options without appending to the options for
<code>compile</code>. Scope to <code>Compile</code> for main sources or to <code>Test</code> for test
sources.
</p><a name="additional-doc-options"></a><h3 id="Add+options+for+javadoc+to+the+compilation+options">Add options for javadoc to the compilation options<a href="#Add+options+for+javadoc+to+the+compilation+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Scope <code>javacOptions</code> to the <code>doc</code> task to configure <code>javadoc</code>. Use <code>+=</code>
or <code>++=</code> to append options to the base options. To append a single
option, use <code>+=</code>. To append a <code>Seq[String]</code>, use <code>++=</code>. Scope to
<code>Compile</code> for main sources or to <code>Test</code> for test sources. For example,
</p><pre><code class="prettyprint lang-scala">javacOptions in (Compile,doc) ++= Seq(&quot;-notimestamp&quot;, &quot;-linksource&quot;)
</code></pre><a name="auto-link"></a><h3 id="Enable+automatic+linking+to+the+external+Scaladoc+of+managed+dependencies">Enable automatic linking to the external Scaladoc of managed dependencies<a href="#Enable+automatic+linking+to+the+external+Scaladoc+of+managed+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>autoAPIMappings := true</code> for sbt to tell <code>scaladoc</code> where it can
find the API documentation for managed dependencies. This requires that
dependencies have this information in its metadata and you are using
<code>scaladoc</code> for Scala 2.10.2 or later.
</p><a name="manual-api-links"></a><h3 id="Enable+manual+linking+to+the+external+Scaladoc+of+managed+dependencies">Enable manual linking to the external Scaladoc of managed dependencies<a href="#Enable+manual+linking+to+the+external+Scaladoc+of+managed+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Add mappings of type <code>(File, URL)</code> to <code>apiMappings</code> to manually tell
<code>scaladoc</code> where it can find the API documentation for dependencies.
(This requires <code>scaladoc</code> for Scala 2.10.2 or later.) These mappings are
used in addition to <code>autoAPIMappings</code>, so this manual configuration is
typically done for unmanaged dependencies. The <code>File</code> key is the
location of the dependency as passed to the classpath. The <code>URL</code> value
is the base URL of the API documentation for the dependency. For
example,
</p><pre><code class="prettyprint lang-scala">apiMappings += (
  (unmanagedBase.value / &quot;a-library.jar&quot;) -&gt; 
    url(&quot;http://example.org/api/&quot;)
)
</code></pre><a name="define-api-url"></a><h3 id="Define+the+location+of+API+documentation+for+a+library">Define the location of API documentation for a library<a href="#Define+the+location+of+API+documentation+for+a+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Set <code>apiURL</code> to define the base <code>URL</code> for the Scaladocs for your
library. This will enable clients of your library to automatically link
against the API documentation using <code>autoAPIMappings</code>. (This only works
for Scala 2.10.2 and later.) For example,
</p><pre><code class="prettyprint lang-scala">apiURL := Some(url(&quot;http://example.org/api/&quot;))
</code></pre><p>This information will get included in a property of the published
<code>pom.xml</code>, where it can be automatically consumed by sbt.
</p><h2 id="Triggered+execution">Triggered execution<a href="#Triggered+execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><a name="basic"></a><h3 id="Run+a+command+when+sources+change">Run a command when sources change<a href="#Run+a+command+when+sources+change" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can make a command run when certain files change by prefixing the
command with <code>~</code>. Monitoring is terminated when <code>enter</code> is pressed. This
triggered execution is configured by the <code>watch</code> setting, but typically
the basic settings <code>watchSources</code> and <code>pollInterval</code> are modified as
described in later sections.
</p><p>The original use-case for triggered execution was continuous
compilation:
</p><pre><code class="">&gt; ~ test:compile

&gt; ~ compile
</code></pre><p>You can use the triggered execution feature to run any command or task,
however. The following will poll for changes to your source code (main
or test) and run <code>testOnly</code> for the specified test.
</p><pre><code class="">&gt; ~ testOnly example.TestA
</code></pre><a name="multi"></a><h3 id="Run+multiple+commands+when+sources+change">Run multiple commands when sources change<a href="#Run+multiple+commands+when+sources+change" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The command passed to <code>~</code> may be any command string, so multiple
commands may be run by separating them with a semicolon. For example,
</p><pre><code class="">&gt; ~ ;a ;b
</code></pre><p>This runs <code>a</code> and then <code>b</code> when sources change.
</p><a name="sources"></a><h3 id="Configure+the+sources+that+are+checked+for+changes">Configure the sources that are checked for changes<a href="#Configure+the+sources+that+are+checked+for+changes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>watchSources</code> defines the files for a single project that are
monitored for changes. By default, a project watches resources and
Scala and Java sources.
</li><li><code>watchTransitiveSources</code> then combines the <code>watchSources</code> for the
current project and all execution and classpath dependencies (see
<a href="../tutorial/Full-Def.html">.scala build definition</a> for details on inter-project
dependencies).
</li></ul><p>To add the file <code>demo/example.txt</code> to the files to watch,
</p><pre><code class="prettyprint lang-scala">watchSources += baseDirectory.value / &quot;demo&quot; / &quot;examples.txt&quot;
</code></pre><a name="interval"></a><h3 id="Set+the+time+interval+between+checks+for+changes+to+sources">Set the time interval between checks for changes to sources<a href="#Set+the+time+interval+between+checks+for+changes+to+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>pollInterval</code> selects the interval between polling for changes in
milliseconds. The default value is <code>500 ms</code>. To change it to <code>1 s</code>,
</p><pre><code class="prettyprint lang-scala">pollInterval := 1000 // in ms
</code></pre><h2 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This section of the documentation has example sbt build definitions and
code. Contributions are welcome!
</p><p>You may want to read the
<a href="../tutorial/index.html">Getting Started Guide</a> as a foundation for
understanding the examples.
</p><h2 id=".sbt+build+examples">.sbt build examples<a href="#.sbt+build+examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Listed here are some examples of settings (each setting is independent).
See <a href="../tutorial/Basic-Def.html">.sbt build definition</a> for details.
</p><p><em>Note</em> that blank lines are used to separate individual settings.
Avoid using blank lines within a single multiline expression. As
explained in <a href="../tutorial/Basic-Def.html">.sbt build definition</a>, each
setting is otherwise a normal Scala expression with expected type
<a href="../api/sbt/Init$SettingsDefinition.html">sbt.SettingDefinition</a>.
</p><pre><code class="prettyprint lang-scala">// set the name of the project
name := &quot;My Project&quot;

version := &quot;1.0&quot;

organization := &quot;org.myproject&quot;

// set the Scala version used for the project
scalaVersion := &quot;2.9.0-SNAPSHOT&quot;

// set the main Scala source directory to be &lt;base&gt;/src
scalaSource in Compile := baseDirectory.value / &quot;src&quot;

// set the Scala test source directory to be &lt;base&gt;/test
scalaSource in Test := baseDirectory.value / &quot;test&quot;

// add a test dependency on ScalaCheck
libraryDependencies += &quot;org.scala-tools.testing&quot; %% &quot;scalacheck&quot; % &quot;1.8&quot; % &quot;test&quot;

// add compile dependencies on some dispatch modules
libraryDependencies ++= Seq(
    &quot;net.databinder&quot; %% &quot;dispatch-meetup&quot; % &quot;0.7.8&quot;,
    &quot;net.databinder&quot; %% &quot;dispatch-twitter&quot; % &quot;0.7.8&quot;
)

// Set a dependency based partially on a val.
{
  val libosmVersion = &quot;2.5.2-RC1&quot;
  libraryDependencies += (&quot;net.sf.travelingsales&quot; % &quot;osmlib&quot; % libosmVersion from
    &quot;http://downloads.sourceforge.net/project/travelingsales/libosm/&quot;+libosmVersion+&quot;/libosm-&quot;+libosmVersion+&quot;.jar&quot;)
}

// reduce the maximum number of errors shown by the Scala compiler
maxErrors := 20

// increase the time between polling for file changes when using continuous execution
pollInterval := 1000

// append several options to the list of options passed to the Java compiler
javacOptions ++= Seq(&quot;-source&quot;, &quot;1.5&quot;, &quot;-target&quot;, &quot;1.5&quot;)

// append -deprecation to the options passed to the Scala compiler
scalacOptions += &quot;-deprecation&quot;

// define the statements initially evaluated when entering 'console', 'consoleQuick', or 'consoleProject'
initialCommands := &quot;&quot;&quot;
  import System.{currentTimeMillis =&gt; now}
  def time[T](f: =&gt; T): T = {
    val start = now
    try { f } finally { println(&quot;Elapsed: &quot; + (now - start)/1000.0 + &quot; s&quot;) }
  }
&quot;&quot;&quot;

// set the initial commands when entering 'console' or 'consoleQuick', but not 'consoleProject'
initialCommands in console := &quot;import myproject._&quot;

// set the main class for packaging the main jar
// 'run' will still auto-detect and prompt
// change Compile to Test to set it for the test jar
mainClass in (Compile, packageBin) := Some(&quot;myproject.MyMain&quot;)

// set the main class for the main 'run' task
// change Compile to Test to set it for 'test:run'
mainClass in (Compile, run) := Some(&quot;myproject.MyMain&quot;)

// add &lt;base&gt;/input to the files that '~' triggers on
watchSources += baseDirectory.value / &quot;input&quot;

// add a maven-style repository
resolvers += &quot;name&quot; at &quot;url&quot;

// add a sequence of maven-style repositories
resolvers ++= Seq(&quot;name&quot; at &quot;url&quot;)

// define the repository to publish to
publishTo := Some(&quot;name&quot; at &quot;url&quot;)

// set Ivy logging to be at the highest level
ivyLoggingLevel := UpdateLogging.Full

// disable updating dynamic revisions (including -SNAPSHOT versions)
offline := true

// set the prompt (for this build) to include the project id.
shellPrompt in ThisBuild := { state =&gt; Project.extract(state).currentRef.project + &quot;&gt; &quot; }

// set the prompt (for the current project) to include the username
shellPrompt := { state =&gt; System.getProperty(&quot;user.name&quot;) + &quot;&gt; &quot; }

// disable printing timing information, but still print [success]
showTiming := false

// disable printing a message indicating the success or failure of running a task
showSuccess := false

// change the format used for printing task completion time
timingFormat := {
    import java.text.DateFormat
    DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT)
}

// disable using the Scala version in output paths and artifacts
crossPaths := false

// fork a new JVM for 'run' and 'test:run'
fork := true

// fork a new JVM for 'test:run', but not 'run'
fork in Test := true

// add a JVM option to use when forking a JVM for 'run'
javaOptions += &quot;-Xmx2G&quot;

// only use a single thread for building
parallelExecution := false

// Execute tests in the current project serially
//   Tests from other projects may still run concurrently.
parallelExecution in Test := false

// set the location of the JDK to use for compiling Java code.
// if 'fork' is true, this is used for 'run' as well
javaHome := Some(file(&quot;/usr/lib/jvm/sun-jdk-1.6&quot;))

// Use Scala from a directory on the filesystem instead of retrieving from a repository
scalaHome := Some(file(&quot;/home/user/scala/trunk/&quot;))

// don't aggregate clean (See FullConfiguration for aggregation details)
aggregate in clean := false

// only show warnings and errors on the screen for compilations.
//  this applies to both test:compile and compile and is Info by default
logLevel in compile := Level.Warn

// only show warnings and errors on the screen for all tasks (the default is Info)
//  individual tasks can then be more verbose using the previous setting
logLevel := Level.Warn

// only store messages at info and above (the default is Debug)
//   this is the logging level for replaying logging with 'last'
persistLogLevel := Level.Debug

// only show 10 lines of stack traces
traceLevel := 10

// only show stack traces up to the first sbt stack frame
traceLevel := 0

// add SWT to the unmanaged classpath
unmanagedJars in Compile += Attributed.blank(file(&quot;/usr/share/java/swt.jar&quot;))

// publish test jar, sources, and docs
publishArtifact in Test := true

// disable publishing of main docs
publishArtifact in (Compile, packageDoc) := false

// change the classifier for the docs artifact
artifactClassifier in packageDoc := Some(&quot;doc&quot;)

// Copy all managed dependencies to &lt;build-root&gt;/lib_managed/
//   This is essentially a project-local cache and is different
//   from the lib_managed/ in sbt 0.7.x.  There is only one
//   lib_managed/ in the build root (not per-project).
retrieveManaged := true

/* Specify a file containing credentials for publishing. The format is:
realm=Sonatype Nexus Repository Manager
host=nexus.scala-tools.org
user=admin
password=admin123
*/
credentials += Credentials(Path.userHome / &quot;.ivy2&quot; / &quot;.credentials&quot;)

// Directly specify credentials for publishing.
credentials += Credentials(&quot;Sonatype Nexus Repository Manager&quot;, &quot;nexus.scala-tools.org&quot;, &quot;admin&quot;, &quot;admin123&quot;)

// Exclude transitive dependencies, e.g., include log4j without including logging via jdmk, jmx, or jms.
libraryDependencies +=
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.15&quot; excludeAll(
    ExclusionRule(organization = &quot;com.sun.jdmk&quot;),
    ExclusionRule(organization = &quot;com.sun.jmx&quot;),
    ExclusionRule(organization = &quot;javax.jms&quot;)
  )
</code></pre><h2 id=".scala+build+example">.scala build example<a href="#.scala+build+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><code>.scala</code> builds are written in Scala, so this example would be
placed as <code>project/Build.scala</code>, not <code>build.sbt</code>. The build can be split
into multiple files.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object BuildSettings {
  val buildOrganization = &quot;odp&quot;
  val buildVersion      = &quot;2.0.29&quot;
  val buildScalaVersion = &quot;2.9.0-1&quot;

  val buildSettings = Seq (
    organization := buildOrganization,
    version      := buildVersion,
    scalaVersion := buildScalaVersion,
    shellPrompt  := ShellPrompt.buildShellPrompt
  )
}

// Shell prompt which show the current project, 
// git branch and build version
object ShellPrompt {
  object devnull extends ProcessLogger {
    def info (s: =&gt; String) {}
    def error (s: =&gt; String) { }
    def buffer[T] (f: =&gt; T): T = f
  }
  def currBranch = (
    (&quot;git status -sb&quot; lines_! devnull headOption)
      getOrElse &quot;-&quot; stripPrefix &quot;## &quot;
  )

  val buildShellPrompt = { 
    (state: State) =&gt; {
      val currProject = Project.extract (state).currentProject.id
      &quot;%s:%s:%s&gt; &quot;.format (
        currProject, currBranch, BuildSettings.buildVersion
      )
    }
  }
}

object Resolvers {
  val sunrepo    = &quot;Sun Maven2 Repo&quot; at &quot;http://download.java.net/maven/2&quot;
  val sunrepoGF  = &quot;Sun GF Maven2 Repo&quot; at &quot;http://download.java.net/maven/glassfish&quot; 
  val oraclerepo = &quot;Oracle Maven2 Repo&quot; at &quot;http://download.oracle.com/maven&quot;

  val oracleResolvers = Seq (sunrepo, sunrepoGF, oraclerepo)
}

object Dependencies {
  val logbackVer = &quot;0.9.16&quot;
  val grizzlyVer = &quot;1.9.19&quot;

  val logbackcore    = &quot;ch.qos.logback&quot; % &quot;logback-core&quot;     % logbackVer
  val logbackclassic = &quot;ch.qos.logback&quot; % &quot;logback-classic&quot;  % logbackVer

  val jacksonjson = &quot;org.codehaus.jackson&quot; % &quot;jackson-core-lgpl&quot; % &quot;1.7.2&quot;

  val grizzlyframwork = &quot;com.sun.grizzly&quot; % &quot;grizzly-framework&quot; % grizzlyVer
  val grizzlyhttp     = &quot;com.sun.grizzly&quot; % &quot;grizzly-http&quot;      % grizzlyVer
  val grizzlyrcm      = &quot;com.sun.grizzly&quot; % &quot;grizzly-rcm&quot;       % grizzlyVer
  val grizzlyutils    = &quot;com.sun.grizzly&quot; % &quot;grizzly-utils&quot;     % grizzlyVer
  val grizzlyportunif = &quot;com.sun.grizzly&quot; % &quot;grizzly-portunif&quot;  % grizzlyVer

  val sleepycat = &quot;com.sleepycat&quot; % &quot;je&quot; % &quot;4.0.92&quot;

  val apachenet   = &quot;commons-net&quot;   % &quot;commons-net&quot;   % &quot;2.0&quot;
  val apachecodec = &quot;commons-codec&quot; % &quot;commons-codec&quot; % &quot;1.4&quot;

  val scalatest = &quot;org.scalatest&quot; % &quot;scalatest_2.9.0&quot; % &quot;1.4.1&quot; % &quot;test&quot;
}

object CDAP2Build extends Build {
  import Resolvers._
  import Dependencies._
  import BuildSettings._

  // Sub-project specific dependencies
  val commonDeps = Seq (
    logbackcore,
    logbackclassic,
    jacksonjson,
    scalatest
  )

  val serverDeps = Seq (
    grizzlyframwork,
    grizzlyhttp,
    grizzlyrcm,
    grizzlyutils,
    grizzlyportunif,
    sleepycat,
    scalatest
  )

  val pricingDeps = Seq (apachenet, apachecodec, scalatest)

  lazy val cdap2 = Project (
    &quot;cdap2&quot;,
    file (&quot;.&quot;),
    settings = buildSettings
  ) aggregate (common, server, compact, pricing, pricing_service)

  lazy val common = Project (
    &quot;common&quot;,
    file (&quot;cdap2-common&quot;),
    settings = buildSettings ++ Seq (libraryDependencies ++= commonDeps)
  )

  lazy val server = Project (
    &quot;server&quot;,
    file (&quot;cdap2-server&quot;),
    settings = buildSettings ++ Seq (resolvers := oracleResolvers, 
                                     libraryDependencies ++= serverDeps)
  ) dependsOn (common)

  lazy val pricing = Project (
    &quot;pricing&quot;,
    file (&quot;cdap2-pricing&quot;),
    settings = buildSettings ++ Seq (libraryDependencies ++= pricingDeps)
  ) dependsOn (common, compact, server)

  lazy val pricing_service = Project (
    &quot;pricing-service&quot;,
    file (&quot;cdap2-pricing-service&quot;),
    settings = buildSettings
  ) dependsOn (pricing, server)

  lazy val compact = Project (
    &quot;compact&quot;,
    file (&quot;compact-hashmap&quot;),
    settings = buildSettings
  )
}
</code></pre><h3 id="External+Builds">External Builds<a href="#External+Builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><a href="http://gist.github.com/1021873">Mojolly Backchat Build</a>
</li><li><a href="https://github.com/scalaz/scalaz/blob/master/project/ScalazBuild.scala">Scalaz Build</a>
</li><li>Source Code Generation
</li><li>Generates Scaladoc and Scala X-Ray HTML Sources, with a unified view
of source from all sub-projects
</li><li>Builds an archive will the artifacts from all modules
</li><li>“Roll your own” approach to appending the Scala version to the
module id of dependencies to allow using snapshot releases of Scala.
</li></ul><h2 id="Advanced+configurations+example">Advanced configurations example<a href="#Advanced+configurations+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is an example <a href="../tutorial/Full-Def.html">.scala build definition</a>
that demonstrates using Ivy configurations to group dependencies.
</p><p>The <code>utils</code> module provides utilities for other modules. It uses Ivy
configurations to group dependencies so that a dependent project doesn’t
have to pull in all dependencies if it only uses a subset of
functionality. This can be an alternative to having multiple utilities
modules (and consequently, multiple utilities jars).
</p><p>In this example, consider a <code>utils</code> project that provides utilities
related to both Scalate and Saxon. It therefore needs both Scalate and
Saxon on the compilation classpath and a project that uses all of the
functionality of ‘utils’ will need these dependencies as well. However,
project <code>a</code> only needs the utilities related to Scalate, so it doesn’t
need Saxon. By depending only on the <code>scalate</code> configuration of <code>utils</code>,
it only gets the Scalate-related dependencies.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object B extends Build {
   /********** Projects ************/

   // An example project that only uses the Scalate utilities.
   lazy val a = Project(&quot;a&quot;, file(&quot;a&quot;)) dependsOn(utils % &quot;compile-&gt;scalate&quot;)

   // An example project that uses the Scalate and Saxon utilities.
   // For the configurations defined here, this is equivalent to doing dependsOn(utils),
   //  but if there were more configurations, it would select only the Scalate and Saxon
   //  dependencies.
   lazy val b = Project(&quot;b&quot;, file(&quot;b&quot;)) dependsOn(utils % &quot;compile-&gt;scalate,saxon&quot;)

   // Defines the utilities project
   lazy val utils = Project(&quot;utils&quot;, file(&quot;utils&quot;)) settings(utilsSettings : _*)

   def utilsSettings: Seq[Setting[_]] =
        // Add the src/common/scala/ compilation configuration.
      inConfig(Common)(Defaults.configSettings) ++
        // Publish the common artifact
      addArtifact(artifact in (Common, packageBin), packageBin in Common) ++ Seq(
        // We want our Common sources to have access to all of the dependencies on the classpaths
        //   for compile and test, but when depended on, it should only require dependencies in 'common'
      classpathConfiguration in Common := CustomCompile,
        // Modify the default Ivy configurations.
        //   'overrideConfigs' ensures that Compile is replaced by CustomCompile
      ivyConfigurations := overrideConfigs(Scalate, Saxon, Common, CustomCompile)(ivyConfigurations.value),
        // Put all dependencies without an explicit configuration into Common (optional)
      defaultConfiguration := Some(Common),
        // Declare dependencies in the appropriate configurations
      libraryDependencies ++= Seq(
         &quot;org.fusesource.scalate&quot; % &quot;scalate-core&quot; % &quot;1.5.0&quot; % &quot;scalate&quot;,
         &quot;org.squeryl&quot; %% &quot;squeryl&quot; % &quot;0.9.4&quot; % &quot;scalate&quot;,
         &quot;net.sf.saxon&quot; % &quot;saxon&quot; % &quot;8.7&quot; % &quot;saxon&quot;
      )
   )

   /********* Configurations *******/

   lazy val Scalate = config(&quot;scalate&quot;) extend(Common) describedAs(&quot;Dependencies for using Scalate utilities.&quot;)
   lazy val Common = config(&quot;common&quot;) describedAs(&quot;Dependencies required in all configurations.&quot;)
   lazy val Saxon = config(&quot;saxon&quot;) extend(Common) describedAs(&quot;Dependencies for using Saxon utilities.&quot;)

     // Define a customized compile configuration that includes
     //   dependencies defined in our other custom configurations
   lazy val CustomCompile = config(&quot;compile&quot;) extend(Saxon, Common, Scalate)
}
</code></pre><h2 id="Advanced+command+example">Advanced command example<a href="#Advanced+command+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is an advanced example showing some of the power of the new
settings system. It shows how to temporarily modify all declared
dependencies in the build, regardless of where they are defined. It
directly operates on the final <code>Seq[Setting[_]]</code> produced from every
setting involved in the build.
</p><p>The modifications are applied by running <em>canonicalize</em>. A <em>reload</em> or
using <em>set</em> reverts the modifications, requiring <em>canonicalize</em> to be
run again.
</p><p>This particular example shows how to transform all declared dependencies
on ScalaCheck to use version 1.8. As an exercise, you might try
transforming other dependencies, the repositories used, or the scalac
options used. It is possible to add or remove settings as well.
</p><p>This kind of transformation is possible directly on the settings of
Project, but it would not include settings automatically added from
plugins or build.sbt files. What this example shows is doing it
unconditionally on all settings in all projects in all builds, including
external builds.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object Canon extends Plugin {
  // Registers the canonicalize command in every project
  override def settings = Seq(commands += canonicalize)

  // Define the command.  This takes the existing settings (including any session settings)
  // and applies 'f' to each Setting[_]
  def canonicalize = Command.command(&quot;canonicalize&quot;) { (state: State) =&gt;
    val extracted = Project.extract(state)
    import extracted._
    val transformed = session.mergeSettings map ( s =&gt; f(s) )
    val newStructure = Load.reapply(transformed, structure)
    Project.setProject(session, newStructure, state)
  }

  // Transforms a Setting[_].
  def f(s: Setting[_]): Setting[_] = s.key.key match {
    // transform all settings that modify libraryDependencies
    case Keys.libraryDependencies.key =&gt;
      // hey scalac.  T == Seq[ModuleID]
      s.asInstanceOf[Setting[Seq[ModuleID]]].mapInit(mapLibraryDependencies)
      // preserve other settings
    case _ =&gt; s
  }
  // This must be idempotent because it gets applied after every transformation.
  // That is, if the user does:
  //  libraryDependencies += a
  //  libraryDependencies += b
  // then this method will be called for Seq(a) and Seq(a,b)
  def mapLibraryDependencies(key: ScopedKey[Seq[ModuleID]], value: Seq[ModuleID]): Seq[ModuleID] =
    value map mapSingle

  // This is the fundamental transformation.
  // Here we map all declared ScalaCheck dependencies to be version 1.8
  def mapSingle(module: ModuleID): ModuleID =
    if(module.name == &quot;scalacheck&quot;) module.copy(revision = &quot;1.8&quot;) 
    else module
}
</code></pre><h2 id="Detailed+Topics">Detailed Topics<a href="#Detailed+Topics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="../tutorial/index.html">Getting Started Guide</a> as
a foundation.
</p><p>Other resources include the
<a href="Howto.html">How to</a> and
<a href="Developers-Guide.html">Developer’s Guide</a>
sections in this reference, and the
<a href="../api/index.html">API Documentation</a>
</p><h2 id="Using+sbt">Using sbt<a href="#Using+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="../tutorial/index.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Command+Line+Reference">Command Line Reference<a href="#Command+Line+Reference" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page is a relatively complete list of command line options,
commands, and tasks you can use from the sbt interactive prompt or in
batch mode. See <a href="../tutorial/Running.html">Running</a> in the Getting
Started Guide for an intro to the basics, while this page has a lot more
detail.
</p><h3 id="Notes+on+the+command+line">Notes on the command line<a href="#Notes+on+the+command+line" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>There is a technical distinction in sbt between <em>tasks</em>, which are
“inside” the build definition, and <em>commands</em>, which manipulate the
build definition itself. If you’re interested in creating a command,
see <a href="Commands.html">Commands</a>. This specific sbt meaning of “command”
means there’s no good general term for “thing you can type at the
sbt prompt”, which may be a setting, task, or command.
</li><li>Some tasks produce useful values. The <code>toString</code> representation of
these values can be shown using <code>show &lt;task&gt;</code> to run the task
instead of just <code>&lt;task&gt;</code>.
</li><li>In a multi-project build, execution dependencies and the aggregate
setting control which tasks from which projects are executed. See
<a href="../tutorial/Multi-Project.html">multi-project builds</a>.
</li></ul><h3 id="Project-level+tasks">Project-level tasks<a href="#Project-level+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>clean</code> Deletes all generated files (the <code>target</code> directory).
</li><li><code>publishLocal</code> Publishes artifacts (such as jars) to the local Ivy
repository as described in Publishing.
</li><li><code>publish</code> Publishes artifacts (such as jars) to the repository
defined by the publishTo setting, described in Publishing.
</li><li><code>update</code> Resolves and retrieves external dependencies as described
in <a href="../tutorial/Library-Dependencies.html">library dependencies</a>.
</li></ul><h3 id="Configuration-level+tasks">Configuration-level tasks<a href="#Configuration-level+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Configuration-level tasks are tasks associated with a configuration. For
example, <code>compile</code>, which is equivalent to <code>compile:compile</code>, compiles
the main source code (the <code>compile</code> configuration). <code>test:compile</code>
compiles the test source code (test <code>test</code> configuration). Most tasks
for the <code>compile</code> configuration have an equivalent in the <code>test</code>
configuration that can be run using a <code>test:</code> prefix.
</p><ul><li><code>compile</code> Compiles the main sources (in the <code>src/main/scala</code>
directory). <code>test:compile</code> compiles test sources (in the
src/test/scala/ directory).
</li><li><code>console</code> Starts the Scala interpreter with a classpath including
the compiled sources, all jars in the lib directory, and managed
libraries. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z
(Windows). Similarly, test:console starts the interpreter with the
test classes and classpath.
</li><li><code>consoleQuick</code> Starts the Scala interpreter with the project’s
compile-time dependencies on the classpath. test:consoleQuick uses
the test dependencies. This task differs from console in that it
does not force compilation of the current project’s sources.
</li><li><code>consoleProject</code> Enters an interactive session with sbt and the
build definition on the classpath. The build definition and related
values are bound to variables and common packages and values are
imported. See the <a href="Console-Project.html">consoleProject documentation</a>
for more information.
</li><li><code>doc</code> Generates API documentation for Scala source files in
<code>src/main/scala</code> using scaladoc. <code>test:doc</code> generates API documentation
for source files in <code>src/test/scala</code>.
</li><li><code>package</code> Creates a jar file containing the files in
<code>src/main/resources</code> and the classes compiled from <code>src/main/scala</code>.
<code>test:package</code> creates a jar containing the files in
<code>src/test/resources</code> and the class compiled from <code>src/test/scala</code>.
</li><li><code>packageDoc</code> Creates a jar file containing API documentation
generated from Scala source files in src/main/scala. test:packageDoc
creates a jar containing API documentation for test sources files in
src/test/scala.
</li><li><code>packageSrc</code>: Creates a jar file containing all main source files
and resources. The packaged paths are relative to src/main/scala and
src/main/resources. Similarly, test:packageSrc operates on test
source files and resources.
</li><li><code>run &lt;argument&gt;*</code> Runs the main class for the project in the same
virtual machine as sbt. The main class is passed the arguments
provided. Please see
<a href="Running-Project-Code.html">Running Project Code</a> for details on the use of
System.exit and multithreading (including GUIs) in code run by this
action. <code>test:run</code> runs a main class in the test code.
</li><li><code>runMain &lt;main-class&gt; &lt;argument&gt;*</code> Runs the specified main class for
the project in the same virtual machine as sbt. The main class is
passed the arguments provided. Please see
<a href="Running-Project-Code.html">Running Project Code</a> for
details on the use of System.exit and multithreading (including
GUIs) in code run by this action. <code>test:runMain</code> runs the specified
main class in the test code.
</li><li><code>test</code> Runs all tests detected during test compilation. See <a href="Testing.html">Testing</a>
for details.
</li><li><code>testOnly &lt;test&gt;*</code> Runs the tests provided as arguments. <code>*</code> (will
be) interpreted as a wildcard in the test name. See <a href="Testing.html">Testing</a> for
details.
</li><li><p><code>testQuick &lt;test&gt;*</code> Runs the tests specified as arguments (or all
tests if no arguments are given) that:
</p><ol><li>have not been run yet OR
</li><li>failed the last time they were run OR
</li><li>had any transitive dependencies recompiled since the last
successful run <code>*</code> (will be) interpreted as a wildcard in the
test name. See [Testing][Testing] for details.
</li></ol></li></ul><h3 id="General+commands">General commands<a href="#General+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>exit</code> or <code>quit</code> End the current interactive session or build.
Additionally, Ctrl+D (Unix) or Ctrl+Z (Windows) will exit the
interactive prompt.
</li><li><code>help &lt;command&gt;</code> Displays detailed help for the specified command.
If the command does not exist, help lists detailed help for commands
whose name or description match the argument, which is interpreted
as a regular expression. If no command is provided, displays brief
descriptions of the main commands. Related commands are tasks and
settings.
</li><li><code>projects [add|remove &lt;URI&gt;]</code> List all available projects if no
arguments provided or adds/removes the build at the provided URI.
(See <a href="../tutorial/Multi-Project.html">multi-project builds</a> for details on multi-project
builds.)
</li><li><code>project &lt;project-id&gt;</code> Change the current project to the project
with ID <code>&lt;project-id&gt;</code>. Further operations will be done in the
context of the given project. (See <a href="../tutorial/Multi-Project.html">multi-project builds</a> for
details on multiple project builds.)
</li><li><code>~ &lt;command&gt;</code> Executes the project specified action or method
whenever source files change. See
<a href="Triggered-Execution.html">Triggered Execution</a> for details.
</li><li><code>&lt; filename</code> Executes the commands in the given file. Each command
should be on its own line. Empty lines and lines beginning with ’#’
are ignored
</li><li><code>+ &lt;command&gt;</code> Executes the project specified action or method for
all versions of Scala defined in the crossScalaVersions setting.
</li><li><code>++ &lt;version|home-directory&gt; &lt;command&gt;</code> Temporarily changes the
version of Scala building the project and executes the provided
command. <code>&lt;command&gt;</code> is optional. The specified version of Scala is
used until the project is reloaded, settings are modified (such as
by the set or session commands), or ++ is run again. <code>&lt;version&gt;</code>
does not need to be listed in the build definition, but it must be
available in a repository. Alternatively, specify the path to a
Scala installation.
</li><li><code>; A ; B</code> Execute A and if it succeeds, run B. Note that the leading
semicolon is required.
</li><li><p><code>eval &lt;Scala-expression&gt;</code> Evaluates the given Scala expression and
returns the result and inferred type. This can be used to set system
properties, as a calculator, to fork processes, etc … For example:
</p><pre><code>&gt; eval System.setProperty(&quot;demo&quot;, &quot;true&quot;)
&gt; eval 1+1
&gt; eval &quot;ls -l&quot; !
</code></pre></li></ul><h3 id="Commands+for+managing+the+build+definition">Commands for managing the build definition<a href="#Commands+for+managing+the+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>reload [plugins|return]</code> If no argument is specified, reloads the
build, recompiling any build or plugin definitions as necessary.
reload plugins changes the current project to the build definition
project (in project/). This can be useful to directly manipulate the
build definition. For example, running clean on the build definition
project will force snapshots to be updated and the build definition
to be recompiled. reload return changes back to the main project.
</li><li><code>set &lt;setting-expression&gt;</code> Evaluates and applies the given setting
definition. The setting applies until sbt is restarted, the build is
reloaded, or the setting is overridden by another set command or
removed by the session command. See
[.sbt build definition][Basic-Def] and
[inspecting settings][Inspecting-Settings] for details.
</li><li><code>session &lt;command&gt;</code> Manages session settings defined by the <code>set</code>
command. It can persist settings configured at the prompt. See
Inspecting-Settings for details.
</li><li><code>inspect &lt;setting-key&gt;</code> Displays information about settings, such as
the value, description, defining scope, dependencies, delegation
chain, and related settings. See
<a href="Inspecting-Settings.html">Inspecting Settings</a> for details.
</li></ul><h3 id="Command+Line+Options">Command Line Options<a href="#Command+Line+Options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>System properties can be provided either as JVM options, or as SBT
arguments, in both cases as <code>-Dprop=value</code>. The following properties
influence SBT execution. Also see <a href="Sbt-Launcher.html">sbt launcher</a>.
</p><table>
  <tr>
    <th>Property</th>
    <th>Values</th>
    <th>Default</th>
    <th>Meaning</th>    
  </tr>

  <tr>
    <td><tt>sbt.log.noformat</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>If true, disable ANSI color
        codes. Useful on build servers
        or terminals that do not support
        color.</td>
  </tr>                

  <tr>
    <td><tt>sbt.global.base`</tt></td>
    <td>Directory</td>
    <td><tt>~/.sbt/0.13</tt></td>
    <td>The directory containing global settings and plugins</td>
  </tr>

  <tr>
    <td><tt>sbt.ivy.home</tt></td>
    <td>Directory</td>
    <td><tt>~/.ivy2</tt></td>
    <td>The directory containing the local Ivy repository and artifact cache</td>
  </tr>

  <tr>
    <td><tt>sbt.boot.directory</tt></td>
    <td>Directory</td>
    <td><tt>~/.sbt/boot</tt></td>
    <td>Path to shared boot directory</td>
  </tr>

  <tr>
    <td><tt>sbt.main.class</tt></td>
    <td>String</td>
    <td><tt></tt></td>
    <td></td>
  </tr>

  <tr>
    <td><tt>xsbt.inc.debug</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td></td>
  </tr>

  <tr>
    <td><tt>sbt.extraClasspath</tt></td>
    <td>Classpath Entries</td>
    <td><tt></tt></td>
    <td>(jar files or directories) that are added to sbt's classpath.
        Note that the entries are deliminted by comma, e.g.:
        <tt>entry1, entry2,..</tt>. See also <tt>resource</tt> in the
        <a href="Launcher.html">sbt launcher</a> documentation.
        </td>
  </tr>

  <tr>
    <td><tt>sbt.version</tt></td>
    <td>Version</td>
    <td><tt>0.13.5</tt></td>
    <td>sbt version to use, usually taken from <tt>project/build.properties</tt>.</td>
  </tr>

  <tr>
    <td><tt>sbt.boot.properties</tt></td>
    <td>File</td>
    <td><tt></tt></td>
    <td>The path to find the sbt  boot properties file. This can be a
        relative path, relative to the sbt base directory, the users
        home directory or the location of the sbt jar file, or it can
        be an absolute path or an absolute file URI.</td>
  </tr>

  <tr>
    <td><tt>sbt.override.build.repos</tt></td>
    <td>Boolean</td>
    <td><tt>false</tt></td>
    <td>If true, repositories configured in a build definition
        are ignored and the repositories configured for the launcher are
        used instead. See <tt>sbt.repository.config</tt> and the
        <a href="Launcher.html">sbt launcher</a> documentation.</td>
  </tr>

  <tr>
    <td><tt>sbt.repository.config</tt></td>
    <td>File</td>
    <td><tt>~/.sbt/repositories</tt></td>
    <td>A file containing the repositories to use for the
        launcher. The format is the same as a
        <tt>[repositories]</tt> section for a
        <a href="Launcher.html">sbt launcher</a> configuration file.
        This setting is typically used in conjuction with setting
        <tt>sbt.override.build.repos</tt> to
        <tt>true</tt> (see previous row and the
        <a href="Launcher.html">sbt launcher</a> documentation).</td>
  </tr>
</table><h2 id="Console+Project">Console Project<a href="#Console+Project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Description">Description<a href="#Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>consoleProject</code> task starts the Scala interpreter with access to
your project definition and to <code>sbt</code>. Specifically, the interpreter is
started up with these commands already executed:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Process._
import Keys._
import &lt;your-project-definition&gt;._
import currentState._
import extracted._
import cpHelpers._
</code></pre><p>For example, running external processes with sbt’s process library (to
be included in the standard library in Scala 2.9):
</p><pre><code class="">&gt; &quot;tar -zcvf project-src.tar.gz src&quot; !
&gt; &quot;find project -name *.jar&quot; !
&gt; &quot;cat build.sbt&quot; #| &quot;grep version&quot; #&gt; new File(&quot;sbt-version&quot;) !
&gt; &quot;grep -r null src&quot; #|| &quot;echo null-free&quot; !
&gt; uri(&quot;http://databinder.net/dispatch/About&quot;).toURL #&gt; file(&quot;About.html&quot;) !
</code></pre><p><code>consoleProject</code> can be useful for creating and modifying your build in
the same way that the Scala interpreter is normally used to explore
writing code. Note that this gives you raw access to your build. Think
about what you pass to <code>IO.delete</code>, for example.
</p><h3 id="Accessing+settings">Accessing settings<a href="#Accessing+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To get a particular setting, use the form:
</p><pre><code class="prettyprint lang-scala">&gt; val value = (&lt;key&gt; in &lt;scope&gt;).eval
</code></pre><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">&gt; IO.delete( (classesDirectory in Compile).eval )
</code></pre><p>Show current compile options:
</p><pre><code class="prettyprint lang-scala">&gt; (scalacOptions in Compile).eval foreach println
</code></pre><p>Show additionally configured repositories.
</p><pre><code class="prettyprint lang-scala">&gt; resolvers.eval foreach println
</code></pre><h3 id="Evaluating+tasks">Evaluating tasks<a href="#Evaluating+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To evaluate a task (and its dependencies), use the same form:
</p><pre><code class="prettyprint lang-scala">&gt; val value = (&lt;key&gt; in &lt;scope&gt;).eval
</code></pre><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Show all repositories, including defaults.
</p><pre><code class="prettyprint lang-scala">&gt; fullResolvers.eval foreach println
</code></pre><p>Show the classpaths used for compilation and testing:
</p><pre><code class="prettyprint lang-scala">&gt; (fullClasspath in Compile).eval.files foreach println
&gt; (fullClasspath in Test).eval.files foreach println
</code></pre><h3 id="State">State<a href="#State" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The current <a href="Build-State.html">build State</a> is available as
<code>currentState</code>. The contents of <code>currentState</code> are imported by default
and can be used without qualification.
</p><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Show the remaining commands to be executed in the build (more
interesting if you invoke <code>consoleProject</code> like
<code>; consoleProject ; clean ; compile</code>):
</p><pre><code class="prettyprint lang-scala">&gt; remainingCommands
</code></pre><p>Show the number of currently registered commands:
</p><pre><code class="prettyprint lang-scala">&gt; definedCommands.size
</code></pre><h2 id="Cross-building">Cross-building<a href="#Cross-building" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Different versions of Scala can be binary incompatible, despite
maintaining source compatibility. This page describes how to use <code>sbt</code>
to build and publish your project against multiple versions of Scala and
how to use libraries that have done the same.
</p><h3 id="Publishing+Conventions">Publishing Conventions<a href="#Publishing+Conventions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The underlying mechanism used to indicate which version of Scala a
library was compiled against is to append <code>_&lt;scala-version&gt;</code> to the
library’s name. For Scala 2.10.0 and later, the binary version is used.
For example, <code>dispatch</code> becomes <code>dispatch_2.8.1</code> for the variant
compiled against Scala 2.8.1 and <code>dispatch_2.10</code> when compiled against
2.10.0, 2.10.0-M1 or any 2.10.x version. This fairly simple approach
allows interoperability with users of Maven, Ant and other build tools.
</p><p>The rest of this page describes how <code>sbt</code> handles this for you as part
of cross-building.
</p><h3 id="Using+Cross-Built+Libraries">Using Cross-Built Libraries<a href="#Using+Cross-Built+Libraries" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To use a library built against multiple versions of Scala, double the
first <code>%</code> in an inline dependency to be <code>%%</code>. This tells <code>sbt</code> that it
should append the current version of Scala being used to build the
library to the dependency’s name. For example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;net.databinder&quot; %% &quot;dispatch&quot; % &quot;0.8.0&quot;
</code></pre><p>A nearly equivalent, manual alternative for a fixed version of Scala is:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;net.databinder&quot; % &quot;dispatch_2.10&quot; % &quot;0.8.0&quot;
</code></pre><p>or for Scala versions before 2.10:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;net.databinder&quot; % &quot;dispatch_2.8.1&quot; % &quot;0.8.0&quot;
</code></pre><h3 id="Cross-Building+a+Project">Cross-Building a Project<a href="#Cross-Building+a+Project" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Define the versions of Scala to build against in the
<code>crossScalaVersions</code> setting. Versions of Scala 2.8.0 or later are
allowed. For example, in a <code>.sbt</code> build definition:
</p><pre><code class="prettyprint lang-scala">crossScalaVersions := Seq(&quot;2.8.2&quot;, &quot;2.9.2&quot;, &quot;2.10.0&quot;)
</code></pre><p>To build against all versions listed in <code>build.scala.versions</code>, prefix
the action to run with <code>+</code>. For example:
</p><pre><code class="">&gt; + package
</code></pre><p>A typical way to use this feature is to do development on a single Scala
version (no <code>+</code> prefix) and then cross-build (using <code>+</code>) occasionally
and when releasing. The ultimate purpose of <code>+</code> is to cross-publish your
project. That is, by doing:
</p><pre><code class="">&gt; + publish
</code></pre><p>you make your project available to users for different versions of
Scala. See <a href="Publishing.html">Publishing</a> for more details on publishing your project.
</p><p>In order to make this process as quick as possible, different output and
managed dependency directories are used for different versions of Scala.
For example, when building against Scala 2.10.0,
</p><ul><li><code>./target/</code> becomes <code>./target/scala_2.1.0/</code>
</li><li><code>./lib_managed/</code> becomes <code>./lib_managed/scala_2.10/</code>
</li></ul><p>Packaged jars, wars, and other artifacts have <code>_&lt;scala-version&gt;</code>
appended to the normal artifact ID as mentioned in the Publishing
Conventions section above.
</p><p>This means that the outputs of each build against each version of Scala
are independent of the others. <code>sbt</code> will resolve your dependencies for
each version separately. This way, for example, you get the version of
Dispatch compiled against 2.8.1 for your 2.8.1 build, the version
compiled against 2.10 for your 2.10.x builds, and so on. You can have
fine-grained control over the behavior for for different Scala versions
by using the <code>cross</code> method on <code>ModuleID</code> These are equivalent:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot;
&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot; cross CrossVersion.Disabled
</code></pre><p>These are equivalent:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; %% &quot;b&quot; % &quot;1.0&quot;
&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot; cross CrossVersion.binary
</code></pre><p>This overrides the defaults to always use the full Scala version instead
of the binary Scala version:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot; cross CrossVersion.full
</code></pre><p>This uses a custom function to determine the Scala version to use based
on the binary Scala version:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot; cross CrossVersion.binaryMapped {
  case &quot;2.9.1&quot; =&gt; &quot;2.9.0&quot; // remember that pre-2.10, binary=full
  case &quot;2.10&quot; =&gt; &quot;2.10.0&quot; // useful if a%b was released with the old style
  case x =&gt; x
}
</code></pre><p>This uses a custom function to determine the Scala version to use based
on the full Scala version:
</p><pre><code class="prettyprint lang-scala">&quot;a&quot; % &quot;b&quot; % &quot;1.0&quot; cross CrossVersion.fullMapped {
  case &quot;2.9.1&quot; =&gt; &quot;2.9.0&quot;
  case x =&gt; x
}
</code></pre><p>A custom function is mainly used when cross-building and a dependency
isn’t available for all Scala versions or it uses a different convention
than the default.
</p><p>As a final note, you can use <code>++ &lt;version&gt;</code> to temporarily switch the
Scala version currently being used to build. <code>&lt;version&gt;</code> should be
either a version for Scala published to a repository, as in <code>++ 2.10.0</code>
or the path to a Scala home directory, as in <code>++ /path/to/scala/home</code>.
See <a href="Command-Line-Reference.html">Command Line Reference</a> for details.
</p><h2 id="Interacting+with+the+Configuration+System">Interacting with the Configuration System<a href="#Interacting+with+the+Configuration+System" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Central to sbt is the new configuration system, which is designed to
enable extensive customization. The goal of this page is to explain the
general model behind the configuration system and how to work with it.
The Getting Started Guide (see
<a href="../tutorial/Basic-Def.html">.sbt files</a>) describes how to define
settings; this page describes interacting with them and exploring them
at the command line.
</p><h3 id="Selecting+commands%2C+tasks%2C+and+settings">Selecting commands, tasks, and settings<a href="#Selecting+commands%2C+tasks%2C+and+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A fully-qualified reference to a setting or task looks like:
</p><pre><code class="">{&lt;build-uri&gt;}&lt;project-id&gt;/config:inkey::key
</code></pre><p>This “scoped key” reference is used by commands like <code>last</code> and
<code>inspect</code> and when selecting a task to run. Only <code>key</code> is usually
required by the parser; the remaining optional pieces select the scope.
These optional pieces are individually referred to as scope axes. In the
above description, <code>{&lt;build-uri&gt;}</code> and <code>&lt;project-id&gt;/</code> specify the
project axis, <code>config:</code> is the configuration axis, and <code>inkey</code> is the
task-specific axis. Unspecified components are taken to be the current
project (project axis) or auto-detected (configuration and task axes).
An asterisk (<code>*</code>) is used to explicitly refer to the <code>Global</code> context,
as in <code>*/*:key</code>.
</p><h4 id="Selecting+the+configuration">Selecting the configuration<a href="#Selecting+the+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In the case of an unspecified configuration (that is, when the <code>config:</code>
part is omitted), if the key is defined in <code>Global</code>, that is selected.
Otherwise, the first configuration defining the key is selected, where
order is determined by the project definition’s <code>configurations</code> member.
By default, this ordering is <code>compile, test, ...</code>
</p><p>For example, the following are equivalent when run in a project <code>root</code>
in the build in <code>/home/user/sample/</code>:
</p><pre><code class="">&gt; compile
&gt; compile:compile
&gt; root/compile
&gt; root/compile:compile
&gt; {file:/home/user/sample/}root/compile:compile
</code></pre><p>As another example, <code>run</code> by itself refers to <code>compile:run</code> because
there is no global <code>run</code> task and the first configuration searched,
<code>compile</code>, defines a <code>run</code>. Therefore, to reference the <code>run</code> task for
the <code>Test</code> configuration, the configuration axis must be specified like
<code>test:run</code>. Some other examples that require the explicit <code>test:</code> axis:
</p><pre><code class="">&gt; test:consoleQuick
&gt; test:console
&gt; test:doc
&gt; test:package
</code></pre><h4 id="Task-specific+Settings">Task-specific Settings<a href="#Task-specific+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Some settings are defined per-task. This is used when there are several
related tasks, such as <code>package</code>, <code>packageSrc</code>, and <code>packageDoc</code>, in the
same configuration (such as <code>compile</code> or <code>test</code>). For package tasks,
their settings are the files to package, the options to use, and the
output file to produce. Each package task should be able to have
different values for these settings.
</p><p>This is done with the task axis, which selects the task to apply a
setting to. For example, the following prints the output jar for the
different package tasks.
</p><pre><code class="">&gt; package::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/demo_2.8.1-0.1.jar

&gt; packageSrc::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/demo_2.8.1-0.1-src.jar

&gt; packageDoc::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/demo_2.8.1-0.1-doc.jar

&gt; test:package::artifactPath
[info] /home/user/sample/target/scala-2.8.1.final/root_2.8.1-0.1-test.jar
</code></pre><p>Note that a single colon <code>:</code> follows a configuration axis and a double
colon <code>::</code> follows a task axis.
</p><h3 id="Discovering+Settings+and+Tasks">Discovering Settings and Tasks<a href="#Discovering+Settings+and+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This section discusses the <code>inspect</code> command, which is useful for
exploring relationships between settings. It can be used to determine
which setting should be modified in order to affect another setting, for
example.
</p><h4 id="Value+and+Provided+By">Value and Provided By<a href="#Value+and+Provided+By" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first piece of information provided by <code>inspect</code> is the type of a
task or the value and type of a setting. The following section of output
is labeled “Provided by”. This shows the actual scope where the setting
is defined. For example,
</p><pre><code class="">&gt; inspect libraryDependencies
[info] Setting: scala.collection.Seq[sbt.ModuleID] = List(org.scalaz:scalaz-core:6.0-SNAPSHOT, org.scala-tools.testing:scalacheck:1.8:test)
[info] Provided by:
[info]  {file:/home/user/sample/}root/*:libraryDependencies
...
</code></pre><p>This shows that <code>libraryDependencies</code> has been defined on the current
project (<code>{file:/home/user/sample/}root</code>) in the global configuration
(<code>*:</code>). For a task like <code>update</code>, the output looks like:
</p><pre><code class="">&gt; inspect update
[info] Task: sbt.UpdateReport
[info] Provided by:
[info]  {file:/home/user/sample/}root/*:update
...
</code></pre><h4 id="Related+Settings">Related Settings<a href="#Related+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The “Related” section of <code>inspect</code> output lists all of the definitions
of a key. For example,
</p><pre><code class="">&gt; inspect compile
...
[info] Related:
[info]  test:compile
</code></pre><p>This shows that in addition to the requested <code>compile:compile</code> task,
there is also a <code>test:compile</code> task.
</p><h4 id="Dependencies">Dependencies<a href="#Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Forward dependencies show the other settings (or tasks) used to define a
setting (or task). Reverse dependencies go the other direction, showing
what uses a given setting. <code>inspect</code> provides this information based on
either the requested dependencies or the actual dependencies. Requested
dependencies are those that a setting directly specifies. Actual
settings are what those dependencies get resolved to. This distinction
is explained in more detail in the following sections.
</p><h5 id="Requested+Dependencies">Requested Dependencies<a href="#Requested+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>As an example, we’ll look at <code>console</code>:
</p><pre><code class="">&gt; inspect console
...
[info] Dependencies:
[info]  compile:console::fullClasspath
[info]  compile:console::scalacOptions
[info]  compile:console::initialCommands
[info]  compile:console::cleanupCommands
[info]  compile:console::compilers
[info]  compile:console::taskTemporary-directory
[info]  compile:console::scalaInstance
[info]  compile:console::streams

...
</code></pre><p>This shows the inputs to the <code>console</code> task. We can see that it gets its
classpath and options from <code>fullClasspath</code> and
<code>scalacOptions(for console)</code>. The information provided by the <code>inspect</code>
command can thus assist in finding the right setting to change. The
convention for keys, like <code>console</code> and <code>fullClasspath</code>, is that the
Scala identifier is camel case, while the String representation is
lowercase and separated by dashes. The Scala identifier for a
configuration is uppercase to distinguish it from tasks like <code>compile</code>
and <code>test</code>. For example, we can infer from the previous example how to
add code to be run when the Scala interpreter starts up:
</p><pre><code class="">&gt; set initialCommands in Compile in console := &quot;import mypackage._&quot;
&gt; console
...
import mypackage._
...
</code></pre><p><code>inspect</code> showed that <code>console</code> used the setting
<code>compile:console::initialCommands</code>. Translating the <code>initialCommands</code>
string to the Scala identifier gives us <code>initialCommands</code>. <code>compile</code>
indicates that this is for the main sources. <code>console::</code> indicates that
the setting is specific to <code>console</code>. Because of this, we can set the
initial commands on the <code>console</code> task without affecting the
<code>consoleQuick</code> task, for example.
</p><h5 id="Actual+Dependencies">Actual Dependencies<a href="#Actual+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>inspect actual &lt;scoped-key&gt;</code> shows the actual dependency used. This is
useful because delegation means that the dependency can come from a
scope other than the requested one. Using <code>inspect actual</code>, we see
exactly which scope is providing a value for a setting. Combining
<code>inspect actual</code> with plain <code>inspect</code>, we can see the range of scopes
that will affect a setting. Returning to the example in Requested
Dependencies,
</p><pre><code class="">&gt; inspect actual console
...
[info] Dependencies:
[info]  compile:scalacOptions
[info]  compile:fullClasspath
[info]  *:scalaInstance
[info]  */*:initialCommands
[info]  */*:cleanupCommands
[info]  */*:taskTemporaryDirectory
[info]  *:console::compilers
[info]  compile:console::streams
...
</code></pre><p>For <code>initialCommands</code>, we see that it comes from the global scope
(<code>*/*:</code>). Combining this with the relevant output from
<code>inspect console</code>:
</p><pre><code class="">compile:console::initialCommands
</code></pre><p>we know that we can set <code>initialCommands</code> as generally as the global
scope, as specific as the current project’s <code>console</code> task scope, or
anything in between. This means that we can, for example, set
<code>initialCommands</code> for the whole project and will affect <code>console</code>:
</p><pre><code class="">&gt; set initialCommands := &quot;import mypackage._&quot;
...
</code></pre><p>The reason we might want to set it here this is that other console tasks
will use this value now. We can see which ones use our new setting by
looking at the reverse dependencies output of <code>inspect actual</code>:
</p><pre><code class="">&gt; inspect actual initialCommands
...
[info] Reverse dependencies:
[info]  test:console
[info]  compile:consoleQuick
[info]  compile:console
[info]  test:consoleQuick
[info]  *:consoleProject
...
</code></pre><p>We now know that by setting <code>initialCommands</code> on the whole project, we
affect all console tasks in all configurations in that project. If we
didn’t want the initial commands to apply for <code>consoleProject</code>, which
doesn’t have our project’s classpath available, we could use the more
specific task axis:
</p><pre><code class="">&gt; set initialCommands in console := &quot;import mypackage._&quot;
&gt; set initialCommands in consoleQuick := &quot;import mypackage._&quot;`
</code></pre><p>or configuration axis:
</p><pre><code class="">&gt; set initialCommands in Compile := &quot;import mypackage._&quot;
&gt; set initialCommands in Test := &quot;import mypackage._&quot;
</code></pre><p>The next part describes the Delegates section, which shows the chain of
delegation for scopes.
</p><h4 id="Delegates">Delegates<a href="#Delegates" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A setting has a key and a scope. A request for a key in a scope A may be
delegated to another scope if A doesn’t define a value for the key. The
delegation chain is well-defined and is displayed in the Delegates
section of the <code>inspect</code> command. The Delegates section shows the order
in which scopes are searched when a value is not defined for the
requested key.
</p><p>As an example, consider the initial commands for <code>console</code> again:
</p><pre><code class="">&gt; inspect console::initialCommands
...
[info] Delegates:
[info]  *:console::initialCommands
[info]  *:initialCommands
[info]  {.}/*:console::initialCommands
[info]  {.}/*:initialCommands
[info]  */*:console::initialCommands
[info]  */*:initialCommands
...
</code></pre><p>This means that if there is no value specifically for
<code>*:console::initialCommands</code>, the scopes listed under Delegates will be
searched in order until a defined value is found.
</p><h2 id="Triggered+Execution">Triggered Execution<a href="#Triggered+Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>You can make a command run when certain files change by prefixing the
command with <code>~</code>. Monitoring is terminated when <code>enter</code> is pressed. This
triggered execution is configured by the <code>watch</code> setting, but typically
the basic settings <code>watchSources</code> and <code>pollInterval</code> are modified.
</p><ul><li><code>watchSources</code> defines the files for a single project that are
monitored for changes. By default, a project watches resources and
Scala and Java sources.
</li><li><code>watchTransitiveSources</code> then combines the <code>watchSources</code> for the
current project and all execution and classpath dependencies (see
<a href="../tutorial/Full-Def.html">.scala build definition</a> for details on
interProject dependencies).
</li><li><code>pollInterval</code> selects the interval between polling for changes in
milliseconds. The default value is 500 ms.
</li></ul><p>Some example usages are described below.
</p><h3 id="Compile">Compile<a href="#Compile" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The original use-case was continuous compilation:
</p><pre><code class="">&gt; ~ test:compile

&gt; ~ compile
</code></pre><h3 id="Testing">Testing<a href="#Testing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can use the triggered execution feature to run any command or task.
One use is for test driven development, as suggested by Erick on the
mailing list.
</p><p>The following will poll for changes to your source code (main or test)
and run <code>testOnly</code> for the specified test.
</p><pre><code class="">&gt; ~ testOnly example.TestA
</code></pre><h3 id="Running+Multiple+Commands">Running Multiple Commands<a href="#Running+Multiple+Commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Occasionally, you may need to trigger the execution of multiple
commands. You can use semicolons to separate the commands to be
triggered.
</p><p>The following will poll for source changes and run <code>clean</code> and <code>test</code>.
</p><pre><code class="">&gt; ~ ;clean ;test
</code></pre><h2 id="Scripts%2C+REPL%2C+and+Dependencies">Scripts, REPL, and Dependencies<a href="#Scripts%2C+REPL%2C+and+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt has two alternative entry points that may be used to:
</p><ul><li>Compile and execute a Scala script containing dependency
declarations or other sbt settings
</li><li>Start up the Scala REPL, defining the dependencies that should be on
the classpath
</li></ul><p>These entry points should be considered experimental. A notable
disadvantage of these approaches is the startup time involved.
</p><h3 id="Setup">Setup<a href="#Setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To set up these entry points, you can either use
<a href="https://github.com/n8han/conscript">conscript</a> or manually construct
the startup scripts. In addition, there is a
<a href="https://github.com/paulp/xsbtscript">setup script</a> for the script
mode that only requires a JRE installed.
</p><h4 id="Setup+with+Conscript">Setup with Conscript<a href="#Setup+with+Conscript" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Install <a href="https://github.com/n8han/conscript">conscript</a>.
</p><pre><code class="">$ cs sbt/sbt --branch 0.12.0
</code></pre><p>This will create two scripts: <code>screpl</code> and <code>scalas</code>.
</p><h4 id="Manual+Setup">Manual Setup<a href="#Manual+Setup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Duplicate your standard <code>sbt</code> script, which was set up according to
<a href="../tutorial/Setup.html">Setup</a>, as <code>scalas</code> and <code>screpl</code> (or whatever
names you like).
</p><p><code>scalas</code> is the script runner and should use <code>sbt.ScriptMain</code> as the
main class, by adding the <code>-Dsbt.main.class=sbt.ScriptMain</code> parameter to
the <code>java</code> command. Its command line should look like:
</p><pre><code class="">$ java -Dsbt.main.class=sbt.ScriptMain -Dsbt.boot.directory=/home/user/.sbt/boot -jar sbt-launch.jar &quot;$@&quot;
</code></pre><p>For the REPL runner <code>screpl</code>, use <code>sbt.ConsoleMain</code> as the main class:
</p><pre><code class="">$ java -Dsbt.main.class=sbt.ConsoleMain -Dsbt.boot.directory=/home/user/.sbt/boot -jar sbt-launch.jar &quot;$@&quot;
</code></pre><p>In each case, <code>/home/user/.sbt/boot</code> should be replaced with wherever
you want sbt’s boot directory to be; you might also need to give more
memory to the JVM via <code>-Xms512M -Xmx1536M</code> or similar options, just like
shown in <a href="../tutorial/Setup.html">Setup</a>.
</p><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="sbt+Script+runner">sbt Script runner<a href="#sbt+Script+runner" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The script runner can run a standard Scala script, but with the
additional ability to configure sbt. sbt settings may be embedded in the
script in a comment block that opens with <code>/***</code>.
</p><h5 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Copy the following script and make it executable. You may need to adjust
the first line depending on your script name and operating system. When
run, the example should retrieve Scala, the required dependencies,
compile the script, and run it directly. For example, if you name it
<code>dispatch_example.scala</code>, you would do on Unix:
</p><pre><code class="">chmod u+x dispatch_example.scala
./dispatch_example.scala
</code></pre><nbsp>
<pre><code class="prettyprint lang-scala">#!/usr/bin/env scalas
!#

/***
scalaVersion := &quot;2.9.0-1&quot;

libraryDependencies ++= Seq(
  &quot;net.databinder&quot; %% &quot;dispatch-twitter&quot; % &quot;0.8.3&quot;,
  &quot;net.databinder&quot; %% &quot;dispatch-http&quot; % &quot;0.8.3&quot;
)
*/

import dispatch.{ json, Http, Request }
import dispatch.twitter.Search
import json.{ Js, JsObject }

def process(param: JsObject) = {
  val Search.text(txt)        = param
  val Search.from_user(usr)   = param
  val Search.created_at(time) = param

  &quot;(&quot; + time + &quot;)&quot; + usr + &quot;: &quot; + txt
}

Http.x((Search(&quot;#scala&quot;) lang &quot;en&quot;) ~&gt; (_ map process foreach println))
</code></pre><h4 id="sbt+REPL+with+dependencies">sbt REPL with dependencies<a href="#sbt+REPL+with+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The arguments to the REPL mode configure the dependencies to use when
starting up the REPL. An argument may be either a jar to include on the
classpath, a dependency definition to retrieve and put on the classpath,
or a resolver to use when retrieving dependencies.
</p><p>A dependency definition looks like:
</p><pre><code class="">organization%module%revision
</code></pre><p>Or, for a cross-built dependency:
</p><pre><code class="">organization%%module%revision
</code></pre><p>A repository argument looks like:
</p><pre><code class="">&quot;id at url&quot;
</code></pre><h5 id="Example%3A">Example:<a href="#Example%3A" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>To add the Sonatype snapshots repository and add Scalaz 7.0-SNAPSHOT to
REPL classpath:
</p><pre><code class="">$ screpl &quot;sonatype-releases at https://oss.sonatype.org/content/repositories/snapshots/&quot; &quot;org.scalaz%%scalaz-core%7.0-SNAPSHOT&quot;
</code></pre><p>This syntax was a quick hack. Feel free to improve it. The relevant
class is <a href="../sxr/sbt/IvyConsole.scala.html">IvyConsole</a>.
</p><h2 id="Understanding+Incremental+Recompilation">Understanding Incremental Recompilation<a href="#Understanding+Incremental+Recompilation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Compiling Scala code is slow, and sbt makes it often faster. By
understanding how, you can even understand how to make compilation even
faster. Modifying source files with many dependencies might require
recompiling only those source files—which might take, say, 5
seconds—instead of all the dependencies—which might take, say, 2
minutes. Often you can control which will be your case and make
development much faster by some simple coding practices.
</p><p>In fact, improving Scala compilation times is one major goal of sbt, and
conversely the speedups it gives are one of the major motivations to use
it. A significant portion of sbt sources and development efforts deals
with strategies for speeding up compilation.
</p><p>To reduce compile times, sbt uses two strategies:
</p><ol><li>reduce the overhead for restarting Scalac;
</li><li>implement smart and transparent strategies for incremental
recompilation, so that only modified files and the needed
dependencies are recompiled.
</li><li>sbt runs Scalac always in the same virtual machine. If one compiles
source code using sbt, keeps sbt alive, modifies source code and
triggers a new compilation, this compilation will be faster because
(part of) Scalac will have already been JIT-compiled. In the future,
sbt will reintroduce support for reusing the same compiler instance,
similarly to fsc.
</li><li>When a source file <code>A.scala</code> is modified, sbt goes to great effort
to recompile other source files depending on A.scala only if
required - that is, only if the interface of A.scala was modified.
With other build management tools (especially for Java, like ant),
when a developer changes a source file in a non-binary-compatible
way, he needs to manually ensure that dependencies are also
recompiled - often by manually running the clean command to remove
existing compilation output; otherwise compilation might succeed
even when dependent class files might need to be recompiled. What is
worse, the change to one source might make dependencies incorrect,
but this is not discovered automatically: One might get a
compilation success with incorrect source code. Since Scala compile
times are so high, running clean is particularly undesirable.
</li></ol><p>By organizing your source code appropriately, you can minimize the
amount of code affected by a change. sbt cannot determine precisely
which dependencies have to be recompiled; the goal is to compute a
conservative approximation, so that whenever a file must be recompiled,
it will, even though we might recompile extra files.
</p><h3 id="sbt+heuristics">sbt heuristics<a href="#sbt+heuristics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt tracks source dependencies at the granularity of source files. For
each source file, sbt tracks files which depend on it directly; if the
<strong>interface</strong> of classes, objects or traits in a file changes, all files
dependent on that source must be recompiled. At the moment sbt uses the
following algorithm to calculate source files dependent on a given
source file:
</p><ul><li>dependencies introduced through inheritance are included
</li></ul><p>   <em>transitively</em>; a dependency is introduced through inheritance if
   a class/trait in one file inherits from a trait/class in another file
-  all other direct dependencies are included; other dependencies are
   also called “meber reference” dependencies because they are
   introduced by referring to a member (class, method, type, etc.)
   defined in some other source file
</p><p>Here’s an example illustrating the definition above:
</p><pre><code class="prettyprint lang-scala">//A.scala
class A {
  def foo: Int = 123
}

//B.scala
class B extends A

//C.scala
class C extends B

//D.scala
class D(a: A)

//E.scala
class E(d: D)
</code></pre><p>There are the following dependencies through inheritance:
</p><pre><code class="">B.scala -&gt; A.scala
C.scala -&gt; B.scala
</code></pre><p>There are also the following member reference dependencies:
</p><pre><code class="">D.scala -&gt; A.scala
E.scala -&gt; D.scala
</code></pre><p>Now if the interface of <code>A.scala</code> is changed the following files will
get invalidated: <code>B.scala</code>, <code>C.scala</code>, <code>D.scala</code>. Both <code>B.scala</code> and
<code>C.scala</code> were included through transtive closure of inheritance
dependencies. The <code>E.scala</code> was not included because <code>E.scala</code> doesn’t
depend directly on <code>A.scala</code>.
</p><p>The distinction between depdencies by inheritance or member reference is
a new feature in sbt 0.13 and is responsible for improved recompilation
times in many cases where deep inheritance chains are not used
extensively.
</p><p>sbt does not instead track dependencies to source code at the
granularity of individual output <code>.class</code> files, as one might hope.
Doing so would be incorrect, because of some problems with sealed
classes (see below for discussion).
</p><p>Dependencies on binary files are different - they are tracked both on
the <code>.class</code> level and on the source file level. Adding a new
implementation of a sealed trait to source file <code>A</code> affects all clients
of that sealed trait, and such dependencies are tracked at the source
file level.
</p><p>Different sources are moreover recompiled together; hence a compile
error in one source implies that no bytecode is generated for any of
those. When a lot of files need to be recompiled and the compile fix is
not clear, it might be best to comment out the offending location (if
possible) to allow other sources to be compiled, and then try to figure
out how to fix the offending location—this way, trying out a possible
solution to the compile error will take less time, say 5 seconds instead
of 2 minutes.
</p><h3 id="What+is+included+in+the+interface+of+a+Scala+class">What is included in the interface of a Scala class<a href="#What+is+included+in+the+interface+of+a+Scala+class" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It is surprisingly tricky to understand which changes to a class require
recompiling its clients. The rules valid for Java are much simpler (even
if they include some subtle points as well); trying to apply them to
Scala will prove frustrating. Here is a list of a few surprising points,
just to illustrate the ideas; this list is not intended to be complete.
</p><ol><li>Since Scala supports named arguments in method invocations, the name
of method arguments are part of its interface.
</li><li>Adding a method to a trait requires recompiling all implementing
classes. The same is true for most changes to a method signature in
a trait.
</li><li>Calls to <code>super.methodName</code> in traits are resolved to calls to an
abstract method called <code>fullyQualifiedTraitName$$super$methodName</code>;
such methods only exist if they are used. Hence, adding the first
call to super.methodName for a specific methodName changes the
interface. At present, this is not yet handled—see gh-466.
</li><li><code>sealed</code> hierarchies of case classes allow to check exhaustiveness
of pattern matching. Hence pattern matches using case classes must
depend on the complete hierarchy - this is one reason why
dependencies cannot be easily tracked at the class level (see Scala
issue <a href="https://issues.scala-lang.org/browse/SI-2559">SI-2559</a> for an
example.)
</li></ol><h4 id="Debugging+an+interface+representation">Debugging an interface representation<a href="#Debugging+an+interface+representation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you see spurious incremental recompilations or you want understand
what changes to an extracted interface cause incremental recompilation
then sbt 0.13 has the right tools for that.
</p><p>In order to debug the interface representation and its changes as you
modify and recompile source code you need to do two things:
</p><blockquote><ol><li>Enable incremental compiler’s apiDebug option.
</li><li>Add <a href="https://code.google.com/p/java-diff-utils/">diff-utils
library</a> to sbt’s
classpath. Check documentation of sbt.extraClasspath system
property in the Command-Line-Reference.
</li></ol></blockquote><blockquote><p><strong>warning</strong>
</p><p>Enabling the <code>apiDebug</code> option increases significantly
:   memory consumption and degrades performance of the incremental
    compiler. The underlying reason is that in order to produce
    meaningful debugging information about interface differences
    incremental compiler has to retain the full representation of the
    interface instead of just hash sum as it does by default.
</p><p>Keep this option enabled when you are debugging incremental compiler
problem only.
</p></blockquote><p>Below is complete transcript which shows how to enable interface
debugging in your project. First, we download the <code>diffutils</code> jar and
pass it to sbt:
</p><pre><code class="prettyprint lang-">curl -O https://java-diff-utils.googlecode.com/files/diffutils-1.2.1.jar
sbt -Dsbt.extraClasspath=diffutils-1.2.1.jar
[info] Loading project definition from /Users/grek/tmp/sbt-013/project
[info] Set current project to sbt-013 (in build file:/Users/grek/tmp/sbt-013/)
&gt; set incOptions := incOptions.value.copy(apiDebug = true)
[info] Defining *:incOptions
[info] The new value will be used by compile:incCompileSetup, test:incCompileSetup
[info] Reapplying settings...
[info] Set current project to sbt-013 (in build file:/Users/grek/tmp/sbt-013/)
</code></pre><p>Let’s suppose you have the following source code in <code>Test.scala</code>:
</p><pre><code class="prettyprint lang-scala">class A {
  def b: Int = 123
}
</code></pre><p>compile it and then change the <code>Test.scala</code> file so it looks like:
</p><pre><code class="prettyprint lang-scala">class A {
   def b: String = &quot;abc&quot;
}
</code></pre><p>and run <code>compile</code> task again. Now if you run <code>last compile</code> you should
see the following lines in the debugging log
</p><pre><code class="prettyprint lang-">&gt; last compile
[...]
[debug] Detected a change in a public API:
[debug] --- /Users/grek/tmp/sbt-013/Test.scala
[debug] +++ /Users/grek/tmp/sbt-013/Test.scala
[debug] @@ -23,7 +23,7 @@
[debug]  ^inherited^ final def ##(): scala.this#Int
[debug]  ^inherited^ final def synchronized[ java.lang.Object.T0 &gt;: scala.this#Nothing &lt;: scala.this#Any](x$1: &lt;java.lang.Object.T0&gt;): &lt;java.lang.Object.T0&gt;
[debug]  ^inherited^ final def $isInstanceOf[ java.lang.Object.T0 &gt;: scala.this#Nothing &lt;: scala.this#Any](): scala.this#Boolean
[debug]  ^inherited^ final def $asInstanceOf[ java.lang.Object.T0 &gt;: scala.this#Nothing &lt;: scala.this#Any](): &lt;java.lang.Object.T0&gt;
[debug]  def &lt;init&gt;(): this#A
[debug] -def b: scala.this#Int
[debug] +def b: java.lang.this#String
[debug]  }
</code></pre><p>You can see an unified diff of two interface textual represetantions. As
you can see, the incremental compiler detected a change to the return
type of <code>b</code> method.
</p><h3 id="How+to+take+advantage+of+sbt+heuristics">How to take advantage of sbt heuristics<a href="#How+to+take+advantage+of+sbt+heuristics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The heuristics used by sbt imply the following user-visible
consequences, which determine whether a change to a class affects other
classes.
</p><p>XXX Please note that this part of the documentation is a first draft;
part of the strategy might be unsound, part of it might be not yet
implemented.
</p><ol><li>Adding, removing, modifying <code>private</code> methods does not require
recompilation of client classes. Therefore, suppose you add a method
to a class with a lot of dependencies, and that this method is only
used in the declaring class; marking it private will prevent
recompilation of clients. However, this only applies to methods
which are not accessible to other classes, hence methods marked with
private or private[this]; methods which are private to a package,
marked with private[name], are part of the API.
</li><li>Modifying the interface of a non-private method requires recompiling
all clients, even if the method is not used.
</li><li>Modifying one class does require recompiling dependencies of other
classes defined in the same file (unlike said in a previous version
of this guide). Hence separating different classes in different
source files might reduce recompilations.
</li><li>Adding a method which did not exist requires recompiling all
clients, counterintuitively, due to complex scenarios with implicit
conversions. Hence in some cases you might want to start
implementing a new method in a separate, new class, complete the
implementation, and then cut-n-paste the complete implementation
back into the original source.
</li><li>Changing the implementation of a method should <em>not</em> affect its
clients, unless the return type is inferred, and the new
implementation leads to a slightly different type being inferred.
Hence, annotating the return type of a non-private method
explicitly, if it is more general than the type actually returned,
can reduce the code to be recompiled when the implementation of such
a method changes. (Explicitly annotating return types of a public
API is a good practice in general.)
</li></ol><p>All the above discussion about methods also applies to fields and
members in general; similarly, references to classes also extend to
objects and traits.
</p><h4 id="Why+changing+the+implementation+of+a+method+might+affect+clients%2C+and+why+type+annotations+help">Why changing the implementation of a method might affect clients, and why type annotations help<a href="#Why+changing+the+implementation+of+a+method+might+affect+clients%2C+and+why+type+annotations+help" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This section explains why relying on type inference for return types of
public methods is not always appropriate. However this is an important
design issue, so we cannot give fixed rules. Moreover, this change is
often invasive, and reducing compilation times is not often a good
enough motivation. That is why we discuss also some of the implications
from the point of view of binary compatibility and software engineering.
</p><p>Consider the following source file <code>A.scala</code>:
</p><pre><code class="prettyprint lang-scala">import java.io._
object A {
  def openFiles(list: List[File]) = 
    list.map(name =&gt; new FileWriter(name))
}
</code></pre><p>Let us now consider the public interface of trait <code>A</code>. Note that the
return type of method <code>openFiles</code> is not specified explicitly, but
computed by type inference to be <code>List[FileWriter]</code>. Suppose that after
writing this source code, we introduce client code and then modify
<code>A.scala</code> as follows:
</p><pre><code class="prettyprint lang-scala">import java.io._
object A {
  def openFiles(list: List[File]) =
    Vector(list.map(name =&gt; new BufferedWriter(new FileWriter(name))): _*)
}
</code></pre><p>Type inference will now compute as result type <code>Vector[BufferedWriter]</code>;
in other words, changing the implementation lead to a change of the
public interface, with two undesirable consequences:
</p><ol><li>Concerning our topic, client code needs to be recompiled, since
changing the return type of a method, in the JVM, is a
binary-incompatible interface change.
</li><li>If our component is a released library, using our new version
requires recompiling all client code, changing the version number,
and so on. Often not good, if you distribute a library where binary
compatibility becomes an issue.
</li><li>More in general, client code might now even be invalid. The
following code will for instance become invalid after the change:
</li></ol><pre><code class="prettyprint lang-scala">val res: List[FileWriter] = A.openFiles(List(new File(&quot;foo.input&quot;)))
</code></pre><p>Also the following code will break:
</p><pre><code class="prettyprint lang-scala">val a: Seq[Writer] = new BufferedWriter(new FileWriter(&quot;bar.input&quot;))
A.openFiles(List(new File(&quot;foo.input&quot;)))
</code></pre><p>How can we avoid these problems?
</p><p>Of course, we cannot solve them in general: if we want to alter the
interface of a module, breakage might result. However, often we can
remove <em>implementation details</em> from the interface of a module. In the
example above, for instance, it might well be that the intended return
type is more general - namely <code>Seq[Writer]</code>. It might also not be the
case - this is a design choice to be decided on a case-by-case basis. In
this example I will assume however that the designer chooses
<code>Seq[Writer]</code>, since it is a reasonable choice both in the above
simplified example and in a real-world extension of the above code.
</p><p>The client snippets above will now become
</p><pre><code class="prettyprint lang-scala">val res: Seq[Writer] =
  A.openFiles(List(new File(&quot;foo.input&quot;)))

val a: Seq[Writer] =
  new BufferedWriter(new FileWriter(&quot;bar.input&quot;)) +:
  A.openFiles(List(new File(&quot;foo.input&quot;)))
</code></pre><p>XXX the rest of the section must be reintegrated or dropped: In general,
changing the return type of a method might be source-compatible, for
instance if the new type is more specific, or if it is less specific,
but still more specific than the type required by clients (note however
that making the type more specific might still invalidate clients in
non-trivial scenarios involving for instance type inference or implicit
conversions—for a more specific type, too many implicit conversions
might be available, leading to ambiguity); however, the bytecode for a
method call includes the return type of the invoked method, hence the
client code needs to be recompiled.
</p><p>Hence, adding explicit return types on classes with many dependencies
might reduce the occasions where client code needs to be recompiled.
Moreover, this is in general a good development practice when interface
between different modules become important—specifying such interface
documents the intended behavior and helps ensuring binary compatibility,
which is especially important when the exposed interface is used by
other software component.
</p><h4 id="Why+adding+a+member+requires+recompiling+existing+clients">Why adding a member requires recompiling existing clients<a href="#Why+adding+a+member+requires+recompiling+existing+clients" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In Java adding a member does not require recompiling existing valid
source code. The same should seemingly hold also in Scala, but this is
not the case: implicit conversions might enrich class <code>Foo</code> with method
<code>bar</code> without modifying class <code>Foo</code> itself (see discussion in issue
gh-288 - XXX integrate more). However, if another method <code>bar</code> is
introduced in class <code>Foo</code>, this method should be used in preference to
the one added through implicit conversions. Therefore any class
depending on <code>Foo</code> should be recompiled. One can imagine more
fine-grained tracking of dependencies, but this is currently not
implemented.
</p><h3 id="Further+references">Further references<a href="#Further+references" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The incremental compilation logic is implemented in
<a href="https://github.com/sbt/sbt/blob/0.13/compile/inc/src/main/scala/inc/Incremental.scala">https://github.com/sbt/sbt/blob/0.13/compile/inc/src/main/scala/inc/Incremental.scala</a>.
Some related documentation for sbt 0.7 is available at:
<a href="https://code.google.com/p/simple-build-tool/wiki/ChangeDetectionAndTesting">https://code.google.com/p/simple-build-tool/wiki/ChangeDetectionAndTesting</a>.
Some discussion on the incremental recompilation policies is available
in issue gh-322 and gh-288.
</p><h2 id="Configuration">Configuration<a href="#Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="../tutorial/index.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Classpaths%2C+sources%2C+and+resources">Classpaths, sources, and resources<a href="#Classpaths%2C+sources%2C+and+resources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page discusses how sbt builds up classpaths for different actions,
like <code>compile</code>, <code>run</code>, and <code>test</code> and how to override or augment these
classpaths.
</p><h3 id="Basics">Basics<a href="#Basics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In sbt 0.10 and later, classpaths now include the Scala library and
(when declared as a dependency) the Scala compiler. Classpath-related
settings and tasks typically provide a value of type <code>Classpath</code>. This
is an alias for <code>Seq[Attributed[File]]</code>.
<a href="../api/sbt/Attributed.html">Attributed</a> is a type that associates
a heterogeneous map with each classpath entry. Currently, this allows
sbt to associate the <code>Analysis</code> resulting from compilation with the
corresponding classpath entry and for managed entries, the <code>ModuleID</code>
and <code>Artifact</code> that defined the dependency.
</p><p>To explicitly extract the raw <code>Seq[File]</code>, use the <code>files</code> method
implicitly added to <code>Classpath</code>:
</p><pre><code class="prettyprint lang-scala">val cp: Classpath = ...
val raw: Seq[File] = cp.files
</code></pre><p>To create a <code>Classpath</code> from a <code>Seq[File]</code>, use <code>classpath</code> and to
create an <code>Attributed[File]</code> from a <code>File</code>, use <code>Attributed.blank</code>:
</p><pre><code class="prettyprint lang-scala">val raw: Seq[File] = ...
val cp: Classpath = raw.classpath

val rawFile: File = ..
val af: Attributed[File] = Attributed.blank(rawFile)
</code></pre><h4 id="Unmanaged+v.+managed">Unmanaged v. managed<a href="#Unmanaged+v.+managed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Classpaths, sources, and resources are separated into two main
categories: unmanaged and managed. Unmanaged files are manually created
files that are outside of the control of the build. They are the inputs
to the build. Managed files are under the control of the build. These
include generated sources and resources as well as resolved and
retrieved dependencies and compiled classes.
</p><p>Tasks that produce managed files should be inserted as follows:
</p><pre><code class="prettyprint lang-scala">sourceGenerators in Compile +=
    generate( (sourceManaged in Compile).value / &quot;some_directory&quot;)
</code></pre><p>In this example, <code>generate</code> is some function of type <code>File =&gt; Seq[File]</code>
that actually does the work. So, we are appending a new task to the list
of main source generators (<code>sourceGenerators in Compile</code>).
</p><p>To insert a named task, which is the better approach for plugins:
</p><pre><code class="prettyprint lang-scala">val mySourceGenerator = taskKey[Seq[File]](...)

mySourceGenerator in Compile :=
  generate( (sourceManaged in Compile).value / &quot;some_directory&quot;)

sourceGenerators in Compile += (mySourceGenerator in Compile).task
</code></pre><p>The <code>task</code> method is used to refer to the actual task instead of the
result of the task.
</p><p>For resources, there are similar keys <code>resourceGenerators</code> and
<code>resourceManaged</code>.
</p><h5 id="Excluding+source+files+by+name">Excluding source files by name<a href="#Excluding+source+files+by+name" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The project base directory is by default a source directory in addition
to <code>src/main/scala</code>. You can exclude source files by name
(<code>butler.scala</code> in the example below) like:
</p><pre><code class="prettyprint lang-scala">excludeFilter in unmanagedSources := &quot;butler.scala&quot; 
</code></pre><p>Read more on
<a href="http://groups.google.com/group/simple-build-tool/browse_thread/thread/cd5332a164405568?hl=en">How to exclude .scala source file in project folder - Google Groups</a>
</p><h4 id="External+v.+internal">External v. internal<a href="#External+v.+internal" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Classpaths are also divided into internal and external dependencies. The
internal dependencies are inter-project dependencies. These effectively
put the outputs of one project on the classpath of another project.
</p><p>External classpaths are the union of the unmanaged and managed
classpaths.
</p><h4 id="Keys">Keys<a href="#Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For classpaths, the relevant keys are:
</p><ul><li><code>unmanagedClasspath</code>
</li><li><code>managedClasspath</code>
</li><li><code>externalDependencyClasspath</code>
</li><li><code>internalDependencyClasspath</code>
</li></ul><p>For sources:
</p><ul><li><code>unmanagedSources</code> These are by default built up from
unmanagedSourceDirectories, which consists of scalaSource and
javaSource.
</li><li><code>managedSources</code> These are generated sources.
</li><li><code>sources</code> Combines <code>managedSources</code> and <code>unmanagedSources</code>.
</li><li><code>sourceGenerators</code> These are tasks that generate source files.
Typically, these tasks will put sources in the directory provided by
sourceManaged.
</li></ul><p>For resources
</p><ul><li><code>unmanagedResources</code> These are by default built up from
unmanagedResourceDirectories, which by default is resourceDirectory,
excluding files matched by defaultExcludes.
</li><li><code>managedResources</code> By default, this is empty for standard projects.
sbt plugins will have a generated descriptor file here.
</li><li><code>resourceGenerators</code> These are tasks that generate resource files.
Typically, these tasks will put resources in the directory provided
by resourceManaged.
</li></ul><p>Use the <a href="Inspecting-Settings.html">inspect command</a> for
more details.
</p><p>See also a related
<a href="http://stackoverflow.com/a/7862872/850196">StackOverflow answer</a>.
</p><h4 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>You have a standalone project which uses a library that loads
xxx.properties from classpath at run time. You put xxx.properties inside
directory “config”. When you run “sbt run”, you want the directory to be
in classpath.
</p><pre><code class="prettyprint lang-scala">unmanagedClasspath in Runtime += baseDirectory.value / &quot;config&quot;
</code></pre><h2 id="Compiler+Plugin+Support">Compiler Plugin Support<a href="#Compiler+Plugin+Support" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There is some special support for using compiler plugins. You can set
<code>autoCompilerPlugins</code> to <code>true</code> to enable this functionality.
</p><pre><code class="prettyprint lang-scala">autoCompilerPlugins := true
</code></pre><p>To use a compiler plugin, you either put it in your unmanaged library
directory (<code>lib/</code> by default) or add it as managed dependency in the
<code>plugin</code> configuration. <code>addCompilerPlugin</code> is a convenience method for
specifying <code>plugin</code> as the configuration for a dependency:
</p><pre><code class="prettyprint lang-scala">addCompilerPlugin(&quot;org.scala-tools.sxr&quot; %% &quot;sxr&quot; % &quot;0.3.0&quot;)
</code></pre><p>The <code>compile</code> and <code>testCompile</code> actions will use any compiler plugins
found in the <code>lib</code> directory or in the <code>plugin</code> configuration. You are
responsible for configuring the plugins as necessary. For example, Scala
X-Ray requires the extra option:
</p><pre><code class="prettyprint lang-scala">// declare the main Scala source directory as the base directory
scalacOptions :=
    scalacOptions.value :+ (&quot;-Psxr:base-directory:&quot; + (scalaSource in Compile).value.getAbsolutePath)
</code></pre><p>You can still specify compiler plugins manually. For example:
</p><pre><code class="prettyprint lang-scala">scalacOptions += &quot;-Xplugin:&lt;path-to-sxr&gt;/sxr-0.3.0.jar&quot;
</code></pre><h3 id="Continuations+Plugin+Example">Continuations Plugin Example<a href="#Continuations+Plugin+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Support for continuations in Scala 2.8 is implemented as a compiler
plugin. You can use the compiler plugin support for this, as shown here.
</p><pre><code class="prettyprint lang-scala">autoCompilerPlugins := true

addCompilerPlugin(&quot;org.scala-lang.plugins&quot; % &quot;continuations&quot; % &quot;2.8.1&quot;)

scalacOptions += &quot;-P:continuations:enable&quot;
</code></pre><h3 id="Version-specific+Compiler+Plugin+Example">Version-specific Compiler Plugin Example<a href="#Version-specific+Compiler+Plugin+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Adding a version-specific compiler plugin can be done as follows:
</p><pre><code class="prettyprint lang-scala">autoCompilerPlugins := true

libraryDependencies +=
    compilerPlugin(&quot;org.scala-lang.plugins&quot; % &quot;continuations&quot; % scalaVersion.value)

scalacOptions += &quot;-P:continuations:enable&quot;
</code></pre><h2 id="Configuring+Scala">Configuring Scala<a href="#Configuring+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt needs to obtain Scala for a project and it can do this automatically
or you can configure it explicitly. The Scala version that is configured
for a project will compile, run, document, and provide a REPL for the
project code. When compiling a project, sbt needs to run the Scala
compiler as well as provide the compiler with a classpath, which may
include several Scala jars, like the reflection jar.
</p><h3 id="Automatically+managed+Scala">Automatically managed Scala<a href="#Automatically+managed+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The most common case is when you want to use a version of Scala that is
available in a repository. The only required configuration is the Scala
version you want to use. For example,
</p><pre><code class="prettyprint lang-scala">scalaVersion := &quot;2.10.0&quot;
</code></pre><p>This will retrieve Scala from the repositories configured via the
<code>resolvers</code> setting. It will use this version for building your project:
compiling, running, scaladoc, and the REPL.
</p><h4 id="Configuring+the+scala-library+dependency">Configuring the scala-library dependency<a href="#Configuring+the+scala-library+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, the standard Scala library is automatically added as a
dependency. If you want to configure it differently than the default or
you have a project with only Java sources, set:
</p><pre><code class="prettyprint lang-scala">autoScalaLibrary := false
</code></pre><p>In order to compile Scala sources, the Scala library needs to be on the
classpath. When <code>autoScalaLibrary</code> is true, the Scala library will be on
all classpaths: test, runtime, and compile. Otherwise, you need to add
it like any other dependency. For example, the following dependency
definition uses Scala only for tests:
</p><pre><code class="prettyprint lang-scala">autoScalaLibrary := false

libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-library&quot; % scalaVersion.value % &quot;test&quot;
</code></pre><h4 id="Configuring+additional+Scala+dependencies">Configuring additional Scala dependencies<a href="#Configuring+additional+Scala+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When using a Scala dependency other than the standard library, add it as
a normal managed dependency. For example, to depend on the Scala
compiler,
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-compiler&quot; % scalaVersion.value
</code></pre><p>Note that this is necessary regardless of the value of the
<code>autoScalaLibrary</code> setting described in the previous section.
</p><h4 id="Configuring+Scala+tool+dependencies">Configuring Scala tool dependencies<a href="#Configuring+Scala+tool+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In order to compile Scala code, run scaladoc, and provide a Scala REPL,
sbt needs the <code>scala-compiler</code> jar. This should not be a normal
dependency of the project, so sbt adds a dependency on <code>scala-compiler</code>
in the special, private <code>scala-tool</code> configuration. It may be desirable
to have more control over this in some situations. Disable this
automatic behavior with the <code>managedScalaInstance</code> key:
</p><pre><code class="prettyprint lang-scala">managedScalaInstance := false
</code></pre><p>This will also disable the automatic dependency on <code>scala-library</code>. If
you do not need the Scala compiler for anything (compiling, the REPL,
scaladoc, etc…), you can stop here. sbt does not need an instance of
Scala for your project in that case. Otherwise, sbt will still need
access to the jars for the Scala compiler for compilation and other
tasks. You can provide them by either declaring a dependency in the
<code>scala-tool</code> configuration or by explicitly defining <code>scalaInstance</code>.
</p><p>In the first case, add the <code>scala-tool</code> configuration and add a
dependency on <code>scala-compiler</code> in this configuration. The organization
is not important, but sbt needs the module name to be <code>scala-compiler</code>
and <code>scala-library</code> in order to handle those jars appropriately. For
example,
</p><pre><code class="prettyprint lang-scala">managedScalaInstance := false

// Add the configuration for the dependencies on Scala tool jars
// You can also use a manually constructed configuration like:
//   config(&quot;scala-tool&quot;).hide
ivyConfigurations += Configurations.ScalaTool

// Add the usual dependency on the library as well on the compiler in the
//  'scala-tool' configuration
libraryDependencies ++= Seq(
   &quot;org.scala-lang&quot; % &quot;scala-library&quot; % scalaVersion.value,
   &quot;org.scala-lang&quot; % &quot;scala-compiler&quot; % scalaVersion.value % &quot;scala-tool&quot;
)
</code></pre><p>In the second case, directly construct a value of type
<a href="../api/sbt/ScalaInstance.html">ScalaInstance</a>, typically using a
method in the <a href="../api/sbt/ScalaInstance$.html">companion object</a>,
and assign it to <code>scalaInstance</code>. You will also need to add the
<code>scala-library</code> jar to the classpath to compile and run Scala sources.
For example,
</p><pre><code class="prettyprint lang-scala">managedScalaInstance := false

scalaInstance := ...

unmanagedJars in Compile += scalaInstance.value.libraryJar
</code></pre><h4 id="Switching+to+a+local+Scala+version">Switching to a local Scala version<a href="#Switching+to+a+local+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To use a locally built Scala version, configure Scala home as described
in the following section. Scala will still be resolved as before, but
the jars will come from the configured Scala home directory.
</p><h3 id="Using+Scala+from+a+local+directory">Using Scala from a local directory<a href="#Using+Scala+from+a+local+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The result of building Scala from source is a Scala home directory
<code>&lt;base&gt;/build/pack/</code> that contains a subdirectory <code>lib/</code> containing the
Scala library, compiler, and other jars. The same directory layout is
obtained by downloading and extracting a Scala distribution. Such a
Scala home directory may be used as the source for jars by setting
<code>scalaHome</code>. For example,
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/home/user/scala-2.10/&quot;))
</code></pre><p>By default, <code>lib/scala-library.jar</code> will be added to the unmanaged
classpath and <code>lib/scala-compiler.jar</code> will be used to compile Scala
sources and provide a Scala REPL. No managed dependency is recorded on
<code>scala-library</code>. This means that Scala will only be resolved from a
repository if you explicitly define a dependency on Scala or if Scala is
depended on indirectly via a dependency. In these cases, the artifacts
for the resolved dependencies will be substituted with jars in the Scala
home <code>lib/</code> directory.
</p><h4 id="Mixing+with+managed+dependencies">Mixing with managed dependencies<a href="#Mixing+with+managed+dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As an example, consider adding a dependency on <code>scala-reflect</code> when
<code>scalaHome</code> is configured:
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/home/user/scala-2.10/&quot;))

libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value
</code></pre><p>This will be resolved as normal, except that sbt will see if
<code>/home/user/scala-2.10/lib/scala-reflect.jar</code> exists. If it does, that
file will be used in place of the artifact from the managed dependency.
</p><h4 id="Using+unmanaged+dependencies+only">Using unmanaged dependencies only<a href="#Using+unmanaged+dependencies+only" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Instead of adding managed dependencies on Scala jars, you can directly
add them. The <code>scalaInstance</code> task provides structured access to the
Scala distribution. For example, to add all jars in the Scala home
<code>lib/</code> directory,
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/home/user/scala-2.10/&quot;))

unmanagedJars in Compile ++= scalaInstance.value.jars
</code></pre><p>To add only some jars, filter the jars from <code>scalaInstance</code> before
adding them.
</p><h3 id="sbt%E2%80%99s+Scala+version">sbt’s Scala version<a href="#sbt%E2%80%99s+Scala+version" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt needs Scala jars to run itself since it is written in Scala. sbt
uses that same version of Scala to compile the build definitions that
you write for your project because they use sbt APIs. This version of
Scala is fixed for a specific sbt release and cannot be changed. For sbt
0.13.5, this version is Scala 2.10.3. Because this Scala
version is needed before sbt runs, the repositories used to retrieve
this version are configured in the sbt
<a href="Sbt-Launcher.html">launcher</a>.
</p><h2 id="Forking">Forking<a href="#Forking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>By default, the <code>run</code> task runs in the same JVM as sbt. Forking is
required under <a href="Running-Project-Code.html">certain circumstances</a>, however.
Or, you might want to fork Java processes when implementing new tasks.
</p><p>By default, a forked process uses the same Java and Scala versions being
used for the build and the working directory and JVM options of the
current process. This page discusses how to enable and configure forking
for both <code>run</code> and <code>test</code> tasks. Each kind of task may be configured
separately by scoping the relevant keys as explained below.
</p><h3 id="Enable+forking">Enable forking<a href="#Enable+forking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>fork</code> setting controls whether forking is enabled (true) or not
(false). It can be set in the <code>run</code> scope to only fork <code>run</code> commands or
in the <code>test</code> scope to only fork <code>test</code> commands.
</p><p>To fork all test tasks (<code>test</code>, <code>testOnly</code>, and <code>testQuick</code>) and run
tasks (<code>run</code>, <code>runMain</code>, <code>test:run</code>, and <code>test:runMain</code>),
</p><pre><code class="prettyprint lang-scala">fork := true
</code></pre><p>To enable forking <code>run</code> tasks only, set <code>fork</code> to <code>true</code> in the <code>run</code>
scope.
</p><pre><code class="prettyprint lang-scala">fork in run := true
</code></pre><p>To only fork <code>test:run</code> and <code>test:runMain</code>:
</p><pre><code class="prettyprint lang-scala">fork in (Test, run) := true
</code></pre><p>Similarly, set <code>fork in (Compile,run) := true</code> to only fork the main
<code>run</code> tasks. <code>run</code> and <code>runMain</code> share the same configuration and cannot
be configured separately.
</p><p>To enable forking all <code>test</code> tasks only, set <code>fork</code> to <code>true</code> in the
<code>test</code> scope:
</p><pre><code class="prettyprint lang-scala">fork in test := true
</code></pre><p>See <a href="Testing.html">Testing</a> for more control over how tests are assigned to JVMs and
what options to pass to each group.
</p><h3 id="Change+working+directory">Change working directory<a href="#Change+working+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To change the working directory when forked, set <code>baseDirectory in run</code>
or <code>baseDirectory in test</code>:
</p><pre><code class="prettyprint lang-scala">// sets the working directory for all `run`-like tasks
baseDirectory in run := file(&quot;/path/to/working/directory/&quot;)

// sets the working directory for `run` and `runMain` only
baseDirectory in (Compile,run) := file(&quot;/path/to/working/directory/&quot;)

// sets the working directory for `test:run` and `test:runMain` only
baseDirectory in (Test,run) := file(&quot;/path/to/working/directory/&quot;)

// sets the working directory for `test`, `testQuick`, and `testOnly`
baseDirectory in test := file(&quot;/path/to/working/directory/&quot;)
</code></pre><h3 id="Forked+JVM+options">Forked JVM options<a href="#Forked+JVM+options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To specify options to be provided to the forked JVM, set <code>javaOptions</code>:
</p><pre><code class="prettyprint lang-scala">javaOptions in run += &quot;-Xmx8G&quot;
</code></pre><p>or specify the configuration to affect only the main or test <code>run</code>
tasks:
</p><pre><code class="prettyprint lang-scala">javaOptions in (Test,run) += &quot;-Xmx8G&quot;
</code></pre><p>or only affect the <code>test</code> tasks:
</p><pre><code class="prettyprint lang-scala">javaOptions in test += &quot;-Xmx8G&quot;
</code></pre><h3 id="Java+Home">Java Home<a href="#Java+Home" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Select the Java installation to use by setting the <code>javaHome</code> directory:
</p><pre><code class="prettyprint lang-scala">javaHome := Some(file(&quot;/path/to/jre/&quot;))
</code></pre><p>Note that if this is set globally, it also sets the Java installation
used to compile Java sources. You can restrict it to running only by
setting it in the <code>run</code> scope:
</p><pre><code class="prettyprint lang-scala">javaHome in run := Some(file(&quot;/path/to/jre/&quot;))
</code></pre><p>As with the other settings, you can specify the configuration to affect
only the main or test <code>run</code> tasks or just the <code>test</code> tasks.
</p><h3 id="Configuring+output">Configuring output<a href="#Configuring+output" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, forked output is sent to the Logger, with standard output
logged at the <code>Info</code> level and standard error at the <code>Error</code> level. This
can be configured with the <code>outputStrategy</code> setting, which is of type
<a href="../api/sbt/OutputStrategy.html">OutputStrategy</a>.
</p><pre><code class="prettyprint lang-scala">// send output to the build's standard output and error
outputStrategy := Some(StdoutOutput)

// send output to the provided OutputStream `someStream`
outputStrategy := Some(CustomOutput(someStream: OutputStream))

// send output to the provided Logger `log` (unbuffered)
outputStrategy := Some(LoggedOutput(log: Logger))

// send output to the provided Logger `log` after the process terminates
outputStrategy := Some(BufferedOutput(log: Logger))
</code></pre><p>As with other settings, this can be configured individually for main or
test <code>run</code> tasks or for <code>test</code> tasks.
</p><h3 id="Configuring+Input">Configuring Input<a href="#Configuring+Input" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, the standard input of the sbt process is not forwarded to
the forked process. To enable this, configure the <code>connectInput</code>
setting:
</p><pre><code class="prettyprint lang-scala">connectInput in run := true
</code></pre><h3 id="Direct+Usage">Direct Usage<a href="#Direct+Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To fork a new Java process, use the
<a href="../api/sbt/Fork$.html">Fork API</a>. The values of interest are
<code>Fork.java</code>, <code>Fork.javac</code>, <code>Fork.scala</code>, and <code>Fork.scalac</code>. These are of
type <a href="../api/sbt/Fork.html">Fork</a> and provide <code>apply</code> and <code>fork</code>
methods. For example, to fork a new Java process, :
</p><pre><code class="prettyprint lang-scala">val options = ForkOptions(...)
val arguments: Seq[String] = ...
val mainClass: String = ...
val exitCode: Int = Fork.java(options, mainClass +: arguments)
</code></pre><p><a href="../api/sbt/ForkOptions.html">ForkOptions</a> defines the Java
installation to use, the working directory, environment variables, and
more. For example, :
</p><pre><code class="prettyprint lang-scala">val cwd: File = ...
val javaDir: File = ...
val options = ForkOptions(
   envVars = Map(&quot;KEY&quot; -&gt; &quot;value&quot;),
   workingDirectory = Some(cwd),
   javaHome = Some(javaDir)
)
</code></pre><h2 id="Global+Settings">Global Settings<a href="#Global+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Basic+global+configuration+file">Basic global configuration file<a href="#Basic+global+configuration+file" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Settings that should be applied to all projects can go in
<code>~/.sbt/0.13/global.sbt</code> (or any file in <code>~/.sbt/0.13</code> with a <code>.sbt</code>
extension). Plugins that are defined globally in <code>~/.sbt/0.13/plugins/</code>
are available to these settings. For example, to change the default
<code>shellPrompt</code> for your projects:
</p><p><code>~/.sbt/0.13/global.sbt</code>
</p><pre><code class="prettyprint lang-scala">shellPrompt := { state =&gt;
  &quot;sbt (%s)&gt; &quot;.format(Project.extract(state).currentProject.id)
}
</code></pre><h3 id="Global+Settings+using+a+Global+Plugin">Global Settings using a Global Plugin<a href="#Global+Settings+using+a+Global+Plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>~/.sbt/0.13/plugins/</code> directory is a global plugin project. This
can be used to provide global commands, plugins, or other code.
</p><p>To add a plugin globally, create <code>~/.sbt/0.13/plugins/build.sbt</code> containing
the dependency definitions. For example:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.example&quot; % &quot;plugin&quot; % &quot;1.0&quot;)
</code></pre><p>To change the default <code>shellPrompt</code> for every project using this
approach, create a local plugin <code>~/.sbt/0.13/plugins/ShellPrompt.scala</code>:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object ShellPrompt extends Plugin {
  override def settings = Seq(
    shellPrompt := { state =&gt;
      &quot;sbt (%s)&gt; &quot;.format(Project.extract(state).currentProject.id) }
  )
}
</code></pre><p>The <code>~/.sbt/0.13/plugins/</code> directory is a full project that is
included as an external dependency of every plugin project. In practice,
settings and code defined here effectively work as if they were defined
in a project’s <code>project/</code> directory. This means that
<code>~/.sbt/0.13/plugins/</code> can be used to try out ideas for plugins such as
shown in the <code>shellPrompt</code> example.
</p><h2 id="Java+Sources">Java Sources<a href="#Java+Sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt has support for compiling Java sources with the limitation that
dependency tracking is limited to the dependencies present in compiled
class files.
</p><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li><code>compile</code> will compile the sources under <code>src/main/java</code> by default.
</li><li><code>testCompile</code> will compile the sources under <code>src/test/java</code> by
default.
</li></ul><p>Pass options to the Java compiler by setting <code>javacOptions</code>:
</p><pre><code class="prettyprint lang-scala">javacOptions += &quot;-g:none&quot;
</code></pre><p>As with options for the Scala compiler, the arguments are not parsed by
sbt. Multi-element options, such as <code>-source 1.5</code>, are specified like:
</p><pre><code class="prettyprint lang-scala">javacOptions ++= Seq(&quot;-source&quot;, &quot;1.5&quot;)
</code></pre><p>You can specify the order in which Scala and Java sources are built with
the <code>compileOrder</code> setting. Possible values are from the <code>CompileOrder</code>
enumeration: <code>Mixed</code>, <code>JavaThenScala</code>, and <code>ScalaThenJava</code>. If you have
circular dependencies between Scala and Java sources, you need the
default, <code>Mixed</code>, which passes both Java and Scala sources to <code>scalac</code>
and then compiles the Java sources with <code>javac</code>. If you do not have
circular dependencies, you can use one of the other two options to speed
up your build by not passing the Java sources to <code>scalac</code>. For example,
if your Scala sources depend on your Java sources, but your Java sources
do not depend on your Scala sources, you can do:
</p><pre><code class="prettyprint lang-scala">compileOrder := CompileOrder.JavaThenScala
</code></pre><p>To specify different orders for main and test sources, scope the setting
by configuration:
</p><pre><code class="prettyprint lang-scala">// Java then Scala for main sources
compileOrder in Compile := CompileOrder.JavaThenScala

// allow circular dependencies for test sources
compileOrder in Test := CompileOrder.Mixed
</code></pre><p>Note that in an incremental compilation setting, it is not practical to
ensure complete isolation between Java sources and Scala sources because
they share the same output directory. So, previously compiled classes
not involved in the current recompilation may be picked up. A clean
compile will always provide full checking, however.
</p><p>By default, sbt includes <code>src/main/scala</code> and <code>src/main/java</code> in its
list of unmanaged source directories. For Java-only projects, the
unnecessary Scala directories can be ignored by modifying
<code>unmanagedSourceDirectories</code>:
</p><pre><code class="prettyprint lang-scala">// Include only src/main/java in the compile configuration
unmanagedSourceDirectories in Compile := (javaSource in Compile).value :: Nil

// Include only src/test/java in the test configuration
unmanagedSourceDirectories in Test := (javaSource in Test).value :: Nil
</code></pre><p>However, there should not be any harm in leaving the Scala directories
if they are empty.
</p><h2 id="Mapping+Files">Mapping Files<a href="#Mapping+Files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Tasks like <code>package</code>, <code>packageSrc</code>, and <code>packageDoc</code> accept mappings of
type <code>Seq[(File, String)]</code> from an input file to the path to use in the
resulting artifact (jar). Similarly, tasks that copy files accept
mappings of type <code>Seq[(File, File)]</code> from an input file to the
destination file. There are some methods on
<a href="../api/sbt/PathFinder.html">PathFinder</a> and
<a href="../api/sbt/Path$.html">Path</a> that can be useful for constructing
the <code>Seq[(File, String)]</code> or <code>Seq[(File, File)]</code> sequences.
</p><p>A common way of making this sequence is to start with a <code>PathFinder</code> or
<code>Seq[File]</code> (which is implicitly convertible to <code>PathFinder</code>) and then
call the <code>pair</code> method. See the
<a href="../api/sbt/PathFinder.html">PathFinder</a> API for details, but
essentially this method accepts a function <code>File =&gt; Option[String]</code> or
<code>File =&gt; Option[File]</code> that is used to generate mappings.
</p><h3 id="Relative+to+a+directory">Relative to a directory<a href="#Relative+to+a+directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Path.relativeTo</code> method is used to map a <code>File</code> to its path
<code>String</code> relative to a base directory or directories. The <code>relativeTo</code>
method accepts a base directory or sequence of base directories to
relativize an input file against. The first directory that is an
ancestor of the file is used in the case of a sequence of base
directories.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">import Path.relativeTo
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair relativeTo(baseDirectories)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;b/C.scala&quot;) :: Nil
assert( mappings == expected )
</code></pre><h3 id="Rebase">Rebase<a href="#Rebase" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Path.rebase</code> method relativizes an input file against one or more
base directories (the first argument) and then prepends a base String or
File (the second argument) to the result. As with <code>relativeTo</code>, the
first base directory that is an ancestor of the input file is used in
the case of multiple base directories.
</p><p>For example, the following demonstrates building a <code>Seq[(File, String)]</code>
using <code>rebase</code>:
</p><pre><code class="prettyprint lang-scala">import Path.rebase
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair rebase(baseDirectories, &quot;pre/&quot;)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;pre/b/C.scala&quot; ) :: Nil
assert( mappings == expected )
</code></pre><p>Or, to build a <code>Seq[(File, File)]</code>:
</p><pre><code class="prettyprint lang-scala">import Path.rebase
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val newBase: File = file(&quot;/new/base&quot;)
val mappings: Seq[(File,File)] = files pair rebase(baseDirectories, newBase)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; file(&quot;/new/base/b/C.scala&quot;) ) :: Nil
assert( mappings == expected )
</code></pre><h3 id="Flatten">Flatten<a href="#Flatten" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>Path.flat</code> method provides a function that maps a file to the last
component of the path (its name). For a File to File mapping, the input
file is mapped to a file with the same name in a given target directory.
For example:
</p><pre><code class="prettyprint lang-scala">import Path.flat
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair flat

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;C.scala&quot; ) :: Nil
assert( mappings == expected )
</code></pre><p>To build a <code>Seq[(File, File)]</code> using <code>flat</code>:
</p><pre><code class="prettyprint lang-scala">import Path.flat
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: Nil
val newBase: File = file(&quot;/new/base&quot;)
val mappings: Seq[(File,File)] = files pair flat(newBase)

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; file(&quot;/new/base/C.scala&quot;) ) :: Nil
assert( mappings == expected )
</code></pre><h3 id="Alternatives">Alternatives<a href="#Alternatives" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To try to apply several alternative mappings for a file, use <code>|</code>, which
is implicitly added to a function of type <code>A =&gt; Option[B]</code>. For example,
to try to relativize a file against some base directories but fall back
to flattening:
</p><pre><code class="prettyprint lang-scala">import Path.relativeTo
val files: Seq[File] = file(&quot;/a/b/C.scala&quot;) :: file(&quot;/zzz/D.scala&quot;) :: Nil
val baseDirectories: Seq[File] = file(&quot;/a&quot;) :: Nil
val mappings: Seq[(File,String)] = files pair ( relativeTo(baseDirectories) | flat )

val expected = (file(&quot;/a/b/C.scala&quot;) -&gt; &quot;b/C.scala&quot;) ) :: (file(&quot;/zzz/D.scala&quot;) -&gt; &quot;D.scala&quot;) ) :: Nil
assert( mappings == expected )
</code></pre><h2 id="Local+Scala">Local Scala<a href="#Local+Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>To use a locally built Scala version, define the <code>scalaHome</code> setting,
which is of type <code>Option[File]</code>. This Scala version will only be used
for the build and not for sbt, which will still use the version it was
compiled against.
</p><p>Example:
</p><pre><code class="prettyprint lang-scala">scalaHome := Some(file(&quot;/path/to/scala&quot;))
</code></pre><p>Using a local Scala version will override the <code>scalaVersion</code> setting and
will not work with <a href="Cross-Build.html">cross building</a>.
</p><p>sbt reuses the class loader for the local Scala version. If you
recompile your local Scala version and you are using sbt interactively,
run
</p><pre><code class="">&gt; reload
</code></pre><p>to use the new compilation results.
</p><h2 id="Macro+Projects">Macro Projects<a href="#Macro+Projects" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Some common problems arise when working with macros.
</p><ol><li>The current macro implementation in the compiler requires that macro
implementations be compiled before they are used. The solution is
typically to put the macros in a subproject or in their own
configuration.
</li><li>Sometimes the macro implementation should be distributed with the
main code that uses them and sometimes the implementation should not
be distributed at all.
</li></ol><p>The rest of the page shows example solutions to these problems.
</p><h3 id="Defining+the+Project+Relationships">Defining the Project Relationships<a href="#Defining+the+Project+Relationships" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The macro implementation will go in a subproject in the <code>macro/</code>
directory. The main project in the project’s base directory will depend
on this subproject and use the macro. This configuration is shown in the
following build definition. <code>project/Build.scala</code>:
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object MacroBuild extends Build {
   lazy val main = Project(&quot;main&quot;, file(&quot;.&quot;)) dependsOn(macroSub)
   lazy val macroSub = Project(&quot;macro&quot;, file(&quot;macro&quot;)) settings(
      libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value
   )
}
</code></pre><p>This specifies that the macro implementation goes in
<code>macro/src/main/scala/</code> and tests go in <code>macro/src/test/scala/</code>. It also
shows that we need a dependency on the compiler for the macro
implementation. As an example macro, we’ll use <code>desugar</code> from
<a href="https://github.com/retronym/macrocosm">macrocosm</a>. <code>macro/src/main/scala/demo/Demo.scala</code>:
</p><pre><code class="prettyprint lang-scala">package demo

import language.experimental.macros
import scala.reflect.macros.Context

object Demo {

  // Returns the tree of `a` after the typer, printed as source code.
  def desugar(a: Any): String = macro desugarImpl

  def desugarImpl(c: Context)(a: c.Expr[Any]) = {
    import c.universe._

    val s = show(a.tree)
    c.Expr(
      Literal(Constant(s))
    )
  }
}
</code></pre><p><code>macro/src/test/scala/demo/Usage.scala</code>:
</p><pre><code class="prettyprint lang-scala">package demo

object Usage {
   def main(args: Array[String]) {
      val s = Demo.desugar(List(1, 2, 3).reverse)
      println(s)
   }
}
</code></pre><p>This can be then be run at the console:
</p><p>Actual tests can be defined and run as usual with <code>macro/test</code>.
</p><p>The main project can use the macro in the same way that the tests do.
For example,
</p><p><code>src/main/scala/MainUsage.scala</code>:
</p><pre><code class="prettyprint lang-scala">package demo

object Usage {
   def main(args: Array[String]) {
      val s = Demo.desugar(List(6, 4, 5).sorted)
      println(s)
   }
}
</code></pre><h3 id="Common+Interface">Common Interface<a href="#Common+Interface" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sometimes, the macro implementation and the macro usage should share
some common code. In this case, declare another subproject for the
common code and have the main project and the macro subproject depend on
the new subproject. For example, the project definitions from above
would look like:
</p><pre><code class="prettyprint lang-scala">lazy val main = Project(&quot;main&quot;, file(&quot;.&quot;)) dependsOn(macroSub, commonSub)
lazy val macroSub = Project(&quot;macro&quot;, file(&quot;macro&quot;)) dependsOn(commonSub) settings(
    libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-reflect&quot; % scalaVersion.value
)
lazy val commonSub = Project(&quot;common&quot;, file(&quot;common&quot;))
</code></pre><p>Code in <code>common/src/main/scala/</code> is available for both the <code>macro</code> and
<code>main</code> projects to use.
</p><h3 id="Distribution">Distribution<a href="#Distribution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To include the macro code with the main code, add the binary and source
mappings from the macro subproject to the main project. For example, the
<code>main</code> Project definition above would now look like:
</p><pre><code class="prettyprint lang-scala">lazy val main = Project(&quot;main&quot;, file(&quot;.&quot;)) dependsOn(macroSub) settings(
   // include the macro classes and resources in the main jar
   mappings in (Compile, packageBin) ++= mappings.in(macroSub, Compile, packageBin).value,
   // include the macro sources in the main source jar
   mappings in (Compile, packageSrc) ++= mappings.in(macroSub, Compile, packageSrc).value
)
</code></pre><p>You may wish to disable publishing the macro implementation. This is
done by overriding <code>publish</code> and <code>publishLocal</code> to do nothing:
</p><pre><code class="prettyprint lang-scala">lazy val macroSub = Project(&quot;macro&quot;, file(&quot;macro&quot;)) settings(
    publish := {},
    publishLocal := {}
)
</code></pre><p>The techniques described here may also be used for the common interface
described in the previous section.
</p><h2 id="Paths">Paths<a href="#Paths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes files, sequences of files, and file filters. The
base type used is
<a href="http://download.oracle.com/javase/6/docs/api/java/io/File.html">java.io.File</a>,
but several methods are augmented through implicits:
</p><ul><li><a href="../api/sbt/RichFile.html">RichFile</a> adds methods to File
</li><li><a href="../api/sbt/PathFinder.html">PathFinder</a> adds methods to File
and Seq[File]
</li><li><a href="../api/sbt/Path$.html">Path</a> and <a href="../api/sbt/IO$.html">IO</a>
provide general methods related to files and I/O.
</li></ul><h3 id="Constructing+a+File">Constructing a File<a href="#Constructing+a+File" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 0.10+ uses
<a href="http://download.oracle.com/javase/6/docs/api/java/io/File.html">java.io.File</a>
to represent a file instead of the custom <code>sbt.Path</code> class that was in
sbt 0.7 and earlier. sbt defines the alias <code>File</code> for <code>java.io.File</code> so
that an extra import is not necessary. The <code>file</code> method is an alias for
the single-argument <code>File</code> constructor to simplify constructing a new
file from a String:
</p><pre><code class="prettyprint lang-scala">val source: File = file(&quot;/home/user/code/A.scala&quot;)
</code></pre><p>Additionally, sbt augments File with a <code>/</code> method, which is an alias for
the two-argument <code>File</code> constructor for building up a path:
</p><pre><code class="prettyprint lang-scala">def readme(base: File): File = base / &quot;README&quot;
</code></pre><p>Relative files should only be used when defining the base directory of a
<code>Project</code>, where they will be resolved properly.
</p><pre><code class="prettyprint lang-scala">val root = Project(&quot;root&quot;, file(&quot;.&quot;))
</code></pre><p>Elsewhere, files should be absolute or be built up from an absolute base
<code>File</code>. The <code>baseDirectory</code> setting defines the base directory of the
build or project depending on the scope.
</p><p>For example, the following setting sets the unmanaged library directory
to be the “custom_lib” directory in a project’s base directory:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value /&quot;custom_lib&quot;
</code></pre><p>Or, more concisely:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value /&quot;custom_lib&quot;
</code></pre><p>This setting sets the location of the shell history to be in the base
directory of the build, irrespective of the project the setting is
defined in:
</p><pre><code class="prettyprint lang-scala">historyPath := Some( (baseDirectory in ThisBuild).value / &quot;.history&quot;),
</code></pre><h3 id="Path+Finders">Path Finders<a href="#Path+Finders" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A <code>PathFinder</code> computes a <code>Seq[File]</code> on demand. It is a way to build a
sequence of files. There are several methods that augment <code>File</code> and
<code>Seq[File]</code> to construct a <code>PathFinder</code>. Ultimately, call <code>get</code> on the
resulting <code>PathFinder</code> to evaluate it and get back a <code>Seq[File]</code>.
</p><h4 id="Selecting+descendants">Selecting descendants<a href="#Selecting+descendants" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>**</code> method accepts a <code>java.io.FileFilter</code> and selects all files
matching that filter.
</p><pre><code class="prettyprint lang-scala">def scalaSources(base: File): PathFinder = (base / &quot;src&quot;) ** &quot;*.scala&quot;
</code></pre><h4 id="get">get<a href="#get" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This selects all files that end in <code>.scala</code> that are in <code>src</code> or a
descendent directory. The list of files is not actually evaluated until
<code>get</code> is called:
</p><pre><code class="prettyprint lang-scala">def scalaSources(base: File): Seq[File] = {
  val finder: PathFinder = (base / &quot;src&quot;) ** &quot;*.scala&quot; 
  finder.get
}
</code></pre><p>If the filesystem changes, a second call to <code>get</code> on the same
<code>PathFinder</code> object will reflect the changes. That is, the <code>get</code> method
reconstructs the list of files each time. Also, <code>get</code> only returns
<code>File</code>s that existed at the time it was called.
</p><h4 id="Selecting+children">Selecting children<a href="#Selecting+children" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Selecting files that are immediate children of a subdirectory is done
with a single <code>*</code>:
</p><pre><code class="prettyprint lang-scala">def scalaSources(base: File): PathFinder = (base / &quot;src&quot;) * &quot;*.scala&quot;
</code></pre><p>This selects all files that end in <code>.scala</code> that are in the <code>src</code>
directory.
</p><h4 id="Existing+files+only">Existing files only<a href="#Existing+files+only" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If a selector, such as <code>/</code>, <code>**</code>, or <code>*</code>, is used on a path that does
not represent a directory, the path list will be empty:
</p><pre><code class="prettyprint lang-scala">def emptyFinder(base: File) = (base / &quot;lib&quot; / &quot;ivy.jar&quot;) * &quot;not_possible&quot;
</code></pre><h4 id="Name+Filter">Name Filter<a href="#Name+Filter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The argument to the child and descendent selectors <code>*</code> and <code>**</code> is
actually a <code>NameFilter</code>. An implicit is used to convert a <code>String</code> to a
<code>NameFilter</code> that interprets <code>*</code> to represent zero or more characters of
any value. See the Name Filters section below for more information.
</p><h4 id="Combining+PathFinders">Combining PathFinders<a href="#Combining+PathFinders" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Another operation is concatenation of <code>PathFinder</code>s:
</p><pre><code class="prettyprint lang-scala">def multiPath(base: File): PathFinder =
   (base / &quot;src&quot; / &quot;main&quot;) +++
   (base / &quot;lib&quot;) +++
   (base / &quot;target&quot; / &quot;classes&quot;)
</code></pre><p>When evaluated using <code>get</code>, this will return <code>src/main/</code>, <code>lib/</code>, and
<code>target/classes/</code>. The concatenated finder supports all standard
methods. For example,
</p><pre><code class="prettyprint lang-scala">def jars(base: File): PathFinder =
   (base / &quot;lib&quot; +++ base / &quot;target&quot;) * &quot;*.jar&quot;
</code></pre><p>selects all jars directly in the “lib” and “target” directories.
</p><p>A common problem is excluding version control directories. This can be
accomplished as follows:
</p><pre><code class="prettyprint lang-scala">def sources(base: File) =
   ( (base / &quot;src&quot;) ** &quot;*.scala&quot;) --- ( (base / &quot;src&quot;) ** &quot;.svn&quot; ** &quot;*.scala&quot;)
</code></pre><p>The first selector selects all Scala sources and the second selects all
sources that are a descendent of a <code>.svn</code> directory. The <code>---</code> method
removes all files returned by the second selector from the sequence of
files returned by the first selector.
</p><a name="file-filter"></a><h4 id="Filtering">Filtering<a href="#Filtering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a <code>filter</code> method that accepts a predicate of type
<code>File =&gt; Boolean</code> and is non-strict:
</p><pre><code class="prettyprint lang-scala">// selects all directories under &quot;src&quot;
def srcDirs(base: File) = ( (base / &quot;src&quot;) ** &quot;*&quot;) filter { _.isDirectory }

// selects archives (.zip or .jar) that are selected by 'somePathFinder'
def archivesOnly(base: PathFinder) = base filter ClasspathUtilities.isArchive
</code></pre><h4 id="Empty+PathFinder">Empty PathFinder<a href="#Empty+PathFinder" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>PathFinder.empty</code> is a <code>PathFinder</code> that returns the empty sequence
when <code>get</code> is called:
</p><pre><code class="prettyprint lang-scala">assert( PathFinder.empty.get == Seq[File]() )
</code></pre><h4 id="PathFinder+to+String+conversions">PathFinder to String conversions<a href="#PathFinder+to+String+conversions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Convert a <code>PathFinder</code> to a String using one of the following methods:
</p><ul><li><code>toString</code> is for debugging. It puts the absolute path of each
component on its own line.
</li><li><code>absString</code> gets the absolute paths of each component and separates
them by the platform’s path separator.
</li><li><code>getPaths</code> produces a <code>Seq[String]</code> containing the absolute paths of
each component
</li></ul><h4 id="Mappings">Mappings<a href="#Mappings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The packaging and file copying methods in sbt expect values of type
<code>Seq[(File,String)]</code> and <code>Seq[(File,File)]</code>, respectively. These are
mappings from the input file to its (String) path in the jar or its
(File) destination. This approach replaces the relative path approach
(using the <code>##</code> method) from earlier versions of sbt.
</p><p>Mappings are discussed in detail on the <code>Mapping-Files</code> page.
</p><h3 id="File+Filters">File Filters<a href="#File+Filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The argument to <code>*</code> and <code>**</code> is of type
<a href="http://download.oracle.com/javase/6/docs/api/java/io/FileFilter.html">java.io.FileFilter</a>.
sbt provides combinators for constructing <code>FileFilter</code>s.
</p><p>First, a String may be implicitly converted to a <code>FileFilter</code>. The
resulting filter selects files with a name matching the string, with a
<code>*</code> in the string interpreted as a wildcard. For example, the following
selects all Scala sources with the word “Test” in them:
</p><pre><code class="prettyprint lang-scala">def testSrcs(base: File): PathFinder =  (base / &quot;src&quot;) * &quot;*Test*.scala&quot;
</code></pre><p>There are some useful combinators added to <code>FileFilter</code>. The <code>||</code> method
declares alternative <code>FileFilter</code>s. The following example selects all
Java or Scala source files under “src”:
</p><pre><code class="prettyprint lang-scala">def sources(base: File): PathFinder  =  (base / &quot;src&quot;) ** (&quot;*.scala&quot; || &quot;*.java&quot;)
</code></pre><p>The <code>--</code> method excludes a files matching a second filter from the files
matched by the first:
</p><pre><code class="prettyprint lang-scala">def imageResources(base: File): PathFinder =
   (base/&quot;src&quot;/&quot;main&quot;/&quot;resources&quot;) * (&quot;*.png&quot; -- &quot;logo.png&quot;)
</code></pre><p>This will get <code>right.png</code> and <code>left.png</code>, but not <code>logo.png</code>, for
example.
</p><h2 id="Parallel+Execution">Parallel Execution<a href="#Parallel+Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Task+ordering">Task ordering<a href="#Task+ordering" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Task ordering is specified by declaring a task’s inputs. Correctness of
execution requires correct input declarations. For example, the
following two tasks do not have an ordering specified:
</p><pre><code class="prettyprint lang-scala">write := IO.write(file(&quot;/tmp/sample.txt&quot;), &quot;Some content.&quot;)

read := IO.read(file(&quot;/tmp/sample.txt&quot;))
</code></pre><p>sbt is free to execute <code>write</code> first and then <code>read</code>, <code>read</code> first and
then <code>write</code>, or <code>read</code> and <code>write</code> simultaneously. Execution of these
tasks is non-deterministic because they share a file. A correct
declaration of the tasks would be:
</p><pre><code class="prettyprint lang-scala">write := {
  val f = file(&quot;/tmp/sample.txt&quot;)
  IO.write(f, &quot;Some content.&quot;)
  f
}

read := IO.read(write.value)
</code></pre><p>This establishes an ordering: <code>read</code> must run after <code>write</code>. We’ve also
guaranteed that <code>read</code> will read from the same file that <code>write</code>
created.
</p><h3 id="Practical+constraints">Practical constraints<a href="#Practical+constraints" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Note: The feature described in this section is experimental. The default
configuration of the feature is subject to change in particular.
</p><h4 id="Background">Background<a href="#Background" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Declaring inputs and dependencies of a task ensures the task is properly
ordered and that code executes correctly. In practice, tasks share
finite hardware and software resources and can require control over
utilization of these resources. By default, sbt executes tasks in
parallel (subject to the ordering constraints already described) in an
effort to utilize all available processors. Also by default, each test
class is mapped to its own task to enable executing tests in parallel.
</p><p>Prior to sbt 0.12, user control over this process was restricted to:
</p><ol><li>Enabling or disabling all parallel execution
(parallelExecution := false, for example).
</li><li>Enabling or disabling mapping tests to their own tasks
(parallelExecution in Test := false, for example).
</li></ol><p>(Although never exposed as a setting, the maximum number of tasks
running at a given time was internally configurable as well.)
</p><p>The second configuration mechanism described above only selected between
running all of a project’s tests in the same task or in separate tasks.
Each project still had a separate task for running its tests and so test
tasks in separate projects could still run in parallel if overall
execution was parallel. There was no way to restriction execution such
that only a single test out of all projects executed.
</p><h3 id="Configuration">Configuration<a href="#Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt 0.12.0 introduces a general infrastructure for restricting task
concurrency beyond the usual ordering declarations. There are two parts
to these restrictions.
</p><ol><li>A task is tagged in order to classify its purpose and resource
utilization. For example, the compile task may be tagged as
Tags.Compile and Tags.CPU.
</li><li>A list of rules restrict the tasks that may execute concurrently.
For example, Tags.limit(Tags.CPU, 4) would allow up to four
computation-heavy tasks to run at a time.
</li></ol><p>The system is thus dependent on proper tagging of tasks and then on a
good set of rules.
</p><h4 id="Tagging+Tasks">Tagging Tasks<a href="#Tagging+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In general, a tag is associated with a weight that represents the task’s
relative utilization of the resource represented by the tag. Currently,
this weight is an integer, but it may be a floating point in the future.
<code>Initialize[Task[T]]</code> defines two methods for tagging the constructed
Task: <code>tag</code> and <code>tagw</code>. The first method, <code>tag</code>, fixes the weight to be
1 for the tags provided to it as arguments. The second method, <code>tagw</code>,
accepts pairs of tags and weights. For example, the following associates
the <code>CPU</code> and <code>Compile</code> tags with the <code>compile</code> task (with a weight of
1).
</p><pre><code class="prettyprint lang-scala">def myCompileTask = Def.task { ... } tag(Tags.CPU, Tags.Compile)

compile := myCompileTask.value
</code></pre><p>Different weights may be specified by passing tag/weight pairs to
<code>tagw</code>:
</p><pre><code class="prettyprint lang-scala">def downloadImpl = Def.task { ... } tagw(Tags.Network -&gt; 3)

download := downloadImpl.value
</code></pre><h4 id="Defining+Restrictions">Defining Restrictions<a href="#Defining+Restrictions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Once tasks are tagged, the <code>concurrentRestrictions</code> setting sets
restrictions on the tasks that may be concurrently executed based on the
weighted tags of those tasks. This is necessarily a global set of rules,
so it must be scoped <code>in Global</code>. For example,
</p><pre><code class="prettyprint lang-scala">concurrentRestrictions in Global := Seq(
  Tags.limit(Tags.CPU, 2),
  Tags.limit(Tags.Network, 10),
  Tags.limit(Tags.Test, 1),
  Tags.limitAll( 15 )
)
</code></pre><p>The example limits:
</p><ul><li>the number of CPU-using tasks to be no more than 2
</li><li>the number of tasks using the network to be no more than 10
</li><li>test execution to only one test at a time across all projects
</li><li>the total number of tasks to be less than or equal to 15
</li></ul><p>Note that these restrictions rely on proper tagging of tasks. Also, the
value provided as the limit must be at least 1 to ensure every task is
able to be executed. sbt will generate an error if this condition is not
met.
</p><p>Most tasks won’t be tagged because they are very short-lived. These
tasks are automatically assigned the label <code>Untagged</code>. You may want to
include these tasks in the CPU rule by using the <code>limitSum</code> method. For
example:
</p><pre><code class="prettyprint lang-scala">...
Tags.limitSum(2, Tags.CPU, Tags.Untagged)
...
</code></pre><p>Note that the limit is the first argument so that tags can be provided
as varargs.
</p><p>Another useful convenience function is <code>Tags.exclusive</code>. This specifies
that a task with the given tag should execute in isolation. It starts
executing only when no other tasks are running (even if they have the
exclusive tag) and no other tasks may start execution until it
completes. For example, a task could be tagged with a custom tag
<code>Benchmark</code> and a rule configured to ensure such a task is executed by
itself:
</p><pre><code class="prettyprint lang-scala">...
Tags.exclusive(Benchmark)
...
</code></pre><p>Finally, for the most flexibility, you can specify a custom function of
type <code>Map[Tag,Int] =&gt; Boolean</code>. The <code>Map[Tag,Int]</code> represents the
weighted tags of a set of tasks. If the function returns <code>true</code>, it
indicates that the set of tasks is allowed to execute concurrently. If
the return value is <code>false</code>, the set of tasks will not be allowed to
execute concurrently. For example, <code>Tags.exclusive(Benchmark)</code> is
equivalent to the following:
</p><pre><code class="prettyprint lang-scala">...
Tags.customLimit { (tags: Map[Tag,Int]) =&gt;
  val exclusive = tags.getOrElse(Benchmark, 0)
   //  the total number of tasks in the group
  val all = tags.getOrElse(Tags.All, 0)
   // if there are no exclusive tasks in this group, this rule adds no restrictions
  exclusive == 0 ||
    // If there is only one task, allow it to execute.
    all == 1
}
...
</code></pre><p>There are some basic rules that custom functions must follow, but the
main one to be aware of in practice is that if there is only one task,
it must be allowed to execute. sbt will generate a warning if the user
defines restrictions that prevent a task from executing at all and will
then execute the task anyway.
</p><h5 id="Built-in+Tags+and+Rules">Built-in Tags and Rules<a href="#Built-in+Tags+and+Rules" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Built-in tags are defined in the <code>Tags</code> object. All tags listed below
must be qualified by this object. For example, <code>CPU</code> refers to the
<code>Tags.CPU</code> value.
</p><p>The built-in semantic tags are:
</p><ul><li><code>Compile</code> - describes a task that compiles sources.
</li><li><code>Test</code> - describes a task that performs a test.
</li><li><code>Publish</code>
</li><li><code>Update</code>
</li><li><code>Untagged</code> - automatically added when a task doesn’t explicitly
define any tags.
</li><li><code>All</code>- automatically added to every task.
</li></ul><p>The built-in resource tags are:
</p><ul><li><code>Network</code> - describes a task’s network utilization.
</li><li><code>Disk</code> - describes a task’s filesystem utilization.
</li><li><code>CPU</code> - describes a task’s computational utilization.
</li></ul><p>The tasks that are currently tagged by default are:
</p><ul><li><code>compile</code> : <code>Compile</code>, <code>CPU</code>
</li><li><code>test</code> : <code>Test</code>
</li><li><code>update</code> : <code>Update</code>, <code>Network</code>
</li><li><code>publish</code>, <code>publishLocal</code> : <code>Publish</code>, <code>Network</code>
</li></ul><p>Of additional note is that the default <code>test</code> task will propagate its
tags to each child task created for each test class.
</p><p>The default rules provide the same behavior as previous versions of sbt:
</p><pre><code class="prettyprint lang-scala">concurrentRestrictions in Global := {
  val max = Runtime.getRuntime.availableProcessors
  Tags.limitAll(if(parallelExecution.value) max else 1) :: Nil
}
</code></pre><p>As before, <code>parallelExecution in Test</code> controls whether tests are mapped
to separate tasks. To restrict the number of concurrently executing
tests in all projects, use:
</p><pre><code class="prettyprint lang-scala">concurrentRestrictions in Global += Tags.limit(Tags.Test, 1)
</code></pre><h4 id="Custom+Tags">Custom Tags<a href="#Custom+Tags" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To define a new tag, pass a String to the <code>Tags.Tag</code> method. For
example:
</p><pre><code class="prettyprint lang-scala">val Custom = Tags.Tag(&quot;custom&quot;)
</code></pre><p>Then, use this tag as any other tag. For example:
</p><pre><code class="prettyprint lang-scala">def aImpl = Def.task { ... } tag(Custom)

aCustomTask := aImpl.value 

concurrentRestrictions in Global += 
  Tags.limit(Custom, 1)
</code></pre><h3 id="Future+work">Future work<a href="#Future+work" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is an experimental feature and there are several aspects that may
change or require further work.
</p><h4 id="Tagging+Tasks">Tagging Tasks<a href="#Tagging+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Currently, a tag applies only to the immediate computation it is defined
on. For example, in the following, the second compile definition has no
tags applied to it. Only the first computation is labeled.
</p><pre><code class="prettyprint lang-scala">def myCompileTask = Def.task { ... } tag(Tags.CPU, Tags.Compile)

compile := myCompileTask.value

compile := { 
  val result = compile.value
  ... do some post processing ...
}
</code></pre><p>Is this desirable? expected? If not, what is a better, alternative
behavior?
</p><h4 id="Fractional+weighting">Fractional weighting<a href="#Fractional+weighting" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Weights are currently <code>int</code>s, but could be changed to be <code>double</code>s if
fractional weights would be useful. It is important to preserve a
consistent notion of what a weight of 1 means so that built-in and
custom tasks share this definition and useful rules can be written.
</p><h4 id="Default+Behavior">Default Behavior<a href="#Default+Behavior" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User feedback on what custom rules work for what workloads will help
determine a good set of default tags and rules.
</p><h4 id="Adjustments+to+Defaults">Adjustments to Defaults<a href="#Adjustments+to+Defaults" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Rules should be easier to remove or redefine, perhaps by giving them
names. As it is, rules must be appended or all rules must be completely
redefined. Also, tags can only be defined for tasks at the original
definition site when using the <code>:=</code> syntax.
</p><p>For removing tags, an implementation of <code>removeTag</code> should follow from
the implementation of <code>tag</code> in a straightforward manner.
</p><h4 id="Other+characteristics">Other characteristics<a href="#Other+characteristics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The system of a tag with a weight was selected as being reasonably
powerful and flexible without being too complicated. This selection is
not fundamental and could be enhance, simplified, or replaced if
necessary. The fundamental interface that describes the constraints the
system must work within is <code>sbt.ConcurrentRestrictions</code>. This interface
is used to provide an intermediate scheduling queue between task
execution (<code>sbt.Execute</code>) and the underlying thread-based parallel
execution service (<code>java.util.concurrent.CompletionService</code>). This
intermediate queue restricts new tasks from being forwarded to the
<code>j.u.c.CompletionService</code> according to the <code>sbt.ConcurrentRestrictions</code>
implementation. See the
<a href="https://github.com/sbt/sbt/blob/v0.12.0/tasks/ConcurrentRestrictions.scala">sbt.ConcurrentRestrictions</a>
API documentation for details.
</p><h2 id="External+Processes">External Processes<a href="#External+Processes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Usage">Usage<a href="#Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>sbt</code> includes a process library to simplify working with external
processes. The library is available without import in build definitions
and at the interpreter started by the <a href="Console-Project.html">consoleProject</a>
task.
</p><p>To run an external command, follow it with an exclamation mark <code>!</code>:
</p><pre><code class="prettyprint lang-scala">&quot;find project -name *.jar&quot; !
</code></pre><p>An implicit converts the <code>String</code> to <code>sbt.ProcessBuilder</code>, which defines
the <code>!</code> method. This method runs the constructed command, waits until
the command completes, and returns the exit code. Alternatively, the
<code>run</code> method defined on <code>ProcessBuilder</code> runs the command and returns an
instance of <code>sbt.Process</code>, which can be used to <code>destroy</code> the process
before it completes. With no arguments, the <code>!</code> method sends output to
standard output and standard error. You can pass a <code>Logger</code> to the <code>!</code>
method to send output to the <code>Logger</code>:
</p><pre><code class="prettyprint lang-scala">&quot;find project -name *.jar&quot; ! log
</code></pre><p>Two alternative implicit conversions are from <code>scala.xml.Elem</code> or
<code>List[String]</code> to <code>sbt.ProcessBuilder</code>. These are useful for
constructing commands. An example of the first variant from the android
plugin:
</p><pre><code class="prettyprint lang-scala">&lt;x&gt; {dxPath.absolutePath} --dex --output={classesDexPath.absolutePath} {classesMinJarPath.absolutePath}&lt;/x&gt; !
</code></pre><p>If you need to set the working directory or modify the environment, call
<code>sbt.Process</code> explicitly, passing the command sequence (command and
argument list) or command string first and the working directory second.
Any environment variables can be passed as a vararg list of key/value
String pairs.
</p><pre><code class="prettyprint lang-scala">Process(&quot;ls&quot; :: &quot;-l&quot; :: Nil, Path.userHome, &quot;key1&quot; -&gt; value1, &quot;key2&quot; -&gt; value2) ! log
</code></pre><p>Operators are defined to combine commands. These operators start with
<code>#</code> in order to keep the precedence the same and to separate them from
the operators defined elsewhere in <code>sbt</code> for filters. In the following
operator definitions, <code>a</code> and <code>b</code> are subcommands.
</p><ul><li><code>a #&amp;&amp; b</code> Execute <code>a</code>. If the exit code is nonzero, return that exit
code and do not execute b. If the exit code is zero, execute b and
return its exit code.
</li><li><code>a #|| b</code> Execute <code>a</code>. If the exit code is zero, return zero for the
exit code and do not execute b. If the exit code is nonzero, execute
b and return its exit code.
</li><li><code>a #| b</code> Execute <code>a</code> and <code>b</code>, piping the output of <code>a</code> to the input
of b.
</li></ul><p>There are also operators defined for redirecting output to <code>File</code>s and
input from <code>File</code>s and <code>URL</code>s. In the following definitions, <code>url</code> is an
instance of <code>URL</code> and <code>file</code> is an instance of <code>File</code>.
</p><ul><li><code>a #&lt; url</code> or <code>url #&gt; a</code> Use <code>url</code> as the input to <code>a</code>. <code>a</code> may be a
File or a command.
</li><li><code>a #&lt; file</code> or <code>file #&gt; a</code> Use <code>file</code> as the input to <code>a</code>. a may be
a File or a command.
</li><li><code>a #&gt; file</code> or <code>file #&lt; a</code> Write the output of <code>a</code> to <code>file</code>. a may
be a File, URL, or a command.
</li><li><code>a #&gt;&gt; file</code> or <code>file #&lt;&lt; a</code> Append the output of <code>a</code> to file. a may
be a File, URL, or a command.
</li></ul><p>There are some additional methods to get the output from a forked
process into a <code>String</code> or the output lines as a <code>Stream[String]</code>. Here
are some examples, but see the
<a href="../api/sbt/ProcessBuilder.html">ProcessBuilder API</a> for details.
</p><pre><code class="prettyprint lang-scala">val listed: String = &quot;ls&quot; !!
val lines2: Stream[String] = &quot;ls&quot; lines_!
</code></pre><p>Finally, there is a <code>cat</code> method to send the contents of <code>File</code>s and
<code>URL</code>s to standard output.
</p><h4 id="Examples">Examples<a href="#Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Download a <code>URL</code> to a <code>File</code>:
</p><pre><code class="prettyprint lang-scala">url(&quot;http://databinder.net/dispatch/About&quot;) #&gt; file(&quot;About.html&quot;) !
// or
file(&quot;About.html&quot;) #&lt; url(&quot;http://databinder.net/dispatch/About&quot;) !
</code></pre><p>Copy a <code>File</code>:
</p><pre><code class="prettyprint lang-scala">file(&quot;About.html&quot;) #&gt; file(&quot;About_copy.html&quot;) !
// or
file(&quot;About_copy.html&quot;) #&lt; file(&quot;About.html&quot;) !
</code></pre><p>Append the contents of a <code>URL</code> to a <code>File</code> after filtering through
<code>grep</code>:
</p><pre><code class="prettyprint lang-scala">url(&quot;http://databinder.net/dispatch/About&quot;) #&gt; &quot;grep JSON&quot; #&gt;&gt; file(&quot;About_JSON&quot;) !
// or
file(&quot;About_JSON&quot;) #&lt;&lt; ( &quot;grep JSON&quot; #&lt; url(&quot;http://databinder.net/dispatch/About&quot;) )  !
</code></pre><p>Search for uses of <code>null</code> in the source directory:
</p><pre><code class="prettyprint lang-scala">&quot;find src -name *.scala -exec grep null {} ;&quot;  #|  &quot;xargs test -z&quot;  #&amp;&amp;  &quot;echo null-free&quot;  #||  &quot;echo null detected&quot;  !
</code></pre><p>Use <code>cat</code>:
</p><pre><code class="prettyprint lang-scala">val spde = url(&quot;http://technically.us/spde/About&quot;)
val dispatch = url(&quot;http://databinder.net/dispatch/About&quot;)
val build = file(&quot;project/build.properties&quot;)
cat(spde, dispatch, build) #| &quot;grep -i scala&quot; !
</code></pre><h2 id="Running+Project+Code">Running Project Code<a href="#Running+Project+Code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The <code>run</code> and <code>console</code> actions provide a means for running user code in
the same virtual machine as sbt. This page describes the problems with
doing so, how sbt handles these problems, what types of code can use
this feature, and what types of code must use a <a href="Forking.html">forked jvm</a>.
Skip to User Code if you just want to see when you should use a
<a href="Forking.html">forked jvm</a>.
</p><h3 id="Problems">Problems<a href="#Problems" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="System.exit">System.exit<a href="#System.exit" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User code can call <code>System.exit</code>, which normally shuts down the JVM.
Because the <code>run</code> and <code>console</code> actions run inside the same JVM as sbt,
this also ends the build and requires restarting sbt.
</p><h4 id="Threads">Threads<a href="#Threads" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User code can also start other threads. Threads can be left running
after the main method returns. In particular, creating a GUI creates
several threads, some of which may not terminate until the JVM
terminates. The program is not completed until either <code>System.exit</code> is
called or all non-daemon threads terminate.
</p><h4 id="Deserialization+and+class+loading">Deserialization and class loading<a href="#Deserialization+and+class+loading" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>During deserialization, the wrong class loader might be used for various
complex reasons. This can happen in many scenarios, and running under
SBT is just one of them. This is discussed for instance in issues
#163 and #136. The reason is
explained
<a href="http://jira.codehaus.org/browse/GROOVY-1627?focusedCommentId=85900#comment-85900">here</a>.
</p><h3 id="sbt%E2%80%99s+Solutions">sbt’s Solutions<a href="#sbt%E2%80%99s+Solutions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="System.exit">System.exit<a href="#System.exit" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>User code is run with a custom <code>SecurityManager</code> that throws a custom
<code>SecurityException</code> when <code>System.exit</code> is called. This exception is
caught by sbt. sbt then disposes of all top-level windows, interrupts
(not stops) all user-created threads, and handles the exit code. If the
exit code is nonzero, <code>run</code> and <code>console</code> complete unsuccessfully. If
the exit code is zero, they complete normally.
</p><h4 id="Threads">Threads<a href="#Threads" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt makes a list of all threads running before executing user code.
After the user code returns, sbt can then determine the threads created
by the user code. For each user-created thread, sbt replaces the
uncaught exception handler with a custom one that handles the custom
<code>SecurityException</code> thrown by calls to <code>System.exit</code> and delegates to
the original handler for everything else. sbt then waits for each
created thread to exit or for <code>System.exit</code> to be called. sbt handles a
call to <code>System.exit</code> as described above.
</p><p>A user-created thread is one that is not in the <code>system</code> thread group
and is not an <code>AWT</code> implementation thread (e.g. <code>AWT-XAWT</code>,
<code>AWT-Windows</code>). User-created threads include the <code>AWT-EventQueue-*</code>
thread(s).
</p><h4 id="User+Code">User Code<a href="#User+Code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Given the above, when can user code be run with the <code>run</code> and <code>console</code>
actions?
</p><p>The user code cannot rely on shutdown hooks and at least one of the
following situations must apply for user code to run in the same JVM:
</p><ol><li>User code creates no threads.
</li><li>User code creates a GUI and no other threads.
</li><li>The program ends when user-created threads terminate on their own.
</li><li><code>System.exit</code> is used to end the program and user-created threads
terminate when interrupted.
</li><li>No deserialization is done, or the deserialization code avoids
ensures that the right class loader is used, as in
<a href="https://github.com/NetLogo/NetLogo/blob/master/src/main/org/nlogo/util/ClassLoaderObjectInputStream.scala">https://github.com/NetLogo/NetLogo/blob/master/src/main/org/nlogo/util/ClassLoaderObjectInputStream.scala</a>
or
<a href="https://github.com/scala/scala/blob/master/src/actors/scala/actors/remote/JavaSerializer.scala#L20">https://github.com/scala/scala/blob/master/src/actors/scala/actors/remote/JavaSerializer.scala#L20</a>.
</li></ol><p>The requirements on threading and shutdown hooks are required because
the JVM does not actually shut down. So, shutdown hooks cannot be run
and threads are not terminated unless they stop when interrupted. If
these requirements are not met, code must run in a
<a href="Forking.html">forked jvm</a>.
</p><p>The feature of allowing <code>System.exit</code> and multiple threads to be used
cannot completely emulate the situation of running in a separate JVM and
is intended for development. Program execution should be checked in a
<a href="Forking.html">forked jvm</a> when using multiple threads or <code>System.exit</code>.
</p><p>As of sbt 0.13.1, multiple <code>run</code> instances can be managed. There can
only be one application that uses AWT at a time, however.
</p><h2 id="Testing">Testing<a href="#Testing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Basics">Basics<a href="#Basics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The standard source locations for testing are:
</p><ul><li>Scala sources in <code>src/test/scala/</code>
</li><li>Java sources in <code>src/test/java/</code>
</li><li>Resources for the test classpath in <code>src/test/resources/</code>
</li></ul><p>The resources may be accessed from tests by using the <code>getResource</code>
methods of <code>java.lang.Class</code> or <code>java.lang.ClassLoader</code>.
</p><p>The main Scala testing frameworks (
<a href="http://specs2.org/">specs2</a>,
<a href="http://scalacheck.org/">ScalaCheck</a>, and
<a href="http://scalatest.org/">ScalaTest</a>) provide an implementation of the
common test interface and only need to be added to the classpath to work
with sbt. For example, ScalaCheck may be used by declaring it as a
<a href="../tutorial/Library-Dependencies.html">managed dependency</a>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scalacheck&quot; %% &quot;scalacheck&quot; % &quot;1.10.1&quot; % &quot;test&quot;
</code></pre><p>The fourth component <code>&quot;test&quot;</code> is the
<a href="Library-Management.html#ivy-configurations">configuration</a> and means that ScalaCheck will
only be on the test classpath and it isn’t needed by the main sources.
This is generally good practice for libraries because your users don’t
typically need your test dependencies to use your library.
</p><p>With the library dependency defined, you can then add test sources in
the locations listed above and compile and run tests. The tasks for
running tests are <code>test</code> and <code>testOnly</code>. The <code>test</code> task accepts no
command line arguments and runs all tests:
</p><pre><code class="">&gt; test
</code></pre><h4 id="testOnly">testOnly<a href="#testOnly" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>testOnly</code> task accepts a whitespace separated list of test names to
run. For example:
</p><pre><code class="">&gt; testOnly org.example.MyTest1 org.example.MyTest2
</code></pre><p>It supports wildcards as well:
</p><pre><code class="">&gt; testOnly org.example.*Slow org.example.MyTest1
</code></pre><h4 id="testQuick">testQuick<a href="#testQuick" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>testQuick</code> task, like <code>testOnly</code>, allows to filter the tests to run
to specific tests or wildcards using the same syntax to indicate the
filters. In addition to the explicit filter, only the tests that satisfy
one of the following conditions are run:
</p><ul><li>The tests that failed in the previous run
</li><li>The tests that were not run before
</li><li>The tests that have one or more transitive dependencies, maybe in a
different project, recompiled.
</li></ul><h5 id="Tab+completion">Tab completion<a href="#Tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Tab completion is provided for test names based on the results of the
last <code>test:compile</code>. This means that a new sources aren’t available for
tab completion until they are compiled and deleted sources won’t be
removed from tab completion until a recompile. A new test source can
still be manually written out and run using <code>testOnly</code>.
</p><h4 id="Other+tasks">Other tasks<a href="#Other+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Tasks that are available for main sources are generally available for
test sources, but are prefixed with <code>test:</code> on the command line and are
referenced in Scala code with <code>in Test</code>. These tasks include:
</p><ul><li><code>test:compile</code>
</li><li><code>test:console</code>
</li><li><code>test:consoleQuick</code>
</li><li><code>test:run</code>
</li><li><code>test:runMain</code>
</li></ul><p>See <a href="../tutorial/Running.html">Running</a> for details on these tasks.
</p><h3 id="Output">Output<a href="#Output" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, logging is buffered for each test source file until all
tests for that file complete. This can be disabled by setting
<code>logBuffered</code>:
</p><pre><code class="prettyprint lang-scala">logBuffered in Test := false
</code></pre><h4 id="Test+Reports">Test Reports<a href="#Test+Reports" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, sbt will generate JUnit XML test reports for all tests in
the build, located in the <code>target/test-reports</code> directory for a project.
This can be disabled by disabling the <code>JUnitXmlReportPlugin</code>
</p><pre><code class="prettyprint lang-scala">val myProject = project in file(&quot;.&quot;) disablePlugins (plugins.JUnitXmlReportPlugin)  
</code></pre><h3 id="Options">Options<a href="#Options" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Test+Framework+Arguments">Test Framework Arguments<a href="#Test+Framework+Arguments" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Arguments to the test framework may be provided on the command line to
the <code>testOnly</code> tasks following a <code>--</code> separator. For example:
</p><pre><code class="">&gt; testOnly org.example.MyTest -- -d -S
</code></pre><p>To specify test framework arguments as part of the build, add options
constructed by <code>Tests.Argument</code>:
</p><pre><code class="prettyprint lang-scala">testOptions in Test += Tests.Argument(&quot;-d&quot;, &quot;-g&quot;)
</code></pre><p>To specify them for a specific test framework only:
</p><pre><code class="prettyprint lang-scala">testOptions in Test += Tests.Argument(TestFrameworks.ScalaCheck, &quot;-d&quot;, &quot;-g&quot;)
</code></pre><h4 id="Setup+and+Cleanup">Setup and Cleanup<a href="#Setup+and+Cleanup" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Specify setup and cleanup actions using <code>Tests.Setup</code> and
<code>Tests.Cleanup</code>. These accept either a function of type <code>() =&gt; Unit</code> or
a function of type <code>ClassLoader =&gt; Unit</code>. The variant that accepts a
ClassLoader is passed the class loader that is (or was) used for running
the tests. It provides access to the test classes as well as the test
framework classes.
</p><blockquote><p><strong>Note</strong>: When forking, the ClassLoader containing the test classes cannot be
provided because it is in another JVM. Only use the () =&gt; Unit
variants in this case.
</p></blockquote><p>Examples:
</p><pre><code class="prettyprint lang-scala">testOptions in Test += Tests.Setup( () =&gt; println(&quot;Setup&quot;) )

testOptions in Test += Tests.Cleanup( () =&gt; println(&quot;Cleanup&quot;) )

testOptions in Test += Tests.Setup( loader =&gt; ... )

testOptions in Test += Tests.Cleanup( loader =&gt; ... )
</code></pre><h4 id="Disable+Parallel+Execution+of+Tests">Disable Parallel Execution of Tests<a href="#Disable+Parallel+Execution+of+Tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>By default, sbt runs all tasks in parallel. Because each test is mapped
to a task, tests are also run in parallel by default. To make tests
within a given project execute serially: :
</p><pre><code class="prettyprint lang-scala">parallelExecution in Test := false
</code></pre><p><code>Test</code> can be replaced with <code>IntegrationTest</code> to only execute
integration tests serially. Note that tests from different projects may
still execute concurrently.
</p><h4 id="Filter+classes">Filter classes<a href="#Filter+classes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you want to only run test classes whose name ends with “Test”, use
<code>Tests.Filter</code>:
</p><pre><code class="prettyprint lang-scala">testOptions in Test := Seq(Tests.Filter(s =&gt; s.endsWith(&quot;Test&quot;)))
</code></pre><h4 id="Forking+tests">Forking tests<a href="#Forking+tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The setting:
</p><pre><code class="prettyprint lang-scala">fork in Test := true
</code></pre><p>specifies that all tests will be executed in a single external JVM. See
<a href="Forking.html">Forking</a> for configuring standard options for forking. More control
over how tests are assigned to JVMs and what options to pass to those is
available with <code>testGrouping</code> key. For example in build.sbt:
</p><pre><code class="prettyprint lang-scala">import Tests._

{
  def groupByFirst(tests: Seq[TestDefinition]) =
    tests groupBy (_.name(0)) map {
      case (letter, tests) =&gt; new Group(letter.toString, tests, SubProcess(Seq(&quot;-Dfirst.letter&quot;+letter)))
    } toSeq

    testGrouping in Test &lt;&lt;= groupByFirst( (definedTests in Test).value )
}
</code></pre><p>The tests in a single group are run sequentially. Control the number of
forked JVMs allowed to run at the same time by setting the limit on
<code>Tags.ForkedTestGroup</code> tag, which is 1 by default. <code>Setup</code> and <code>Cleanup</code>
actions cannot be provided with the actual test class loader when a
group is forked.
</p><a name="additional-test-configurations"></a><h3 id="Additional+test+configurations">Additional test configurations<a href="#Additional+test+configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>You can add an additional test configuration to have a separate set of
test sources and associated compilation, packaging, and testing tasks
and settings. The steps are:
</p><ul><li>Define the configuration
</li><li>Add the tasks and settings
</li><li>Declare library dependencies
</li><li>Create sources
</li><li>Run tasks
</li></ul><p>The following two examples demonstrate this. The first example shows how
to enable integration tests. The second shows how to define a customized
test configuration. This allows you to define multiple types of tests
per project.
</p><h4 id="Integration+Tests">Integration Tests<a href="#Integration+Tests" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The following full build configuration demonstrates integration tests.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object B extends Build {
  lazy val root =
    Project(&quot;root&quot;, file(&quot;.&quot;)).
      configs( IntegrationTest ).
      settings( Defaults.itSettings : _*).
      settings( libraryDependencies += specs )

  lazy val specs = &quot;org.specs2&quot; %% &quot;specs2&quot; % &quot;2.0&quot; % &quot;it,test&quot;
}
</code></pre><ul><li><code>configs(IntegrationTest)</code> adds the predefined integration test
configuration. This configuration is referred to by the name it.
</li><li><code>settings( Defaults.itSettings : _* )</code> adds compilation, packaging,
and testing actions and settings in the IntegrationTest
configuration.
</li><li><code>settings( libraryDependencies += specs )</code> adds specs to both the
standard test configuration and the integration test configuration
it. To define a dependency only for integration tests, use “it” as
the configuration instead of “it,test”.
</li></ul><p>The standard source hierarchy is used:
</p><ul><li><code>src/it/scala</code> for Scala sources
</li><li><code>src/it/java</code> for Java sources
</li><li><code>src/it/resources</code> for resources that should go on the integration
test classpath
</li></ul><p>The standard testing tasks are available, but must be prefixed with
<code>it:</code>. For example,
</p><pre><code class="">&gt; it:testOnly org.example.AnIntegrationTest
</code></pre><p>Similarly the standard settings may be configured for the
<code>IntegrationTest</code> configuration. If not specified directly, most
<code>IntegrationTest</code> settings delegate to <code>Test</code> settings by default. For
example, if test options are specified as:
</p><pre><code class="prettyprint lang-scala">testOptions in Test += ...
</code></pre><p>then these will be picked up by the <code>Test</code> configuration and in turn by
the <code>IntegrationTest</code> configuration. Options can be added specifically
for integration tests by putting them in the <code>IntegrationTest</code>
configuration:
</p><pre><code class="prettyprint lang-scala">testOptions in IntegrationTest += ...
</code></pre><p>Or, use <code>:=</code> to overwrite any existing options, declaring these to be
the definitive integration test options:
</p><pre><code class="prettyprint lang-scala">testOptions in IntegrationTest := Seq(...)
</code></pre><h4 id="Custom+test+configuration">Custom test configuration<a href="#Custom+test+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The previous example may be generalized to a custom test configuration.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object B extends Build {
  lazy val root =
    Project(&quot;root&quot;, file(&quot;.&quot;)).
      configs( FunTest ).
      settings( inConfig(FunTest)(Defaults.testSettings) : _*).
      settings( libraryDependencies += specs )

  lazy val FunTest = config(&quot;fun&quot;) extend(Test)
  lazy val specs = &quot;org.specs2&quot; %% &quot;specs2&quot; % &quot;2.0&quot; % &quot;fun&quot;
}
</code></pre><p>Instead of using the built-in configuration, we defined a new one:
</p><pre><code class="prettyprint lang-scala">lazy val FunTest = config(&quot;fun&quot;) extend(Test)
</code></pre><p>The <code>extend(Test)</code> part means to delegate to <code>Test</code> for undefined
<code>CustomTest</code> settings. The line that adds the tasks and settings for the
new test configuration is:
</p><pre><code class="prettyprint lang-scala">settings( inConfig(FunTest)(Defaults.testSettings) : _*)
</code></pre><p>This says to add test and settings tasks in the <code>FunTest</code> configuration.
We could have done it this way for integration tests as well. In fact,
<code>Defaults.itSettings</code> is a convenience definition:
<code>val itSettings = inConfig(IntegrationTest)(Defaults.testSettings)</code>.
</p><p>The comments in the integration test section hold, except with
<code>IntegrationTest</code> replaced with <code>FunTest</code> and <code>&quot;it&quot;</code> replaced with
<code>&quot;fun&quot;</code>. For example, test options can be configured specifically for
<code>FunTest</code>:
</p><pre><code class="prettyprint lang-scala">testOptions in FunTest += ...
</code></pre><p>Test tasks are run by prefixing them with <code>fun:</code>
</p><pre><code class="">&gt; fun:test
</code></pre><h4 id="Additional+test+configurations+with+shared+sources">Additional test configurations with shared sources<a href="#Additional+test+configurations+with+shared+sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An alternative to adding separate sets of test sources (and
compilations) is to share sources. In this approach, the sources are
compiled together using the same classpath and are packaged together.
However, different tests are run depending on the configuration.
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object B extends Build {
  lazy val root =
    Project(&quot;root&quot;, file(&quot;.&quot;))
      .configs( FunTest )
      .settings( inConfig(FunTest)(Defaults.testTasks) : _*)
      .settings(
        libraryDependencies += specs,
        testOptions in Test := Seq(Tests.Filter(unitFilter)),
        testOptions in FunTest := Seq(Tests.Filter(itFilter))
      )

  def itFilter(name: String): Boolean = name endsWith &quot;ITest&quot;
  def unitFilter(name: String): Boolean = (name endsWith &quot;Test&quot;) &amp;&amp; !itFilter(name)

  lazy val FunTest = config(&quot;fun&quot;) extend(Test)
  lazy val specs = &quot;org.specs2&quot; %% &quot;specs2&quot; % &quot;2.0&quot; % &quot;test&quot;
}
</code></pre><p>The key differences are:
</p><ul><li>We are now only adding the test tasks
(inConfig(FunTest)(Defaults.testTasks)) and not compilation and
packaging tasks and settings.
</li><li>We filter the tests to be run for each configuration.
</li></ul><p>To run standard unit tests, run <code>test</code> (or equivalently, <code>test:test</code>):
</p><pre><code class="">&gt; test
</code></pre><p>To run tests for the added configuration (here, <code>&quot;fun&quot;</code>), prefix it with
the configuration name as before:
</p><pre><code class="">&gt; fun:test
&gt; fun:testOnly org.example.AFunTest
</code></pre><h5 id="Application+to+parallel+execution">Application to parallel execution<a href="#Application+to+parallel+execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>One use for this shared-source approach is to separate tests that can
run in parallel from those that must execute serially. Apply the
procedure described in this section for an additional configuration.
Let’s call the configuration <code>serial</code>:
</p><pre><code class="prettyprint lang-scala">lazy val Serial = config(&quot;serial&quot;) extend(Test)
</code></pre><p>Then, we can disable parallel execution in just that configuration
using:
</p><pre><code class="prettyprint lang-scala">parallelExecution in Serial := false
</code></pre><p>The tests to run in parallel would be run with <code>test</code> and the ones to
run in serial would be run with <code>serial:test</code>.
</p><h3 id="JUnit">JUnit<a href="#JUnit" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Support for JUnit is provided by
<a href="https://github.com/szeiger/junit-interface">junit-interface</a>. To add
JUnit support into your project, add the junit-interface dependency in
your project’s main build.sbt file.
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;com.novocode&quot; % &quot;junit-interface&quot; % &quot;0.9&quot; % &quot;test&quot;
</code></pre><h3 id="Extensions">Extensions<a href="#Extensions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This page describes adding support for additional testing libraries and
defining additional test reporters. You do this by implementing <code>sbt</code>
interfaces (described below). If you are the author of the testing
framework, you can depend on the test interface as a provided
dependency. Alternatively, anyone can provide support for a test
framework by implementing the interfaces in a separate project and
packaging the project as an sbt <a href="Plugins.html">Plugin</a>.
</p><h4 id="Custom+Test+Framework">Custom Test Framework<a href="#Custom+Test+Framework" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The main Scala testing libraries have built-in support for sbt. To add
support for a different framework, implement the
<a href="http://github.com/sbt/test-interface">uniform test interface</a>.
</p><h4 id="Custom+Test+Reporters">Custom Test Reporters<a href="#Custom+Test+Reporters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Test frameworks report status and results to test reporters. You can
create a new test reporter by implementing either
<a href="../api/sbt/TestReportListener.html">TestReportListener</a> or
<a href="../api/sbt/TestsListener.html">TestsListener</a>.
</p><h4 id="Using+Extensions">Using Extensions<a href="#Using+Extensions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To use your extensions in a project definition:
</p><p>Modify the <code>testFrameworks</code> setting to reference your test framework:
</p><pre><code class="prettyprint lang-scala">testFrameworks += new TestFramework(&quot;custom.framework.ClassName&quot;)
</code></pre><p>Specify the test reporters you want to use by overriding the
<code>testListeners</code> setting in your project definition.
</p><pre><code class="prettyprint lang-scala">testListeners += customTestListener
</code></pre><p>where <code>customTestListener</code> is of type <code>sbt.TestReportListener</code>.
</p><h2 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="../tutorial/index.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Artifacts">Artifacts<a href="#Artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Selecting+default+artifacts">Selecting default artifacts<a href="#Selecting+default+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, the published artifacts are the main binary jar, a jar
containing the main sources and resources, and a jar containing the API
documentation. You can add artifacts for the test classes, sources, or
API or you can disable some of the main artifacts.
</p><p>To add all test artifacts:
</p><pre><code class="prettyprint lang-scala">publishArtifact in Test := true
</code></pre><p>To add them individually:
</p><pre><code class="prettyprint lang-scala">// enable publishing the jar produced by `test:package`
publishArtifact in (Test, packageBin) := true

// enable publishing the test API jar
publishArtifact in (Test, packageDoc) := true

// enable publishing the test sources jar
publishArtifact in (Test, packageSrc) := true
</code></pre><p>To disable main artifacts individually:
</p><pre><code class="prettyprint lang-scala">// disable publishing the main jar produced by `package`
publishArtifact in (Compile, packageBin) := false

// disable publishing the main API jar
publishArtifact in (Compile, packageDoc) := false

// disable publishing the main sources jar
publishArtifact in (Compile, packageSrc) := false
</code></pre><h3 id="Modifying+default+artifacts">Modifying default artifacts<a href="#Modifying+default+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Each built-in artifact has several configurable settings in addition to
<code>publishArtifact</code>. The basic ones are <code>artifact</code> (of type
<code>SettingKey[Artifact]</code>), <code>mappings</code> (of type <code>TaskKey[(File,String)]</code>),
and <code>artifactPath</code> (of type <code>SettingKey[File]</code>). They are scoped by
<code>(&lt;config&gt;, &lt;task&gt;)</code> as indicated in the previous section.
</p><p>To modify the type of the main artifact, for example:
</p><pre><code class="prettyprint lang-scala">artifact in (Compile, packageBin) := {
  val previous: Artifact = (artifact in (Compile, packageBin)).value
  previous.copy(`type` = &quot;bundle&quot;)
}
</code></pre><p>The generated artifact name is determined by the <code>artifactName</code> setting.
This setting is of type <code>(ScalaVersion, ModuleID, Artifact) =&gt; String</code>.
The ScalaVersion argument provides the full Scala version String and the
binary compatible part of the version String. The String result is the
name of the file to produce. The default implementation is
<code>Artifact.artifactName _</code>. The function may be modified to produce
different local names for artifacts without affecting the published
name, which is determined by the <code>artifact</code> definition combined with the
repository pattern.
</p><p>For example, to produce a minimal name without a classifier or cross
path:
</p><pre><code class="prettyprint lang-scala">artifactName := { (sv: ScalaVersion, module: ModuleID, artifact: Artifact) =&gt;
  artifact.name + &quot;-&quot; + module.revision + &quot;.&quot; + artifact.extension
}
</code></pre><p>(Note that in practice you rarely want to drop the classifier.)
</p><p>Finally, you can get the <code>(Artifact, File)</code> pair for the artifact by
mapping the <code>packagedArtifact</code> task. Note that if you don’t need the
<code>Artifact</code>, you can get just the File from the package task (<code>package</code>,
<code>packageDoc</code>, or <code>packageSrc</code>). In both cases, mapping the task to get
the file ensures that the artifact is generated first and so the file is
guaranteed to be up-to-date.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">val myTask = taskKey[Unit](&quot;My task.&quot;)

myTask :=  {
  val (art, file) = packagedArtifact.in(Compile, packageBin).value
  println(&quot;Artifact definition: &quot; + art)
  println(&quot;Packaged file: &quot; + file.getAbsolutePath)
}
</code></pre><h3 id="Defining+custom+artifacts">Defining custom artifacts<a href="#Defining+custom+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to configuring the built-in artifacts, you can declare other
artifacts to publish. Multiple artifacts are allowed when using Ivy
metadata, but a Maven POM file only supports distinguishing artifacts
based on classifiers and these are not recorded in the POM.
</p><p>Basic <code>Artifact</code> construction look like:
</p><pre><code class="prettyprint lang-scala">Artifact(&quot;name&quot;, &quot;type&quot;, &quot;extension&quot;)
Artifact(&quot;name&quot;, &quot;classifier&quot;)
Artifact(&quot;name&quot;, url: URL)
Artifact(&quot;name&quot;, Map(&quot;extra1&quot; -&gt; &quot;value1&quot;, &quot;extra2&quot; -&gt; &quot;value2&quot;))
</code></pre><p>For example:
</p><pre><code class="prettyprint lang-scala">Artifact(&quot;myproject&quot;, &quot;zip&quot;, &quot;zip&quot;)
Artifact(&quot;myproject&quot;, &quot;image&quot;, &quot;jpg&quot;)
Artifact(&quot;myproject&quot;, &quot;jdk15&quot;)
</code></pre><p>See the
<a href="http://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency-artifact.html">Ivy documentation</a>
for more details on artifacts. See the
<a href="../api/sbt/Artifact$.html">Artifact API</a> for combining the
parameters above and specifying [Configurations] and extra attributes.
</p><p>To declare these artifacts for publishing, map them to the task that
generates the artifact:
</p><pre><code class="prettyprint lang-scala">val myImageTask = taskKey[File](...)

myImageTask := {
  val artifact: File = makeArtifact(...)
  artifact
}

addArtifact( Artifact(&quot;myproject&quot;, &quot;image&quot;, &quot;jpg&quot;), myImageTask )
</code></pre><p><code>addArtifact</code> returns a sequence of settings (wrapped in a
<a href="../api/#sbt.Init$SettingsDefinition">SettingsDefinition</a>). In a
full build configuration, usage looks like:
</p><pre><code class="prettyprint lang-scala">...
lazy val proj = Project(...).
  settings( addArtifact(...).settings : _* )
...
</code></pre><h3 id="Publishing+.war+files">Publishing .war files<a href="#Publishing+.war+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A common use case for web applications is to publish the <code>.war</code> file
instead of the <code>.jar</code> file.
</p><pre><code class="prettyprint lang-scala">// disable .jar publishing 
publishArtifact in (Compile, packageBin) := false 

// create an Artifact for publishing the .war file 
artifact in (Compile, packageWar) := {
  val previous: Artifact = (artifact in (Compile, packageWar)).value
  previous.copy(`type` = &quot;war&quot;, extension = &quot;war&quot;) 
} 

// add the .war file to what gets published 
addArtifact(artifact in (Compile, packageWar), packageWar) 
</code></pre><h3 id="Using+dependencies+with+artifacts">Using dependencies with artifacts<a href="#Using+dependencies+with+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To specify the artifacts to use from a dependency that has custom or
multiple artifacts, use the <code>artifacts</code> method on your dependencies. For
example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org&quot; % &quot;name&quot; % &quot;rev&quot; artifacts(Artifact(&quot;name&quot;, &quot;type&quot;, &quot;ext&quot;))
</code></pre><p>The <code>from</code> and <code>classifer</code> methods (described on the
<a href="Library-Management.html">Library Management</a> page) are actually convenience
methods that translate to <code>artifacts</code>:
</p><pre><code class="prettyprint lang-scala">def from(url: String) = artifacts( Artifact(name, new URL(url)) )
def classifier(c: String) = artifacts( Artifact(name, c) )
</code></pre><p>That is, the following two dependency declarations are equivalent:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.testng&quot; % &quot;testng&quot; % &quot;5.7&quot; classifier &quot;jdk15&quot;

libraryDependencies += &quot;org.testng&quot; % &quot;testng&quot; % &quot;5.7&quot; artifacts(Artifact(&quot;testng&quot;, &quot;jdk15&quot;) )
</code></pre><h2 id="Dependency+Management+Flow">Dependency Management Flow<a href="#Dependency+Management+Flow" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>sbt 0.12.1 addresses several issues with dependency management. These fixes
were made possible by specific, reproducible examples, such as a
situation where the resolution cache got out of date (gh-532). A brief
summary of the current work flow with dependency management in sbt
follows.
</p><h3 id="Background">Background<a href="#Background" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p><code>update</code> resolves dependencies according to the settings in a build
file, such as <code>libraryDependencies</code> and <code>resolvers</code>. Other tasks use the
output of <code>update</code> (an <code>UpdateReport</code>) to form various classpaths. Tasks
that in turn use these classpaths, such as <code>compile</code> or <code>run</code>, thus
indirectly depend on <code>update</code>. This means that before <code>compile</code> can run,
the <code>update</code> task needs to run. However, resolving dependencies on every
<code>compile</code> would be unnecessarily slow and so <code>update</code> must be particular
about when it actually performs a resolution.
</p><h3 id="Caching+and+Configuration">Caching and Configuration<a href="#Caching+and+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Normally, if no dependency management configuration has changed
since the last successful resolution and the retrieved files are
still present, sbt does not ask Ivy to perform resolution.
</li><li>Changing the configuration, such as adding or removing dependencies
or changing the version or other attributes of a dependency, will
automatically cause resolution to be performed. Updates to locally
published dependencies should be detected in sbt 0.12.1 and later
and will force an update. Dependent tasks like compile and run will
get updated classpaths.
</li><li>Directly running the <code>update</code> task (as opposed to a task that
depends on it) will force resolution to run, whether or not
configuration changed. This should be done in order to refresh
remote SNAPSHOT dependencies.
</li><li>When <code>offline := true</code>, remote SNAPSHOTs will not be updated by a
resolution, even an explicitly requested update. This should
effectively support working without a connection to remote
repositories. Reproducible examples demonstrating otherwise are
appreciated. Obviously, update must have successfully run before
going offline.
</li><li>Overriding all of the above, <code>skip in update := true</code> will tell sbt
to never perform resolution. Note that this can cause dependent
tasks to fail. For example, compilation may fail if jars have been
deleted from the cache (and so needed classes are missing) or a
dependency has been added (but will not be resolved because skip is
true). Also, update itself will immediately fail if resolution has
not been allowed to run since the last clean.
</li></ol><h3 id="General+troubleshooting+steps">General troubleshooting steps<a href="#General+troubleshooting+steps" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A.  Run <code>update</code> explicitly. This will typically fix problems with out
    of date SNAPSHOTs or locally published artifacts.
B.  If a file cannot be found, look at the output of update to see where
    Ivy is looking for the file. This may help diagnose an incorrectly
    defined dependency or a dependency that is actually not present in a
    repository.
C.  <code>last update</code> contains more information about the most recent
    resolution and download. The amount of debugging output from Ivy is
    high, so you may want to use lastGrep (run help lastGrep for usage).
D.  Run <code>clean</code> and then <code>update</code>. If this works, it could indicate a
    bug in sbt, but the problem would need to be reproduced in order to
    diagnose and fix it.
E.  Before deleting all of the Ivy cache, first try deleting files in
    <code>~/.ivy2/cache</code> related to problematic dependencies. For example, if
    there are problems with dependency <code>&quot;org.example&quot; % &quot;demo&quot; % &quot;1.0&quot;</code>,
    delete <code>~/.ivy2/cache/org.example/demo/1.0/</code> and retry update. This
    avoids needing to redownload all dependencies.
F.  Normal sbt usage should not require deleting files from
    <code>~/.ivy2/cache</code>, especially if the first four steps have been
    followed. If deleting the cache fixes a dependency management issue,
    please try to reproduce the issue and submit a test case.
</p><h3 id="Plugins">Plugins<a href="#Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>These troubleshooting steps can be run for plugins by changing to the
build definition project, running the commands, and then returning to
the main project. For example:
</p><pre><code class="">&gt; reload plugins
&gt; update
&gt; reload return
</code></pre><h3 id="Notes">Notes<a href="#Notes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A.  Configure offline behavior for all projects on a machine by putting
    <code>offline := true</code> in <code>~/.sbt/0.13/global.sbt</code>. A command that does this for
    the user would make a nice pull request. Perhaps the setting of
    offline should go into the output of about or should it be a warning
    in the output of update or both?
B.  The cache improvements in 0.12.1 address issues in the change
    detection for update so that it will correctly re-resolve
    automatically in more situations. A problem with an out of date
    cache can usually be attributed to a bug in that change detection if
    explicitly running update fixes the problem.
C.  A common solution to dependency management problems in sbt has been
    to remove <code>~/.ivy2/cache</code>. Before doing this with 0.12.1, be sure to
    follow the steps in the troubleshooting section first. In
    particular, verify that a clean and an explicit update do not solve
    the issue.
D.  There is no need to mark SNAPSHOT dependencies as <code>changing()</code>
    because sbt configures Ivy to know this already.
</p><h2 id="Library+Management">Library Management<a href="#Library+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There’s now a
<a href="../tutorial/Library-Dependencies.html">getting started page</a> about
library management, which you may want to read first.
</p><p><em>Documentation Maintenance Note:</em> it would be nice to remove the overlap
between this page and the getting started page, leaving this page with
the more advanced topics such as checksums and external Ivy files.
</p><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are two ways for you to manage libraries with sbt: manually or
automatically. These two ways can be mixed as well. This page discusses
the two approaches. All configurations shown here are settings that go
either directly in a
<a href="../tutorial/Basic-Def.html">.sbt file</a> or are
appended to the <code>settings</code> of a Project in a
<a href="../tutorial/Full-Def.html">.scala file</a>.
</p><h3 id="Manual+Dependency+Management">Manual Dependency Management<a href="#Manual+Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Manually managing dependencies involves copying any jars that you want
to use to the <code>lib</code> directory. sbt will put these jars on the classpath
during compilation, testing, running, and when using the interpreter.
You are responsible for adding, removing, updating, and otherwise
managing the jars in this directory. No modifications to your project
definition are required to use this method unless you would like to
change the location of the directory you store the jars in.
</p><p>To change the directory jars are stored in, change the <code>unmanagedBase</code>
setting in your project definition. For example, to use <code>custom_lib/</code>:
</p><pre><code class="prettyprint lang-scala">unmanagedBase := baseDirectory.value / &quot;custom_lib&quot;
</code></pre><p>If you want more control and flexibility, override the <code>unmanagedJars</code>
task, which ultimately provides the manual dependencies to sbt. The
default implementation is roughly:
</p><pre><code class="prettyprint lang-scala">unmanagedJars in Compile := (baseDirectory.value ** &quot;*.jar&quot;).classpath
</code></pre><p>If you want to add jars from multiple directories in addition to the
default directory, you can do:
</p><pre><code class="prettyprint lang-scala">unmanagedJars in Compile ++= {
    val base = baseDirectory.value
    val baseDirectories = (base / &quot;libA&quot;) +++ (base / &quot;b&quot; / &quot;lib&quot;) +++ (base / &quot;libC&quot;)
    val customJars = (baseDirectories ** &quot;*.jar&quot;) +++ (base / &quot;d&quot; / &quot;my.jar&quot;)
    customJars.classpath
}
</code></pre><p>See <a href="Paths.html">Paths</a> for more information on building up paths.
</p><h3 id="Automatic+Dependency+Management">Automatic Dependency Management<a href="#Automatic+Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This method of dependency management involves specifying the direct
dependencies of your project and letting sbt handle retrieving and
updating your dependencies. sbt supports three ways of specifying these
dependencies:
</p><ul><li>Declarations in your project definition
</li><li>Maven POM files (dependency definitions only: no repositories)
</li><li>Ivy configuration and settings files
</li></ul><p>sbt uses <a href="http://ant.apache.org/ivy/">Apache Ivy</a> to implement
dependency management in all three cases. The default is to use inline
declarations, but external configuration can be explicitly selected. The
following sections describe how to use each method of automatic
dependency management.
</p><h4 id="Inline+Declarations">Inline Declarations<a href="#Inline+Declarations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Inline declarations are a basic way of specifying the dependencies to be
automatically retrieved. They are intended as a lightweight alternative
to a full configuration using Ivy.
</p><h5 id="Dependencies">Dependencies<a href="#Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Declaring a dependency looks like:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID % artifactID % revision % configuration
</code></pre><p>See <a href="#ivy-configurations">configurations</a> for details on configuration
mappings. Also, several dependencies can be declared together:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  groupID %% artifactID % revision,
  groupID %% otherID % otherRevision
)
</code></pre><p>If you are using a dependency that was built with sbt, double the first
<code>%</code> to be <code>%%</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += groupID %% artifactID % revision
</code></pre><p>This will use the right jar for the dependency built with the version of
Scala that you are currently using. If you get an error while resolving
this kind of dependency, that dependency probably wasn’t published for
the version of Scala you are using. See <a href="Cross-Build.html">Cross Build</a> for details.
</p><p>Ivy can select the latest revision of a module according to constraints
you specify. Instead of a fixed revision like <code>&quot;1.6.1&quot;</code>, you specify
<code>&quot;latest.integration&quot;</code>, <code>&quot;2.9.+&quot;</code>, or <code>&quot;[1.0,)&quot;</code>. See the
<a href="http://ant.apache.org/ivy/history/2.3.0/ivyfile/dependency.html#revision">Ivy revisions</a>
documentation for details.
</p><h5 id="Resolvers">Resolvers<a href="#Resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt uses the standard Maven2 repository by default.
</p><p>Declare additional repositories with the form:
</p><pre><code class="prettyprint lang-scala">resolvers += name at location
</code></pre><p>For example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
    &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;,
    &quot;org.specs&quot; % &quot;specs&quot; % &quot;1.6.1&quot;
)

resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>sbt can search your local Maven repository if you add it as a
repository:
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.absolutePath+&quot;/.m2/repository&quot;
</code></pre><p>See <a href="Resolvers.html">Resolvers</a> for details on defining other types of repositories.
</p><h5 id="Override+default+resolvers">Override default resolvers<a href="#Override+default+resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>resolvers</code> configures additional, inline user resolvers. By default,
<code>sbt</code> combines these resolvers with default repositories (Maven Central
and the local Ivy repository) to form <code>externalResolvers</code>. To have more
control over repositories, set <code>externalResolvers</code> directly. To only
specify repositories in addition to the usual defaults, configure
<code>resolvers</code>.
</p><p>For example, to use the Sonatype OSS Snapshots repository in addition to
the default repositories,
</p><pre><code class="prettyprint lang-scala">resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>To use the local repository, but not the Maven Central repository:
</p><pre><code class="prettyprint lang-scala">externalResolvers := Resolver.withDefaultResolvers(resolvers.value, mavenCentral = false)
</code></pre><h5 id="Override+all+resolvers+for+all+builds">Override all resolvers for all builds<a href="#Override+all+resolvers+for+all+builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The repositories used to retrieve sbt, Scala, plugins, and application
dependencies can be configured globally and declared to override the
resolvers configured in a build or plugin definition. There are two
parts:
</p><ol><li>Define the repositories used by the launcher.
</li><li>Specify that these repositories should override those in build
definitions.
</li></ol><p>The repositories used by the launcher can be overridden by defining
<code>~/.sbt/repositories</code>, which must contain a <code>[repositories]</code> section
with the same format as the <code>Launcher</code> configuration file. For example:
</p><pre><code class="">[repositories]
local
my-maven-repo: http://example.org/repo
my-ivy-repo: http://example.org/ivy-repo/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre><p>A different location for the repositories file may be specified by the
<code>sbt.repository.config</code> system property in the sbt startup script. The
final step is to set <code>sbt.override.build.repos</code> to true to use these
repositories for dependency resolution and retrieval.
</p><h5 id="Explicit+URL">Explicit URL<a href="#Explicit+URL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>If your project requires a dependency that is not present in a
repository, a direct URL to its jar can be specified as follows:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;slinky&quot; % &quot;slinky&quot; % &quot;2.1&quot; from &quot;http://slinky2.googlecode.com/svn/artifacts/2.1/slinky.jar&quot;
</code></pre><p>The URL is only used as a fallback if the dependency cannot be found
through the configured repositories. Also, the explicit URL is not
included in published metadata (that is, the pom or ivy.xml).
</p><h5 id="Disable+Transitivity">Disable Transitivity<a href="#Disable+Transitivity" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>By default, these declarations fetch all project dependencies,
transitively. In some instances, you may find that the dependencies
listed for a project aren’t necessary for it to build. Projects using
the Felix OSGI framework, for instance, only explicitly require its main
jar to compile and run. Avoid fetching artifact dependencies with either
<code>intransitive()</code> or <code>notTransitive()</code>, as in this example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.apache.felix&quot; % &quot;org.apache.felix.framework&quot; % &quot;1.8.0&quot; intransitive()
</code></pre><h5 id="Classifiers">Classifiers<a href="#Classifiers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>You can specify the classifier for a dependency using the <code>classifier</code>
method. For example, to get the jdk15 version of TestNG:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.testng&quot; % &quot;testng&quot; % &quot;5.7&quot; classifier &quot;jdk15&quot;
</code></pre><p>For multiple classifiers, use multiple <code>classifier</code> calls:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += 
  &quot;org.lwjgl.lwjgl&quot; % &quot;lwjgl-platform&quot; % lwjglVersion classifier &quot;natives-windows&quot; classifier &quot;natives-linux&quot; classifier &quot;natives-osx&quot;
</code></pre><p>To obtain particular classifiers for all dependencies transitively, run
the <code>updateClassifiers</code> task. By default, this resolves all artifacts
with the <code>sources</code> or <code>javadoc</code> classifier. Select the classifiers to
obtain by configuring the <code>transitiveClassifiers</code> setting. For example,
to only retrieve sources:
</p><pre><code class="prettyprint lang-scala">transitiveClassifiers := Seq(&quot;sources&quot;)
</code></pre><h5 id="Exclude+Transitive+Dependencies">Exclude Transitive Dependencies<a href="#Exclude+Transitive+Dependencies" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>To exclude certain transitive dependencies of a dependency, use the
<code>excludeAll</code> or <code>exclude</code> methods. The <code>exclude</code> method should be used
when a pom will be published for the project. It requires the
organization and module name to exclude. For example,
</p><pre><code class="prettyprint lang-scala">libraryDependencies += 
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.15&quot; exclude(&quot;javax.jms&quot;, &quot;jms&quot;)
</code></pre><p>The <code>excludeAll</code> method is more flexible, but because it cannot be
represented in a pom.xml, it should only be used when a pom doesn’t need
to be generated. For example,
</p><pre><code class="prettyprint lang-scala">libraryDependencies +=
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.15&quot; excludeAll(
    ExclusionRule(organization = &quot;com.sun.jdmk&quot;),
    ExclusionRule(organization = &quot;com.sun.jmx&quot;),
    ExclusionRule(organization = &quot;javax.jms&quot;)
  )
</code></pre><p>See <a href="../api/sbt/ModuleID.html">ModuleID</a> for API details.
</p><h5 id="Download+Sources">Download Sources<a href="#Download+Sources" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Downloading source and API documentation jars is usually handled by an
IDE plugin. These plugins use the <code>updateClassifiers</code> and
<code>updateSbtClassifiers</code> tasks, which produce an <code>Update-Report</code>
referencing these jars.
</p><p>To have sbt download the dependency’s sources without using an IDE
plugin, add <code>withSources()</code> to the dependency definition. For API jars,
add <code>withJavadoc()</code>. For example:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += 
  &quot;org.apache.felix&quot; % &quot;org.apache.felix.framework&quot; % &quot;1.8.0&quot; withSources() withJavadoc()
</code></pre><p>Note that this is not transitive. Use the <code>update-*classifiers</code> tasks
for that.
</p><h5 id="Extra+Attributes">Extra Attributes<a href="#Extra+Attributes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><a href="http://ant.apache.org/ivy/history/2.3.0/concept.html#extra">Extra attributes</a>
can be specified by passing key/value pairs to the <code>extra</code> method.
</p><p>To select dependencies by extra attributes:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org&quot; % &quot;name&quot; % &quot;rev&quot; extra(&quot;color&quot; -&gt; &quot;blue&quot;)
</code></pre><p>To define extra attributes on the current project:
</p><pre><code class="prettyprint lang-scala">projectID := {
    val previous = projectID.value
    previous.extra(&quot;color&quot; -&gt; &quot;blue&quot;, &quot;component&quot; -&gt; &quot;compiler-interface&quot;)
}
</code></pre><h5 id="Inline+Ivy+XML">Inline Ivy XML<a href="#Inline+Ivy+XML" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt additionally supports directly specifying the configurations or
dependencies sections of an Ivy configuration file inline. You can mix
this with inline Scala dependency and repository declarations.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">ivyXML :=
  &lt;dependencies&gt;
    &lt;dependency org=&quot;javax.mail&quot; name=&quot;mail&quot; rev=&quot;1.4.2&quot;&gt;
      &lt;exclude module=&quot;activation&quot;/&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre><h5 id="Ivy+Home+Directory">Ivy Home Directory<a href="#Ivy+Home+Directory" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>By default, sbt uses the standard Ivy home directory location
<code>${user.home}/.ivy2/</code>. This can be configured machine-wide, for use by
both the sbt launcher and by projects, by setting the system property
<code>sbt.ivy.home</code> in the sbt startup script (described in
<a href="../tutorial/Setup.html">Setup</a>).
</p><p>For example:
</p><pre><code class="">java -Dsbt.ivy.home=/tmp/.ivy2/ ...
</code></pre><h5 id="Checksums">Checksums<a href="#Checksums" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>sbt
(<a href="http://ant.apache.org/ivy/history/latest-milestone/concept.html#checksum">through Ivy</a>)
verifies the checksums of downloaded files by default. It also publishes
checksums of artifacts by default. The checksums to use are specified by
the <em>checksums</em> setting.
</p><p>To disable checksum checking during update:
</p><pre><code class="prettyprint lang-scala">checksums in update := Nil
</code></pre><p>To disable checksum creation during artifact publishing:
</p><pre><code class="prettyprint lang-scala">checksums in publishLocal := Nil

checksums in publish := Nil
</code></pre><p>The default value is:
</p><pre><code class="prettyprint lang-scala">checksums := Seq(&quot;sha1&quot;, &quot;md5&quot;)
</code></pre><a name="conflict-management"></a><h5 id="Conflict+Management">Conflict Management<a href="#Conflict+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The conflict manager decides what to do when dependency resolution
brings in different versions of the same library. By default, the latest
revision is selected. This can be changed by setting <code>conflictManager</code>,
which has type <a href="../api/sbt/ConflictManager.html">ConflictManager</a>.
See the
<a href="http://ant.apache.org/ivy/history/latest-milestone/settings/conflict-managers.html">Ivy documentation</a>
for details on the different conflict managers. For example, to specify
that no conflicts are allowed,
</p><pre><code class="prettyprint lang-scala">conflictManager := ConflictManager.strict
</code></pre><p>With this set, any conflicts will generate an error. To resolve a
conflict,
</p><blockquote><ul><li>configure a dependency override if the conflict is for a
transitive dependency
</li><li>force the revision if it is a direct dependency
</li></ul></blockquote><p>Both are explained in the following sections.
</p><h5 id="Forcing+a+revision">Forcing a revision<a href="#Forcing+a+revision" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The following direct dependencies will introduce a conflict on the log4j
version because spark requires log4j 1.2.16.
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  &quot;org.spark-project&quot; %% &quot;spark-core&quot; % &quot;0.5.1&quot;,
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.14&quot;
)
</code></pre><p>The default conflict manager will select the newer version of log4j,
1.2.16. This can be confirmed in the output of <code>show update</code>, which
shows the newer version as being selected and the older version as not
selected:
</p><pre><code class="">&gt; show update
[info] compile:
[info]    log4j:log4j:1.2.16: ...
...
[info]    (EVICTED) log4j:log4j:1.2.14
...
</code></pre><p>To say that we prefer the version we’ve specified over the version from
indirect dependencies, use <code>force()</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
  &quot;org.spark-project&quot; %% &quot;spark-core&quot; % &quot;0.5.1&quot;,
  &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.14&quot; force()
)
</code></pre><p>The output of <code>show update</code> is now reversed:
</p><pre><code class="">&gt; show update
[info] compile:
[info]    log4j:log4j:1.2.14: ...
...
[info]    (EVICTED) log4j:log4j:1.2.16
...
</code></pre><p><strong>Note:</strong> this is an Ivy-only feature and cannot be included in a
published pom.xml.
</p><h5 id="Forcing+a+revision+without+introducing+a+dependency">Forcing a revision without introducing a dependency<a href="#Forcing+a+revision+without+introducing+a+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Use of the <code>force()</code> method described in the previous section requires
having a direct dependency. However, it may be desirable to force a
revision without introducing that direct dependency. Ivy provides
overrides for this and in sbt, overrides are configured in sbt with the
<code>dependencyOverrides</code> setting, which is a set of <code>ModuleIDs</code>. For
example, the following dependency definitions conflict because spark
uses log4j 1.2.16 and scalaxb uses log4j 1.2.17:
</p><pre><code class="prettyprint lang-scala">libraryDependencies ++= Seq(
   &quot;org.spark-project&quot; %% &quot;spark-core&quot; % &quot;0.5.1&quot;,
   &quot;org.scalaxb&quot; %% &quot;scalaxb&quot; % &quot;1.0.0&quot;
)
</code></pre><p>The default conflict manager chooses the latest revision of log4j,
1.2.17:
</p><pre><code class="">&gt; show update
[info] compile:
[info]    log4j:log4j:1.2.17: ...
...
[info]    (EVICTED) log4j:log4j:1.2.16
...
</code></pre><p>To change the version selected, add an override:
</p><pre><code class="prettyprint lang-scala">dependencyOverrides += &quot;log4j&quot; % &quot;log4j&quot; % &quot;1.2.16&quot;
</code></pre><p>This will not add a direct dependency on log4j, but will force the
revision to be 1.2.16. This is confirmed by the output of <code>show update</code>:
</p><pre><code class="">&gt; show update
[info] compile:
[info]    log4j:log4j:1.2.16
...
</code></pre><blockquote><p><strong>Note:</strong> this is an Ivy-only feature and will not be included in a
published pom.xml.
</p></blockquote><h5 id="Publishing">Publishing<a href="#Publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>See <a href="Publishing.html">Publishing</a> for how to publish your project.
</p><a name="ivy-configurations"></a><h5 id="Configurations">Configurations<a href="#Configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Ivy configurations are a useful feature for your build when you need
custom groups of dependencies, such as for a plugin. Ivy configurations
are essentially named sets of dependencies. You can read the
<a href="http://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html">Ivy documentation</a>
for details.
</p><p>The built-in use of configurations in sbt is similar to scopes in Maven.
sbt adds dependencies to different classpaths by the configuration that
they are defined in. See the description of
<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">Maven Scopes</a>
for details.
</p><p>You put a dependency in a configuration by selecting one or more of its
configurations to map to one or more of your project’s configurations.
The most common case is to have one of your configurations <code>A</code> use a
dependency’s configuration <code>B</code>. The mapping for this looks like
<code>&quot;A-&gt;B&quot;</code>. To apply this mapping to a dependency, add it to the end of
your dependency definition:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;2.1.3&quot; % &quot;test-&gt;compile&quot;
</code></pre><p>This says that your project’s <code>&quot;test&quot;</code> configuration uses <code>ScalaTest</code>’s
<code>&quot;compile&quot;</code> configuration. See the
<a href="http://ant.apache.org/ivy/history/2.3.0/tutorial/conf.html">Ivy documentation</a>
for more advanced mappings. Most projects published to Maven
repositories will use the <code>&quot;compile&quot;</code> configuration.
</p><p>A useful application of configurations is to group dependencies that are
not used on normal classpaths. For example, your project might use a
<code>&quot;js&quot;</code> configuration to automatically download jQuery and then include
it in your jar by modifying <code>resources</code>. For example:
</p><pre><code class="prettyprint lang-scala">ivyConfigurations += config(&quot;js&quot;) hide

libraryDependencies += &quot;jquery&quot; % &quot;jquery&quot; % &quot;1.3.2&quot; % &quot;js-&gt;default&quot; from &quot;http://jqueryjs.googlecode.com/files/jquery-1.3.2.min.js&quot;

resources ++= update.value.select(configurationFilter(&quot;js&quot;))
</code></pre><p>The <code>config</code> method defines a new configuration with name <code>&quot;js&quot;</code> and
makes it private to the project so that it is not used for publishing.
See <a href="Update-Report.html">Update Report</a> for more information on selecting
managed artifacts.
</p><p>A configuration without a mapping (no <code>&quot;-&gt;&quot;</code>) is mapped to <code>&quot;default&quot;</code>
or <code>&quot;compile&quot;</code>. The <code>-&gt;</code> is only needed when mapping to a different
configuration than those. The ScalaTest dependency above can then be
shortened to:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scalatest&quot; %% &quot;scalatest&quot; % &quot;2.1.3&quot; % &quot;test&quot;
</code></pre><h4 id="Maven%2FIvy">Maven/Ivy<a href="#Maven%2FIvy" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>For this method, create the configuration files as you would for Maven
(<code>pom.xml</code>) or Ivy (<code>ivy.xml</code> and optionally <code>ivysettings.xml</code>).
External configuration is selected by using one of the following
expressions.
</p><h5 id="Ivy+settings+%28resolver+configuration%29">Ivy settings (resolver configuration)<a href="#Ivy+settings+%28resolver+configuration%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><pre><code class="prettyprint lang-scala">externalIvySettings()
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">externalIvySettings(baseDirectory.value / &quot;custom-settings-name.xml&quot;)
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">externalIvySettingsURL(url(&quot;your_url_here&quot;))
</code></pre><h5 id="Ivy+file+%28dependency+configuration%29">Ivy file (dependency configuration)<a href="#Ivy+file+%28dependency+configuration%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><pre><code class="prettyprint lang-scala">externalIvyFile()
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">externalIvyFile(Def.setting(baseDirectory.value / &quot;custom-name.xml&quot;))
</code></pre><p>Because Ivy files specify their own configurations, sbt needs to know
which configurations to use for the compile, runtime, and test
classpaths. For example, to specify that the Compile classpath should
use the ‘default’ configuration:
</p><pre><code class="prettyprint lang-scala">classpathConfiguration in Compile := config(&quot;default&quot;)
</code></pre><h5 id="Maven+pom+%28dependencies+only%29">Maven pom (dependencies only)<a href="#Maven+pom+%28dependencies+only%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><pre><code class="prettyprint lang-scala">externalPom()
</code></pre><p>or
</p><pre><code class="prettyprint lang-scala">externalPom(Def.setting(baseDirectory.value / &quot;custom-name.xml&quot;))
</code></pre><h5 id="Full+Ivy+Example">Full Ivy Example<a href="#Full+Ivy+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>For example, a <code>build.sbt</code> using external Ivy files might look like:
</p><pre><code class="prettyprint lang-scala">externalIvySettings()

externalIvyFile(Def.setting(baseDirectory.value / &quot;ivyA.xml&quot;))

classpathConfiguration in Compile := Compile

classpathConfiguration in Test := Test

classpathConfiguration in Runtime := Runtime
</code></pre><h5 id="Known+limitations">Known limitations<a href="#Known+limitations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Maven support is dependent on Ivy’s support for Maven POMs. Known issues
with this support:
</p><ul><li>Specifying <code>relativePath</code> in the <code>parent</code> section of a POM will
produce an error.
</li><li>Ivy ignores repositories specified in the POM. A workaround is to
specify repositories inline or in an Ivy ivysettings.xml file.
</li></ul><h2 id="Proxy+Repositories">Proxy Repositories<a href="#Proxy+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>It’s often the case that users wish to set up a maven/ivy proxy
repository inside their corporate firewall, and have developer sbt
instances resolve artifacts through such a proxy. Let’s detail what
exact changes must be made for this to work.
</p><h3 id="Overview">Overview<a href="#Overview" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The situation arises when many developers inside an organization are
attempting to resolve artifacts. Each developer’s machine will hit the
internet and download an artifact, regardless of whether or not another
on the team has already done so. Proxy repositories provide a single
point of remote download for an organization. In addition to control and
security concerns, Proxy repositories are primarily important for
increased speed across a team.
</p><p><img src="files/proxy-cloud-setup.png" alt="image"/>
</p><p>There are many good proxy repository solutions out there, with the big
three being (in alphabetical order):
</p><ul><li><a href="http://archiva.apache.org/">Archiva</a>
</li><li><a href="http://www.jfrog.com/home/v_artifactory_opensource_overview">Artifactory</a>
</li><li><a href="http://www.sonatype.org/nexus/">Nexus</a>
</li></ul><p>Once you have a proxy repository installed and configured, then it’s
time to configure sbt for your needs. Read the note at the bottom about
proxy issues with ivy repositories.
</p><h3 id="sbt+Configuration">sbt Configuration<a href="#sbt+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt requires configuration in two places to make use of a proxy
repository. The first is the <code>~/.sbt/repositories</code> file, and the second
is the launcher script.
</p><h3 id=""><code>~/.sbt/repositories</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The repositories file is an external configuration for the Launcher. The
exact syntax for the configuration file is detailed in the
<a href="Sbt-Launcher.html">sbt Launcher</a>.
</p><p>Here’s an example config:
</p><pre><code class="">[repositories]
  local
  my-ivy-proxy-releases: http://repo.company.com/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]
  my-maven-proxy-releases: http://repo.company.com/maven-releases/
</code></pre><p>This example configuration has three repositories configured for sbt.
</p><p>The first resolver is <code>local</code>, and is used so that artifacts pushed
using <code>publish-local</code> will be seen in other sbt projects.
</p><p>The second resolver is <code>my-ivy-proxy-releases</code>. This repository is used
to resolve sbt <em>itself</em> from the company proxy repository, as well as
any sbt plugins that may be required. Note that the ivy resolver pattern
is important, make sure that yours matches the one shown or you may not
be able to resolve sbt plugins.
</p><p>The final resolver is <code>my-maven-proxy-releases</code>. This repository is a
proxy for all standard maven repositories, including maven central.
</p><h4 id="Launcher+Script">Launcher Script<a href="#Launcher+Script" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The sbt launcher supports two configuration options that allow the usage
of proxy repositories. The first is the <code>sbt.override.build.repos</code>
setting and the second is the <code>sbt.repository.config</code> setting.
</p><h4 id=""><code>sbt.override.build.repos</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This setting is used to specify that all sbt project added resolvers
should be ignored in favor of those configured in the <code>repositories</code>
configuration. Using this with a properly configured
<code>~/.sbt/repositories</code> file leads to only your proxy repository used for
builds.
</p><p>It is specified like so:
</p><pre><code class="">-Dsbt.override.build.repos=true
</code></pre><h4 id=""><code>sbt.repository.config</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you are unable to create a <code>~/.sbt/repositories</code> file, due to user
permission errors or for convenience of developers, you can modify the
sbt start script directly with the following:
</p><pre><code class="">-Dsbt.repository.config=&lt;path-to-your-repo-file&gt;
</code></pre><p>This is only necessary if users do not already have their own default
repository file.
</p><h3 id="Proxying+Ivy+Repositories">Proxying Ivy Repositories<a href="#Proxying+Ivy+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The most common mistake made when setting up a proxy repository for sbt
is the attempting to <em>merge</em> both <em>maven</em> and <em>ivy</em> repositories into
the <em>same</em> proxy repository. While some repository managers will allow
this, it’s not recommended to do so.
</p><p>Even if your company does not use ivy, sbt uses a custom layout to
handle binary compatibility constraints of its own plugins. To ensure
that these are resolved correctly, simple set up two virtual/proxy
repositories, one for maven and one for ivy.
</p><p>Here’s an example setup:
</p><p><img src="files/proxy-ivy-mvn-setup.png" alt="image"/>
</p><h2 id="Publishing">Publishing<a href="#Publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes how to publish your project. Publishing consists of
uploading a descriptor, such as an Ivy file or Maven POM, and artifacts,
such as a jar or war, to a repository so that other projects can specify
your project as a dependency.
</p><p>The <code>publish</code> action is used to publish your project to a remote
repository. To use publishing, you need to specify the repository to
publish to and the credentials to use. Once these are set up, you can
run <code>publish</code>.
</p><p>The <code>publishLocal</code> action is used to publish your project to a local Ivy
repository. You can then use this project from other projects on the
same machine.
</p><h3 id="Define+the+repository">Define the repository<a href="#Define+the+repository" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To specify the repository, assign a repository to <code>publishTo</code> and
optionally set the publishing style. For example, to upload to Nexus:
</p><pre><code class="prettyprint lang-scala">publishTo := Some(&quot;Sonatype Snapshots Nexus&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;)
</code></pre><p>To publish to a local repository:
</p><pre><code class="prettyprint lang-scala">publishTo := Some(Resolver.file(&quot;file&quot;,  new File( &quot;path/to/my/maven-repo/releases&quot; )) )
</code></pre><p>Publishing to the users local maven repository:
</p><pre><code class="prettyprint lang-scala">publishTo := Some(Resolver.file(&quot;file&quot;,  new File(Path.userHome.absolutePath+&quot;/.m2/repository&quot;)))
</code></pre><p>If you’re using Maven repositories you will also have to select the
right repository depending on your artifacts: SNAPSHOT versions go to
the /snapshot repository while other versions go to the /releases
repository. Doing this selection can be done by using the value of the
<code>version</code> SettingKey:
</p><pre><code class="prettyprint lang-scala">publishTo := {
  val nexus = &quot;https://oss.sonatype.org/&quot;
  if (version.value.trim.endsWith(&quot;SNAPSHOT&quot;)) 
    Some(&quot;snapshots&quot; at nexus + &quot;content/repositories/snapshots&quot;) 
  else
    Some(&quot;releases&quot;  at nexus + &quot;service/local/staging/deploy/maven2&quot;)
}
</code></pre><h3 id="Credentials">Credentials<a href="#Credentials" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are two ways to specify credentials for such a repository. The
first is to specify them inline:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(&quot;Sonatype Nexus Repository Manager&quot;, &quot;nexus.scala-tools.org&quot;, &quot;admin&quot;, &quot;admin123&quot;)
</code></pre><p>The second and better way is to load them from a file, for example:
</p><pre><code class="prettyprint lang-scala">credentials += Credentials(Path.userHome / &quot;.ivy2&quot; / &quot;.credentials&quot;)
</code></pre><p>The credentials file is a properties file with keys <code>realm</code>, <code>host</code>,
<code>user</code>, and <code>password</code>. For example:
</p><pre><code class="">realm=Sonatype Nexus Repository Manager
host=nexus.scala-tools.org
user=admin
password=admin123
</code></pre><h3 id="Cross-publishing">Cross-publishing<a href="#Cross-publishing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To support multiple incompatible Scala versions, enable cross building
and do <code>+ publish</code> (see <a href="Cross-Build.html">Cross Build</a>). See [Resolvers] for other
supported repository types.
</p><h3 id="Published+artifacts">Published artifacts<a href="#Published+artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>By default, the main binary jar, a sources jar, and a API documentation
jar are published. You can declare other types of artifacts to publish
and disable or modify the default artifacts. See the <a href="Artifacts.html">Artifacts</a> page
for details.
</p><h3 id="Modifying+the+generated+POM">Modifying the generated POM<a href="#Modifying+the+generated+POM" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>When <code>publishMavenStyle</code> is <code>true</code>, a POM is generated by the <code>makePom</code>
action and published to the repository instead of an Ivy file. This POM
file may be altered by changing a few settings. Set <code>pomExtra</code> to
provide XML (<code>scala.xml.NodeSeq</code>) to insert directly into the generated
pom. For example:
</p><pre><code class="prettyprint lang-scala">pomExtra :=
  &lt;licenses&gt;
    &lt;license&gt;
      &lt;name&gt;Apache 2&lt;/name&gt;
      &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;
      &lt;distribution&gt;repo&lt;/distribution&gt;
    &lt;/license&gt;
&lt;/licenses&gt;
</code></pre><p><code>makePom</code> adds to the POM any Maven-style repositories you have
declared. You can filter these by modifying <code>pomRepositoryFilter</code>, which
by default excludes local repositories. To instead only include local
repositories:
</p><pre><code class="prettyprint lang-scala">pomIncludeRepository := { (repo: MavenRepository) =&gt; 
  repo.root.startsWith(&quot;file:&quot;)
}
</code></pre><p>There is also a <code>pomPostProcess</code> setting that can be used to manipulate
the final XML before it is written. It’s type is <code>Node =&gt; Node</code>.
</p><pre><code class="prettyprint lang-scala">pomPostProcess := { (node: Node) =&gt;
  ...
}
</code></pre><h3 id="Publishing+Locally">Publishing Locally<a href="#Publishing+Locally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The <code>publishLocal</code> command will publish to the local Ivy repository. By
default, this is in <code>${user.home}/.ivy2/local</code>. Other projects on the
same machine can then list the project as a dependency. For example, if
the SBT project you are publishing has configuration parameters like:
</p><pre><code class="prettyprint lang-scala">name := &quot;My Project&quot;

organization := &quot;org.me&quot;

version := &quot;0.1-SNAPSHOT&quot;
</code></pre><p>Then another project can depend on it:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.me&quot; %% &quot;my-project&quot; % &quot;0.1-SNAPSHOT&quot;
</code></pre><p>The version number you select must end with <code>SNAPSHOT</code>, or you must
change the version number each time you publish. Ivy maintains a cache,
and it stores even local projects in that cache. If Ivy already has a
version cached, it will not check the local repository for updates,
unless the version number matches a
<a href="http://ant.apache.org/ivy/history/2.3.0/concept.html#change">changing pattern</a>,
and <code>SNAPSHOT</code> is one such pattern.
</p><h2 id="Resolvers">Resolvers<a href="#Resolvers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Maven">Maven<a href="#Maven" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Resolvers for Maven2 repositories are added as follows:
</p><pre><code class="prettyprint lang-scala">resolvers += 
  &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;
</code></pre><p>This is the most common kind of user-defined resolvers. The rest of this
page describes how to define other types of repositories.
</p><h3 id="Predefined">Predefined<a href="#Predefined" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A few predefined repositories are available and are listed below
</p><ul><li><code>DefaultMavenRepository</code> This is the main Maven repository at
<a href="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</a> and is included by default
</li><li><code>JavaNet1Repository</code> This is the Maven 1 repository at
<a href="http://download.java.net/maven/1/">http://download.java.net/maven/1/</a>
</li></ul><p>For example, to use the <code>java.net</code> repository, use the following setting
in your build definition:
</p><pre><code class="prettyprint lang-scala">resolvers += JavaNet1Repository
</code></pre><p>Predefined repositories will go under Resolver going forward so they are
in one place:
</p><pre><code class="prettyprint lang-scala">Resolver.sonatypeRepo(&quot;releases&quot;)  // Or &quot;snapshots&quot;
</code></pre><h3 id="Custom">Custom<a href="#Custom" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt provides an interface to the repository types available in Ivy:
file, URL, SSH, and SFTP. A key feature of repositories in Ivy is using
<a href="http://ant.apache.org/ivy/history/latest-milestone/concept.html#patterns">patterns</a>
to configure repositories.
</p><p>Construct a repository definition using the factory in <code>sbt.Resolver</code>
for the desired type. This factory creates a <code>Repository</code> object that
can be further configured. The following table contains links to the Ivy
documentation for the repository type and the API documentation for the
factory and repository class. The SSH and SFTP repositories are
configured identically except for the name of the factory. Use
<code>Resolver.ssh</code> for SSH and <code>Resolver.sftp</code> for SFTP.
</p><table>
  <tr>
    <th>Type</th>
    <th>Factory</th>
    <th>Ivy Docs</th>
    <th>Factory API</th>
    <th>Repository Class API</th>
  </tr>

  <tr>
    <td>Filesystem</td>
    <td><tt>Resolver.file</tt></td>
    <td><a href="http://ant.apache.org/ivy/history/latest-milestone/resolver/filesystem.html">Ivy filesystem</a></td>
    <td><a href="../api/sbt/Resolver$$file$.html">filesystem factory</a></td>
    <td><a href="../api/sbt/FileRepository.html">FileRepository API</a></td>
  </tr>

  <tr>
    <td>SFTP</td>
    <td><tt>Resolver.sftp</tt></td>
    <td><a href="http://ant.apache.org/ivy/history/latest-milestone/resolver/sftp.html">Ivy sftp</a></td>
    <td><a href="../api/sbt/Resolver$$Define$.html">sftp factory</a></td>
    <td><a href="../api/sbt/SftpRepository.html">SftpRepository API</a></td>
  </tr>

  <tr>
    <td>SSH</td>
    <td><tt>Resolver.ssh</tt></td>
    <td><a href="http://ant.apache.org/ivy/history/latest-milestone/resolver/ssh.html">Ivy ssh</a></td>
    <td><a href="../api/sbt/Resolver$$Define$.html">ssh factory</a></td>
    <td><a href="../api/sbt/SshRepository.html">SshRepository API</a></td>
  </tr>

  <tr>
    <td>URL</td>
    <td><tt>Resolver.url</tt></td>
    <td><a href="http://ant.apache.org/ivy/history/latest-milestone/resolver/url.html">Ivy url</a></td>
    <td><a href="../api/sbt/Resolver$$url$.html">url factory</a></td>
    <td><a href="../api/sbt/URLRepository.html">URLRepository API</a></td>
  </tr>
</table><h4 id="Basic+Examples">Basic Examples<a href="#Basic+Examples" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These are basic examples that use the default Maven-style repository
layout.
</p><h5 id="Filesystem">Filesystem<a href="#Filesystem" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Define a filesystem repository in the <code>test</code> directory of the current
working directory and declare that publishing to this repository must be
atomic.
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.file(&quot;my-test-repo&quot;, file(&quot;test&quot;)) transactional()
</code></pre><h5 id="URL">URL<a href="#URL" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Define a URL repository at <code>&quot;http://example.org/repo-releases/&quot;</code>.
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;, url(&quot;http://example.org/repo-releases/&quot;))
</code></pre><p>To specify an Ivy repository, use:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;, url)(Resolver.ivyStylePatterns)
</code></pre><p>or customize the layout pattern described in the Custom Layout section
below.
</p><h5 id="SFTP+and+SSH+Repositories">SFTP and SSH Repositories<a href="#SFTP+and+SSH+Repositories" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The following defines a repository that is served by SFTP from host
<code>&quot;example.org&quot;</code>:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sftp(&quot;my-sftp-repo&quot;, &quot;example.org&quot;)
</code></pre><p>To explicitly specify the port:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sftp(&quot;my-sftp-repo&quot;, &quot;example.org&quot;, 22)
</code></pre><p>To specify a base path:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.sftp(&quot;my-sftp-repo&quot;, &quot;example.org&quot;, &quot;maven2/repo-releases/&quot;)
</code></pre><p>Authentication for the repositories returned by <code>sftp</code> and <code>ssh</code> can be
configured by the <code>as</code> methods.
</p><p>To use password authentication:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;, &quot;password&quot;)
</code></pre><p>or to be prompted for the password:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;)
</code></pre><p>To use key authentication:
</p><pre><code class="prettyprint lang-scala">resolvers += {
  val keyFile: File = ...
  Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;, keyFile, &quot;keyFilePassword&quot;)
}
</code></pre><p>or if no keyfile password is required or if you want to be prompted for
it:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) as(&quot;user&quot;, keyFile)
</code></pre><p>To specify the permissions used when publishing to the server:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.ssh(&quot;my-ssh-repo&quot;, &quot;example.org&quot;) withPermissions(&quot;0644&quot;)
</code></pre><p>This is a chmod-like mode specification.
</p><h4 id="Custom+Layout">Custom Layout<a href="#Custom+Layout" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These examples specify custom repository layouts using patterns. The
factory methods accept an <code>Patterns</code> instance that defines the patterns
to use. The patterns are first resolved against the base file or URL.
The default patterns give the default Maven-style layout. Provide a
different Patterns object to use a different layout. For example:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;, url)( Patterns(&quot;[organisation]/[module]/[revision]/[artifact].[ext]&quot;) )
</code></pre><p>You can specify multiple patterns or patterns for the metadata and
artifacts separately. You can also specify whether the repository should
be Maven compatible (as defined by Ivy). See the
<a href="../api/sbt/Patterns$.html">patterns API</a> for the methods to use.
</p><p>For filesystem and URL repositories, you can specify absolute patterns
by omitting the base URL, passing an empty <code>Patterns</code> instance, and
using <code>ivys</code> and <code>artifacts</code>:
</p><pre><code class="prettyprint lang-scala">resolvers += Resolver.url(&quot;my-test-repo&quot;) artifacts
        &quot;http://example.org/[organisation]/[module]/[revision]/[artifact].[ext]&quot;
</code></pre><h2 id="Update+Report">Update Report<a href="#Update+Report" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><code>update</code> and related tasks produce a value of type
<a href="../api/sbt/UpdateReport.html">sbt.UpdateReport</a> This data
structure provides information about the resolved configurations,
modules, and artifacts. At the top level, <code>UpdateReport</code> provides
reports of type <code>ConfigurationReport</code> for each resolved configuration. A
<code>ConfigurationReport</code> supplies reports (of type <code>ModuleReport</code>) for each
module resolved for a given configuration. Finally, a <code>ModuleReport</code>
lists each successfully retrieved <code>Artifact</code> and the <code>File</code> it was
retrieved to as well as the <code>Artifact</code>s that couldn’t be downloaded.
This missing <code>Arifact</code> list is always empty for <code>update</code>, which will
fail if it is non-empty. However, it may be non-empty for
<code>updateClassifiers</code> and <code>updateSbtClassifers</code>.
</p><h3 id="Filtering+a+Report+and+Getting+Artifacts">Filtering a Report and Getting Artifacts<a href="#Filtering+a+Report+and+Getting+Artifacts" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A typical use of <code>UpdateReport</code> is to retrieve a list of files matching
a filter. A conversion of type <code>UpdateReport =&gt; RichUpdateReport</code>
implicitly provides these methods for <code>UpdateReport</code>. The filters are
defined by the
<a href="../api/sbt/DependencyFilter.html">DependencyFilter</a>,
<a href="../api/sbt/ConfigurationFilter.html">ConfigurationFilter</a>,
<a href="../api/sbt/ModuleFilter.html">ModuleFilter</a>, and
<a href="../api/sbt/ArtifactFilter.html">ArtifactFilter</a> types. Using
these filter types, you can filter by the configuration name, the module
organization, name, or revision, and the artifact name, type, extension,
or classifier.
</p><p>The relevant methods (implicitly on <code>UpdateReport</code>) are:
</p><pre><code class="prettyprint lang-scala">def matching(f: DependencyFilter): Seq[File]

def select(configuration: ConfigurationFilter = ...,
  module: ModuleFilter = ...,
  artifact: ArtifactFilter = ...): Seq[File]
</code></pre><p>Any argument to <code>select</code> may be omitted, in which case all values are
allowed for the corresponding component. For example, if the
<code>ConfigurationFilter</code> is not specified, all configurations are accepted.
The individual filter types are discussed below.
</p><h4 id="Filter+Basics">Filter Basics<a href="#Filter+Basics" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Configuration, module, and artifact filters are typically built by
applying a <code>NameFilter</code> to each component of a <code>Configuration</code>,
<code>ModuleID</code>, or <code>Artifact</code>. A basic <code>NameFilter</code> is implicitly
constructed from a String, with <code>*</code> interpreted as a wildcard.
</p><pre><code class="prettyprint lang-scala">import sbt._
// each argument is of type NameFilter
val mf: ModuleFilter = moduleFilter(organization = &quot;*sbt*&quot;,
  name = &quot;main&quot; | &quot;actions&quot;, revision = &quot;1.*&quot; - &quot;1.0&quot;)

// unspecified arguments match everything by default
val mf: ModuleFilter = moduleFilter(organization = &quot;net.databinder&quot;)

// specifying &quot;*&quot; is the same as omitting the argument
val af: ArtifactFilter = artifactFilter(name = &quot;*&quot;, `type` = &quot;source&quot;,
  extension = &quot;jar&quot;, classifier = &quot;sources&quot;)

val cf: ConfigurationFilter = configurationFilter(name = &quot;compile&quot; | &quot;test&quot;)
</code></pre><p>Alternatively, these filters, including a <code>NameFilter</code>, may be directly
defined by an appropriate predicate (a single-argument function
returning a Boolean).
</p><pre><code class="prettyprint lang-scala">import sbt._

// here the function value of type String =&gt; Boolean is implicitly converted to a NameFilter
val nf: NameFilter = (s: String) =&gt; s.startsWith(&quot;dispatch-&quot;)

// a Set[String] is a function String =&gt; Boolean
val acceptConfigs: Set[String] = Set(&quot;compile&quot;, &quot;test&quot;)
// implicitly converted to a ConfigurationFilter
val cf: ConfigurationFilter = acceptConfigs

val mf: ModuleFilter = (m: ModuleID) =&gt; m.organization contains &quot;sbt&quot;

val af: ArtifactFilter = (a: Artifact) =&gt; a.classifier.isEmpty
</code></pre><h4 id="ConfigurationFilter">ConfigurationFilter<a href="#ConfigurationFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A configuration filter essentially wraps a <code>NameFilter</code> and is
explicitly constructed by the <code>configurationFilter</code> method:
</p><pre><code class="prettyprint lang-scala">def configurationFilter(name: NameFilter = ...): ConfigurationFilter
</code></pre><p>If the argument is omitted, the filter matches all configurations.
Functions of type <code>String =&gt; Boolean</code> are implicitly convertible to a
<code>ConfigurationFilter</code>. As with <code>ModuleFilter</code>, <code>ArtifactFilter</code>, and
<code>NameFilter</code>, the <code>&amp;</code>, <code>|</code>, and <code>-</code> methods may be used to combine
<code>ConfigurationFilter</code>s.
</p><pre><code class="prettyprint lang-scala">import sbt._
val a: ConfigurationFilter = Set(&quot;compile&quot;, &quot;test&quot;)
val b: ConfigurationFilter = (c: String) =&gt; c.startsWith(&quot;r&quot;)
val c: ConfigurationFilter = a | b
</code></pre><p>(The explicit types are optional here.)
</p><h4 id="ModuleFilter">ModuleFilter<a href="#ModuleFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A module filter is defined by three <code>NameFilter</code>s: one for the
organization, one for the module name, and one for the revision. Each
component filter must match for the whole module filter to match. A
module filter is explicitly constructed by the <code>moduleFilter</code> method:
</p><pre><code class="prettyprint lang-scala">def moduleFilter(organization: NameFilter = ..., name: NameFilter = ..., revision: NameFilter = ...): ModuleFilter
</code></pre><p>An omitted argument does not contribute to the match. If all arguments
are omitted, the filter matches all <code>ModuleID</code>s. Functions of type
<code>ModuleID =&gt; Boolean</code> are implicitly convertible to a <code>ModuleFilter</code>. As
with <code>ConfigurationFilter</code>, <code>ArtifactFilter</code>, and <code>NameFilter</code>, the <code>&amp;</code>,
<code>|</code>, and <code>-</code> methods may be used to combine <code>ModuleFilter</code>s:
</p><pre><code class="prettyprint lang-scala">import sbt._
val a: ModuleFilter = moduleFilter(name = &quot;dispatch-twitter&quot;, revision = &quot;0.7.8&quot;)
val b: ModuleFilter = moduleFilter(name = &quot;dispatch-*&quot;)
val c: ModuleFilter = b - a
</code></pre><p>(The explicit types are optional here.)
</p><h4 id="ArtifactFilter">ArtifactFilter<a href="#ArtifactFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An artifact filter is defined by four <code>NameFilter</code>s: one for the name,
one for the type, one for the extension, and one for the classifier.
Each component filter must match for the whole artifact filter to match.
An artifact filter is explicitly constructed by the <code>artifactFilter</code>
method:
</p><pre><code class="prettyprint lang-scala">def artifactFilter(name: NameFilter = ..., `type`: NameFilter = ...,
  extension: NameFilter = ..., classifier: NameFilter = ...): ArtifactFilter
</code></pre><p>Functions of type <code>Artifact =&gt; Boolean</code> are implicitly convertible to an
<code>ArtifactFilter</code>. As with <code>ConfigurationFilter</code>, <code>ModuleFilter</code>, and
<code>NameFilter</code>, the <code>&amp;</code>, <code>|</code>, and <code>-</code> methods may be used to combine
<code>ArtifactFilter</code>s:
</p><pre><code class="prettyprint lang-scala">import sbt._
val a: ArtifactFilter = artifactFilter(classifier = &quot;javadoc&quot;)
val b: ArtifactFilter = artifactFilter(`type` = &quot;jar&quot;)
val c: ArtifactFilter = b - a
</code></pre><p>(The explicit types are optional here.)
</p><h4 id="DependencyFilter">DependencyFilter<a href="#DependencyFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A <code>DependencyFilter</code> is typically constructed by combining other
<code>DependencyFilter</code>s together using <code>&amp;&amp;</code>, <code>||</code>, and <code>--</code>. Configuration,
module, and artifact filters are <code>DependencyFilter</code>s themselves and can
be used directly as a <code>DependencyFilter</code> or they can build up a
<code>DependencyFilter</code>. Note that the symbols for the <code>DependencyFilter</code>
combining methods are doubled up to distinguish them from the
combinators of the more specific filters for configurations, modules,
and artifacts. These double-character methods will always return a
<code>DependencyFilter</code>, whereas the single character methods preserve the
more specific filter type. For example:
</p><pre><code class="prettyprint lang-scala">import sbt._

val df: DependencyFilter =
  configurationFilter(name = &quot;compile&quot; | &quot;test&quot;) &amp;&amp;
  artifactFilter(`type` = &quot;jar&quot;) ||
  moduleFilter(name = &quot;dispatch-*&quot;)
</code></pre><p>Here, we used <code>&amp;&amp;</code> and <code>||</code> to combine individual component filters into
a dependency filter, which can then be provided to the
<code>UpdateReport.matches</code> method. Alternatively, the <code>UpdateReport.select</code>
method may be used, which is equivalent to calling <code>matches</code> with its
arguments combined with <code>&amp;&amp;</code>.
</p><h2 id="Tasks+and+Commands">Tasks and Commands<a href="#Tasks+and+Commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the
<a href="../tutorial/index.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="Tasks">Tasks<a href="#Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><!-- TODO: Replace error with sys.error() -->
<p>Tasks and settings are introduced in the
<a href="../tutorial/Basic-Def.html">getting started guide</a>, which you may wish
to read first. This page has additional details and background and is
intended more as a reference.
</p><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Both settings and tasks produce values, but there are two major
differences between them:
</p><ol><li>Settings are evaluated at project load time. Tasks are executed on
demand, often in response to a command from the user.
</li><li>At the beginning of project loading, settings and their dependencies
are fixed. Tasks can introduce new tasks during execution, however.
</li></ol><h3 id="Features">Features<a href="#Features" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are several features of the task system:
</p><ol><li>By integrating with the settings system, tasks can be added,
removed, and modified as easily and flexibly as settings.
</li><li><a href="Input-Tasks.html">Input Tasks</a> use
<a href="Parsing-Input.html">parser combinators</a> to define the syntax for their
arguments. This allows flexible syntax and tab-completions in the
same way as <a href="Commands.html">Commands</a>.
</li><li>Tasks produce values. Other tasks can access a task’s value by
calling <code>value</code> on it within a task definition.
</li><li>Dynamically changing the structure of the task graph is possible.
Tasks can be injected into the execution graph based on the result
of another task.
</li><li>There are ways to handle task failure, similar to
<code>try/catch/finally</code>.
</li><li>Each task has access to its own Logger that by default persists the
logging for that task at a more verbose level than is initially
printed to the screen.
</li></ol><p>These features are discussed in detail in the following sections.
</p><h3 id="Defining+a+Task">Defining a Task<a href="#Defining+a+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Hello+World+example+%28sbt%29">Hello World example (sbt)<a href="#Hello+World+example+%28sbt%29" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p><code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">lazy val hello = taskKey[Unit](&quot;Prints 'Hello World'&quot;)

hello := println(&quot;hello world!&quot;)
</code></pre><p>Run “sbt hello” from command line to invoke the task. Run “sbt tasks” to
see this task listed.
</p><h4 id="Define+the+key">Define the key<a href="#Define+the+key" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To declare a new task, define a lazy val of type <code>TaskKey</code>:
</p><pre><code class="prettyprint lang-scala">lazy val sampleTask = taskKey[Int](&quot;A sample task.&quot;)
</code></pre><p>The name of the <code>val</code> is used when referring to the task in Scala code
and at the command line. The string passed to the <code>taskKey</code> method is a
description of the task. The type parameter passed to <code>taskKey</code> (here,
<code>Int</code>) is the type of value produced by the task.
</p><p>We’ll define a couple of other keys for the examples:
</p><pre><code class="prettyprint lang-scala">lazy val intTask = taskKey[Int](&quot;An int task&quot;)
lazy val stringTask = taskKey[String](&quot;A string task&quot;)
</code></pre><p>The examples themselves are valid entries in a <code>build.sbt</code> or can be
provided as part of a sequence to <code>Project.settings</code> (see
<a href="../tutorial/Full-Def.html">.scala build definition</a>).
</p><h4 id="Implement+the+task">Implement the task<a href="#Implement+the+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There are three main parts to implementing a task once its key is
defined:
</p><ol><li>Determine the settings and other tasks needed by the task. They are
the task’s inputs.
</li><li>Define the code that implements the task in terms of these inputs.
</li><li>Determine the scope the task will go in.
</li></ol><p>These parts are then combined just like the parts of a setting are
combined.
</p><h5 id="Defining+a+basic+task">Defining a basic task<a href="#Defining+a+basic+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>A task is defined using <code>:=</code>
</p><pre><code class="prettyprint lang-scala">intTask := 1 + 2

stringTask := System.getProperty(&quot;user.name&quot;)

sampleTask := {
   val sum = 1 + 2
   println(&quot;sum: &quot; + sum)
   sum
}
</code></pre><p>As mentioned in the introduction, a task is evaluated on demand. Each
time <code>sampleTask</code> is invoked, for example, it will print the sum. If the
username changes between runs, <code>stringTask</code> will take different values
in those separate runs. (Within a run, each task is evaluated at most
once.) In contrast, settings are evaluated once on project load and are
fixed until the next reload.
</p><h5 id="Tasks+with+inputs">Tasks with inputs<a href="#Tasks+with+inputs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Tasks with other tasks or settings as inputs are also defined using
<code>:=</code>. The values of the inputs are referenced by the <code>value</code> method.
This method is special syntax and can only be called when defining a
task, such as in the argument to <code>:=</code>. The following defines a task that
adds one to the value produced by <code>intTask</code> and returns the result.
</p><pre><code class="prettyprint lang-scala">sampleTask := intTask.value + 1
</code></pre><p>Multiple settings are handled similarly:
</p><pre><code class="prettyprint lang-scala">stringTask := &quot;Sample: &quot; + sampleTask.value + &quot;, int: &quot; + intTask.value
</code></pre><h5 id="Task+Scope">Task Scope<a href="#Task+Scope" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>As with settings, tasks can be defined in a specific scope. For example,
there are separate <code>compile</code> tasks for the <code>compile</code> and <code>test</code> scopes.
The scope of a task is defined the same as for a setting. In the
following example, <code>test:sampleTask</code> uses the result of
<code>compile:intTask</code>.
</p><pre><code class="prettyprint lang-scala">sampleTask in Test := (intTask in Compile).value * 3
</code></pre><h5 id="On+precedence">On precedence<a href="#On+precedence" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>As a reminder, infix method precedence is by the name of the method and
postfix methods have lower precedence than infix methods.
</p><ol><li>Assignment methods have the lowest precedence. These are methods
with names ending in <code>=</code>, except for <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, and names that
start with <code>=</code>.
</li><li>Methods starting with a letter have the next highest precedence.
</li><li><p>Methods with names that start with a symbol and aren’t included in
</p><ol><li>have the highest precedence. (This category is divided further
according to the specific character it starts with. See the Scala
specification for details.)
</li></ol></li></ol><p>Therefore, the the previous example is equivalent to the following:
</p><pre><code class="prettyprint lang-scala">(sampleTask in Test).:=( (intTask in Compile).value * 3 )
</code></pre><p>Additionally, the braces in the following are necessary:
</p><pre><code class="prettyprint lang-scala">helloTask := { &quot;echo Hello&quot; ! }
</code></pre><p>Without them, Scala interprets the line as
<code>( helloTask.:=(&quot;echo Hello&quot;) ).!</code> instead of the desired
<code>helloTask.:=( &quot;echo Hello&quot;.! )</code>.
</p><h4 id="Separating+implementations">Separating implementations<a href="#Separating+implementations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The implementation of a task can be separated from the binding. For
example, a basic separate definition looks like:
</p><pre><code class="prettyprint lang-scala">// Define a new, standalone task implemention
lazy val intTaskImpl: Initialize[Task[Int]] =
   Def.task { sampleTask.value - 3 }

// Bind the implementation to a specific key
intTask := intTaskImpl.value
</code></pre><p>Note that whenever <code>.value</code> is used, it must be within a task
definition, such as within <code>Def.task</code> above or as an argument to <code>:=</code>.
</p><h4 id="Modifying+an+Existing+Task">Modifying an Existing Task<a href="#Modifying+an+Existing+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>In the general case, modify a task by declaring the previous task as an
input.
</p><pre><code class="prettyprint lang-scala">// initial definition
intTask := 3

// overriding definition that references the previous definition
intTask := intTask.value + 1
</code></pre><p>Completely override a task by not declaring the previous task as an
input. Each of the definitions in the following example completely
overrides the previous one. That is, when <code>intTask</code> is run, it will only
print <code>#3</code>.
</p><pre><code class="prettyprint lang-scala">intTask := {
    println(&quot;#1&quot;)
    3
}

intTask := {
    println(&quot;#2&quot;)
    5
}

intTask :=  {
    println(&quot;#3&quot;)
    sampleTask.value - 3
}
</code></pre><a name="multiple-scopes"></a><h3 id="Getting+values+from+multiple+scopes">Getting values from multiple scopes<a href="#Getting+values+from+multiple+scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The general form of an expression that gets values from multiple scopes
is:
</p><pre><code class="prettyprint lang-scala">&lt;setting-or-task&gt;.all(&lt;scope-filter&gt;).value
</code></pre><p>The <code>all</code> method is implicitly added to tasks and settings. It accepts a
<code>ScopeFilter</code> that will select the <code>Scopes</code>. The result has type
<code>Seq[T]</code>, where <code>T</code> is the key’s underlying type.
</p><h4 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A common scenario is getting the sources for all subprojects for
processing all at once, such as passing them to scaladoc. The task that
we want to obtain values for is <code>sources</code> and we want to get the values
in all non-root projects and in the <code>Compile</code> configuration. This looks
like:
</p><pre><code class="prettyprint lang-scala">lazy val core = project

lazy val util = project

lazy val root = project.settings(
   sources := {
      val filter = ScopeFilter( inProjects(core, util), inConfigurations(Compile) )
      // each sources definition is of type Seq[File],
      //   giving us a Seq[Seq[File]] that we then flatten to Seq[File]
      val allSources: Seq[Seq[File]] = sources.all(filter).value
      allSources.flatten
   }
)
</code></pre><p>The next section describes various ways to construct a ScopeFilter.
</p><h4 id="ScopeFilter">ScopeFilter<a href="#ScopeFilter" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A basic <code>ScopeFilter</code> is constructed by the <code>ScopeFilter.apply</code> method.
This method makes a <code>ScopeFilter</code> from filters on the parts of a
<code>Scope</code>: a <code>ProjectFilter</code>, <code>ConfigurationFilter</code>, and <code>TaskFilter</code>. The
simplest case is explicitly specifying the values for the parts:
</p><pre><code class="prettyprint lang-scala">val filter: ScopeFilter =
   ScopeFilter(
      inProjects( core, util ),
      inConfigurations( Compile, Test )
   )
</code></pre><h5 id="Unspecified+filters">Unspecified filters<a href="#Unspecified+filters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>If the task filter is not specified, as in the example above, the
default is to select scopes without a specific task (global). Similarly,
an unspecified configuration filter will select scopes in the global
configuration. The project filter should usually be explicit, but if
left unspecified, the current project context will be used.
</p><h5 id="More+on+filter+construction">More on filter construction<a href="#More+on+filter+construction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The example showed the basic methods <code>inProjects</code> and
<code>inConfigurations</code>. This section describes all methods for constructing
a <code>ProjectFilter</code>, <code>ConfigurationFilter</code>, or <code>TaskFilter</code>. These methods
can be organized into four groups:
</p><ul><li>Explicit member list (<code>inProjects</code>, <code>inConfigurations</code>, <code>inTasks</code>)
</li><li>Global value (<code>inGlobalProject</code>, <code>inGlobalConfiguration</code>,
<code>inGlobalTask</code>)
</li><li>Default filter (<code>inAnyProject</code>, <code>inAnyConfiguration</code>, <code>inAnyTask</code>)
</li><li>Project relationships (<code>inAggregates</code>, <code>inDependencies</code>)
</li></ul><p>See the <a href="../api/sbt/ScopeFilter$$Make.html">API documentation</a> for
details.
</p><h5 id="Combining+ScopeFilters">Combining ScopeFilters<a href="#Combining+ScopeFilters" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p><code>ScopeFilters</code> may be combined with the <code>&amp;&amp;</code>, <code>||</code>, <code>--</code>, and <code>-</code>
methods:
</p><ul><li><code>a &amp;&amp; b</code> Selects scopes that match both a and b
</li><li><code>a || b</code> Selects scopes that match either a or b
</li><li><code>a -- b</code> Selects scopes that match a but not b
</li><li><code>-b</code> Selects scopes that do not match b
</li></ul><p>For example, the following selects the scope for the <code>Compile</code> and
<code>Test</code> configurations of the <code>core</code> project and the global configuration
of the <code>util</code> project:
</p><pre><code class="prettyprint lang-scala">val filter: ScopeFilter =
   ScopeFilter( inProjects(core), inConfigurations(Compile, Test)) ||
   ScopeFilter( inProjects(util), inGlobalConfiguration )
</code></pre><h4 id="More+operations">More operations<a href="#More+operations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>all</code> method applies to both settings (values of type
<code>Initialize[T]</code>) and tasks (values of type <code>Initialize[Task[T]]</code>). It
returns a setting or task that provides a <code>Seq[T]</code>, as shown in this
table:
</p><table>
  <tr>
    <th>Target</th>
    <th>Result</th>
  </tr>

  <tr>
    <td><tt>Initialize[T] </tt></td>
    <td><tt>Initialize[Seq[T]]</tt></td>
  </tr>

  <tr>
    <td><tt>Initialize[Task[T]]</tt></td>
    <td><tt>Initialize[Task[Seq[T]]]</tt></td>
  </tr>
</table><p>This means that the <code>all</code> method can be combined with methods that
construct tasks and settings.
</p><h5 id="Missing+values">Missing values<a href="#Missing+values" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Some scopes might not define a setting or task. The <code>?</code> and <code>??</code> methods
can help in this case. They are both defined on settings and tasks and
indicate what to do when a key is undefined.
</p><table>
  <tr>
    <td><tt>?</tt></td>
    <td><tt>On a setting or task with underlying type T, this accepts no
    arguments and returns a setting or task (respectively) of type
    Option[T]. The result is None if the setting/task is undefined and
    Some[T] with the value if it is.</tt></td>
  </tr>

  <tr>
    <td><tt>??</tt></td>
    <td><tt>On a setting or task with underlying type T, this accepts an
    argument of type T and uses this argument if the setting/task is
    undefined.</tt></td>
  </tr>
</table><p>The following contrived example sets the maximum errors to be the
maximum of all aggregates of the current project.
</p><pre><code class="prettyprint lang-scala">maxErrors := {
   // select the transitive aggregates for this project, but not the project itself
   val filter: ScopeFilter =
      ScopeFilter( inAggregates(ThisProject, includeRoot=false) )
   // get the configured maximum errors in each selected scope,
   // using 0 if not defined in a scope
   val allVersions: Seq[Int] =
      (maxErrors ?? 0).all(filter).value
   allVersions.max
}
</code></pre><h5 id="Multiple+values+from+multiple+scopes">Multiple values from multiple scopes<a href="#Multiple+values+from+multiple+scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The target of <code>all</code> is any task or setting, including anonymous ones.
This means it is possible to get multiple values at once without
defining a new task or setting in each scope. A common use case is to
pair each value obtained with the project, configuration, or full scope
it came from.
</p><ul><li><code>resolvedScoped</code>: Provides the full enclosing ScopedKey (which is a Scope +
<code>AttributeKey[_]</code>)
</li><li><code>thisProject</code>: Provides the Project associated with this scope (undefined at the
global and build levels)
</li><li><code>thisProjectRef</code>: Provides the ProjectRef for the context (undefined at the global and
build levels)
</li><li><code>configuration</code>: Provides the Configuration for the context (undefined for the global
configuration)
</li></ul><p>For example, the following defines a task that prints non-Compile
configurations that define sbt plugins. This might be used to identify
an incorrectly configured build (or not, since this is a fairly
contrived example):
</p><pre><code class="prettyprint lang-scala">// Select all configurations in the current project except for Compile
lazy val filter: ScopeFilter = ScopeFilter(
   inProjects(ThisProject),
   inAnyConfiguration -- inConfigurations(Compile)
)

// Define a task that provides the name of the current configuration
//   and the set of sbt plugins defined in the configuration
lazy val pluginsWithConfig: Initialize[Task[ (String, Set[String]) ]] =
   Def.task {
      ( configuration.value.name, definedSbtPlugins.value )
   }

checkPluginsTask := {
   val oddPlugins: Seq[(String, Set[String])] =
      pluginsWithConfig.all(filter).value
   // Print each configuration that defines sbt plugins
   for( (config, plugins) &lt;- oddPlugins if plugins.nonEmpty )
      println(s&quot;$config defines sbt plugins: ${plugins.mkString(&quot;, &quot;)}&quot;)
}
</code></pre><h3 id="Advanced+Task+Operations">Advanced Task Operations<a href="#Advanced+Task+Operations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The examples in this section use the task keys defined in the previous
section.
</p><h4 id="Streams%3A+Per-task+logging">Streams: Per-task logging<a href="#Streams%3A+Per-task+logging" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Per-task loggers are part of a more general system for task-specific
data called Streams. This allows controlling the verbosity of stack
traces and logging individually for tasks as well as recalling the last
logging for a task. Tasks also have access to their own persisted binary
or text data.
</p><p>To use Streams, get the value of the <code>streams</code> task. This is a special
task that provides an instance of
<a href="../api/sbt/std/TaskStreams.html">TaskStreams</a> for the defining
task. This type provides access to named binary and text streams, named
loggers, and a default logger. The default
<a href="../api/sbt/Logger.html">Logger</a>, which is the most commonly used
aspect, is obtained by the <code>log</code> method:
</p><pre><code class="prettyprint lang-scala">myTask := {
  val s: TaskStreams = streams.value
  s.log.debug(&quot;Saying hi...&quot;)
  s.log.info(&quot;Hello!&quot;)
}
</code></pre><p>You can scope logging settings by the specific task’s scope:
</p><pre><code class="prettyprint lang-scala">logLevel in myTask := Level.Debug

traceLevel in myTask := 5
</code></pre><p>To obtain the last logging output from a task, use the <code>last</code> command:
</p><pre><code class="">$ last myTask
[debug] Saying hi...
[info] Hello!
</code></pre><p>The verbosity with which logging is persisted is controlled using the
<code>persistLogLevel</code> and <code>persistTraceLevel</code> settings. The <code>last</code> command
displays what was logged according to these levels. The levels do not
affect already logged information.
</p><h3 id="Dynamic+Computations+with">Dynamic Computations with <code>Def.taskDyn</code><a href="#Dynamic+Computations+with" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It can be useful to use the result of a task to determine the next tasks
to evaluate. This is done using <code>Def.taskDyn</code>. The result of <code>taskDyn</code>
is called a dynamic task because it introduces dependencies at runtime.
The <code>taskDyn</code> method supports the same syntax as <code>Def.task</code> and <code>:=</code>
except that you return a task instead of a plain value.
</p><p>For example,
</p><pre><code class="prettyprint lang-scala">val dynamic = Def.taskDyn {
  // decide what to evaluate based on the value of `stringTask`
  if(stringTask.value == &quot;dev&quot;)
    // create the dev-mode task: this is only evaluated if the
    //   value of stringTask is &quot;dev&quot;
    Def.task {
      3
    }
  else
    // create the production task: only evaluated if the value
    //    of the stringTask is not &quot;dev&quot;
    Def.task {
      intTask.value + 5
    }
}

myTask := {
  val num = dynamic.value
  println(s&quot;Number selected was $num&quot;)
}
</code></pre><p>The only static dependency of <code>myTask</code> is <code>stringTask</code>. The dependency
on <code>intTask</code> is only introduced in non-dev mode.
</p><blockquote><p><strong>Note</strong>: A dynamic task cannot refer to itself or a circular dependency will
result. In the example above, there would be a circular dependency if
the code passed to taskDyn referenced myTask.
</p></blockquote><h4 id="Handling+Failure">Handling Failure<a href="#Handling+Failure" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This section discusses the <code>failure</code>, <code>result</code>, and <code>andFinally</code>
methods, which are used to handle failure of other tasks.
</p><h4 id=""><code>failure</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>failure</code> method creates a new task that returns the <code>Incomplete</code>
value when the original task fails to complete normally. If the original
task succeeds, the new task fails.
<a href="../api/sbt/Incomplete.html">Incomplete</a> is an exception with
information about any tasks that caused the failure and any underlying
exceptions thrown during task execution.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">intTask := error(&quot;Failed.&quot;)

intTask := {
   println(&quot;Ignoring failure: &quot; + intTask.failure.value)
   3
}
</code></pre><p>This overrides the <code>intTask</code> so that the original exception is printed
and the constant <code>3</code> is returned.
</p><p><code>failure</code> does not prevent other tasks that depend on the target from
failing. Consider the following example:
</p><pre><code class="prettyprint lang-scala">intTask := if(shouldSucceed) 5 else error(&quot;Failed.&quot;)

// Return 3 if intTask fails. If intTask succeeds, this task will fail.
aTask := intTask.failure.value - 2

// A new task that increments the result of intTask.
bTask := intTask.value + 1

cTask := aTask.value + bTask.value
</code></pre><p>The following table lists the results of each task depending on the
initially invoked task:
</p><table>
  <thead>
    <tr>
      <th>invoked task</th>
      <th>intTask result</th>
      <th>aTask result</th>
      <th>bTask result</th>
      <th>cTask result</th>
      <th>overall result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>intTask</td>
      <td>failure</td>
      <td>not run</td>
      <td>not run</td>
      <td>not run</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>aTask</td>
      <td>failure</td>
      <td>success</td>
      <td>not run</td>
      <td>not run</td>
      <td>success</td>
    </tr>
    <tr>
      <td>bTask</td>
      <td>failure</td>
      <td>not run</td>
      <td>failure</td>
      <td>not run</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>cTask</td>
      <td>failure</td>
      <td>success</td>
      <td>failure</td>
      <td>failure</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>intTask</td>
      <td>success</td>
      <td>not run</td>
      <td>not run</td>
      <td>not run</td>
      <td>success</td>
    </tr>
    <tr>
      <td>aTask</td>
      <td>success</td>
      <td>failure</td>
      <td>not run</td>
      <td>not run</td>
      <td>failure</td>
    </tr>
    <tr>
      <td>bTask</td>
      <td>success</td>
      <td>not run</td>
      <td>success</td>
      <td>not run</td>
      <td>success</td>
    </tr>
    <tr>
      <td>cTask</td>
      <td>success</td>
      <td>failure</td>
      <td>success</td>
      <td>failure</td>
      <td>failure</td>
    </tr>
  </tbody>
</table><p>The overall result is always the same as the root task (the directly
invoked task). A <code>failure</code> turns a success into a failure, and a failure
into an <code>Incomplete</code>. A normal task definition fails when any of its
inputs fail and computes its value otherwise.
</p><h4 id=""><code>result</code><a href="#" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>result</code> method creates a new task that returns the full <code>Result[T]</code>
value for the original task. <a href="../api/sbt/Result.html">Result</a> has
the same structure as <code>Either[Incomplete, T]</code> for a task result of type
<code>T</code>. That is, it has two subtypes:
</p><ul><li><code>Inc</code>, which wraps <code>Incomplete</code> in case of failure
</li><li><code>Value</code>, which wraps a task’s result in case of success.
</li></ul><p>Thus, the task created by <code>result</code> executes whether or not the original
task succeeds or fails.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">intTask := error(&quot;Failed.&quot;)

intTask := intTask.result.value match {
   case Inc(inc: Incomplete) =&gt;
      println(&quot;Ignoring failure: &quot; + inc)
      3
   case Value(v) =&gt;
      println(&quot;Using successful result: &quot; + v)
      v
}
</code></pre><p>This overrides the original <code>intTask</code> definition so that if the original
task fails, the exception is printed and the constant <code>3</code> is returned.
If it succeeds, the value is printed and returned.
</p><h5 id="andFinally">andFinally<a href="#andFinally" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The <code>andFinally</code> method defines a new task that runs the original task
and evaluates a side effect regardless of whether the original task
succeeded. The result of the task is the result of the original task.
For example:
</p><pre><code class="prettyprint lang-scala">intTask := error(&quot;I didn't succeed.&quot;)

lazy val intTaskImpl = intTask andFinally { println(&quot;andFinally&quot;) }

intTask := intTaskImpl.value
</code></pre><p>This modifies the original <code>intTask</code> to always print “andFinally” even
if the task fails.
</p><p>Note that <code>andFinally</code> constructs a new task. This means that the new
task has to be invoked in order for the extra block to run. This is
important when calling andFinally on another task instead of overriding
a task like in the previous example. For example, consider this code:
</p><pre><code class="prettyprint lang-scala">intTask := error(&quot;I didn't succeed.&quot;)

lazy val intTaskImpl = intTask andFinally { println(&quot;andFinally&quot;) }

otherIntTask := intTaskImpl.value
</code></pre><p>If <code>intTask</code> is run directly, <code>otherIntTask</code> is never involved in
execution. This case is similar to the following plain Scala code:
</p><pre><code class="prettyprint lang-scala">def intTask(): Int =
  error(&quot;I didn't succeed.&quot;)

def otherIntTask(): Int =
  try { intTask() }
  finally { println(&quot;finally&quot;) }

intTask()
</code></pre><p>It is obvious here that calling intTask() will never result in “finally”
being printed.
</p><h2 id="Input+Tasks">Input Tasks<a href="#Input+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Input Tasks parse user input and produce a task to run.
<a href="Parsing-Input.html">Parsing Input</a> describes how to use the parser
combinators that define the input syntax and tab completion. This page
describes how to hook those parser combinators into the input task
system.
</p><h3 id="Input+Keys">Input Keys<a href="#Input+Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A key for an input task is of type <code>InputKey</code> and represents the input
task like a <code>SettingKey</code> represents a setting or a <code>TaskKey</code> represents
a task. Define a new input task key using the <code>inputKey.apply</code> factory
method:
</p><pre><code class="prettyprint lang-scala">// goes in project/Build.scala or in build.sbt
val demo = inputKey[Unit](&quot;A demo input task.&quot;)
</code></pre><p>The definition of an input task is similar to that of a normal task, but
it can also use the result of a
</p><p><a href="Parsing-Input.html">Parser</a> applied to user input. Just as
the special <code>value</code> method gets the value of a setting or task, the
special <code>parsed</code> method gets the result of a <code>Parser</code>.
</p><h3 id="Basic+Input+Task+Definition">Basic Input Task Definition<a href="#Basic+Input+Task+Definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The simplest input task accepts a space-delimited sequence of arguments.
It does not provide useful tab completion and parsing is basic. The
built-in parser for space-delimited arguments is constructed via the
<code>spaceDelimited</code> method, which accepts as its only argument the label to
present to the user during tab completion.
</p><p>For example, the following task prints the current Scala version and
then echoes the arguments passed to it on their own line.
</p><pre><code class="prettyprint lang-scala">demo := {
    // get the result of parsing
  val args: Seq[String] = spaceDelimited(&quot;&lt;arg&gt;&quot;).parsed
    // Here, we also use the value of the `scalaVersion` setting
  println(&quot;The current Scala version is &quot; + scalaVersion.value)
  println(&quot;The arguments to demo were:&quot;)
  args foreach println
}
</code></pre><h3 id="Input+Task+using+Parsers">Input Task using Parsers<a href="#Input+Task+using+Parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Parser provided by the <code>spaceDelimited</code> method does not provide any
flexibility in defining the input syntax. Using a custom parser is just
a matter of defining your own <code>Parser</code> as described on the
<a href="Parsing-Input.html">Parsing Input</a> page.
</p><h4 id="Constructing+the+Parser">Constructing the Parser<a href="#Constructing+the+Parser" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first step is to construct the actual <code>Parser</code> by defining a value
of one of the following types:
</p><ul><li><code>Parser[I]</code>: a basic parser that does not use any settings
</li><li><code>Initialize[Parser[I]]</code>: a parser whose definition depends on one or
more settings
</li><li><code>Initialize[State =&gt; Parser[I]]</code>: a parser that is defined using
both settings and the current <a href="Build-State.html">state</a>
</li></ul><p>We already saw an example of the first case with <code>spaceDelimited</code>, which
doesn’t use any settings in its definition. As an example of the third
case, the following defines a contrived <code>Parser</code> that uses the project’s
Scala and sbt version settings as well as the state. To use these
settings, we need to wrap the Parser construction in <code>Def.setting</code> and
get the setting values with the special <code>value</code> method:
</p><pre><code class="prettyprint lang-scala">import complete.DefaultParsers._

val parser: Initialize[State =&gt; Parser[(String,String)]] =
Def.setting {
  (state: State) =&gt;
    ( token(&quot;scala&quot; &lt;~ Space) ~ token(scalaVersion.value) ) |
    ( token(&quot;sbt&quot; &lt;~ Space) ~ token(sbtVersion.value) ) |
    ( token(&quot;commands&quot; &lt;~ Space) ~
        token(state.remainingCommands.size.toString) )
}
</code></pre><p>This Parser definition will produce a value of type <code>(String,String)</code>.
The input syntax defined isn’t very flexible; it is just a
demonstration. It will produce one of the following values for a
successful parse (assuming the current Scala version is 2.10.3,
the current sbt version is 0.13.5, and there are 3 commands left to
run):
</p><p>Again, we were able to access the current Scala and sbt version for the
project because they are settings. Tasks cannot be used to define the
parser.
</p><h4 id="Constructing+the+Task">Constructing the Task<a href="#Constructing+the+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Next, we construct the actual task to execute from the result of the
<code>Parser</code>. For this, we define a task as usual, but we can access the
result of parsing via the special <code>parsed</code> method on <code>Parser</code>.
</p><p>The following contrived example uses the previous example’s output (of
type <code>(String,String)</code>) and the result of the <code>package</code> task to print
some information to the screen.
</p><pre><code class="prettyprint lang-scala">demo := {
    val (tpe, value) = parser.parsed
    println(&quot;Type: &quot; + tpe)
    println(&quot;Value: &quot; + value)
    println(&quot;Packaged: &quot; + packageBin.value.getAbsolutePath)
}
</code></pre><h3 id="The+InputTask+type">The InputTask type<a href="#The+InputTask+type" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It helps to look at the <code>InputTask</code> type to understand more advanced
usage of input tasks. The core input task type is:
</p><pre><code class="prettyprint lang-scala">class InputTask[T](val parser: State =&gt; Parser[Task[T]])
</code></pre><p>Normally, an input task is assigned to a setting and you work with
<code>Initialize[InputTask[T]]</code>.
</p><p>Breaking this down,
</p><ol><li>You can use other settings (via Initialize) to construct an input
task.
</li><li>You can use the current State to construct the parser.
</li><li>The parser accepts user input and provides tab completion.
</li><li>The parser produces the task to run.
</li></ol><p>So, you can use settings or <code>State</code> to construct the parser that defines
an input task’s command line syntax. This was described in the previous
section. You can then use settings, <code>State</code>, or user input to construct
the task to run. This is implicit in the input task syntax.
</p><h3 id="Using+other+input+tasks">Using other input tasks<a href="#Using+other+input+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The types involved in an input task are composable, so it is possible to
reuse input tasks. The <code>.parsed</code> and <code>.evaluated</code> methods are defined on
InputTasks to make this more convenient in common situations:
</p><ul><li>Call <code>.parsed</code> on an <code>InputTask[T]</code> or <code>Initialize[InputTask[T]]</code>
to get the <code>Task[T]</code> created after parsing the command line
</li><li>Call <code>.evaluated</code> on an <code>InputTask[T]</code> or
<code>Initialize[InputTask[T]]</code> to get the value of type <code>T</code> from
evaluating that task
</li></ul><p>In both situations, the underlying <code>Parser</code> is sequenced with other
parsers in the input task definition. In the case of <code>.evaluated</code>, the
generated task is evaluated.
</p><p>The following example applies the <code>run</code> input task, a literal separator
parser <code>--</code>, and <code>run</code> again. The parsers are sequenced in order of
syntactic appearance, so that the arguments before <code>--</code> are passed to
the first <code>run</code> and the ones after are passed to the second.
</p><pre><code class="prettyprint lang-scala">val run2 = inputKey[Unit](
    &quot;Runs the main class twice with different argument lists separated by --&quot;)

val separator: Parser[String] = &quot;--&quot;

run2 := {
   val one = (run in Compile).evaluated
   val sep = separator.parsed
   val two = (run in Compile).evaluated
}
</code></pre><p>For a main class Demo that echoes its arguments, this looks like:
</p><pre><code class="">$ sbt
&gt; run2 a b -- c d
[info] Running Demo c d
[info] Running Demo a b
c
d
a
b
</code></pre><h3 id="Preapplying+input">Preapplying input<a href="#Preapplying+input" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Because <code>InputTasks</code> are built from <code>Parsers</code>, it is possible to
generate a new <code>InputTask</code> by applying some input programmatically. (It
is also possible to generate a <code>Task</code>, which is covered in the next
section.) Two convenience methods are provided on <code>InputTask[T]</code> and
<code>Initialize[InputTask[T]]</code> that accept the String to apply.
</p><ul><li><code>partialInput</code> applies the input and allows further input, such as
from the command line
</li><li><code>fullInput</code> applies the input and terminates parsing, so that
further input is not accepted
</li></ul><p>In each case, the input is applied to the input task’s parser. Because
input tasks handle all input after the task name, they usually require
initial whitespace to be provided in the input.
</p><p>Consider the example in the previous section. We can modify it so that
we:
</p><ul><li>Explicitly specify all of the arguments to the first <code>run</code>. We use
<code>name</code> and <code>version</code> to show that settings can be used to define
and modify parsers.
</li><li>Define the initial arguments passed to the second <code>run</code>, but allow
further input on the command line.
</li></ul><blockquote><p><strong>Note</strong>: the current implementation of <code>:=</code> doesn’t actually support
applying input derived from settings yet.
</p></blockquote><pre><code class="prettyprint lang-scala">lazy val run2 = inputKey[Unit](&quot;Runs the main class twice: &quot; +
   &quot;once with the project name and version as arguments&quot;
   &quot;and once with command line arguments preceded by hard coded values.&quot;)

// The argument string for the first run task is ' &lt;name&gt; &lt;version&gt;'
lazy val firstInput: Initialize[String] =
   Def.setting(s&quot; ${name.value} ${version.value}&quot;)

// Make the first arguments to the second run task ' red blue'
lazy val secondInput: String = &quot; red blue&quot;

run2 := {
   val one = (run in Compile).fullInput(firstInput.value).evaluated
   val two = (run in Compile).partialInput(secondInput).evaluated
}
</code></pre><p>For a main class Demo that echoes its arguments, this looks like:
</p><pre><code class="">$ sbt
&gt; run2 green
[info] Running Demo demo 1.0
[info] Running Demo red blue green
demo
1.0
red
blue
green
</code></pre><h3 id="Get+a+Task+from+an+InputTask">Get a Task from an InputTask<a href="#Get+a+Task+from+an+InputTask" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The previous section showed how to derive a new <code>InputTask</code> by applying
input. In this section, applying input produces a <code>Task</code>. The <code>toTask</code>
method on <code>Initialize[InputTask[T]]</code> accepts the <code>String</code> input to apply
and produces a task that can be used normally. For example, the
following defines a plain task <code>runFixed</code> that can be used by other
tasks or run directly without providing any input, :
</p><pre><code class="prettyprint lang-scala">lazy val runFixed = taskKey[Unit](&quot;A task that hard codes the values to `run`&quot;)

runFixed := {
   val _ = (run in Compile).toTask(&quot; blue green&quot;).value
   println(&quot;Done!&quot;)
}
</code></pre><p>For a main class Demo that echoes its arguments, running <code>runFixed</code>
looks like:
</p><pre><code class="">$ sbt
&gt; runFixed
[info] Running Demo blue green
blue
green
Done!
</code></pre><p>Each call to <code>toTask</code> generates a new task, but each task is configured
the same as the original <code>InputTask</code> (in this case, <code>run</code>) but with
different input applied. For example, :
</p><pre><code class="prettyprint lang-scala">lazy val runFixed2 = taskKey[Unit](&quot;A task that hard codes the values to `run`&quot;)

fork in run := true

runFixed2 := {
   val x = (run in Compile).toTask(&quot; blue green&quot;).value
   val y = (run in Compile).toTask(&quot; red orange&quot;).value
   println(&quot;Done!&quot;)
}
</code></pre><p>The different <code>toTask</code> calls define different tasks that each run the
project’s main class in a new jvm. That is, the <code>fork</code> setting
configures both, each has the same classpath, and each run the same main
class. However, each task passes different arguments to the main class.
For a main class Demo that echoes its arguments, the output of running
<code>runFixed2</code> might look like:
</p><pre><code class="">$ sbt
&gt; runFixed2
[info] Running Demo blue green
[info] Running Demo red orange
blue
green
red
orange
Done!
</code></pre><h2 id="Commands">Commands<a href="#Commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="What+is+a+%E2%80%9Ccommand%E2%80%9D%3F">What is a “command”?<a href="#What+is+a+%E2%80%9Ccommand%E2%80%9D%3F" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A “command” looks similar to a task: it’s a named operation that can be
executed from the sbt console.
</p><p>However, a command’s implementation takes as its parameter the entire
state of the build (represented by <a href="Build-State.html">State</a>) and
computes a new <a href="Build-State.html">State</a>. This means that a command can
look at or modify other sbt settings, for example. Typically, you would
resort to a command when you need to do something that’s impossible in a
regular task.
</p><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are three main aspects to commands:
</p><ol><li><p>The syntax used by the user to invoke the command, including:
</p><ul><li>Tab completion for the syntax
</li><li>The parser to turn input into an appropriate data structure
</li></ul></li><li>The action to perform using the parsed data structure. This action
transforms the build <a href="../api/sbt/State.html">State</a>.
</li><li>Help provided to the user
</li></ol><p>In sbt, the syntax part, including tab completion, is specified with
parser combinators. If you are familiar with the parser combinators in
Scala’s standard library, these are very similar. The action part is a
function <code>(State, T) =&gt; State</code>, where <code>T</code> is the data structure produced
by the parser. See the
<a href="Parsing-Input.html">Parsing Input</a> page for how to
use the parser combinators.
</p><p><a href="../api/sbt/State.html">State</a> provides access to the build state,
such as all registered <code>Command</code>s, the remaining commands to execute,
and all project-related information. See <a href="Build-State.html">States and Actions</a> for details on
State.
</p><p>Finally, basic help information may be provided that is used by the
<code>help</code> command to display command help.
</p><h3 id="Defining+a+Command">Defining a Command<a href="#Defining+a+Command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A command combines a function <code>State =&gt; Parser[T]</code> with an action
<code>(State, T) =&gt; State</code>. The reason for <code>State =&gt; Parser[T]</code> and not
simply <code>Parser[T]</code> is that often the current <code>State</code> is used to build
the parser. For example, the currently loaded projects (provided by
<code>State</code>) determine valid completions for the <code>project</code> command. Examples
for the general and specific cases are shown in the following sections.
</p><p>See <a href="../sxr/sbt/Command.scala.html">Command.scala</a> for the source
API details for constructing commands.
</p><h4 id="General+commands">General commands<a href="#General+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>General command construction looks like:
</p><pre><code class="prettyprint lang-scala">val action: (State, T) =&gt; State = ...
val parser: State =&gt; Parser[T] = ...
val command: Command = Command(&quot;name&quot;)(parser)(action)
</code></pre><h4 id="No-argument+commands">No-argument commands<a href="#No-argument+commands" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a convenience method for constructing commands that do not
accept any arguments.
</p><pre><code class="prettyprint lang-scala">val action: State =&gt; State = ...
val command: Command = Command.command(&quot;name&quot;)(action)
</code></pre><h4 id="Single-argument+command">Single-argument command<a href="#Single-argument+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a convenience method for constructing commands that accept a
single argument with arbitrary content.
</p><pre><code class="prettyprint lang-scala">// accepts the state and the single argument
val action: (State, String) =&gt; State = ...
val command: Command = Command.single(&quot;name&quot;)(action)
</code></pre><h4 id="Multi-argument+command">Multi-argument command<a href="#Multi-argument+command" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>There is a convenience method for constructing commands that accept
multiple arguments separated by spaces.
</p><pre><code class="prettyprint lang-scala">val action: (State, Seq[String]) =&gt; State = ...

// &lt;arg&gt; is the suggestion printed for tab completion on an argument
val command: Command = Command.args(&quot;name&quot;, &quot;&lt;arg&gt;&quot;)(action)
</code></pre><h3 id="Full+Example">Full Example<a href="#Full+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The following example is a valid <code>project/Build.scala</code> that adds
commands to a project. To try it out:
</p><ol><li>Copy the following build definition into <code>project/Build.scala</code> for a
new project.
</li><li>Run sbt on the project.
</li><li>Try out the <code>hello</code>, <code>helloAll</code>, <code>failIfTrue</code>, <code>color</code>, and
printState commands.
</li><li>Use tab-completion and the code below as guidance.
</li></ol><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

// imports standard command parsing functionality
import complete.DefaultParsers._

object CommandExample extends Build {
    // Declare a single project, adding several new commands, which are discussed below.
    lazy override val projects = Seq(root)
    lazy val root = Project(&quot;root&quot;, file(&quot;.&quot;)) settings(
        commands ++= Seq(hello, helloAll, failIfTrue, changeColor, printState)
    )

    // A simple, no-argument command that prints &quot;Hi&quot;,
    //  leaving the current state unchanged.
    def hello = Command.command(&quot;hello&quot;) { state =&gt;
        println(&quot;Hi!&quot;)
        state
    }


    // A simple, multiple-argument command that prints &quot;Hi&quot; followed by the arguments.
    //   Again, it leaves the current state unchanged.
    def helloAll = Command.args(&quot;helloAll&quot;, &quot;&lt;name&gt;&quot;) { (state, args) =&gt;
        println(&quot;Hi &quot; + args.mkString(&quot; &quot;))
        state
    }


    // A command that demonstrates failing or succeeding based on the input
    def failIfTrue = Command.single(&quot;failIfTrue&quot;) {
        case (state, &quot;true&quot;) =&gt; state.fail
        case (state, _) =&gt; state
    }


    // Demonstration of a custom parser.
    // The command changes the foreground or background terminal color
    //  according to the input.
    lazy val change = Space ~&gt; (reset | setColor)
    lazy val reset = token(&quot;reset&quot; ^^^ &quot;\033[0m&quot;)
    lazy val color = token( Space ~&gt; (&quot;blue&quot; ^^^ &quot;4&quot; | &quot;green&quot; ^^^ &quot;2&quot;) )
    lazy val select = token( &quot;fg&quot; ^^^ &quot;3&quot; | &quot;bg&quot; ^^^ &quot;4&quot; )
    lazy val setColor = (select ~ color) map { case (g, c) =&gt; &quot;\033[&quot; + g + c + &quot;m&quot; }

    def changeColor = Command(&quot;color&quot;)(_ =&gt; change) { (state, ansicode) =&gt;
        print(ansicode)
        state
    }


    // A command that demonstrates getting information out of State.
    def printState = Command.command(&quot;printState&quot;) { state =&gt;
        import state._
        println(definedCommands.size + &quot; registered commands&quot;)
        println(&quot;commands to run: &quot; + show(remainingCommands))
        println()

        println(&quot;original arguments: &quot; + show(configuration.arguments))
        println(&quot;base directory: &quot; + configuration.baseDirectory)
        println()

        println(&quot;sbt version: &quot; + configuration.provider.id.version)
        println(&quot;Scala version (for sbt): &quot; + configuration.provider.scalaProvider.version)
        println()

        val extracted = Project.extract(state)
        import extracted._
        println(&quot;Current build: &quot; + currentRef.build)
        println(&quot;Current project: &quot; + currentRef.project)
        println(&quot;Original setting count: &quot; + session.original.size)
        println(&quot;Session setting count: &quot; + session.append.size)

        state
    }

    def show[T](s: Seq[T]) =
        s.map(&quot;'&quot; + _ + &quot;'&quot;).mkString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;)
}
</code></pre><h2 id="Parsing+and+tab+completion">Parsing and tab completion<a href="#Parsing+and+tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes the parser combinators in sbt. These parser
combinators are typically used to parse user input and provide tab
completion for <a href="Input-Tasks.html">Input Tasks</a> and <a href="Commands.html">Commands</a>. If
you are already familiar with Scala’s parser combinators, the methods
are mostly the same except that their arguments are strict. There are
two additional methods for controlling tab completion that are discussed
at the end of the section.
</p><p>Parser combinators build up a parser from smaller parsers. A <code>Parser[T]</code>
in its most basic usage is a function <code>String =&gt; Option[T]</code>. It accepts
a <code>String</code> to parse and produces a value wrapped in <code>Some</code> if parsing
succeeds or <code>None</code> if it fails. Error handling and tab completion make
this picture more complicated, but we’ll stick with <code>Option</code> for this
discussion.
</p><p>The following examples assume the imports: :
</p><pre><code class="prettyprint lang-scala">import sbt._
import complete.DefaultParsers._
</code></pre><h3 id="Basic+parsers">Basic parsers<a href="#Basic+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The simplest parser combinators match exact inputs:
</p><pre><code class="prettyprint lang-scala">// A parser that succeeds if the input is 'x', returning the Char 'x'
//  and failing otherwise
val singleChar: Parser[Char] = 'x'

// A parser that succeeds if the input is &quot;blue&quot;, returning the String &quot;blue&quot;
//   and failing otherwise
val litString: Parser[String] = &quot;blue&quot;
</code></pre><p>In these examples, implicit conversions produce a literal <code>Parser</code> from
a <code>Char</code> or <code>String</code>. Other basic parser constructors are the
<code>charClass</code>, <code>success</code> and <code>failure</code> methods:
</p><pre><code class="prettyprint lang-scala">// A parser that succeeds if the character is a digit, returning the matched Char 
//   The second argument, &quot;digit&quot;, describes the parser and is used in error messages
val digit: Parser[Char] = charClass( (c: Char) =&gt; c.isDigit, &quot;digit&quot;)

// A parser that produces the value 3 for an empty input string, fails otherwise
val alwaysSucceed: Parser[Int] = success( 3 )

// Represents failure (always returns None for an input String).
//  The argument is the error message.
val alwaysFail: Parser[Nothing] = failure(&quot;Invalid input.&quot;)
</code></pre><h3 id="Built-in+parsers">Built-in parsers<a href="#Built-in+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt comes with several built-in parsers defined in
<a href="../api/sbt/complete/DefaultParsers$.html">sbt.complete.DefaultParsers</a>.
Some commonly used built-in parsers are:
</p><blockquote><ul><li><code>Space</code>, <code>NotSpace</code>, <code>OptSpace</code>, and <code>OptNotSpace</code> for parsing
spaces or non-spaces, required or not.
</li><li><code>StringBasic</code> for parsing text that may be quoted.
</li><li><code>IntBasic</code> for parsing a signed Int value.
</li><li><code>Digit</code> and <code>HexDigit</code> for parsing a single decimal or hexadecimal
digit.
</li><li><code>Bool</code> for parsing a <code>Boolean</code> value
</li></ul></blockquote><p>See the
<a href="../api/sbt/complete/DefaultParsers$.html">DefaultParsers API</a> for
details.
</p><h3 id="Combining+parsers">Combining parsers<a href="#Combining+parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>We build on these basic parsers to construct more interesting parsers.
We can combine parsers in a sequence, choose between parsers, or repeat
a parser.
</p><pre><code class="prettyprint lang-scala">// A parser that succeeds if the input is &quot;blue&quot; or &quot;green&quot;,
//  returning the matched input
val color: Parser[String] = &quot;blue&quot; | &quot;green&quot;

// A parser that matches either &quot;fg&quot; or &quot;bg&quot;
val select: Parser[String] = &quot;fg&quot; | &quot;bg&quot;

// A parser that matches &quot;fg&quot; or &quot;bg&quot;, a space, and then the color, returning the matched values.
//   ~ is an alias for Tuple2.
val setColor: Parser[String ~ Char ~ String] =
  select ~ ' ' ~ color

// Often, we don't care about the value matched by a parser, such as the space above
//  For this, we can use ~&gt; or &lt;~, which keep the result of
//  the parser on the right or left, respectively
val setColor2: Parser[String ~ String]  =  select ~ (' ' ~&gt; color)

// Match one or more digits, returning a list of the matched characters
val digits: Parser[Seq[Char]]  =  charClass(_.isDigit, &quot;digit&quot;).+

// Match zero or more digits, returning a list of the matched characters
val digits0: Parser[Seq[Char]]  =  charClass(_.isDigit, &quot;digit&quot;).*

// Optionally match a digit
val optDigit: Parser[Option[Char]]  =  charClass(_.isDigit, &quot;digit&quot;).?
</code></pre><h3 id="Transforming+results">Transforming results<a href="#Transforming+results" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A key aspect of parser combinators is transforming results along the way
into more useful data structures. The fundamental methods for this are
<code>map</code> and <code>flatMap</code>. Here are examples of <code>map</code> and some convenience
methods implemented on top of <code>map</code>.
</p><pre><code class="prettyprint lang-scala">// Apply the `digits` parser and apply the provided function to the matched
//   character sequence
val num: Parser[Int] = digits map { (chars: Seq[Char]) =&gt; chars.mkString.toInt }

// Match a digit character, returning the matched character or return '0' if the input is not a digit
val digitWithDefault: Parser[Char]  =  charClass(_.isDigit, &quot;digit&quot;) ?? '0'

// The previous example is equivalent to:
val digitDefault: Parser[Char] =
  charClass(_.isDigit, &quot;digit&quot;).? map { (d: Option[Char]) =&gt; d getOrElse '0' }

// Succeed if the input is &quot;blue&quot; and return the value 4
val blue = &quot;blue&quot; ^^^ 4

// The above is equivalent to:
val blueM = &quot;blue&quot; map { (s: String) =&gt; 4 }
</code></pre><h3 id="Controlling+tab+completion">Controlling tab completion<a href="#Controlling+tab+completion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Most parsers have reasonable default tab completion behavior. For
example, the string and character literal parsers will suggest the
underlying literal for an empty input string. However, it is impractical
to determine the valid completions for <code>charClass</code>, since it accepts an
arbitrary predicate. The <code>examples</code> method defines explicit completions
for such a parser:
</p><pre><code class="prettyprint lang-scala">val digit = charClass(_.isDigit, &quot;digit&quot;).examples(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;)
</code></pre><p>Tab completion will use the examples as suggestions. The other method
controlling tab completion is <code>token</code>. The main purpose of <code>token</code> is to
determine the boundaries for suggestions. For example, if your parser
is:
</p><pre><code class="prettyprint lang-scala">(&quot;fg&quot; | &quot;bg&quot;) ~ ' ' ~ (&quot;green&quot; | &quot;blue&quot;)
</code></pre><p>then the potential completions on empty input are:
<code>console fg green fg blue bg green bg blue</code>
</p><p>Typically, you want to suggest smaller segments or the number of
suggestions becomes unmanageable. A better parser is:
</p><pre><code class="prettyprint lang-scala">token( (&quot;fg&quot; | &quot;bg&quot;) ~ ' ') ~ token(&quot;green&quot; | &quot;blue&quot;)
</code></pre><p>Now, the initial suggestions would be (with <code>_</code> representing a space):
<code>console fg_ bg_</code>
</p><p>Be careful not to overlap or nest tokens, as in
<code>token(&quot;green&quot; ~ token(&quot;blue&quot;))</code>. The behavior is unspecified (and
should generate an error in the future), but typically the outer most
token definition will be used.
</p><h2 id="State+and+actions">State and actions<a href="#State+and+actions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><a href="../api/sbt/State$.html">State</a> is the entry point to all
available information in sbt. The key methods are:
</p><ul><li><code>definedCommands: Seq[Command]</code> returns all registered Command
definitions
</li><li><code>remainingCommands: Seq[String]</code> returns the remaining commands to
be run
</li><li><code>attributes: AttributeMap</code> contains generic data.
</li></ul><p>The action part of a command performs work and transforms <code>State</code>. The
following sections discuss <code>State =&gt; State</code> transformations. As
mentioned previously, a command will typically handle a parsed value as
well: <code>(State, T) =&gt; State</code>.
</p><h3 id="Command-related+data">Command-related data<a href="#Command-related+data" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A Command can modify the currently registered commands or the commands
to be executed. This is done in the action part by transforming the
(immutable) State provided to the command. A function that registers
additional power commands might look like:
</p><pre><code class="prettyprint lang-scala">val powerCommands: Seq[Command] = ...

val addPower: State =&gt; State =
  (state: State) =&gt;
    state.copy(definedCommands =
      (state.definedCommands ++ powerCommands).distinct
    )
</code></pre><p>This takes the current commands, appends new commands, and drops
duplicates. Alternatively, State has a convenience method for doing the
above:
</p><pre><code class="prettyprint lang-scala">val addPower2 = (state: State) =&gt; state ++ powerCommands
</code></pre><p>Some examples of functions that modify the remaining commands to
execute:
</p><pre><code class="prettyprint lang-scala">val appendCommand: State =&gt; State =
  (state: State) =&gt;
    state.copy(remainingCommands = state.remainingCommands :+ &quot;cleanup&quot;)

val insertCommand: State =&gt; State =
  (state: State) =&gt;
    state.copy(remainingCommands = &quot;next-command&quot; +: state.remainingCommands)
</code></pre><p>The first adds a command that will run after all currently specified
commands run. The second inserts a command that will run next. The
remaining commands will run after the inserted command completes.
</p><p>To indicate that a command has failed and execution should not continue,
return <code>state.fail</code>.
</p><pre><code class="prettyprint lang-scala">(state: State) =&gt; {
  val success: Boolean = ...
  if(success) state else state.fail
}
</code></pre><h3 id="Project-related+data">Project-related data<a href="#Project-related+data" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Project-related information is stored in <code>attributes</code>. Typically,
commands won’t access this directly but will instead use a convenience
method to extract the most useful information:
</p><pre><code class="prettyprint lang-scala">val state: State
val extracted: Extracted = Project.extract(state)
import extracted._
</code></pre><p><a href="../api/sbt/Extracted.html">Extracted</a> provides:
</p><ul><li>Access to the current build and project (<code>currentRef</code>)
</li><li>Access to initialized project setting data (<code>structure.data</code>)
</li><li>Access to session <code>Setting</code>s and the original, permanent settings
from .sbt and .scala files (session.append and session.original,
respectively)
</li><li>Access to the current <a href="../api/sbt/compiler/Eval.html">Eval</a>
instance for evaluating Scala expressions in the build context.
</li></ul><h3 id="Project+data">Project data<a href="#Project+data" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>All project data is stored in <code>structure.data</code>, which is of type
<code>sbt.Settings[Scope]</code>. Typically, one gets information of type <code>T</code> in
the following way:
</p><pre><code class="prettyprint lang-scala">val key: SettingKey[T]
val scope: Scope
val value: Option[T] = key in scope get structure.data
</code></pre><p>Here, a <code>SettingKey[T]</code> is typically obtained from
<a href="../api/sbt/Keys$.html">Keys</a> and is the same type that is used to
define settings in <code>.sbt</code> files, for example.
<a href="../api/sbt/Scope.html">Scope</a> selects the scope the key is
obtained for. There are convenience overloads of <code>in</code> that can be used
to specify only the required scope axes. See
<a href="../sxr/sbt/Structure.scala.html">Structure.scala</a> for where <code>in</code>
and other parts of the settings interface are defined. Some examples:
</p><pre><code class="prettyprint lang-scala">import Keys._
val extracted: Extracted
import extracted._

// get name of current project
val nameOpt: Option[String] = name in currentRef get structure.data

// get the package options for the `test:packageSrc` task or Nil if none are defined
val pkgOpts: Seq[PackageOption] = packageOptions in (currentRef, Test, packageSrc) get structure.data getOrElse Nil
</code></pre><p><a href="../api/sbt/Load$$BuildStructure.html">BuildStructure</a> contains
information about build and project relationships. Key members are:
</p><pre><code class="prettyprint lang-scala">units: Map[URI, LoadedBuildUnit]
root: URI
</code></pre><p>A <code>URI</code> identifies a build and <code>root</code> identifies the initial build
loaded. <a href="../api/sbt/Load$$LoadedBuildUnit.html">LoadedBuildUnit</a>
provides information about a single build. The key members of
<code>LoadedBuildUnit</code> are:
</p><pre><code class="prettyprint lang-scala">// Defines the base directory for the build
localBase: File

// maps the project ID to the Project definition
defined: Map[String, ResolvedProject]
</code></pre><p><a href="../api/sbt/ResolvedProject.html">ResolvedProject</a> has the same
information as the <code>Project</code> used in a <code>project/Build.scala</code> except that
<a href="../api/sbt/ProjectReference.html">ProjectReferences</a> are resolved
to <code>ProjectRef</code>s.
</p><h3 id="Classpaths">Classpaths<a href="#Classpaths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Classpaths in sbt 0.10+ are of type <code>Seq[Attributed[File]]</code>. This allows
tagging arbitrary information to classpath entries. sbt currently uses
this to associate an <code>Analysis</code> with an entry. This is how it manages
the information needed for multi-project incremental recompilation. It
also associates the ModuleID and Artifact with managed entries (those
obtained by dependency management). When you only want the underlying
<code>Seq[File]</code>, use <code>files</code>:
</p><pre><code class="prettyprint lang-scala">val attributedClasspath: Seq[Attribute[File]] = ...
val classpath: Seq[File] = attributedClasspath.files
</code></pre><h3 id="Running+tasks">Running tasks<a href="#Running+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It can be useful to run a specific project task from a
<a href="Commands.html">command</a> (<em>not from another task</em>) and get its result. For
example, an IDE-related command might want to get the classpath from a
project or a task might analyze the results of a compilation. The
relevant method is <code>Project.evaluateTask</code>, which has the following
signature:
</p><pre><code class="prettyprint lang-scala">def evaluateTask[T](taskKey: ScopedKey[Task[T]], state: State,
  checkCycles: Boolean = false, maxWorkers: Int = ...): Option[Result[T]]
</code></pre><p>For example,
</p><pre><code class="prettyprint lang-scala">val eval: State =&gt; State = (state: State) =&gt; {

    // This selects the main 'compile' task for the current project.
    //   The value produced by 'compile' is of type inc.Analysis,
    //   which contains information about the compiled code.
    val taskKey = Keys.compile in Compile

    // Evaluate the task
    // None if the key is not defined
    // Some(Inc) if the task does not complete successfully (Inc for incomplete)
    // Some(Value(v)) with the resulting value
    val result: Option[Result[inc.Analysis]] = Project.evaluateTask(taskKey, state)
    // handle the result
    result match
    {
        case None =&gt; // Key wasn't defined.
        case Some(Inc(inc)) =&gt; // error detail, inc is of type Incomplete, use Incomplete.show(inc.tpe) to get an error message
        case Some(Value(v)) =&gt; // do something with v: inc.Analysis
    }
}
</code></pre><p>For getting the test classpath of a specific project, use this key:
</p><pre><code class="prettyprint lang-scala">val projectRef: ProjectRef = ...
val taskKey: Task[Seq[Attributed[File]]] =
  Keys.fullClasspath in (projectRef, Test)
</code></pre><h3 id="Using+State+in+a+task">Using State in a task<a href="#Using+State+in+a+task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>To access the current State from a task, use the <code>state</code> task as an
input. For example,
</p><pre><code class="prettyprint lang-scala">myTask := ... state.value ...
</code></pre><h2 id="Tasks%2FSettings%3A+Motivation">Tasks/Settings: Motivation<a href="#Tasks%2FSettings%3A+Motivation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page motivates the task and settings system. You should already
know how to use tasks and settings, which are described in the
<a href="../tutorial/More-About-Settings.html">getting started guide</a> and on
the <a href="Tasks.html">Tasks</a> page.
</p><p>An important aspect of the task system is to combine two common, related
steps in a build:
</p><ol><li>Ensure some other task is performed.
</li><li>Use some result from that task.
</li></ol><p>Earlier versions of sbt configured these steps separately using
</p><ol><li>Dependency declarations
</li><li>Some form of shared state
</li></ol><p>To see why it is advantageous to combine them, compare the situation to
that of deferring initialization of a variable in Scala. This Scala code
is a bad way to expose a value whose initialization is deferred:
</p><pre><code class="prettyprint lang-scala">// Define a variable that will be initialized at some point
// We don't want to do it right away, because it might be expensive
var foo: Foo = _

// Define a function to initialize the variable
def makeFoo(): Unit = ... initialize foo ...
</code></pre><p>Typical usage would be:
</p><pre><code class="prettyprint lang-scala">makeFoo()
doSomething(foo)
</code></pre><p>This example is rather exaggerated in its badness, but I claim it is
nearly the same situation as our two step task definitions. Particular
reasons this is bad include:
</p><ol><li>A client needs to know to call <code>makeFoo()</code> first.
</li><li><code>foo</code> could be changed by other code. There could be a
def makeFoo2(), for example.
</li><li>Access to foo is not thread safe.
</li></ol><p>The first point is like declaring a task dependency, the second is like
two tasks modifying the same state (either project variables or files),
and the third is a consequence of unsynchronized, shared state.
</p><p>In Scala, we have the built-in functionality to easily fix this:
<code>lazy val</code>.
</p><pre><code class="prettyprint lang-scala">lazy val foo: Foo = ... initialize foo ...
</code></pre><p>with the example usage:
</p><pre><code class="prettyprint lang-scala">doSomething(foo)
</code></pre><p>Here, <code>lazy val</code> gives us thread safety, guaranteed initialization
before access, and immutability all in one, DRY construct. The task
system in sbt does the same thing for tasks (and more, but we won’t go
into that here) that <code>lazy val</code> did for our bad example.
</p><p>A task definition must declare its inputs and the type of its output.
sbt will ensure that the input tasks have run and will then provide
their results to the function that implements the task, which will
generate its own result. Other tasks can use this result and be assured
that the task has run (once) and be thread-safe and typesafe in the
process.
</p><p>The general form of a task definition looks like:
</p><pre><code class="prettyprint lang-scala">myTask := {
  val a: A = aTask.value
  val b: B = bTask.value
  ... do something with a, b and generate a result ...
}
</code></pre><p>(This is only intended to be a discussion of the ideas behind tasks, so
see the <a href="Tasks.html">sbt Tasks</a> page for details on usage.)
Here, <code>aTask</code> is assumed to produce a result of type <code>A</code> and <code>bTask</code> is
assumed to produce a result of type <code>B</code>.
</p><h3 id="Application">Application<a href="#Application" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>As an example, consider generating a zip file containing the binary jar,
source jar, and documentation jar for your project. First, determine
what tasks produce the jars. In this case, the input tasks are
<code>packageBin</code>, <code>packageSrc</code>, and <code>packageDoc</code> in the main <code>Compile</code>
scope. The result of each of these tasks is the File for the jar that
they generated. Our zip file task is defined by mapping these package
tasks and including their outputs in a zip file. As good practice, we
then return the File for this zip so that other tasks can map on the zip
task.
</p><pre><code class="prettyprint lang-scala">zip := {
    val bin: File = (packageBin in Compile).value
    val src: File = (packageSrc in Compile).value
    val doc: File = (packageDoc in Compile).value
    val out: File = zipPath.value
    val inputs: Seq[(File,String)] = Seq(bin, src, doc) x Path.flat
    IO.zip(inputs, out)
    out
}
</code></pre><p>The <code>val inputs</code> line defines how the input files are mapped to paths in
the zip. See <a href="Mapping-Files.html">Mapping Files</a> for details. The explicit
types are not required, but are included for clarity.
</p><p>The <code>zipPath</code> input would be a custom task to define the location of the
zip file. For example:
</p><pre><code class="prettyprint lang-scala">zipPath := target.value / &quot;out.zip&quot;
</code></pre><h2 id="Plugins+and+Best+Practices">Plugins and Best Practices<a href="#Plugins+and+Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This part of the documentation has pages documenting particular sbt
topics in detail. Before reading anything in here, you will need the
information in the 
<a href="../tutorial/index.html">Getting Started Guide</a> as
a foundation.
</p><h2 id="General+Best+Practices">General Best Practices<a href="#General+Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes best practices for working with sbt.
</p><h3 id="vs."><code>project/</code> vs. <code>~/.sbt/</code><a href="#vs." class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Anything that is necessary for building the project should go in
<code>project/</code>. This includes things like the web plugin. <code>~/.sbt/</code> should
contain local customizations and commands for working with a build, but
are not necessary. An example is an IDE plugin.
</p><h3 id="Local+settings">Local settings<a href="#Local+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are two options for settings that are specific to a user. An
example of such a setting is inserting the local Maven repository at the
beginning of the resolvers list:
</p><pre><code class="prettyprint lang-scala">resolvers := {
  val localMaven = &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.absolutePath+&quot;/.m2/repository&quot;
  localMaven +: resolvers.value
}
</code></pre><ol><li>Put settings specific to a user in a global <code>.sbt</code> file, such as
<code>~/.sbt/0.13/global.sbt</code>. These settings will be applied to all projects.
</li><li>Put settings in a <code>.sbt</code> file in a project that isn’t checked into
version control, such as <code>&lt;project&gt;/local.sbt</code>. sbt combines the
settings from multiple .sbt files, so you can still have the
standard <code>&lt;project&gt;/build.sbt</code> and check that into version control.
</li></ol><h3 id=".sbtrc">.sbtrc<a href="#.sbtrc" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Put commands to be executed when sbt starts up in a <code>.sbtrc</code> file, one
per line. These commands run before a project is loaded and are useful
for defining aliases, for example. sbt executes commands in
<code>$HOME/.sbtrc</code> (if it exists) and then <code>&lt;project&gt;/.sbtrc</code> (if it
exists).
</p><h3 id="Generated+files">Generated files<a href="#Generated+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Write any generated files to a subdirectory of the output directory,
which is specified by the <code>target</code> setting. This makes it easy to clean
up after a build and provides a single location to organize generated
files. Any generated files that are specific to a Scala version should
go in <code>crossTarget</code> for efficient cross-building.
</p><p>For generating sources and resources, see <a href="Howto-Generating-Files.html">Generating Files</a>.
</p><h3 id="Don%E2%80%99t+hard+code">Don’t hard code<a href="#Don%E2%80%99t+hard+code" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Don’t hard code constants, like the output directory <code>target/</code>. This is
especially important for plugins. A user might change the <code>target</code>
setting to point to <code>build/</code>, for example, and the plugin needs to
respect that. Instead, use the setting, like:
</p><pre><code class="prettyprint lang-scala">myDirectory := target.value / &quot;sub-directory&quot;
</code></pre><h3 id="Don%E2%80%99t+%E2%80%9Cmutate%E2%80%9D+files">Don’t “mutate” files<a href="#Don%E2%80%99t+%E2%80%9Cmutate%E2%80%9D+files" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A build naturally consists of a lot of file manipulation. How can we
reconcile this with the task system, which otherwise helps us avoid
mutable state? One approach, which is the recommended approach and the
approach used by sbt’s default tasks, is to only write to any given file
once and only from a single task.
</p><p>A build product (or by-product) should be written exactly once by only
one task. The task should then, at a minimum, provide the Files created
as its result. Another task that wants to use Files should map the task,
simultaneously obtaining the File reference and ensuring that the task
has run (and thus the file is constructed). Obviously you cannot do much
about the user or other processes modifying the files, but you can make
the I/O that is under the build’s control more predictable by treating
file contents as immutable at the level of Tasks.
</p><p>For example:
</p><pre><code class="prettyprint lang-scala">lazy val makeFile = taskKey[File](&quot;Creates a file with some content.&quot;)

// define a task that creates a file,
//  writes some content, and returns the File
makeFile := {
    val f: File = file(&quot;/tmp/data.txt&quot;)
    IO.write(f, &quot;Some content&quot;)
    f
}

// The result of makeFile is the constructed File,
//   so useFile can map makeFile and simultaneously
//   get the File and declare the dependency on makeFile
useFile :=
    doSomething( makeFile.value )
</code></pre><p>This arrangement is not always possible, but it should be the rule and
not the exception.
</p><h3 id="Use+absolute+paths">Use absolute paths<a href="#Use+absolute+paths" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Construct only absolute Files. Either specify an absolute path
</p><pre><code class="prettyprint lang-scala">file(&quot;/home/user/A.scala&quot;)
</code></pre><p>or construct the file from an absolute base:
</p><pre><code class="prettyprint lang-scala">base / &quot;A.scala&quot;
</code></pre><p>This is related to the no hard coding best practice because the proper
way involves referencing the <code>baseDirectory</code> setting. For example, the
following defines the myPath setting to be the <code>&lt;base&gt;/licenses/</code>
directory.
</p><pre><code class="prettyprint lang-scala">myPath := baseDirectory.value / &quot;licenses&quot;
</code></pre><p>In Java (and thus in Scala), a relative File is relative to the current
working directory. The working directory is not always the same as the
build root directory for a number of reasons.
</p><p>The only exception to this rule is when specifying the base directory
for a Project. Here, sbt will resolve a relative File against the build
root directory for you for convenience.
</p><h3 id="Parser+combinators">Parser combinators<a href="#Parser+combinators" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ol><li>Use <code>token</code> everywhere to clearly delimit tab completion boundaries.
</li><li>Don’t overlap or nest tokens. The behavior here is unspecified and
will likely generate an error in the future.
</li><li>Use <code>flatMap</code> for general recursion. sbt’s combinators are strict to
limit the number of classes generated, so use flatMap like:
</li></ol><pre><code class="prettyprint lang-scala">lazy val parser: Parser[Int] =
  token(IntBasic) flatMap { i =&gt;
    if(i &lt;= 0)
      success(i)
    else
      token(Space ~&gt; parser)
  }
</code></pre><blockquote><p>This example defines a parser a whitespace-delimited list of integers,
ending with a negative number, and returning that final, negative
number.
</p></blockquote><h2 id="Plugins">Plugins<a href="#Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin is essentially a way to use external code in a build
definition. A plugin can be a library used to implement a task. For
example, you might use
<a href="https://github.com/tristanjuricek/knockoff/">Knockoff</a> to write a
markdown processing task. A plugin can define a sequence of sbt Settings
that are automatically added to all projects or that are explicitly
declared for selected projects. For example, a plugin might add a
<code>proguard</code> task and associated (overridable) settings. Also, <code>Commands</code>
can be added with the <code>commands</code> setting
</p><p>The <code>Plugins-Best-Practices</code> page describes the currently evolving
guidelines to writing sbt plugins. See also the general
<a href="Best-Practices.html">best practices</a>.
</p><h3 id="Using+a+binary+sbt+plugin">Using a binary sbt plugin<a href="#Using+a+binary+sbt+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A common situation is using a binary plugin published to a repository.
Create <code>project/plugins.sbt</code> with the desired sbt plugins, any general
dependencies, and any necessary repositories:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.example&quot; % &quot;plugin&quot; % &quot;1.0&quot;)

addSbtPlugin(&quot;org.example&quot; % &quot;another-plugin&quot; % &quot;2.0&quot;)

// plain library (not an sbt plugin) for use in the build definition
libraryDependencies += &quot;org.example&quot; % &quot;utilities&quot; % &quot;1.3&quot;

resolvers += &quot;Example Plugin Repository&quot; at &quot;http://example.org/repo/&quot;
</code></pre><p>See the rest of the page for more information on creating and using
plugins.
</p><h3 id="By+Description">By Description<a href="#By+Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin definition is a project in <code>&lt;main-project&gt;/project/</code>. This
project’s classpath is the classpath used for build definitions in
<code>&lt;main-project&gt;/project/</code> and any <code>.sbt</code> files in the project’s base
directory. It is also used for the <code>eval</code> and <code>set</code> commands.
</p><p>Specifically,
</p><ol><li>Managed dependencies declared by the <code>project/</code> project are
retrieved and are available on the build definition classpath, just
like for a normal project.
</li><li>Unmanaged dependencies in <code>project/lib/</code> are available to the build
definition, just like for a normal project.
</li><li>Sources in the <code>project/</code> project are the build definition files and
are compiled using the classpath built from the managed and
unmanaged dependencies.
</li><li>Project dependencies can be declared in <code>project/plugins.sbt</code> or
project/project/Build.scala and will be available to the build
definition sources. Think of project/project/ as the build
definition for the build definition.
</li></ol><p>The build definition classpath is searched for <code>sbt/sbt.plugins</code>
descriptor files containing the names of Plugin implementations. A
Plugin is a module that defines settings to automatically inject to
projects. Additionally, all Plugin modules are wildcard imported for the
<code>eval</code> and <code>set</code> commands and <code>.sbt</code> files. A Plugin implementation is
not required to produce a plugin, however. It is a convenience for
plugin consumers and because of the automatic nature, it is not always
appropriate.
</p><p>The <code>reload plugins</code> command changes the current build to
<code>&lt;current-build&gt;/project/</code>. This allows manipulating the build
definition project like a normal project. <code>reload return</code> changes back
to the original build. Any session settings for the plugin definition
project that have not been saved are dropped.
</p><p><em>Note</em>: At runtime, all plugins for all builds are loaded in a separate,
parent class loader of the class loaders for builds. This means that
plugins will not see classes or resources from build definitions.
</p><h4 id="Global+plugins">Global plugins<a href="#Global+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>~/.sbt/0.13/plugins/</code> directory is treated as a global plugin
definition project. It is a normal sbt project whose classpath is
available to all sbt project definitions for that user as described
above for per-project plugins.
</p><h3 id="By+Example">By Example<a href="#By+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Using+a+library+in+a+build+definition">Using a library in a build definition<a href="#Using+a+library+in+a+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As an example, we’ll add the Grizzled Scala library as a plugin.
Although this does not provide sbt-specific functionality, it
demonstrates how to declare plugins.
</p><h5 id="1a%29+Manually+managed">1a) Manually managed<a href="#1a%29+Manually+managed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><ol><li>Download the jar manually from
<a href="https://oss.sonatype.org/content/repositories/releases/org/clapper/grizzled-scala_2.8.1/1.0.4/grizzled-scala_2.8.1-1.0.4.jar">https://oss.sonatype.org/content/repositories/releases/org/clapper/grizzled-scala<em>2.8.1/1.0.4/grizzled-scala</em>2.8.1-1.0.4.jar</a>
</li><li>Put it in <code>project/lib/</code>
</li></ol><h5 id="1b%29+Automatically+managed%3A+direct+editing+approach">1b) Automatically managed: direct editing approach<a href="#1b%29+Automatically+managed%3A+direct+editing+approach" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Edit <code>project/plugins.sbt</code> to contain:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.clapper&quot; %% &quot;grizzled-scala&quot; % &quot;1.0.4&quot;
</code></pre><p>If sbt is running, do <code>reload</code>.
</p><h5 id="1c%29+Automatically+managed%3A+command+line+approach">1c) Automatically managed: command line approach<a href="#1c%29+Automatically+managed%3A+command+line+approach" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>We can change to the plugins project in <code>project/</code> using
<code>reload plugins</code>.
</p><pre><code class="">$ sbt
&gt; reload plugins
[info] Set current project to default (in build file:/Users/harrah/demo2/project/)
&gt;
</code></pre><p>Then, we can add dependencies like usual and save them to
<code>project/plugins.sbt</code>. It is useful, but not required, to run <code>update</code>
to verify that the dependencies are correct.
</p><pre><code class="">&gt; set libraryDependencies += &quot;org.clapper&quot; %% &quot;grizzled-scala&quot; % &quot;1.0.4&quot;
...
&gt; update
...
&gt; session save
...
</code></pre><p>To switch back to the main project:
</p><pre><code class="">&gt; reload return
[info] Set current project to root (in build file:/Users/harrah/demo2/)
</code></pre><h5 id="1d%29+Project+dependency">1d) Project dependency<a href="#1d%29+Project+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>This variant shows how to use sbt’s external project support to declare
a source dependency on a plugin. This means that the plugin will be
built from source and used on the classpath.
</p><p>Edit <code>project/plugins.sbt</code>
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;)).dependsOn(assemblyPlugin)
lazy val assemblyPlugin = uri(&quot;git://github.com/sbt/sbt-assembly&quot;)
</code></pre><p>If sbt is running, run <code>reload</code>.
</p><p>Note that this approach can be useful used when developing a plugin. A
project that uses the plugin will rebuild the plugin on <code>reload</code>. This
saves the intermediate steps of <code>publishLocal</code> and <code>update</code>. It can also
be used to work with the development version of a plugin from its
repository.
</p><p>It is recommended to explicitly specify the commit or tag by appending
it to the repository as a fragment:
</p><pre><code class="prettyprint lang-scala">lazy val assemblyPlugin = uri(&quot;git://github.com/sbt/sbt-assembly#0.9.1&quot;)
</code></pre><p>One caveat to using this method is that the local sbt will try to run
the remote plugin’s build. It is quite possible that the plugin’s own
build uses a different sbt version, as many plugins cross-publish for
several sbt versions. As such, it is recommended to stick with binary
artifacts when possible.
</p><h5 id="2%29+Use+the+library">2) Use the library<a href="#2%29+Use+the+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Grizzled Scala is ready to be used in build definitions. This includes
the <code>eval</code> and <code>set</code> commands and <code>.sbt</code> and <code>project/*.scala</code> files.
</p><pre><code class="">&gt; eval grizzled.sys.os
</code></pre><p>In a <code>build.sbt</code> file:
</p><pre><code class="prettyprint lang-scala">import grizzled.sys._
import OperatingSystem._

libraryDependencies ++=
    if(os ==Windows)
        (&quot;org.example&quot; % &quot;windows-only&quot; % &quot;1.0&quot;) :: Nil
    else
        Nil
</code></pre><h3 id="Creating+a+plugin">Creating a plugin<a href="#Creating+a+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A minimal plugin is a Scala library that is built against the version of
Scala that sbt runs (currently, 2.10.3) or a Java library.
Nothing special needs to be done for this type of library, as shown in
the previous section. A more typical plugin will provide sbt tasks,
commands, or settings. This kind of plugin may provide these settings
automatically or make them available for the user to explicitly
integrate.
</p><h4 id="Description">Description<a href="#Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To make a plugin, create a project and configure <code>sbtPlugin</code> to <code>true</code>.
Then, write the plugin code and publish your project to a repository.
The plugin can be used as described in the previous section.
</p><ul><li>Automatically importing selective names to <code>.sbt</code> files.
</li><li>Specifying plugin dependencies.
</li><li>Automatically activating itself when all dependencies are present.
</li><li>Specifying <code>projectSettings</code>, <code>buildSettings</code>, and <code>globalSettings</code>
as appropriate.
</li></ul><p>When an AutoPlugin provides a stable field such as <code>val</code> or <code>object</code>
named <code>autoImport</code>, the contents of the field are wildcard imported in
in <code>set</code>, <code>eval</code>, and <code>.sbt</code> files. Typically, this is used to provide
new keys (SettingKey, TaskKey, or InputKey) or core methods without
requiring an import or qualification.
</p><p>The AutoPlugin’s <code>projectSettings</code> is automatically appended to each
project’s settings, when its dependencies also exist on that project.
The <code>requires</code> method defines the dependencies to other plugins. The
<code>trigger</code> method defines the conditions by which this plugin’s settings
are automatically activated. The <code>buildSettings</code> is appended to each
build’s settings (that is, <code>in ThisBuild</code>). The <code>globalSettings</code> is
appended once to the global settings (<code>in Global</code>). These allow a plugin
to automatically provide new functionality or new defaults. One main use
of this feature is to globally add commands, such as for IDE plugins.
Use <code>globalSettings</code> to define the default value of a setting.
</p><h4 id="Example+Plugin">Example Plugin<a href="#Example+Plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An example of a typical plugin:
</p><p><code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">sbtPlugin := true

name := &quot;sbt-obfuscate&quot;

organization := &quot;org.example&quot;
</code></pre><p><code>Plugin.scala</code>:
</p><pre><code class="prettyprint lang-scala">package sbtobfuscate

import sbt._

object Plugin extends AutoPlugin
{
    // by definging autoImport, these are automatically imported into user's `*.sbt`
    object autoImport
    {
        // configuration points, like the built in `version`, `libraryDependencies`, or `compile`
        val obfuscate = taskKey[Seq[File]](&quot;Obfuscates files.&quot;)
        val obfuscateLiterals = settingKey[Boolean](&quot;Obfuscate literals.&quot;)

        // default values for the tasks and settings
        lazy val baseObfuscateSettings: Seq[sbt.Def.Setting[_]] = Seq(
            obfuscate := {
                Obfuscate(sources.value, (obfuscateLiterals in obfuscate).value)
            },
            obfuscateLiterals in obfuscate := false                
        )
    }

    import autoImport._
    override def requires = sbt.plugins.JvmModule

    // This plugin is automatically enabled for projects which are JvmModules.
    override def trigger = allRequirements

    // a group of settings that are automatically added to projects.
    override val projectSettings =
        inConfig(Compile)(baseObfucscateSettings) ++
        inConfig(Test)(baseObfuscateSettings)
}

object Obfuscate
{
    def apply(sources: Seq[File]): Seq[File] := sources
}
</code></pre><h4 id="Usage+example">Usage example<a href="#Usage+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A build definition that uses the plugin might look like. <code>obfuscate.sbt</code>:
</p><pre><code class="prettyprint lang-scala">obfuscateLiterals in obfuscate := true
</code></pre><h4 id="Root+Plugins">Root Plugins<a href="#Root+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Some plugins should always be explicitly enabled on projects. Sbt calls
these root plugins, i.e. plugins that are “root” nodes in the plugin
depdendency graph. <code>AutoPlugin</code> by default defines a root plugin.
</p><h4 id="Example+command+root+plugin">Example command root plugin<a href="#Example+command+root+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A basic plugin that adds commands looks like. <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">sbtPlugin := true

name := &quot;sbt-sample&quot;

organization := &quot;org.example&quot;
</code></pre><p><code>Plugin.scala</code>:
</p><pre><code class="prettyprint lang-scala">package sbtsample

import sbt._
import Keys._
object Plugin extends AutoPlugin {
  override lazy val projectSettings = Seq(commands += myCommand)

  lazy val myCommand = 
    Command.command(&quot;hello&quot;) { (state: State) =&gt;
      println(&quot;Hi!&quot;)
      state
    }
}
</code></pre><p>This example demonstrates how to take a Command (here, <code>myCommand</code>) and
distribute it in a plugin. Note that multiple commands can be included
in one plugin (for example, use <code>commands ++= Seq(a,b)</code>). See
<a href="Commands.html">Commands</a>
for defining more useful commands, including ones that accept arguments
and affect the execution state.
</p><p>For a user to consume this plugin, it requires an explicit include via
the <code>Project</code> instance. Here’s what their local sbt will look like. <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">val root = Project(&quot;example-plugin-usage&quot;, file(&quot;.&quot;)).setPlugins(MyPlugin)
</code></pre><p>The <code>setPlugins</code> method allows projects to explicitly define the
<code>RootPlugin</code>s they wish to consume. <code>AutoPlugin</code>s are automatically
added to the project as appropriate.
</p><p>Projects can also exclude any type of plugin using the <code>disablePlugins</code>
method. For example, if we wish to remove the JvmModule settings
(<code>compile</code>,<code>test</code>,<code>run</code>), we modify our <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">val root = Project(&quot;example-plugin-usage&quot;, file(&quot;.&quot;)).setPlugins(MyPlugin).disablePlugins(plugins.JvmModule)
</code></pre><h4 id="Global+plugins+example">Global plugins example<a href="#Global+plugins+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The simplest global plugin definition is declaring a library or plugin
in <code>~/.sbt/0.13/plugins/build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.example&quot; %% &quot;example-plugin&quot; % &quot;0.1&quot;
</code></pre><p>This plugin will be available for every sbt project for the current
user.
</p><p>In addition:
</p><ul><li>Jars may be placed directly in <code>~/.sbt/0.13/plugins/lib/</code>
and will be available to every build definition for the current user.
</li><li>Dependencies on plugins built from source may be declared in
<code>~/.sbt/0.13/plugins/project/Build.scala</code> as described at
[.scala build definition][Full-Deff].
</li><li>A Plugin may be directly defined in Scala
source files in <code>~/.sbt/0.13/plugins/</code>, such as
<code>~/.sbt/0.13/plugins/MyPlugin.scala</code>.
<code>~/.sbt/0.13/plugins//build.sbt</code>
should contain <code>sbtPlugin := true</code>. This can be used for quicker
turnaround when developing a plugin initially:
</li></ul><ol><li>Edit the global plugin code
</li><li>reload the project you want to use the modified plugin in
</li><li><p>sbt will rebuild the plugin and use it for the project.
</p><p>   Additionally, the plugin will be available in other projects on
   the machine without recompiling again. This approach skips the
   overhead of publishLocal and cleaning the plugins directory of the
   project using the plugin.
</p></li></ol><p>These are all consequences of <code>~/.sbt/0.13/plugins/</code> being a standard
project whose classpath is added to every sbt project’s build
definition.
</p><h3 id="Best+Practices">Best Practices<a href="#Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you’re a plugin writer, please consult the <a href="Plugins-Best-Practices.html">plugins best practices</a>
page; it contains a set of guidelines to help you ensure that your
plugin is consistent with and plays well with other plugins.
</p><h2 id="Plugins+Best+Practices">Plugins Best Practices<a href="#Plugins+Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><em>This page is intended primarily for sbt plugin authors.</em>
</p><p>A plugin developer should strive for consistency and ease of use.
Specifically:
</p><ul><li>Plugins should play well with other plugins. Avoiding namespace
clashes (in both sbt and Scala) is paramount.
</li><li>Plugins should follow consistent conventions. The experiences of an
sbt <em>user</em> should be consistent, no matter what plugins are pulled
in.
</li></ul><p>Here are some current plugin best practices. <strong>NOTE:</strong> Best practices
are evolving, so check back frequently.
</p><h3 id="Don%E2%80%99t+use+default+package">Don’t use default package<a href="#Don%E2%80%99t+use+default+package" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Users who have their build files in some package will not be able to use
your plugin if it’s defined in default (no-name) package.
</p><h3 id="Avoid+older++mechanism">Avoid older <code>sbt.Plugin</code> mechanism<a href="#Avoid+older++mechanism" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt has deprecated the old <code>sbt.Plugin</code> mechanism in favor of
<code>sbt.AutoPlugin</code>. The new mechanism features a set of user-level
controls and dependency declarations that cleans up a lot of
long-standing issues with plugins.
</p><h3 id="Reuse+existing+keys">Reuse existing keys<a href="#Reuse+existing+keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>sbt has a number of <a href="../api/sbt/Keys%24.html">predefined keys</a>.
Where possible, reuse them in your plugin. For instance, don’t define:
</p><pre><code class="prettyprint lang-scala">val sourceFiles = settingKey[Seq[File]](&quot;Some source files&quot;)
</code></pre><p>Instead, simply reuse sbt’s existing <code>sources</code> key.
</p><h3 id="Avoid+namespace+clashes">Avoid namespace clashes<a href="#Avoid+namespace+clashes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Sometimes, you need a new key, because there is no existing sbt key. In
this case, use a plugin-specific prefix, both in the (string) key name
used in the sbt namespace and in the Scala <code>val</code>. There are two
acceptable ways to accomplish this goal.
</p><h4 id="Just+use+a++prefix">Just use a <code>val</code> prefix<a href="#Just+use+a++prefix" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">package sbtobfuscate
object Plugin extends sbt.Plugin {
  val obfuscateStylesheet = settingKey[File](&quot;Obfuscate stylesheet&quot;)
}
</code></pre><p>In this approach, every <code>val</code> starts with <code>obfuscate</code>. A user of the
plugin would refer to the settings like this:
</p><pre><code class="prettyprint lang-scala">obfuscateStylesheet := ...
</code></pre><h4 id="Use+a+nested+object">Use a nested object<a href="#Use+a+nested+object" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">package sbtobfuscate
object Plugin extends sbt.Plugin {
  object ObfuscateKeys {
    val stylesheet = SettingKey[File](&quot;obfuscateStylesheet&quot;)
  }
}
</code></pre><p>In this approach, all non-common settings are in a nested object. A user
of the plugin would refer to the settings like this:
</p><pre><code class="prettyprint lang-scala">import ObfuscateKeys._ // place this at the top of build.sbt

stylesheet := ...
</code></pre><h3 id="Configuration+Advice">Configuration Advice<a href="#Configuration+Advice" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Due to usability concerns from the shell, you could opt out of
task-scoping described in this section, if your plugin makes heavy use
of the shell. Using configuration-scoping the user could discover your
tasks using tab completion:
</p><pre><code class="">coffee:[tab]
</code></pre><p>This method no longer works with per-task keys, but there’s a pending
case, so hopefully it will be addressed in the future.
</p><h4 id="When+to+define+your+own+configuration">When to define your own configuration<a href="#When+to+define+your+own+configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If your plugin introduces a new concept (even if that concept reuses an
existing key), you want your own configuration. For instance, suppose
you’ve built a plugin that produces PDF files from some kind of markup,
and your plugin defines a target directory to receive the resulting
PDFs. That target directory is scoped in its own configuration, so it is
distinct from other target directories. Thus, these two definitions use
the same <em>key</em>, but they represent distinct <em>values</em>. So, in a user’s
<code>build.sbt</code>, we might see:
</p><pre><code class="prettyprint lang-scala">target in PDFPlugin := baseDirectory.value / &quot;mytarget&quot; / &quot;pdf&quot;

target in Compile := baseDirectory.value / &quot;mytarget&quot;
</code></pre><p>In the PDF plugin, this is achieved with an <code>inConfig</code> definition:
</p><pre><code class="prettyprint lang-scala">val settings: Seq[sbt.Project.Setting[_]] = inConfig(LWM)(Seq(
  target := baseDirectory.value / &quot;target&quot; / &quot;docs&quot; # the default value
))
</code></pre><h4 id="When++to+define+your+own+configuration.">When <em>not</em> to define your own configuration.<a href="#When++to+define+your+own+configuration." class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>If you’re merely adding to existing definitions, don’t define your own
configuration. Instead, reuse an existing one <em>or</em> scope by the main
task (see below).
</p><pre><code class="prettyprint lang-scala">val akka = config(&quot;akka&quot;)  // This isn't needed.
val akkaStartCluster = TaskKey[Unit](&quot;akkaStartCluster&quot;)

target in akkaStartCluster := ... // This is ok.

akkaStartCluster in akka := ...   // BAD.  No need for a Config for plugin-specific task.
</code></pre><h4 id="Configuration+Cat+says+%E2%80%9CConfiguration+is+for+configuration%E2%80%9C">Configuration Cat says “Configuration is for configuration“<a href="#Configuration+Cat+says+%E2%80%9CConfiguration+is+for+configuration%E2%80%9C" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When defining a new type of configuration, e.g.
</p><pre><code class="prettyprint lang-scala">val Config = config(&quot;profile&quot;)
</code></pre><p>should be used to create a “cross-task” configuration. The task
definitions don’t change in this case, but the default configuration
does. For example, the <code>profile</code> configuration can extend the test
configuration with additional settings and changes to allow profiling in
sbt. Plugins should not create arbitrary Configurations, but utilize
them for specific purposes and builds.
</p><p>Configurations actually tie into dependency resolution (with Ivy) and
can alter generated pom files.
</p><p>Configurations should <em>not</em> be used to namespace keys for a plugin. e.g.
</p><pre><code class="prettyprint lang-scala">val Config = config(&quot;my-plugin&quot;)
val pluginKey = settingKey[String](&quot;A plugin specific key&quot;)
val settings = pluginKey in Config  // DON'T DO THIS!
</code></pre><h4 id="Playing+nice+with+configurations">Playing nice with configurations<a href="#Playing+nice+with+configurations" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Whether you ship with a configuration or not, a plugin should strive to
support multiple configurations, including those created by the build
user. Some tasks that are tied to a particular configuration can be
re-used in other configurations. While you may not see the need
immediately in your plugin, some project may and will ask you for the
flexibility.
</p><h5 id="Provide+raw+settings+and+configured+settings">Provide raw settings and configured settings<a href="#Provide+raw+settings+and+configured+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Split your settings by the configuration axis like so:
</p><pre><code class="prettyprint lang-scala">val obfuscate = TaskKey[Seq[File]](&quot;obfuscate&quot;)
val obfuscateSettings = inConfig(Compile)(baseObfuscateSettings)
val baseObfuscateSettings: Seq[Setting[_]] = Seq(
  obfuscate := ... (sources in obfuscate).value ...,
  sources in obfuscate := sources.value
)
</code></pre><p>The <code>baseObfuscateSettings</code> value provides base configuration for the
plugin’s tasks. This can be re-used in other configurations if projects
require it. The <code>obfuscateSettings</code> value provides the default <code>Compile</code>
scoped settings for projects to use directly. This gives the greatest
flexibility in using features provided by a plugin. Here’s how the raw
settings may be reused:
</p><pre><code class="prettyprint lang-scala">Project.inConfig(Test)(sbtObfuscate.Plugin.baseObfuscateSettings)
</code></pre><p>Alternatively, one could provide a utility method to load settings in a
given configuration:
</p><pre><code class="prettyprint lang-scala">def obfuscateSettingsIn(c: Configuration): Seq[Project.Setting[_]] =
  inConfig(c)(baseObfuscateSettings)
</code></pre><p>This could be used as follows:
</p><pre><code class="prettyprint lang-scala">seq(obfuscateSettingsIn(Test): _*) 
</code></pre><h5 id="Using+a+%E2%80%98main%E2%80%99+task+scope+for+settings">Using a ‘main’ task scope for settings<a href="#Using+a+%E2%80%98main%E2%80%99+task+scope+for+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Sometimes you want to define some settings for a particular ‘main’ task
in your plugin. In this instance, you can scope your settings using the
task itself.
</p><pre><code class="prettyprint lang-scala">val obfuscate = TaskKey[Seq[File]](&quot;obfuscate&quot;)
val obfuscateSettings = inConfig(Compile)(baseObfuscateSettings)
val baseObfuscateSettings: Seq[Setting[_]] = Seq(
  obfuscate := ... (sources in obfuscate).value ...,
  sources in obfuscate := sources.value
)
</code></pre><p>In the above example, <code>sources in obfuscate</code> is scoped under the main
task, <code>obfuscate</code>.
</p><h3 id="Mucking+with+Global+build+state">Mucking with Global build state<a href="#Mucking+with+Global+build+state" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There may be times when you need to muck with global build state. The
general rule is <em>be careful what you touch</em>.
</p><p>First, make sure your user does not include global build configuration
in <em>every</em> project but rather in the build itself. e.g.
</p><pre><code class="prettyprint lang-scala">object MyBuild extends Build {
  override lazy val settings = super.settings ++ MyPlugin.globalSettings
  val main = project(file(&quot;.&quot;), &quot;root&quot;) settings(MyPlugin.globalSettings:_*) // BAD!
}
</code></pre><p>Global settings should <em>not</em> be placed into a <code>build.sbt</code> file.
</p><p>When overriding global settings, care should be taken to ensure previous
settings from other plugins are not ignored. e.g. when creating a new
<code>onLoad</code> handler, ensure that the previous <code>onLoad</code> handler is not
removed.
</p><pre><code class="prettyprint lang-scala">object MyPlugin extends Plugin {
   val globalSettigns: Seq[Setting[_]] = Seq(
     onLoad in Global := (onLoad in Global).value andThen { state =&gt;
         ... return new state ...
     }
   )
</code></pre><h2 id="Sbt+Launcher">Sbt Launcher<a href="#Sbt+Launcher" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The sbt launcher provides a generic container that can load and run
programs resolved using the Ivy dependency manager. Sbt uses this as its
own deployment mechanism.
</p><h2 id="Getting+Started+with+the+Sbt+Launcher">Getting Started with the Sbt Launcher<a href="#Getting+Started+with+the+Sbt+Launcher" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The sbt launcher component is a self-contained jar that boots a Scala
application or server without Scala or the application already existing
on the system. The only prerequisites are the launcher jar itself, an
optional configuration file, and a java runtime version 1.6 or greater.
</p><h3 id="Overview">Overview<a href="#Overview" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A user downloads the launcher jar and creates a script to run it. In
this documentation, the script will be assumed to be called <code>launch</code>.
For unix, the script would look like: <code>java -jar sbt-launcher.jar &quot;$@&quot;</code>
</p><p>The user can now launch servers and applications which provide sbt
launcher configuration.
</p><h4 id="Applications">Applications<a href="#Applications" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To launch an application, the user then downloads the configuration file
for the application (call it <code>my.app.configuration</code>) and creates a
script to launch it (call it <code>myapp</code>):
<code>launch @my.app.configuration &quot;$@&quot;</code>
</p><p>The user can then launch the application using <code>myapp arg1 arg2 ...</code>
</p><p>More on launcher configuration can be found at
<a href="Launcher-Configuration.html">Launcher Configuration</a>
</p><h4 id="Servers">Servers<a href="#Servers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The sbt launcher can be used to launch and discover running servers on
the system. The launcher can be used to launch servers similarly to
applications. However, if desired, the launcher can also be used to
ensure that only one instance of a server is running at time. This is
done by having clients always use the launcher as a <em>service locator</em>.
</p><p>To discover where a server is running (or launch it if it is not
running), the user downloads the configuration file for the server (call
it <code>my.server.configuration</code>) and creates a script to discover the
server (call it <code>find-myserver</code>):
<code>launch --locate @my.server.properties</code>.
</p><p>This command will print out one string, the URI at which to reach the
server, e.g. <code>sbt://127.0.0.1:65501</code>. Clients should use the IP/port to
connect to to the server and initiate their connection.
</p><p>When using the <code>locate</code> feature, the sbt launcher makes these following
restrictions to servers:
</p><ul><li>The Server must have a starting class that extends the
xsbti.ServerMain class
</li><li>The Server must have an entry point (URI) that clients can use to
detect the server
</li><li>The server must have defined a lock file which the launcher can use
to ensure that only one instance is running at a time
</li><li>The filesystem on which the lock file resides must support locking.
</li><li>The server must allow the launcher to open a socket against the port
without sending any data. This is used to check if a previous server
is still alive.
</li></ul><h4 id="Resolving+Applications%2FServers">Resolving Applications/Servers<a href="#Resolving+Applications%2FServers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Like the launcher used to distribute <code>sbt</code>, the downloaded launcher jar
will retrieve Scala and the application according to the provided
configuration file. The versions may be fixed or read from a different
configuration file (the location of which is also configurable). The
location to which the Scala and application jars are downloaded is
configurable as well. The repositories searched are configurable.
Optional initialization of a properties file on launch is configurable.
</p><p>Once the launcher has downloaded the necessary jars, it loads the
application/server and calls its entry point. The application is passed
information about how it was called: command line arguments, current
working directory, Scala version, and application ID (organization,
name, version). In addition, the application can ask the launcher to
perform operations such as obtaining the Scala jars and a <code>ClassLoader</code>
for any version of Scala retrievable from the repositories specified in
the configuration file. It can request that other applications be
downloaded and run. When the application completes, it can tell the
launcher to exit with a specific exit code or to reload the application
with a different version of Scala, a different version of the
application, or different arguments.
</p><p>There are some other options for setup, such as putting the
configuration file inside the launcher jar and distributing that as a
single download. The rest of this documentation describes the details of
configuring, writing, distributing, and running the application.
</p><h4 id="Creating+a+Launched+Application">Creating a Launched Application<a href="#Creating+a+Launched+Application" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This section shows how to make an application that is launched by this
launcher. First, declare a dependency on the launcher-interface. Do not
declare a dependency on the launcher itself. The launcher interface
consists strictly of Java interfaces in order to avoid binary
incompatibility between the version of Scala used to compile the
launcher and the version used to compile your application. The launcher
interface class will be provided by the launcher, so it is only a
compile-time dependency. If you are building with sbt, your dependency
definition would be:
</p><p>Make the entry point to your class implement ‘xsbti.AppMain’. An example
that uses some of the information:
</p><pre><code class="prettyprint lang-scala">package xsbt.test
class Main extends xsbti.AppMain
{
    def run(configuration: xsbti.AppConfiguration) =
    {
        // get the version of Scala used to launch the application
        val scalaVersion = configuration.provider.scalaProvider.version

        // Print a message and the arguments to the application
        println(&quot;Hello world!  Running Scala &quot; + scalaVersion)
        configuration.arguments.foreach(println)

        // demonstrate the ability to reboot the application into different versions of Scala
        // and how to return the code to exit with
        scalaVersion match
        {
            case &quot;2.9.3&quot; =&gt;
                new xsbti.Reboot {
                    def arguments = configuration.arguments
                    def baseDirectory = configuration.baseDirectory
                    def scalaVersion = &quot;2.10.2
                    def app = configuration.provider.id
                }
            case &quot;2.10.2&quot; =&gt; new Exit(1)
            case _ =&gt; new Exit(0)
        }
    }
    class Exit(val code: Int) extends xsbti.Exit
}
</code></pre><p>Next, define a configuration file for the launcher. For the above class,
it might look like:
</p><p>Then, <code>publishLocal</code> or <code>+publishLocal</code> the application to make it
available. For more information, see
<a href="Launcher-Configuration.html">Launcher Configuration</a>.
</p><h4 id="Running+an+Application">Running an Application<a href="#Running+an+Application" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As mentioned above, there are a few options to actually run the
application. The first involves providing a modified jar for download.
The second two require providing a configuration file for download.
</p><ul><li>Replace the <code>/sbt/sbt.boot.properties</code> file in the launcher jar and
distribute the modified jar. The user would need a script to run
<code>java -jar your-launcher.jar arg1 arg2 ....</code>
</li><li><p>The user downloads the launcher jar and you provide the
configuration file.
</p><ul><li>The user needs to run
<code>java -Dsbt.boot.properties=your.boot.properties -jar launcher.jar</code>.
</li><li>The user already has a script to run the launcher (call it
‘launch’). The user needs to run
<code>launch @your.boot.properties your-arg-1 your-arg-2</code>
</li></ul></li></ul><h4 id="Execution">Execution<a href="#Execution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Let’s review what’s happening when the launcher starts your application.
</p><p>On startup, the launcher searches for its configuration and then parses
it. Once the final configuration is resolved, the launcher proceeds to
obtain the necessary jars to launch the application. The
<code>boot.directory</code> property is used as a base directory to retrieve jars
to. Locking is done on the directory, so it can be shared system-wide.
The launcher retrieves the requested version of Scala to
</p><pre><code class="">${boot.directory}/${scala.version}/lib/
</code></pre><p>If this directory already exists, the launcher takes a shortcut for
startup performance and assumes that the jars have already been
downloaded. If the directory does not exist, the launcher uses Apache
Ivy to resolve and retrieve the jars. A similar process occurs for the
application itself. It and its dependencies are retrieved to
</p><pre><code class="">${boot.directory}/${scala.version}/${app.org}/${app.name}/.
</code></pre><p>Once all required code is downloaded, the class loaders are set up. The
launcher creates a class loader for the requested version of Scala. It
then creates a child class loader containing the jars for the requested
‘app.components’ and with the paths specified in <code>app.resources</code>. An
application that does not use components will have all of its jars in
this class loader.
</p><p>The main class for the application is then instantiated. It must be a
public class with a public no-argument constructor and must conform to
xsbti.AppMain. The <code>run</code> method is invoked and execution passes to the
application. The argument to the ‘run’ method provides configuration
information and a callback to obtain a class loader for any version of
Scala that can be obtained from a repository in [repositories]. The
return value of the run method determines what is done after the
application executes. It can specify that the launcher should restart
the application or that it should exit with the provided exit code.
</p><h2 id="Sbt+Launcher+Architecture">Sbt Launcher Architecture<a href="#Sbt+Launcher+Architecture" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The sbt launcher is a mechanism whereby modules can be loaded from ivy
and executed within a jvm. It abstracts the mechanism of grabbing and
caching jars, allowing users to focus on what application they want and
control its versions.
</p><p>The launcher’s primary goal is to take configuration for applications,
mostly just ivy coordinates and a main class, and start the application.
The launcher resolves the ivy module, caches the required runtime jars
and starts the application.
</p><p>The sbt launcher provides the application with the means to load a
different application when it completes, exit normally, or load
additional applications from inside another.
</p><p>The sbt launcher provides these core functions:
</p><ul><li>Module Resolution
</li><li>Classloader Caching and Isolation
</li><li>File Locking
</li><li>Service Discovery and Isolation
</li></ul><h3 id="Module+Resolution">Module Resolution<a href="#Module+Resolution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The primary purpose of the sbt launcher is to resolve applications and
run them. This is done through the <code>[app]</code> configuration section. See
[launcher configuration][Launcher-Configuration] for more information on how to configure module
resolution.
</p><p>Module resolution is performed using the Ivy dependency managemnet
library. This library supports loading artifacts from Maven repositories
as well.
</p><h3 id="Classloader+Caching+and+Isolation">Classloader Caching and Isolation<a href="#Classloader+Caching+and+Isolation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The sbt launcher’s classloading structure is different than just
starting an application in the standard java mechanism. Every
application loaded by by the launcher is given its own classloader. This
classloader is a child of the Scala classloader used by the application.
The Scala classloader can see all of the <code>xsbti.*</code> classes from the
launcher itself.
</p><p>Here’s an example classloader layout from an sbt launched application.
</p><p><img src="files/classloaders.png" alt="image"/>
</p><p>In this diagram, three different applications were loaded. Two of these
use the same version of Scala (2.9.2). In this case, sbt can share the
same classloader for these applications. This has the benefit that any
JIT optimisations performed on scala classes can be re-used between
applications thanks to the shared classloader.
</p><h3 id="Caching">Caching<a href="#Caching" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The sbt launcher creates a secondary cache on top of Ivy’s own cache.
This helps isolate applications from errors resulting from unstable
revisions, like <code>-SNAPSHOT</code>. For any launched application, the launcher
creates a directory to store all its jars. Here’s an example layout.
</p><h3 id="Locking">Locking<a href="#Locking" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>In addition to providing a secondary cache, the launcher also provides a
mechanism of safely doing file-based locks. This is used in two places
directly by the launcher:
</p><ol><li>Locking the boot directory.
</li><li>Ensuring located servers have at most one active process.
</li></ol><p>This feature requires a filesystem which supports locking. It is exposed
via the <code>xsbti.GlobalLock</code> interface.
</p><ul><li>Note: This is both a thread and file lock. Not only are we limiting
access to a single process, but also a single thread within that
process.*
</li></ul><h3 id="Service+Discovery+and+Isolation">Service Discovery and Isolation<a href="#Service+Discovery+and+Isolation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The launcher also provides a mechanism to ensure that only one instance
of a server is running, while dynamically starting it when a client
requests. This is done through the <code>--locate</code> flag on the launcher. When
the launcher is started with the <code>--locate</code> flag it will do the
following:
</p><ol><li>Lock on the configured server lock file.
</li><li>Read the server properties to find the URI of the previous server.
</li><li>If the port is still listening to connection requests, print this
URI on the command line.
</li><li>If the port is not listening, start a new server and write the URI
on the command line.
</li><li>Release all locks and shutdown.
</li></ol><p>The configured <code>server.lock</code> file is thus used to prevent multiple
servers from running. Sbt itself uses this to prevent more than one
server running on any given project directory by configuring
<code>server.lock</code> to be <code>${user.dir}/.sbtserver</code>.
</p><h2 id="Sbt+Launcher+Configuration">Sbt Launcher Configuration<a href="#Sbt+Launcher+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The launcher may be configured in one of the following ways in
increasing order of precedence:
</p><ul><li>Replace the <code>/sbt/sbt.boot.properties</code> file in the launcher jar
</li><li>Put a configuration file named <code>sbt.boot.properties</code> on the
classpath. Put it in the classpath root without the /sbt prefix.
</li><li>Specify the location of an alternate configuration on the command
line, either as a path or an absolute URI. This can be done by
either specifying the location as the system property
sbt.boot.properties or as the first argument to the launcher
prefixed by ’@’. The system property has lower precedence.
Resolution of a relative path is first attempted against the current
working directory, then against the user’s home directory, and then
against the directory containing the launcher jar.
</li></ul><p>An error is generated if none of these attempts succeed.
</p><h3 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The default configuration file for sbt as an application looks like:
</p><p>Let’s look at all the launcher configuration sections in detail:
</p><h4 id="1.+Scala+Configuration">1. Scala Configuration<a href="#1.+Scala+Configuration" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[scala]</code> section is used to configure the version of Scala. It has
one property:
</p><ul><li><code>version</code> - The version of scala an application uses, or <code>auto</code> if
the application is not cross-versioned.
</li><li><code>classifiers</code> - The (optional) list of additional scala artifacts to
resolve, e.g. sources.
</li></ul><h4 id="2.+Applicaiton+Identification">2. Applicaiton Identification<a href="#2.+Applicaiton+Identification" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[app]</code> section configures how the launcher will look for your
application using the Ivy dependency manager. It consists of the
following properties:
</p><ul><li><code>org</code> - The organization associated with the Ivy module. (groupId in
maven vernacular)
</li><li><code>name</code> - The name of the Ivy module. (<code>artifactId</code> in maven
vernacular)
</li><li><code>version</code> - The revision of the Ivy module.
</li><li><p><code>class</code> - The name of the “entry point” into the application. An
entry point must be a class which meets one of the following critera
</p><ul><li>Extends the xsbti.AppMain interface.
</li><li>Extends the xsbti.ServerMain interfaces.
</li><li>Contains a method with the signature static void main(String[])
</li><li>Contains a method with the signature static int main(String[])
</li></ul><ul><li>Contains a method with the signature
static xsbti.Exit main(String[])
</li></ul></li><li><code>components</code> - An optional list of additional components that Ivy
should resolve.
</li><li><code>cross-versioned</code> - An optional string denoting how this application
is published. If app.cross-versioned is binary, the resolved module
ID is
<code>{app.name+'_'+CrossVersion.binaryScalaVersion(scala.version)}</code>. If
app.cross-versioned is true or full, the resolved module ID is
<code>{app.name+'_'+scala.version}</code>. The scala.version property must be
specified and cannot be auto when cross-versioned.
</li><li><code>resources</code> - An optional list of jar files that should be added to
the application’s classpath.
</li><li><code>classifiers</code> - An optional list of additional classifiers that
should be resolved with this application, e.g. sources.
</li></ul><h4 id="3.+Repositories+Section">3. Repositories Section<a href="#3.+Repositories+Section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[repositories]</code> section configures where and how Ivy will look for
your application. Each line denotes a repository where Ivy will look.
</p><ul><li>Note: This section configured the default location where Ivy will look,
but this can be overriden via user configuration.*
</li></ul><p>There are several built-in strings that can be used for common
repositories:
</p><ul><li><code>local</code> - the local ivy repository <code>~/.ivy2/local</code>.
</li><li><code>maven-local</code> - The local maven repository <code>~/.ivy2/local</code>.
</li><li><code>maven-central</code> - The maven central repository <code>repo.maven.org</code>.
</li></ul><p>Besides built in repositories, other repositories can be configured
using the following syntax:
</p><blockquote><p>name: url(, pattern)(,descriptorOptional)(,skipConsistencyCheck)
</p></blockquote><p>The <code>name</code> property is an identifier which Ivy uses to cache modules
resolved from this location. The <code>name</code> should be unique across all
repositories.
</p><p>The <code>url</code> property is the base <code>url</code> where Ivy should look for modules.
</p><p>The <code>pattern</code> property is an optional specification of <em>how</em> Ivy should
look for modules. By default, the launcher assumes repositories are in
the maven style format.
</p><p>The <code>skipConsistencyCheck</code> string is used to tell ivy not to validate
checksums and signatures of files it resolves.
</p><h4 id="4.+The+Boot+section">4. The Boot section<a href="#4.+The+Boot+section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[boot]</code> section is used to configure where the sbt launcher will
store its cache and configuration information. It consists of the
following properties:
</p><ul><li><code>directory</code> - The directory defined here is used to store all cached
JARs resolved launcher.
</li><li><code>properties</code> - (optional) A properties file to use for any <code>read</code>
variables.
</li></ul><h4 id="5.+The+Ivy+section">5. The Ivy section<a href="#5.+The+Ivy+section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>[ivy]</code> section is used to configure the Ivy dependency manager for
resolving applications. It consists of the following properties:
</p><ul><li><code>ivy-home</code> - The home directory for Ivy. This determines where the
ivy-local repository is located, and also where the ivy cache is
stored. Defaults to <code>~/.ivy2</code>
</li><li><code>ivy.cache-directory</code> - provides an alternative location for the Ivy
cache used by the launcher. This does not automatically set the Ivy
cache for the application, but the application is provided this
location through the AppConfiguration instance.
</li><li><code>checksums</code> - The comma-separated list of checksums that Ivy should
use to verify artifacts have correctly resolved, e.g. md5 or sha1.
</li><li><code>override-build-repos</code> - If this is set, then the
<code>isOverrideRepositories</code> method on xsbti.Launcher interface will
return its value. The use of this method is application specific,
but in the case of sbt denotes that the configuration of
repositories in the launcher should override those used by any
build. Applications should respect this convention if they can.
</li><li><code>repository-config</code> - This specifies a configuration location where
ivy repositories can also be configured. If this file exists, then
its contents override the [repositories] section.
</li></ul><h4 id="6.+The+Server+Section">6. The Server Section<a href="#6.+The+Server+Section" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>When using the <code>--locate</code> feature of the launcher, this section
configures how a server is started. It consists of the following
properties:
</p><ul><li><code>lock</code> - The file that controls access to the running server. This
file will contain the active port used by a server and must be
located on a a filesystem that supports locking.
</li><li><code>jvmargs</code> - A file that contains line-separated JVM arguments that where
:   use when starting the server.
</li><li><code>jvmprops</code> - The location of a properties file that will define
override properties in the server. All properties defined in this
file will be set as -D java properties.
</li></ul><h3 id="Variable+Substitution">Variable Substitution<a href="#Variable+Substitution" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Property values may include variable substitutions. A variable
substitution has one of these forms:
</p><ul><li><code>${variable.name}</code>
</li><li><code>${variable.name-default}</code>
</li></ul><p>where <code>variable.name</code> is the name of a system property. If a system
property by that name exists, the value is substituted. If it does not
exists and a default is specified, the default is substituted after
recursively substituting variables in it. If the system property does
not exist and no default is specified, the original string is not
substituted.
</p><p>There is also a special variable substitution:
</p><ul><li><code>read(property.name)[default]</code>
</li></ul><p>This will look in the file configured by <code>boot.properties</code> for a value.
If there is no <code>boot.properties</code> file configured, or the property does
not existt, then the default value is chosen.
</p><h3 id="Syntax">Syntax<a href="#Syntax" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The configuration file is line-based, read as UTF-8 encoded, and defined
by the following grammar. <code>'nl'</code> is a newline or end of file and
<code>'text'</code> is plain text without newlines or the surrounding delimiters
(such as parentheses or square brackets):
</p><pre><code class="prettyprint lang-scala">configuration: scala app repositories boot log appProperties
scala: &quot;[&quot; &quot;scala&quot; &quot;]&quot; nl version nl classifiers nl
app: &quot;[&quot; &quot;app&quot; &quot;]&quot; nl org nl name nl version nl components nl class nl crossVersioned nl resources nl classifiers nl
repositories: &quot;[&quot; &quot;repositories&quot; &quot;]&quot; nl (repository nl)*
boot: &quot;[&quot; &quot;boot&quot; &quot;]&quot; nl directory nl bootProperties nl search nl promptCreate nl promptFill nl quickOption nl
log: &quot;[&quot;' &quot;log&quot; &quot;]&quot; nl logLevel nl
appProperties: &quot;[&quot; &quot;app-properties&quot; &quot;]&quot; nl (property nl)*
ivy: &quot;[&quot; &quot;ivy&quot; &quot;]&quot; nl homeDirectory nl checksums nl overrideRepos nl repoConfig nl
directory: &quot;directory&quot; &quot;:&quot; path
bootProperties: &quot;properties&quot; &quot;:&quot; path
search: &quot;search&quot; &quot;:&quot; (&quot;none&quot; | &quot;nearest&quot; | &quot;root-first&quot; | &quot;only&quot; ) (&quot;,&quot; path)*
logLevel: &quot;level&quot; &quot;:&quot; (&quot;debug&quot; | &quot;info&quot; | &quot;warn&quot; | &quot;error&quot;)
promptCreate: &quot;prompt-create&quot;  &quot;:&quot;  label
promptFill: &quot;prompt-fill&quot; &quot;:&quot; boolean
quickOption: &quot;quick-option&quot; &quot;:&quot; boolean
version: &quot;version&quot; &quot;:&quot; versionSpecification
versionSpecification: readProperty | fixedVersion
readProperty: &quot;read&quot;  &quot;(&quot; propertyName &quot;)&quot;  &quot;[&quot; default &quot;]&quot;
fixedVersion: text
classifiers: &quot;classifiers&quot; &quot;:&quot; text (&quot;,&quot; text)*
homeDirectory: &quot;ivy-home&quot; &quot;:&quot; path
checksums: &quot;checksums&quot; &quot;:&quot; checksum (&quot;,&quot; checksum)*
overrideRepos: &quot;override-build-repos&quot; &quot;:&quot; boolean
repoConfig: &quot;repository-config&quot; &quot;:&quot; path
org: &quot;org&quot; &quot;:&quot; text
name: &quot;name&quot; &quot;:&quot; text
class: &quot;class&quot; &quot;:&quot; text
components: &quot;components&quot; &quot;:&quot; component (&quot;,&quot; component)*
crossVersioned: &quot;cross-versioned&quot; &quot;:&quot;  (&quot;true&quot; | &quot;false&quot; | &quot;none&quot; | &quot;binary&quot; | &quot;full&quot;)
resources: &quot;resources&quot; &quot;:&quot; path (&quot;,&quot; path)*
repository: ( predefinedRepository | customRepository ) nl
predefinedRepository: &quot;local&quot; | &quot;maven-local&quot; | &quot;maven-central&quot;
customRepository: label &quot;:&quot; url [ [&quot;,&quot; ivyPattern] [&quot;,&quot; artifactPattern] [&quot;, mavenCompatible&quot;] [&quot;, bootOnly&quot;]]
property: label &quot;:&quot; propertyDefinition (&quot;,&quot; propertyDefinition)*
propertyDefinition: mode &quot;=&quot; (set | prompt)
mode: &quot;quick&quot; | &quot;new&quot; | &quot;fill&quot;
set: &quot;set&quot; &quot;(&quot; value &quot;)&quot;
prompt: &quot;prompt&quot;  &quot;(&quot; label &quot;)&quot; (&quot;[&quot; default &quot;]&quot;)?
boolean: &quot;true&quot; | &quot;false&quot;
nl: &quot;\r\n&quot; | &quot;\n&quot; | &quot;\r&quot;
path: text
propertyName: text
label: text
default: text
checksum: text
ivyPattern: text
artifactPattern: text
url: text
component: text
</code></pre><h2 id="Developer%E2%80%99s+Guide">Developer’s Guide<a href="#Developer%E2%80%99s+Guide" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is the set of documentation about the Architecture of sbt. This
covers all the core components of sbt as well as the general notion of
how they all work together. This documentation is suitable for those who
wish to have a deeper understanding of sbt’s core, but already
understand the fundamentals of <code>Setting[_]</code>, <code>Task[_]</code> and constructing
builds.
</p><h2 id="Core+Principles">Core Principles<a href="#Core+Principles" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This document details the core principles overarching sbt’s design and
code style. Sbt’s core principles can be stated quite simply:
</p><ol><li>Everything should have a <code>Type</code>, enforced as much as is practical.
</li><li>Dependencies should be <strong>explicit</strong>.
</li><li>Once learned, a concept should hold throughout <strong>all</strong> parts of sbt.
</li><li>Parallel is the default.
</li></ol><p>With these principles in mind, let’s walk through the core design of
sbt.
</p><h3 id="Introduction+to+build+state">Introduction to build state<a href="#Introduction+to+build+state" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>This is the first piece you hit when starting sbt. Sbt’s command engine
is the means by which it processes user requests using the build state.
The command engine is essentially a means of applying <strong>state
transformations</strong> on the build state, to execute user requests.
</p><p>In sbt, commands are functions that take the current build state
(<code>sbt.State</code>) and produce the next state. In other words, they are
essentially functions of <code>sbt.State =&gt; sbt.State</code>. However, in reality,
Commands are actually string processors which take some string input and
act on it, returning the next build state.
</p><p>So, the entirety of sbt is driven off the <code>sbt.State</code> class. Since this
class needs to be resilient in the face of custom code and plugins, it
needs a mechanism to store the state from any potential client. In
dynamic languages, this can be done directly on objects.
</p><p>A naive approach in Scala is to use a <code>Map&lt;String,Any&gt;</code>. However, this
vioaltes tennant #1: Everythign should have a <code>Type</code>. So, sbt defines a
new type of map called an <code>AttributeMap</code>. An <code>AttributeMap</code> is a
key-value storage mechanism where keys are both strings <em>and</em> expected
<code>Type</code>s for their value.
</p><p>Here is what the typesafe <code>AttributeKey</code> key looks like :
</p><pre><code>sealed trait AttributeKey[T] {
  /** The label is the identifier for the key and is camelCase by convention. */
  def label: String
  /** The runtime evidence for ``T`` */
  def manifest: Manifest[T]
}
</code></pre><p>These keys store both a <code>label</code> (<code>string</code>) and some runtime type
information (<code>manifest</code>). To put or get something on the AttributeMap,
we first need to construct one of these keys. Let’s look at the basic
definition of the <code>AttributeMap</code> :
</p><pre><code>trait AttributeMap {
  /** Gets the value of type ``T`` associated with the key ``k`` or ``None`` if no value is associated. 
  * If a key with the same label but a different type is defined, this method will return ``None``. */
  def get[T](k: AttributeKey[T]): Option[T]

  /** Adds the mapping ``k -&gt; value`` to this map, replacing any existing mapping for ``k``.
  * Any mappings for keys with the same label but different types are unaffected. */
  def put[T](k: AttributeKey[T], value: T): AttributeMap
}
</code></pre><p>Now that there’s a definition of what build state is, there needs to be
a way to dynamically construct it. In sbt, this is done through the
<code>Setting[_]</code> sequence.
</p><h3 id="Settings+Architecture">Settings Architecture<a href="#Settings+Architecture" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A Setting represents the means of constructing the value of one
particular <code>AttributeKey[_]</code> in the <code>AttributeMap</code> of build state. A
setting consists of two pieces:
</p><ol><li>The <code>AttributeKey[T]</code> where the value of the setting should be
assigned.
</li><li>An <code>Initialize[T]</code> object which is able to construct the value for
this setting.
</li></ol><p>Sbt’s initialization time is basically just taking a sequence of these
<code>Setting[_]</code> objects and running their initialization objects and then
storing the value into the <code>AttributeMap</code>. This means overwriting an
exisitng value at a key is as easy as appending a <code>Setting[_]</code> to the
end of the sequence which does so.
</p><p>Where it gets interesting is that <code>Initialize[T]</code> can depend on other
<code>AttributeKey[_]</code>s in the build state. Each <code>Initialize[_]</code> can pull
values from any <code>AttributeKey[_]</code> in the build state’s <code>AttributeMap</code> to
compute its value. Sbt ensures a few things when it comes to
<code>Initialize[_]</code> dependencies:
</p><ol><li>There can be no circular dependencies
</li><li><p>If one <code>Initialize[_]</code> depends on another <code>Initialize[_]</code> key, then
</p><p><em>all</em> associated <code>Initialize[_]</code> blocks for that key must have run
before we load the value.
</p></li></ol><p>Let’s look at what gets stored for the setting :
</p><pre><code>normalizedName := normalize(name.value)
</code></pre><p><img src="files/overview-setting-example.png" alt="image"/>
</p><p>Here, a <code>Setting[_]</code> is constructed that understands it depends on the
value in the <code>name</code> AttributeKey. Its initialize block first grabs the
value of the <code>name</code> key, then runs the function normalize on it to
compute its value.
</p><p>This represents the core mechanism of how to construct sbt’s build
state. Conceptually, at some point we have a graph of dependencies and
initialization functions which we can use to construct the first build
state. Once this is completed, we can then start to process user
requests.
</p><h3 id="Task+Architecture">Task Architecture<a href="#Task+Architecture" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The next layer in sbt is around these user request, or tasks. When a
user configures a build, they are defining a set of repeatable tasks
that they can run on their project. Things like <code>compile</code> or <code>test</code>.
These tasks <em>also</em> have a dependency graph, where e.g. the <code>test</code> task
requires that <code>compile</code> has run before it can successfully execute.
</p><p>Sbt’s defines a class <code>Task[T]</code>. The <code>T</code> type parameter represents the
type of data returned by a task. Remember the tenets of sbt? “All things
have types” and “Dependencies are explicit” both hold true for tasks.
Sbt promotes a style of task dependencies that is closer to functional
programming: Return data for your users rather than using shared mutable
state.
</p><p>Most build tools communciate over the filesystem, and indeed sbt, by
necessity, does some of this. However, for stable parallelization it is
far better to keep tasks isolated on the filesystem and communicate
directly through types.
</p><p>Similarly to how a <code>Setting[_]</code> stores both dependencies and an
initialization function, a <code>Task[_]</code> stores both its
<code>Task[_]</code>dependencies and its behavior (a function).
</p><p>TODO - More on <code>Task[_]</code>
</p><p>TODO - Transition into <code>InputTask[_]</code>, rehash Command
</p><p>TODO - Tansition into Scope.
</p><h2 id="Settings+Core">Settings Core<a href="#Settings+Core" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page describes the core settings engine a bit. This may be useful
for using it outside of sbt. It may also be useful for understanding how
sbt works internally.
</p><p>The documentation is comprised of two parts. The first part shows an
example settings system built on top of the settings engine. The second
part comments on how sbt’s settings system is built on top of the
settings engine. This may help illuminate what exactly the core settings
engine provides and what is needed to build something like the sbt
settings system.
</p><h3 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Setting+up">Setting up<a href="#Setting+up" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To run this example, first create a new project with the following
build.sbt file:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.scala-sbt&quot; %% &quot;collections&quot; % sbtVersion.value

resolvers += sbtResolver.value
</code></pre><p>Then, put the following examples in source files <code>SettingsExample.scala</code>
and <code>SettingsUsage.scala</code>. Finally, run sbt and enter the REPL using
<code>console</code>. To see the output described below, enter <code>SettingsUsage</code>.
</p><h4 id="Example+Settings+System">Example Settings System<a href="#Example+Settings+System" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first part of the example defines the custom settings system. There
are three main parts:
</p><ol><li>Define the Scope type.
</li><li>Define a function that converts that Scope (plus an AttributeKey) to
a String.
</li><li>Define a delegation function that defines the sequence of Scopes in
which to look up a value.
</li></ol><p>There is also a fourth, but its usage is likely to be specific to sbt at
this time. The example uses a trivial implementation for this part.
</p><p><code>SettingsExample.scala</code>
</p><pre><code class="prettyprint lang-scala">  import sbt._

/** Define our settings system */

// A basic scope indexed by an integer.
final case class Scope(index: Int)

// Extend the Init trait.
//  (It is done this way because the Scope type parameter is used everywhere in Init.
//  Lots of type constructors would become binary, which as you may know requires lots of type lambdas
//  when you want a type function with only one parameter.
//  That would be a general pain.)
object SettingsExample extends Init[Scope]
{
    // Provides a way of showing a Scope+AttributeKey[_]
    val showFullKey: Show[ScopedKey[_]] = new Show[ScopedKey[_]] {
        def apply(key: ScopedKey[_]) = key.scope.index + &quot;/&quot; + key.key.label
    }

    // A sample delegation function that delegates to a Scope with a lower index.
    val delegates: Scope =&gt; Seq[Scope] = { case s @ Scope(index) =&gt;
        s +: (if(index &lt;= 0) Nil else delegates(Scope(index-1)) )
    }

    // Not using this feature in this example.
    val scopeLocal: ScopeLocal = _ =&gt; Nil

    // These three functions + a scope (here, Scope) are sufficient for defining our settings system.
}
</code></pre><h4 id="Example+Usage">Example Usage<a href="#Example+Usage" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This part shows how to use the system we just defined. The end result is
a <code>Settings[Scope]</code> value. This type is basically a mapping
<code>Scope -&gt; AttributeKey[T] -&gt; Option[T]</code>. See the
<a href="../api/sbt/Settings.html">Settings API documentation</a> for
details. <code>SettingsUsage.scala</code>:
</p><pre><code class="prettyprint lang-scala">/** Usage Example **/

   import sbt._
   import SettingsExample._
   import Types._

object SettingsUsage {

      // Define some keys
   val a = AttributeKey[Int](&quot;a&quot;)
   val b = AttributeKey[Int](&quot;b&quot;)

      // Scope these keys
   val a3 = ScopedKey(Scope(3), a)
   val a4 = ScopedKey(Scope(4), a)
   val a5 = ScopedKey(Scope(5), a)

   val b4 = ScopedKey(Scope(4), b)

      // Define some settings
   val mySettings: Seq[Setting[_]] = Seq(
      setting( a3, value( 3 ) ),
      setting( b4, map(a4)(_ * 3)),
      update(a5)(_ + 1)
   )

      // &quot;compiles&quot; and applies the settings.
      //  This can be split into multiple steps to access intermediate results if desired.
      //  The 'inspect' command operates on the output of 'compile', for example.
   val applied: Settings[Scope] = make(mySettings)(delegates, scopeLocal, showFullKey)

   // Show results.
   for(i &lt;- 0 to 5; k &lt;- Seq(a, b)) {
      println( k.label + i + &quot; = &quot; + applied.get( Scope(i), k) )
   }
}
</code></pre><p>This produces the following output when run:
</p><pre><code class="">a0 = None
b0 = None
a1 = None
b1 = None
a2 = None
b2 = None
a3 = Some(3)
b3 = None
a4 = Some(3)
b4 = Some(9)
a5 = Some(4)
b5 = Some(9)
</code></pre><ul><li>For the None results, we never defined the value and there was no
value to delegate to.
</li><li>For a3, we explicitly defined it to be 3.
</li><li>a4 wasn’t defined, so it delegates to a3 according to our delegates
function.
</li><li>b4 gets the value for a4 (which delegates to a3, so it is 3) and
multiplies by 3
</li><li>a5 is defined as the previous value of a5 + 1 and since no previous
value of a5 was defined, it delegates to a4, resulting in 3+1=4.
</li><li>b5 isn’t defined explicitly, so it delegates to b4 and is therefore
equal to 9 as well
</li></ul><h3 id="sbt+Settings+Discussion">sbt Settings Discussion<a href="#sbt+Settings+Discussion" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Scopes">Scopes<a href="#Scopes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt defines a more complicated scope than the one shown here for the
standard usage of settings in a build. This scope has four components:
the project axis, the configuration axis, the task axis, and the extra
axis. Each component may be 
<a href="../api/sbt/Global$.html">Global</a> (no specific value),
<a href="../api/sbt/This$.html">This</a>
(current context), or
<a href="../api/sbt/Select.html">Select</a> (containing a specific value). sbt
resolves <code>This_</code> to either
<a href="../api/sbt/Global$.html">Global</a> or
<a href="../api/sbt/Select.html">Select</a>
depending on the context.
</p><p>For example, in a project, a
<a href="../api/sbt/This$.html">This</a> project axis becomes a
<a href="../api/sbt/Select.html">Select</a> referring to the defining project. All other axes that are
<a href="../api/sbt/This$.html">This</a> are
translated to
<a href="../api/sbt/Global$.html">Global</a>. Functions like inConfig and inTask transform
This into a
<a href="../api/sbt/Select.html">Select</a> for a specific value. For example,
<code>inConfig(Compile)(someSettings)</code> translates the configuration axis for
all settings in <em>someSettings</em> to be <code>Select(Compile)</code> if the axis value
is
<a href="../api/sbt/This$.html">This</a>.
</p><p>So, from the example and from sbt’s scopes, you can see that the core
settings engine does not impose much on the structure of a scope. All it
requires is a delegates function <code>Scope =&gt; Seq[Scope]</code> and a <code>display</code>
function. You can choose a scope type that makes sense for your
situation.
</p><h4 id="Constructing+settings">Constructing settings<a href="#Constructing+settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <em>app</em>, <em>value</em>, <em>update</em>, and related methods are the core methods
for constructing settings. This example obviously looks rather different
from sbt’s interface because these methods are not typically used
directly, but are wrapped in a higher-level abstraction.
</p><p>With the core settings engine, you work with HLists to access other
settings. In sbt’s higher-level system, there are wrappers around HList
for TupleN and FunctionN for N = 1-9 (except Tuple1 isn’t actually
used). When working with arbitrary arity, it is useful to make these
wrappers at the highest level possible. This is because once wrappers
are defined, code must be duplicated for every N. By making the wrappers
at the top-level, this requires only one level of duplication.
</p><p>Additionally, sbt uniformly integrates its task engine into the settings
system. The underlying settings engine has no notion of tasks. This is
why sbt uses a <code>SettingKey</code> type and a <code>TaskKey</code> type. Methods on an
underlying <code>TaskKey[T]</code> are basically translated to operating on an
underlying <code>SettingKey[Task[T]]</code> (and they both wrap an underlying
<code>AttributeKey</code>).
</p><p>For example, <code>a := 3</code> for a SettingKey <em>a</em> will very roughly translate
to <code>setting(a, value(3))</code>. For a TaskKey <em>a</em>, it will roughly translate
to <code>setting(a, value( task { 3 } ) )</code>. See
<a href="../sxr/sbt/Structure.scala">main/Structure.scala</a> for details.
</p><h4 id="Settings+definitions">Settings definitions<a href="#Settings+definitions" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>sbt also provides a way to define these settings in a file (build.sbt
and Build.scala). This is done for build.sbt using basic parsing and
then passing the resulting chunks of code to <code>compile/Eval.scala</code>. For
all definitions, sbt manages the classpaths and recompilation process to
obtain the settings. It also provides a way for users to define project,
task, and configuration delegation, which ends up being used by the
delegates function.
</p><h2 id="Setting+Initialization">Setting Initialization<a href="#Setting+Initialization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This page outlines the mechanisms by which sbt loads settings for a
particular build, including the hooks where users can control the
ordering of everything.
</p><p>As stated elsewhere, sbt constructs its initialization graph and task
graph via <code>Setting[_]</code> objects. A setting is something which can take
the values stored at other Keys in the build state, and generates a new
value for a particular build key. Sbt converts all registered
<code>Setting[_]</code> objects into a giant linear sequence and <em>compiles</em> them
into the a task graph. This task graph is then used to execute your
build.
</p><p>All of sbt’s loading semantics are contained within the
<a href="../sxr/sbt/Load.scala.html">Load.scala</a> file. It is approximately
the following:
</p><p><img src="files/settings-initialization-load-ordering.png" alt="image"/>
</p><p>The blue circles represent actions happening when sbt loads a project.
We can see that sbt performs the following actions in load:
</p><ol><li><p>Compile the user-level project (<code>~/.sbt/&lt;version&gt;/</code>)
</p><p>a. Load any plugins defined by this project (<code>~/.sbt/&lt;version&gt;/plugins/*.sbt</code> and <code>~/.sbt/&lt;version&gt;/plugins/project/*.scala</code>)
b. Load all settings defined (<code>~/.sbt/&lt;version&gt;/*.sbt</code> and <code>~/.sbt/&lt;version&gt;/plugins/*.scala</code>)
</p></li><li><p>Compile the current project (<code>&lt;working-directory/project</code>)
</p><p>a. Load all defined plugins (<code>project/plugins.sbt</code> and <code>project/project/*.scala</code>)
b. Load/Compile the project (<code>project/*.scala</code>)
</p></li><li>Load project <code>*.sbt</code> files (<code>build.sbt</code> and friends).
</li></ol><p>Each of these loads defines several sequences of settings. The diagram
shows the two most important:
</p><ul><li><p><code>buildSettings</code> - These are settings defined to be <code>in ThisBuild</code> or
directly against the <code>Build</code> object. They are initialized <em>once</em> for
the build. You can add these, e.g. in <code>project/build.scala</code> :
</p><pre><code class="prettyprint lang-scala">object MyBuild extends Build {
  override val settings = Seq(foo := &quot;hi&quot;)
}
</code></pre><p>or in a <code>build.sbt</code> file :
</p><pre><code class="prettyprint lang-scala">foo in ThisBuild := &quot;hi&quot;
</code></pre></li><li><p><code>projectSettings</code> - These are settings specific to a project. They
are specific to a <em>particular sub project</em> in the build. A plugin
may be contributing its settings to more than on project, in which
case the values are duplicated for each project. You add project
specific settings, eg. in <code>project/build.scala</code> :
</p><pre><code class="prettyprint lang-scala">object MyBuild extends Build {
  val test = project.in(file(&quot;.&quot;)).settings(...)
}
</code></pre></li></ul><p>After loading/compiling all the build definitions, sbt has a series of
<code>Seq[Setting[_]]</code> that it must order. As shown in the diagram, the
default inclusion order for sbt is:
</p><ol><li>All AutoPlugin settings
</li><li>All settings defined in <code>project/Build.scala</code>
</li><li>All settings defined in the user directory
(<code>~/.sbt/&lt;verison&gt;/*.sbt</code>)
</li><li>All local configurations (<code>build.sbt</code>)
</li></ol><h3 id="Controlling+Initialization">Controlling Initialization<a href="#Controlling+Initialization" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The order which sbt uses to load settings is configurable at a <em>project</em>
level. This means that we can’t control the order of settings added to
Build/Global namespace, but we can control how each project loads, e.g.
plugins and <code>.sbt</code> files. To do so, use the <code>AddSettings</code> class :
</p><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

import AddSettings._

object MyOwnOrder extends Build {
  // here we load config from a txt file.
  lazy val root = project.in(file(&quot;.&quot;)).settingSets( autoPlugins, buildScalaFiles, sbtFiles(file(&quot;silly.txt&quot;)) )
}
</code></pre><p>In the above project, we’ve modified the order of settings to be:
</p><ol><li>All AutoPlugin settings.
</li><li>All settings defined in the <code>project/Build.scala</code> file (shown
above).
</li><li>All settings found in the <code>silly.txt</code> file.
</li></ol><p>What we’ve excluded:
</p><ul><li>All settings from the user directory (<code>~/.sbt/&lt;verison&gt;</code>)
</li><li>All <code>*.sbt</code> settings.
</li></ul><p>The AddSettings object provides the following “groups” of settings you
can use for ordering:
</p><ul><li><code>autoPlugins</code> All the ordered settings of plugins after they’ve gone through
dependency resolution
</li><li><code>buildScalaFiles</code> The full sequence of settings defined directly in <code>project/*.scala</code>
builds.
</li><li><code>sbtFiles(*)</code> Specifies the exact setting DSL files to include (files must use the
<code>.sbt</code> file format)
</li><li><code>userSettings</code> All the settings defined in the user directory <code>~/.sbt/&lt;version&gt;/</code>.
</li><li><code>defaultSbtFiles</code> Include all local <code>*.sbt</code> file settings.
</li></ul><blockquote><ul><li>Note: Be very careful when reordering settings. It’s easy to
accidentally remove core functionality.*
</li></ul></blockquote><p>For example, let’s see what happens if we move the <code>build.sbt</code> files
<em>before</em> the <code>buildScalaFile</code>.
</p><p>Let’s create an example project the following defintiion. <code>project/build.scala</code> :
</p><pre><code class="prettyprint lang-scala">object MyTestBuild extends Build {
  val testProject = project.in(file(&quot;.&quot;)).settingSets(autoPlugins, defaultSbtFiles, buildScalaFile).settings(
    version := scalaBinaryVersion.value match {
      case &quot;2.10&quot; =&gt; &quot;1.0-SNAPSHOT&quot;
      case v =&gt; &quot;1.0-for-${v}-SNAPSHOT&quot;
    }
  )
}
</code></pre><p>This build defines a version string which appends the scala version if
the current scala version is not the in the <code>2.10.x</code> series. Now, when
issuing a release we want to lock down the version. Most tools assume
this can happen by writing a <code>version.sbt</code> file. <code>version.sbt</code> :
</p><pre><code class="prettyprint lang-scala">version := &quot;1.0.0&quot;
</code></pre><p>However, when we load this new build, we find that the <code>version</code> in
<code>version.sbt</code> has been <strong>overriden</strong> by the one defined in
<code>project/Build.scala</code> because of the order we defined for settings, so
the new <code>version.sbt</code> file has no effect.
</p><h2 id="Build+Loaders">Build Loaders<a href="#Build+Loaders" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Build loaders are the means by which sbt resolves, builds, and
transforms build definitions. Each aspect of loading may be customized
for special applications. Customizations are specified by overriding the
<em>buildLoaders</em> methods of your build definition’s Build object. These
customizations apply to external projects loaded by the build, but not
the (already loaded) Build in which they are defined. Also documented on
this page is how to manipulate inter-project dependencies from a
setting.
</p><h3 id="Custom+Resolver">Custom Resolver<a href="#Custom+Resolver" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The first type of customization introduces a new resolver. A resolver
provides support for taking a build URI and retrieving it to a local
directory on the filesystem. For example, the built-in resolver can
checkout a build using git based on a git URI, use a build in an
existing local directory, or download and extract a build packaged in a
jar file. A resolver has type:
</p><pre><code class="prettyprint lang-scala">ResolveInfo =&gt; Option[() =&gt; File]
</code></pre><p>The resolver should return None if it cannot handle the URI or Some
containing a function that will retrieve the build. The ResolveInfo
provides a staging directory that can be used or the resolver can
determine its own target directory. Whichever is used, it should be
returned by the loading function. A resolver is registered by passing it
to <em>BuildLoader.resolve</em> and overriding <em>Build.buildLoaders</em> with the
result:
</p><pre><code class="prettyprint lang-scala">...
object Demo extends Build {
  ...
  override def buildLoaders =
    BuildLoader.resolve(demoResolver) ::
    Nil

  def demoResolver: BuildLoader.ResolveInfo =&gt; Option[() =&gt; File] = ...

}
</code></pre><h4 id="API+Documentation">API Documentation<a href="#API+Documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Relevant API documentation for custom resolvers:
</p><ul><li><a href="../api/index.html#sbt.BuildLoader$$ResolveInfo">ResolveInfo</a>
</li><li><a href="../api/sbt/BuildLoader$.html">BuildLoader</a>
</li></ul><h4 id="Full+Example">Full Example<a href="#Full+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><pre><code class="prettyprint lang-scala">import sbt._
import Keys._

object Demo extends Build
{
  // Define a project that depends on an external project with a custom URI
  lazy val root = Project(&quot;root&quot;, file(&quot;.&quot;)).dependsOn(
    uri(&quot;demo:a&quot;)
  )

  // Register the custom resolver
  override def buildLoaders =
    BuildLoader.resolve(demoResolver) ::
    Nil

  // Define the custom resolver, which handles the 'demo' scheme.
  // The resolver's job is to produce a directory containing the project to load.
  // A subdirectory of info.staging can be used to create new local
  //   directories, such as when doing 'git clone ...'
  def demoResolver(info: BuildLoader.ResolveInfo): Option[() =&gt; File] =
    if(info.uri.getScheme != &quot;demo&quot;)
      None
    else
    {
      // Use a subdirectory of the staging directory for the new local build.
      // The subdirectory name is derived from a hash of the URI,
      //   and so identical URIs will resolve to the same directory (as desired).
      val base = RetrieveUnit.temporary(info.staging, info.uri)

      // Return a closure that will do the actual resolution when requested.
      Some(() =&gt; resolveDemo(base, info.uri.getSchemeSpecificPart))
    }

  // Construct a sample project on the fly with the name specified in the URI.
  def resolveDemo(base: File, ssp: String): File =
  {
    // Only create the project if it hasn't already been created.
    if(!base.exists)
      IO.write(base / &quot;build.sbt&quot;, template.format(ssp))
    base
  }

  def template =  &quot;&quot;&quot;
name := &quot;%s&quot;

version := &quot;1.0&quot;
&quot;&quot;&quot;
}
</code></pre><h3 id="Custom+Builder">Custom Builder<a href="#Custom+Builder" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Once a project is resolved, it needs to be built and then presented to
sbt as an instance of <code>sbt.BuildUnit</code>. A custom builder has type:
</p><pre><code class="prettyprint lang-scala">BuildInfo =&gt; Option[() =&gt; BuildUnit] 
</code></pre><p>A builder returns None if it does not want to handle the build
identified by the <code>BuildInfo</code>. Otherwise, it provides a function that
will load the build when evaluated. Register a builder by passing it to
<em>BuildLoader.build</em> and overriding <em>Build.buildLoaders</em> with the result:
</p><pre><code class="prettyprint lang-scala">...
object Demo extends Build {
  ...
  override def buildLoaders =
    BuildLoader.build(demoBuilder) ::
    Nil

  def demoBuilder: BuildLoader.BuildInfo =&gt; Option[() =&gt; BuildUnit] = ...

}
</code></pre><h4 id="API+Documentation">API Documentation<a href="#API+Documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Relevant API documentation for custom builders:
</p><ul><li><a href="../api/sbt/BuildLoader$$BuildInfo.html">BuildInfo</a>
</li><li><a href="../api/sbt/BuildLoader$.html">BuildLoader</a>
</li><li><a href="../api/index.html#sbt.Load$$BuildUnit">BuildUnit</a>
</li></ul><h4 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>This example demonstrates the structure of how a custom builder could
read configuration from a pom.xml instead of the standard .sbt files and
project/ directory.
</p><pre><code class="prettyprint lang-scala">... imports ...

object Demo extends Build
{
  lazy val root = Project(&quot;root&quot;, file(&quot;.&quot;)) dependsOn( file(&quot;basic-pom-project&quot;) )

  override def buildLoaders =
    BuildLoader.build(demoBuilder) ::
    Nil

  def demoBuilder: BuildInfo =&gt; Option[() =&gt; BuildUnit] = info =&gt;
    if(pomFile(info).exists)
      Some(() =&gt; pomBuild(info))
    else
      None

  def pomBuild(info: BuildInfo): BuildUnit =
  {
    val pom = pomFile(info)
    val model = readPom(pom)

    val n = Project.normalizeProjectID(model.getName)
    val base = Option(model.getProjectDirectory) getOrElse info.base
    val root = Project(n, base) settings( pomSettings(model) : _*)
    val build = new Build { override def projects = Seq(root) }
    val loader = this.getClass.getClassLoader
    val definitions = new LoadedDefinitions(info.base, Nil, loader, build :: Nil, Nil)
    val plugins = new LoadedPlugins(info.base / &quot;project&quot;, Nil, loader, Nil, Nil)
    new BuildUnit(info.uri, info.base, definitions, plugins)
  }

  def readPom(file: File): Model = ...
  def pomSettings(m: Model): Seq[Setting[_]] = ...
  def pomFile(info: BuildInfo): File = info.base / &quot;pom.xml&quot;
</code></pre><h3 id="Custom+Transformer">Custom Transformer<a href="#Custom+Transformer" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Once a project has been loaded into an <code>sbt.BuildUnit</code>, it is
transformed by all registered transformers. A custom transformer has
type:
</p><pre><code class="prettyprint lang-scala">TransformInfo =&gt; BuildUnit
</code></pre><p>A transformer is registered by passing it to <em>BuildLoader.transform</em> and
overriding <em>Build.buildLoaders</em> with the result:
</p><pre><code class="prettyprint lang-scala">...
object Demo extends Build {
  ...
  override def buildLoaders =
    BuildLoader.transform(demoTransformer) ::
    Nil

  def demoBuilder: BuildLoader.TransformInfo =&gt; BuildUnit = ...

}
</code></pre><h4 id="API+Documentation">API Documentation<a href="#API+Documentation" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Relevant API documentation for custom transformers:
</p><ul><li><a href="../api/index.html#sbt.BuildLoader$$TransformInfo">TransformInfo</a>
</li><li><a href="../api/sbt/BuildLoader$.html">BuildLoader</a>
</li><li><a href="../api/index.html#sbt.Load$$BuildUnit">BuildUnit</a>
</li></ul><h5 id="Manipulating+Project+Dependencies+in+Settings">Manipulating Project Dependencies in Settings<a href="#Manipulating+Project+Dependencies+in+Settings" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>The <code>buildDependencies</code> setting, in the Global scope, defines the
aggregation and classpath dependencies between projects. By default,
this information comes from the dependencies defined by <code>Project</code>
instances by the <code>aggregate</code> and <code>dependsOn</code> methods. Because
<code>buildDependencies</code> is a setting and is used everywhere dependencies
need to be known (once all projects are loaded), plugins and build
definitions can transform it to manipulate inter-project dependencies at
setting evaluation time. The only requirement is that no new projects
are introduced because all projects are loaded before settings get
evaluated. That is, all Projects must have been declared directly in a
Build or referenced as the argument to <code>Project.aggregate</code> or
<code>Project.dependsOn</code>.
</p><h3 id="The+BuildDependencies+type">The BuildDependencies type<a href="#The+BuildDependencies+type" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The type of the <code>buildDependencies</code> setting is
<a href="../api/sbt/BuildDependencies.html">BuildDependencies</a>.
<code>BuildDependencies</code> provides mappings from a project to its aggregate or
classpath dependencies. For classpath dependencies, a dependency has
type <code>ClasspathDep[ProjectRef]</code>, which combines a <code>ProjectRef</code> with a
configuration (see <a href="../api/sbt/ClasspathDep.html">ClasspathDep</a>
and <a href="../api/sbt/ProjectRef.html">ProjectRef</a>). For aggregate
dependencies, the type of a dependency is just <code>ProjectRef</code>.
</p><p>The API for <code>BuildDependencies</code> is not extensive, covering only a little
more than the minimum required, and related APIs have more of an
internal, unpolished feel. Most manipulations consist of modifying the
relevant map (classpath or aggregate) manually and creating a new
<code>BuildDependencies</code> instance.
</p><h4 id="Example">Example<a href="#Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As an example, the following replaces a reference to a specific build
URI with a new URI. This could be used to translate all references to a
certain git repository to a different one or to a different mechanism,
like a local directory.
</p><pre><code class="prettyprint lang-scala">buildDependencies in Global := {
  val deps = (buildDependencies in Global).value
  val oldURI = uri(&quot;...&quot;) // the URI to replace
  val newURI = uri(&quot;...&quot;) // the URI replacing oldURI
  def substitute(dep: ClasspathDep[ProjectRef]): ClasspathDep[ProjectRef] =
    if(dep.project.build == oldURI)
      ResolvedClasspathDependency(ProjectRef(newURI, dep.project.project), dep.configuration)
    else
      dep
  val newcp = 
    for( (proj, deps) &lt;- deps.cp) yield
      (proj, deps map substitute)
  new BuildDependencies(newcp, deps.aggregate)
}
</code></pre><p>It is not limited to such basic translations, however. The configuration
a dependency is defined in may be modified and dependencies may be added
or removed. Modifying <code>buildDependencies</code> can be combined with modifying
<code>libraryDependencies</code> to convert binary dependencies to and from source
dependencies, for example.
</p><h2 id="Creating+Command+Line+Applications+Using+sbt">Creating Command Line Applications Using sbt<a href="#Creating+Command+Line+Applications+Using+sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>There are several components of sbt that may be used to create a command
line application. The <a href="Sbt-Launcher.html">launcher</a> and the
<a href="Commands.html">command system</a> are the two main ones illustrated here.
</p><p>As described on the <a href="Sbt-Launcher.html">launcher page</a>, a
launched application implements the xsbti.AppMain interface and defines
a brief configuration file that users pass to the launcher to run the
application. To use the command system, an application sets up a
<a href="Build-State.html">State</a> instance that provides
<a href="Commands.html">command implementations</a> and the initial commands to run. A
minimal hello world example is given below.
</p><h3 id="Hello+World+Example">Hello World Example<a href="#Hello+World+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>There are three files in this example:
</p><ol><li>build.sbt
</li><li>Main.scala
</li><li>hello.build.properties
</li></ol><p>To try out this example:
</p><ol><li>Put the first two files in a new directory
</li><li>Run <code>sbt publishLocal</code> in that directory
</li><li>Run <code>sbt @path/to/hello.build.properties</code> to run the application.
</li></ol><p>Like for sbt itself, you can specify commands from the command line
(batch mode) or run them at an prompt (interactive mode).
</p><h4 id="Build+Definition%3A+build.sbt">Build Definition: build.sbt<a href="#Build+Definition%3A+build.sbt" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The build.sbt file should define the standard settings: name, version,
and organization. To use the sbt command system, a dependency on the
<code>command</code> module is needed. To use the task system, add a dependency on
the <code>task-system</code> module as well.
</p><pre><code class="prettyprint lang-scala">organization := &quot;org.example&quot;

name := &quot;hello&quot;

version := &quot;0.1-SNAPSHOT&quot;

libraryDependencies += &quot;org.scala-sbt&quot; % &quot;command&quot; % &quot;0.12.0&quot;
</code></pre><h4 id="Application%3A+Main.scala">Application: Main.scala<a href="#Application%3A+Main.scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The application itself is defined by implementing
<a href="../api/xsbti/AppMain.html">xsbti.AppMain</a>. The basic steps are
</p><ol><li>Provide command definitions. These are the commands that are
available for users to run.
</li><li>Define initial commands. These are the commands that are initially
scheduled to run. For example, an application will typically add
anything specified on the command line (what sbt calls batch mode)
and if no commands are defined, enter interactive mode by running
the ‘shell’ command.
</li><li>Set up logging. The default setup in the example rotates the log
file after each user interaction and sends brief logging to the
console and verbose logging to the log file.
</li></ol><pre><code class="prettyprint lang-scala">package org.example

   import sbt._
   import java.io.{File, PrintWriter}

final class Main extends xsbti.AppMain
{
   /** Defines the entry point for the application.
   * The call to `initialState` sets up the application.
   * The call to runLogged starts command processing. */
   def run(configuration: xsbti.AppConfiguration): xsbti.MainResult =
      MainLoop.runLogged( initialState(configuration) )

   /** Sets up the application by constructing an initial State instance with the supported commands
   * and initial commands to run.  See the State API documentation for details. */
   def initialState(configuration: xsbti.AppConfiguration): State =
   {
      val commandDefinitions = hello +: BasicCommands.allBasicCommands
      val commandsToRun = Hello +: &quot;iflast shell&quot; +: configuration.arguments.map(_.trim)
      State( configuration, commandDefinitions, Set.empty, None, commandsToRun, State.newHistory,
         AttributeMap.empty, initialGlobalLogging, State.Continue )
   }

   // defines an example command.  see the Commands page for details.
   val Hello = &quot;hello&quot;
   val hello = Command.command(Hello) { s =&gt;
      s.log.info(&quot;Hello!&quot;)
      s
   }

   /** Configures logging to log to a temporary backing file as well as to the console. 
   * An application would need to do more here to customize the logging level and
   * provide access to the backing file (like sbt's last command and logLevel setting).*/
   def initialGlobalLogging: GlobalLogging =
      GlobalLogging.initial(MainLogging.globalDefault _, File.createTempFile(&quot;hello&quot;, &quot;log&quot;))
}
</code></pre><h4 id="Launcher+configuration+file%3A+hello.build.properties">Launcher configuration file: hello.build.properties<a href="#Launcher+configuration+file%3A+hello.build.properties" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The launcher needs a configuration file in order to retrieve and run an
application. <code>hello.build.properties</code>:
</p><pre><code class="">[scala]
  version: 2.9.1

[app]
  org: org.example
  name: hello
  version: 0.1-SNAPSHOT
  class: org.example.Main
  components: xsbti
  cross-versioned: true

[repositories]
  local
  maven-central
  typesafe-ivy-releases: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre><h2 id="Nightly+Builds">Nightly Builds<a href="#Nightly+Builds" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>The latest development versions of 0.13.5 are available as nightly
builds on <a href="http://repo.typesafe.com/typesafe/ivy-snapshots/">Typesafe Snapshots</a>.
</p><p>To use a nightly build, the instructions are the same for
<a href="../tutorial/Manual-Installation.html">normal manual setup</a> except:
</p><ol><li>Download the launcher jar from one of the subdirectories of
|nightly-launcher|. They should be listed in chronological order, so
the most recent one will be last.
</li><li>The version number is the name of the subdirectory and is of the
form <code>0.13.5.x-yyyyMMdd-HHmmss</code>. Use this in a build.properties
file.
</li><li>Call your script something like <code>sbt-nightly</code> to retain access to a
stable sbt launcher. The documentation will refer to the script as
sbt, however.
</li></ol><p>Related to the third point, remember that an <code>sbt.version</code> setting in
<code>&lt;build-base&gt;/project/build.properties</code> determines the version of sbt to
use in a project. If it is not present, the default version associated
with the launcher is used. This means that you must set
<code>sbt.version=yyyyMMdd-HHmmss</code> in an existing
<code>&lt;build-base&gt;/project/build.properties</code>. You can verify the right
version of sbt is being used to build a project by running <code>about</code>.
</p><p>To reduce problems, it is recommended to not use a launcher jar for one
nightly version to launch a different nightly version of sbt.
</p><h2 id="Index">Index<a href="#Index" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>This is an index of common methods, types, and values you might find in
an sbt build definition. For command names, see
<a href="../tutorial/Running.html">Running</a>. For available plugins, see
<a href="Communitiy-Plugins.html">the plugins list</a>.
</p><h3 id="Values+and+Types">Values and Types<a href="#Values+and+Types" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="../api/sbt/ModuleID.html">ModuleID</a> is the type of a dependency
definition. See
<a href="Library-Management.html">Library Management</a>.
</li><li><a href="../api/sbt/Artifact.html">Artifact</a> represents a single artifact
(such as a jar or a pom) to be built and published. See
<a href="Library-Management.html">Library Management</a> and <a href="Artifacts.html">Artifacts</a>.
</li><li>A <a href="../api/sbt/Resolver.html">Resolver</a> can resolve and retrieve
dependencies. Many types of Resolvers can publish dependencies as
well. A repository is a closely linked idea that typically refers to
the actual location of the dependencies. However, sbt is not very
consistent with this terminology and repository and resolver are
occasionally used interchangeably.
</li><li>A [ModuleConfiguration] defines a specific resolver to use for a
group of dependencies.
</li><li>A <a href="../api/sbt/Configuration.html">Configuration</a> is a useful Ivy
construct for grouping dependencies. See ivy-configurations. It is
also used for <a href="../tutorial/Scopes.html">scoping settings</a>.
</li><li><code>Compile</code>, <code>Test</code>, <code>Runtime</code>, <code>Provided</code>, and <code>Optional</code> are
predefined <a href="Library-Management.html#ivy-configurations">configurations</a>.
</li></ul><h4 id="Settings+and+Tasks">Settings and Tasks<a href="#Settings+and+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>A <a href="../api/sbt/Init$Setting.html">Setting</a> describes how to
initialize a specific setting in the build. It can use the values of
other settings or the previous value of the setting being
initialized.
</li><li>A <a href="../api/sbt/Init$SettingsDefinition.html">SettingsDefinition</a>
is the actual type of an expression in a build.sbt. This allows
either a single <a href="../api/sbt/Init$Setting.html">Setting</a> or a
sequence of settings
(<a href="../api/sbt/Init$SettingList.html">SettingList</a>) to be defined at
once. The types in a <a href="../tutorial/Full-Def.html">.scala build definition</a> always use just a
plain <a href="../api/sbt/Init$Setting.html">Setting</a>.
</li><li><a href="../api/sbt/Init$Initialize.html">Initialize</a> describes how to
initialize a setting using other settings, but isn’t bound to a
particular setting yet. Combined with an initialization method and a
setting to initialize, it produces a full
<a href="../api/sbt/Init$Setting.html">Setting</a>.
</li><li><a href="../api/sbt/TaskKey.html">TaskKey</a>,
<a href="../api/sbt/SettingKey.html">SettingKey</a>, and
<a href="../api/sbt/InputKey.html">InputKey</a> are keys that represent a task
or setting. These are not the actual tasks, but keys that are used
to refer to them. They can be scoped to produce
<a href="../api/sbt/ScopedTask.html">ScopedTask</a>,
<a href="../api/sbt/ScopedSetting.html">ScopedSetting</a>, and
<a href="../api/sbt/ScopedInput.html">ScopedInput</a>. These form the base
types that provide the Settings methods.
</li><li><a href="../api/sbt/InputTask.html">InputTask</a> parses and tab completes
user input, producing a task to run.
</li><li><a href="../api/sbt/Task.html">Task</a> is the type of a task. A task is an
action that runs on demand. This is in contrast to a setting, which
is run once at project initialization.
</li></ul><h4 id="Process">Process<a href="#Process" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li>A <a href="../api/sbt/ProcessBuilder.html">ProcessBuilder</a> is the type
used to define a process. It provides combinators for building up
processes from smaller processes.
</li><li>A <a href="../api/sbt/Process.html">Process</a> represents the actual forked
process.
</li><li>The <a href="../api/sbt/Process$.html">Process companion object</a> provides
methods for constructing primitive processes.
</li></ul><h4 id="Build+Structure">Build Structure<a href="#Build+Structure" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><ul><li><a href="../api/sbt/Build.html">Build</a> is the trait implemented for a
<a href="../tutorial/Full-Def.html">.scala build definition</a>, which defines project
relationships and settings.
</li><li><a href="../api/sbt/Plugin.html">Plugin</a> is the trait implemented for sbt
<a href="../tutorial/Using-Plugins.html">plugins</a>.
</li><li><a href="../api/sbt/Project.html">Project</a> is both a trait and a
companion object that declares a single module in a build. See
<a href="../tutorial/Full-Def.html">.scala build definition</a>.
</li><li><a href="../api/sbt/Keys$.html">Keys</a> is an object that provides all of
the built-in keys for settings and tasks.
</li><li><a href="../api/sbt/State.html">State</a> contains the full state for a
build. It is mainly used by <a href="Commands.html">Commands</a> and sometimes
<a href="Input-Tasks.html">Input Tasks</a>. See also <a href="Build-State.html">State and Actions</a>.
</li></ul><h3 id="Methods">Methods<a href="#Methods" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Settings+and+Tasks">Settings and Tasks<a href="#Settings+and+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See the <a href="../tutorial/Basic-Def.html">Getting Started Guide</a> for
details.
</p><ul><li><code>:=</code>, <code>+=</code>, <code>++=</code> These construct a
<a href="../api/sbt/Init$Setting.html">Setting</a>, which is the fundamental
type in the <a href="../tutorial/Basic-Def.html">settings</a> system.
</li><li><code>value</code> This uses the value of another setting or task in the
definition of a new setting or task. This method is special (it is a
macro) and cannot be used except in the argument of one of the
setting definition methods above (:=, …) or in the standalone
construction methods Def.setting and Def.task. See
<a href="../tutorial/More-About-Settings.html">more about settings</a> for
details.
</li><li><code>in</code> specifies the <a href="../api/sbt/Scope.html">Scope</a> or part of the
<a href="../api/sbt/Scope.html">Scope</a> of a setting being referenced. See
<a href="../tutorial/Scopes.html">scopes</a>.
</li></ul><h4 id="File+and+IO">File and IO<a href="#File+and+IO" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="../api/sbt/RichFile.html">RichFile</a>,
<a href="../api/sbt/PathFinder.html">PathFinder</a>, and
<a href="Paths.html">Paths</a> for the full documentation.
</p><ul><li><code>/</code> When called on a single File, this is <code>new File(x,y)</code>. For
Seq[File], this is applied for each member of the sequence..
</li><li><code>*</code> and <code>**</code> are methods for selecting children (<code>*</code>) or descendants
(<code>**</code>) of a File or Seq[File] that match a filter.
</li><li><code>|</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>&amp;</code>, <code>-</code>, and <code>--</code> are methods for combining
filters, which are often used for selecting Files. See
<a href="../api/sbt/NameFilter.html">NameFilter</a> and
<a href="../api/sbt/FileFilter.html">FileFilter</a>. Note that methods with
these names also exist for other types, such as collections (like
Seq) and <a href="../api/sbt/complete/Parser.html">Parser</a> (see
<a href="Parsing-Input.html">Parsing Input</a>).
</li><li><code>pair</code> Used to construct mappings from a <code>File</code> to another <code>File</code> or
to a String. See <a href="Mapping-Files.html">Mapping Files</a>.
</li><li><code>get</code> forces a <a href="../api/sbt/PathFinder.html">PathFinder</a> (a
call-by-name data structure) to a strict <code>Seq[File]</code> representation.
This is a common name in Scala, used by types like Option.
</li></ul><h4 id="Dependency+Management">Dependency Management<a href="#Dependency+Management" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>See <a href="Library-Management.html">Library Management</a> for full documentation.
</p><ul><li><code>%</code> This is used to build up a <a href="../api/sbt/ModuleID.html">ModuleID</a>.
</li><li><code>%%</code> This is similar to <code>%</code> except that it identifies a dependency
that has been <a href="Cross-Build.html">cross built</a>.
</li><li><code>from</code> Used to specify the fallback URL for a dependency
</li><li><code>classifier</code> Used to specify the classifier for a dependency.
</li><li><code>at</code> Used to define a Maven-style resolver.
</li><li><code>intransitive</code> Marks a <a href="../api/sbt/ModuleID.html">dependency</a> or
<a href="../api/sbt/Configuration.html">Configuration</a> as being
intransitive.
</li><li><code>hide</code> Marks a <a href="../api/sbt/Configuration.html">Configuration</a> as
internal and not to be included in the published metadata.
</li></ul><h4 id="Parsing">Parsing<a href="#Parsing" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These methods are used to build up
<a href="../api/sbt/complete/Parser.html">Parser</a>s from smaller
<a href="../api/sbt/complete/Parser.html">Parser</a>s. They closely follow the
names of the standard library’s parser combinators. See
<a href="Parsing-Input.html">Parsing Input</a> for the full documentation. These are
used for
<a href="Input-Tasks.html">Input Tasks</a> and
<a href="Commands.html">Commands</a>.
</p><ul><li><code>~</code>, <code>~&gt;</code>, <code>&lt;~</code> Sequencing methods.
</li><li><code>??</code>, <code>?</code> Methods for making a Parser optional. <code>?</code> is postfix.
</li><li><code>id</code> Used for turning a Char or String literal into a Parser. It is
generally used to trigger an implicit conversion to a Parser.
</li><li><code>|</code>, <code>||</code> Choice methods. These are common method names in Scala.
</li><li><code>^^^</code> Produces a constant value when a Parser matches.
</li><li><code>+</code>, <code>*</code> Postfix repetition methods. These are common method names
in Scala.
</li><li><code>map</code>, <code>flatMap</code> Transforms the result of a Parser. These are common
method names in Scala.
</li><li><code>filter</code> Restricts the inputs that a Parser matches on. This is a
common method name in Scala.
</li><li><code>-</code> Prefix negation. Only matches the input when the original parser
doesn’t match the input.
</li><li><code>examples</code>, <code>token</code> Tab completion
</li><li><code>!!!</code> Provides an error message to use when the original parser
doesn’t match the input.
</li></ul><h4 id="Processes">Processes<a href="#Processes" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>These methods are used to
<a href="Process.html">fork external processes</a>. Note that this API
has been included in the Scala standard library for version 2.9.
<a href="../api/sbt/ProcessBuilder.html">ProcessBuilder</a> is the builder type
and <a href="../api/sbt/Process.html">Process</a> is the type representing the
actual forked process. The methods to combine processes start with <code>#</code>
so that they share the same precedence.
</p><ul><li><code>run</code>, <code>!</code>, <code>!!</code>, <code>!&lt;</code>, <code>lines</code>, <code>lines_!</code> are different ways to
start a process once it has been defined. The lines variants produce
a Stream[String] to obtain the output lines.
</li><li><code>#&lt;</code>, <code>#&lt;&lt;</code>, <code>#&gt;</code> are used to get input for a process from a source
or send the output of a process to a sink.
</li><li><code>#|</code> is used to pipe output from one process into the input of
another.
</li><li><code>#||</code>, <code>#&amp;&amp;</code>, <code>###</code> sequence processes in different ways.
</li></ul>
          </div>
        </div>
        <div class="header">
          <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,900,400italic,700italic" rel="stylesheet" type="text/css">
<div class="container navbar-static-top nav">
    <div class="logo">
      <a href="../../index.html"><img src="files/sbt-logo-white-72x50.png" alt="sbt"></a>
    </div>
    <ul class="navlist">
      <li><a href="../../documentation.html">Documentation</a></li>
      <li><a href="../../download.html">Download</a></li>
      <li><a href="../../community.html">Community</a></li>
      <li id="source-code"><a href="https://github.com/sbt/sbt"><img src="files/github-logo.png" alt="Source code"></a></li>
      <li id="twitter"><a href="https://twitter.com/scala_sbt"><img src="files/twitter-logo-white.png" alt="sbt on Twitter"></a></li>
    </ul>
</div>

        </div>
        <div class="footer">
          
        </div>
        
        
      </body>
    </html>