<!DOCTYPE html SYSTEM "about:legacy-compat">
<html manifest="pamflet.manifest">
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>sbt Reference Manual — Plugins</title>
        
        <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/blueprint/grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print"/> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href={ relativeBase + "css/blueprint/ie.css" } type="text/css" media="screen, projection"/>
        <![endif]-->
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_80px_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery.collapse.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/custom.css" type="text/css" media="screen, projection"/>
        
        
      </head>
      <body class="color_scheme-github">
        <a class="page prev nav" href="Best-Practices.html">
            <span class="space">&nbsp;</span>
            <span class="flip arrow">&gt;</span>
          </a><a class="page next nav" href="Plugins-Best-Practices.html">
            <span class="space">&nbsp;</span>
            <span class="arrow">&gt;</span>
          </a>
        <div class="container contentswrapper">
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Plugins">Plugins<a href="#Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><h3 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin is essentially a way to use external code in a build
definition. A plugin can be a library used to implement a task. For
example, you might use
<a href="https://github.com/tristanjuricek/knockoff/">Knockoff</a> to write a
markdown processing task. A plugin can define a sequence of sbt Settings
that are automatically added to all projects or that are explicitly
declared for selected projects. For example, a plugin might add a
<code>proguard</code> task and associated (overridable) settings. Also, <code>Commands</code>
can be added with the <code>commands</code> setting
</p><p>The <code>Plugins-Best-Practices</code> page describes the currently evolving
guidelines to writing sbt plugins. See also the general
<a href="Best-Practices.html">best practices</a>.
</p><h3 id="Using+a+binary+sbt+plugin">Using a binary sbt plugin<a href="#Using+a+binary+sbt+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A common situation is using a binary plugin published to a repository.
Create <code>project/plugins.sbt</code> with the desired sbt plugins, any general
dependencies, and any necessary repositories:
</p><pre><code class="prettyprint lang-scala">addSbtPlugin(&quot;org.example&quot; % &quot;plugin&quot; % &quot;1.0&quot;)

addSbtPlugin(&quot;org.example&quot; % &quot;another-plugin&quot; % &quot;2.0&quot;)

// plain library (not an sbt plugin) for use in the build definition
libraryDependencies += &quot;org.example&quot; % &quot;utilities&quot; % &quot;1.3&quot;

resolvers += &quot;Example Plugin Repository&quot; at &quot;http://example.org/repo/&quot;
</code></pre><p>See the rest of the page for more information on creating and using
plugins.
</p><h3 id="By+Description">By Description<a href="#By+Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A plugin definition is a project in <code>&lt;main-project&gt;/project/</code>. This
project’s classpath is the classpath used for build definitions in
<code>&lt;main-project&gt;/project/</code> and any <code>.sbt</code> files in the project’s base
directory. It is also used for the <code>eval</code> and <code>set</code> commands.
</p><p>Specifically,
</p><ol><li>Managed dependencies declared by the <code>project/</code> project are
retrieved and are available on the build definition classpath, just
like for a normal project.
</li><li>Unmanaged dependencies in <code>project/lib/</code> are available to the build
definition, just like for a normal project.
</li><li>Sources in the <code>project/</code> project are the build definition files and
are compiled using the classpath built from the managed and
unmanaged dependencies.
</li><li>Project dependencies can be declared in <code>project/plugins.sbt</code> or
project/project/Build.scala and will be available to the build
definition sources. Think of project/project/ as the build
definition for the build definition.
</li></ol><p>The build definition classpath is searched for <code>sbt/sbt.plugins</code>
descriptor files containing the names of Plugin implementations. A
Plugin is a module that defines settings to automatically inject to
projects. Additionally, all Plugin modules are wildcard imported for the
<code>eval</code> and <code>set</code> commands and <code>.sbt</code> files. A Plugin implementation is
not required to produce a plugin, however. It is a convenience for
plugin consumers and because of the automatic nature, it is not always
appropriate.
</p><p>The <code>reload plugins</code> command changes the current build to
<code>&lt;current-build&gt;/project/</code>. This allows manipulating the build
definition project like a normal project. <code>reload return</code> changes back
to the original build. Any session settings for the plugin definition
project that have not been saved are dropped.
</p><p><em>Note</em>: At runtime, all plugins for all builds are loaded in a separate,
parent class loader of the class loaders for builds. This means that
plugins will not see classes or resources from build definitions.
</p><h4 id="Global+plugins">Global plugins<a href="#Global+plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The <code>~/.sbt/0.13/plugins/</code> directory is treated as a global plugin
definition project. It is a normal sbt project whose classpath is
available to all sbt project definitions for that user as described
above for per-project plugins.
</p><h3 id="By+Example">By Example<a href="#By+Example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Using+a+library+in+a+build+definition">Using a library in a build definition<a href="#Using+a+library+in+a+build+definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>As an example, we’ll add the Grizzled Scala library as a plugin.
Although this does not provide sbt-specific functionality, it
demonstrates how to declare plugins.
</p><h5 id="1a%29+Manually+managed">1a) Manually managed<a href="#1a%29+Manually+managed" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><ol><li>Download the jar manually from
<a href="https://oss.sonatype.org/content/repositories/releases/org/clapper/grizzled-scala_2.8.1/1.0.4/grizzled-scala_2.8.1-1.0.4.jar">https://oss.sonatype.org/content/repositories/releases/org/clapper/grizzled-scala<em>2.8.1/1.0.4/grizzled-scala</em>2.8.1-1.0.4.jar</a>
</li><li>Put it in <code>project/lib/</code>
</li></ol><h5 id="1b%29+Automatically+managed%3A+direct+editing+approach">1b) Automatically managed: direct editing approach<a href="#1b%29+Automatically+managed%3A+direct+editing+approach" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Edit <code>project/plugins.sbt</code> to contain:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.clapper&quot; %% &quot;grizzled-scala&quot; % &quot;1.0.4&quot;
</code></pre><p>If sbt is running, do <code>reload</code>.
</p><h5 id="1c%29+Automatically+managed%3A+command+line+approach">1c) Automatically managed: command line approach<a href="#1c%29+Automatically+managed%3A+command+line+approach" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>We can change to the plugins project in <code>project/</code> using
<code>reload plugins</code>.
</p><pre><code class="">$ sbt
&gt; reload plugins
[info] Set current project to default (in build file:/Users/harrah/demo2/project/)
&gt;
</code></pre><p>Then, we can add dependencies like usual and save them to
<code>project/plugins.sbt</code>. It is useful, but not required, to run <code>update</code>
to verify that the dependencies are correct.
</p><pre><code class="">&gt; set libraryDependencies += &quot;org.clapper&quot; %% &quot;grizzled-scala&quot; % &quot;1.0.4&quot;
...
&gt; update
...
&gt; session save
...
</code></pre><p>To switch back to the main project:
</p><pre><code class="">&gt; reload return
[info] Set current project to root (in build file:/Users/harrah/demo2/)
</code></pre><h5 id="1d%29+Project+dependency">1d) Project dependency<a href="#1d%29+Project+dependency" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>This variant shows how to use sbt’s external project support to declare
a source dependency on a plugin. This means that the plugin will be
built from source and used on the classpath.
</p><p>Edit <code>project/plugins.sbt</code>
</p><pre><code class="prettyprint lang-scala">lazy val root = (project in file(&quot;.&quot;)).dependsOn(assemblyPlugin)
lazy val assemblyPlugin = uri(&quot;git://github.com/sbt/sbt-assembly&quot;)
</code></pre><p>If sbt is running, run <code>reload</code>.
</p><p>Note that this approach can be useful used when developing a plugin. A
project that uses the plugin will rebuild the plugin on <code>reload</code>. This
saves the intermediate steps of <code>publishLocal</code> and <code>update</code>. It can also
be used to work with the development version of a plugin from its
repository.
</p><p>It is recommended to explicitly specify the commit or tag by appending
it to the repository as a fragment:
</p><pre><code class="prettyprint lang-scala">lazy val assemblyPlugin = uri(&quot;git://github.com/sbt/sbt-assembly#0.9.1&quot;)
</code></pre><p>One caveat to using this method is that the local sbt will try to run
the remote plugin’s build. It is quite possible that the plugin’s own
build uses a different sbt version, as many plugins cross-publish for
several sbt versions. As such, it is recommended to stick with binary
artifacts when possible.
</p><h5 id="2%29+Use+the+library">2) Use the library<a href="#2%29+Use+the+library" class="header-link"><span class="header-link-content">&nbsp;</span></a></h5><p>Grizzled Scala is ready to be used in build definitions. This includes
the <code>eval</code> and <code>set</code> commands and <code>.sbt</code> and <code>project/*.scala</code> files.
</p><pre><code class="">&gt; eval grizzled.sys.os
</code></pre><p>In a <code>build.sbt</code> file:
</p><pre><code class="prettyprint lang-scala">import grizzled.sys._
import OperatingSystem._

libraryDependencies ++=
    if(os ==Windows)
        (&quot;org.example&quot; % &quot;windows-only&quot; % &quot;1.0&quot;) :: Nil
    else
        Nil
</code></pre><h3 id="Creating+a+plugin">Creating a plugin<a href="#Creating+a+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><h4 id="Introduction">Introduction<a href="#Introduction" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A minimal plugin is a Scala library that is built against the version of
Scala that sbt runs (currently, 2.10.3) or a Java library.
Nothing special needs to be done for this type of library, as shown in
the previous section. A more typical plugin will provide sbt tasks,
commands, or settings. This kind of plugin may provide these settings
automatically or make them available for the user to explicitly
integrate.
</p><h4 id="Description">Description<a href="#Description" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>To make a plugin, create a project and configure <code>sbtPlugin</code> to <code>true</code>.
Then, write the plugin code and publish your project to a repository.
The plugin can be used as described in the previous section.
</p><ul><li>Automatically importing selective names to <code>.sbt</code> files.
</li><li>Specifying plugin dependencies.
</li><li>Automatically activating itself when all dependencies are present.
</li><li>Specifying <code>projectSettings</code>, <code>buildSettings</code>, and <code>globalSettings</code>
as appropriate.
</li></ul><p>When an AutoPlugin provides a stable field such as <code>val</code> or <code>object</code>
named <code>autoImport</code>, the contents of the field are wildcard imported in
in <code>set</code>, <code>eval</code>, and <code>.sbt</code> files. Typically, this is used to provide
new keys (SettingKey, TaskKey, or InputKey) or core methods without
requiring an import or qualification.
</p><p>The AutoPlugin’s <code>projectSettings</code> is automatically appended to each
project’s settings, when its dependencies also exist on that project.
The <code>requires</code> method defines the dependencies to other plugins. The
<code>trigger</code> method defines the conditions by which this plugin’s settings
are automatically activated. The <code>buildSettings</code> is appended to each
build’s settings (that is, <code>in ThisBuild</code>). The <code>globalSettings</code> is
appended once to the global settings (<code>in Global</code>). These allow a plugin
to automatically provide new functionality or new defaults. One main use
of this feature is to globally add commands, such as for IDE plugins.
Use <code>globalSettings</code> to define the default value of a setting.
</p><h4 id="Example+Plugin">Example Plugin<a href="#Example+Plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>An example of a typical plugin:
</p><p><code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">sbtPlugin := true

name := &quot;sbt-obfuscate&quot;

organization := &quot;org.example&quot;
</code></pre><p><code>Plugin.scala</code>:
</p><pre><code class="prettyprint lang-scala">package sbtobfuscate

import sbt._

object Plugin extends AutoPlugin
{
    // by definging autoImport, these are automatically imported into user's `*.sbt`
    object autoImport
    {
        // configuration points, like the built in `version`, `libraryDependencies`, or `compile`
        val obfuscate = taskKey[Seq[File]](&quot;Obfuscates files.&quot;)
        val obfuscateLiterals = settingKey[Boolean](&quot;Obfuscate literals.&quot;)

        // default values for the tasks and settings
        lazy val baseObfuscateSettings: Seq[sbt.Def.Setting[_]] = Seq(
            obfuscate := {
                Obfuscate(sources.value, (obfuscateLiterals in obfuscate).value)
            },
            obfuscateLiterals in obfuscate := false                
        )
    }

    import autoImport._
    override def requires = sbt.plugins.JvmModule

    // This plugin is automatically enabled for projects which are JvmModules.
    override def trigger = allRequirements

    // a group of settings that are automatically added to projects.
    override val projectSettings =
        inConfig(Compile)(baseObfucscateSettings) ++
        inConfig(Test)(baseObfuscateSettings)
}

object Obfuscate
{
    def apply(sources: Seq[File]): Seq[File] := sources
}
</code></pre><h4 id="Usage+example">Usage example<a href="#Usage+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A build definition that uses the plugin might look like. <code>obfuscate.sbt</code>:
</p><pre><code class="prettyprint lang-scala">obfuscateLiterals in obfuscate := true
</code></pre><h4 id="Root+Plugins">Root Plugins<a href="#Root+Plugins" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Some plugins should always be explicitly enabled on projects. Sbt calls
these root plugins, i.e. plugins that are “root” nodes in the plugin
depdendency graph. <code>AutoPlugin</code> by default defines a root plugin.
</p><h4 id="Example+command+root+plugin">Example command root plugin<a href="#Example+command+root+plugin" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>A basic plugin that adds commands looks like. <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">sbtPlugin := true

name := &quot;sbt-sample&quot;

organization := &quot;org.example&quot;
</code></pre><p><code>Plugin.scala</code>:
</p><pre><code class="prettyprint lang-scala">package sbtsample

import sbt._
import Keys._
object Plugin extends AutoPlugin {
  override lazy val projectSettings = Seq(commands += myCommand)

  lazy val myCommand = 
    Command.command(&quot;hello&quot;) { (state: State) =&gt;
      println(&quot;Hi!&quot;)
      state
    }
}
</code></pre><p>This example demonstrates how to take a Command (here, <code>myCommand</code>) and
distribute it in a plugin. Note that multiple commands can be included
in one plugin (for example, use <code>commands ++= Seq(a,b)</code>). See
<a href="Commands.html">Commands</a>
for defining more useful commands, including ones that accept arguments
and affect the execution state.
</p><p>For a user to consume this plugin, it requires an explicit include via
the <code>Project</code> instance. Here’s what their local sbt will look like. <code>build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">val root = Project(&quot;example-plugin-usage&quot;, file(&quot;.&quot;)).setPlugins(MyPlugin)
</code></pre><p>The <code>setPlugins</code> method allows projects to explicitly define the
<code>RootPlugin</code>s they wish to consume. <code>AutoPlugin</code>s are automatically
added to the project as appropriate.
</p><p>Projects can also exclude any type of plugin using the <code>disablePlugins</code>
method. For example, if we wish to remove the JvmModule settings
(<code>compile</code>,<code>test</code>,<code>run</code>), we modify our <code>build.sbt</code> as follows:
</p><pre><code class="prettyprint lang-scala">val root = Project(&quot;example-plugin-usage&quot;, file(&quot;.&quot;)).setPlugins(MyPlugin).disablePlugins(plugins.JvmModule)
</code></pre><h4 id="Global+plugins+example">Global plugins example<a href="#Global+plugins+example" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The simplest global plugin definition is declaring a library or plugin
in <code>~/.sbt/0.13/plugins/build.sbt</code>:
</p><pre><code class="prettyprint lang-scala">libraryDependencies += &quot;org.example&quot; %% &quot;example-plugin&quot; % &quot;0.1&quot;
</code></pre><p>This plugin will be available for every sbt project for the current
user.
</p><p>In addition:
</p><ul><li>Jars may be placed directly in <code>~/.sbt/0.13/plugins/lib/</code>
and will be available to every build definition for the current user.
</li><li>Dependencies on plugins built from source may be declared in
<code>~/.sbt/0.13/plugins/project/Build.scala</code> as described at
[.scala build definition][Full-Deff].
</li><li>A Plugin may be directly defined in Scala
source files in <code>~/.sbt/0.13/plugins/</code>, such as
<code>~/.sbt/0.13/plugins/MyPlugin.scala</code>.
<code>~/.sbt/0.13/plugins//build.sbt</code>
should contain <code>sbtPlugin := true</code>. This can be used for quicker
turnaround when developing a plugin initially:
</li></ul><ol><li>Edit the global plugin code
</li><li>reload the project you want to use the modified plugin in
</li><li><p>sbt will rebuild the plugin and use it for the project.
</p><p>   Additionally, the plugin will be available in other projects on
   the machine without recompiling again. This approach skips the
   overhead of publishLocal and cleaning the plugins directory of the
   project using the plugin.
</p></li></ol><p>These are all consequences of <code>~/.sbt/0.13/plugins/</code> being a standard
project whose classpath is added to every sbt project’s build
definition.
</p><h3 id="Best+Practices">Best Practices<a href="#Best+Practices" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>If you’re a plugin writer, please consult the <a href="Plugins-Best-Practices.html">plugins best practices</a>
page; it contains a set of guidelines to help you ensure that your
plugin is consistent with and plays well with other plugins.
</p><div class="bottom nav span-16">
                        <em>Next Page</em>
                        <span class="arrow">&gt;</span>
                        <a href="Plugins-Best-Practices.html"> Plugins Best Practices </a>                        
                        
                      </div><div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="index.html">sbt Reference Manual</a></div><ol class="toc"> <li><div><a href="General-Info.html">General Information</a></div><ol class="toc"> <li><div><a href="Credits.html">Credits</a></div></li><li><div><a href="Community-Plugins.html">Community Plugins</a></div></li><li><div><a href="Repository-Roles.html">Community Repository Policy</a></div></li><li><div><a href="Bintray-For-Plugins.html">Bintray For Plugins</a></div></li><li><div><a href="Setup-Notes.html">Setup Notes</a></div></li><li><div><a href="Using-Sonatype.html">Deploying to Sonatype</a></div></li><li><div><a href="Changes.html">Changes</a></div><ol class="toc"> <li><div><a href="ChangeSummary_0.13.0.html">sbt 0.13.0 Changes</a></div></li><li><div><a href="ChangeSummary_0.12.0.html">sbt 0.12.0 Changes</a></div></li><li><div><a href="Older-Changes.html">Older Changes</a></div></li><li><div><a href="Migrating-from-sbt-07x.html">Migrating from 0.7 to 0.10+</a></div></li> </ol></li><li><div><a href="Contibuting-to-sbt.html">Contributing to sbt</a></div></li> </ol></li><li><div><a href="Faq.html">Frequently Asked Questions</a></div><ol class="toc">  </ol></li><li><div><a href="Howto.html">How to…</a></div><ol class="toc"> <li><div><a href="Howto-Classpaths.html">Classpaths</a></div></li><li><div><a href="Howto-Customizing-Paths.html">Customizing paths</a></div></li><li><div><a href="Howto-Generating-Files.html">Generating files</a></div></li><li><div><a href="Howto-Inspect-the-Build.html">Inspect the build</a></div></li><li><div><a href="Howto-Interactive-Mode.html">Interactive mode</a></div></li><li><div><a href="Howto-Logging.html">Configure and use logging</a></div></li><li><div><a href="Howto-Project-Metadata.html">Project metadata</a></div></li><li><div><a href="Howto-Package.html">Configure packaging</a></div></li><li><div><a href="Howto-Running-Commands.html">Running commands</a></div></li><li><div><a href="Howto-Scala.html">Configure and use Scala</a></div></li><li><div><a href="Howto-Scaladoc.html">Generate API documentation</a></div></li><li><div><a href="Howto-Triggered.html">Triggered execution</a></div></li><li><div><a href="Examples.html">Examples</a></div><ol class="toc"> <li><div><a href="Basic-Def-Examples.html">.sbt build examples</a></div></li><li><div><a href="Full-Def-Example.html">.scala build example</a></div></li><li><div><a href="Advanced-Configurations-Example.html">Advanced configurations example</a></div></li><li><div><a href="Advanced-Command-Example.html">Advanced command example</a></div></li> </ol></li> </ol></li><li><div><a href="Detailed-Topics.html">Detailed Topics</a></div><ol class="toc"> <li><div><a href="Using-sbt.html">Using sbt</a></div><ol class="toc"> <li><div><a href="Command-Line-Reference.html">Command Line Reference</a></div></li><li><div><a href="Console-Project.html">Console Project</a></div></li><li><div><a href="Cross-Build.html">Cross-building</a></div></li><li><div><a href="Inspecting-Settings.html">Interacting with the Configuration System</a></div></li><li><div><a href="Triggered-Execution.html">Triggered Execution</a></div></li><li><div><a href="Scripts.html">Scripts, REPL, and Dependencies</a></div></li><li><div><a href="Understanding-Recompilation.html">Understanding Incremental Recompilation</a></div></li> </ol></li><li><div><a href="Configuration-Index.html">Configuration</a></div><ol class="toc"> <li><div><a href="Classpaths.html">Classpaths, sources, and resources</a></div></li><li><div><a href="Compiler-Plugins.html">Compiler Plugin Support</a></div></li><li><div><a href="Configuring-Scala.html">Configuring Scala</a></div></li><li><div><a href="Forking.html">Forking</a></div></li><li><div><a href="Global-Settings.html">Global Settings</a></div></li><li><div><a href="Java-Sources.html">Java Sources</a></div></li><li><div><a href="Mapping-Files.html">Mapping Files</a></div></li><li><div><a href="Local-Scala.html">Local Scala</a></div></li><li><div><a href="Macro-Projects.html">Macro Projects</a></div></li><li><div><a href="Paths.html">Paths</a></div></li><li><div><a href="Parallel-Execution.html">Parallel Execution</a></div></li><li><div><a href="Process.html">External Processes</a></div></li><li><div><a href="Running-Project-Code.html">Running Project Code</a></div></li><li><div><a href="Testing.html">Testing</a></div></li> </ol></li><li><div><a href="Dependency-Management-Index.html">Dependency Management</a></div><ol class="toc"> <li><div><a href="Artifacts.html">Artifacts</a></div></li><li><div><a href="Dependency-Management-Flow.html">Dependency Management Flow</a></div></li><li><div><a href="Library-Management.html">Library Management</a></div></li><li><div><a href="Proxy-Repositories.html">Proxy Repositories</a></div></li><li><div><a href="Publishing.html">Publishing</a></div></li><li><div><a href="Resolvers.html">Resolvers</a></div></li><li><div><a href="Update-Report.html">Update Report</a></div></li> </ol></li><li><div><a href="Tasks-and-Commands.html">Tasks and Commands</a></div><ol class="toc"> <li><div><a href="Tasks.html">Tasks</a></div></li><li><div><a href="Input-Tasks.html">Input Tasks</a></div></li><li><div><a href="Commands.html">Commands</a></div></li><li><div><a href="Parsing-Input.html">Parsing and tab completion</a></div></li><li><div><a href="Build-State.html">State and actions</a></div></li><li><div><a href="Task-Inputs.html">Tasks/Settings: Motivation</a></div></li> </ol></li><li><div><a href="Plugins-and-Best-Practices.html">Plugins and Best Practices</a></div><ol class="toc"> <li><div><a href="Best-Practices.html">General Best Practices</a></div></li><li><div class="current">Plugins</div></li><li><div><a href="Plugins-Best-Practices.html">Plugins Best Practices</a></div></li> </ol></li><li><div><a href="Sbt-Launcher.html">Sbt Launcher</a></div><ol class="toc"> <li><div><a href="Launcher-Getting-Started.html">Getting Started with the Sbt Launcher</a></div></li><li><div><a href="Launcher-Architecture.html">Sbt Launcher Architecture</a></div></li><li><div><a href="Launcher-Configuration.html">Sbt Launcher Configuration</a></div></li> </ol></li> </ol></li><li><div><a href="Developers-Guide.html">Developer’s Guide</a></div><ol class="toc"> <li><div><a href="Core-Principles.html">Core Principles</a></div></li><li><div><a href="Settings-Core.html">Settings Core</a></div></li><li><div><a href="Setting-Initialization.html">Setting Initialization</a></div></li><li><div><a href="Build-Loaders.html">Build Loaders</a></div></li><li><div><a href="Command-Line-Applications.html">Creating Command Line Applications Using sbt</a></div></li><li><div><a href="Nightly-Builds.html">Nightly Builds</a></div></li> </ol></li><li><div><a href="Name-Index.html">Index</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol></div></div>
          </div>
        </div>
        <div class="header">
          <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,900,400italic,700italic" rel="stylesheet" type="text/css">
<div class="container navbar-static-top nav">
    <div class="logo">
      <a href="../../index.html"><img src="files/sbt-logo-white-72x50.png" alt="sbt"></a>
    </div>
    <ul class="navlist">
      <li><a href="../../documentation.html">Documentation</a></li>
      <li><a href="../../download.html">Download</a></li>
      <li><a href="../../community.html">Community</a></li>
      <li id="source-code"><a href="https://github.com/sbt/sbt"><img src="files/github-logo.png" alt="Source code"></a></li>
      <li id="twitter"><a href="https://twitter.com/scala_sbt"><img src="files/twitter-logo-white.png" alt="sbt on Twitter"></a></li>
    </ul>
</div>

        </div>
        <div class="footer">
          
        </div>
        
        
      </body>
    </html>