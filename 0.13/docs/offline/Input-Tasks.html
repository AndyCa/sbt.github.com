<!DOCTYPE html SYSTEM "about:legacy-compat">
<html manifest="pamflet.manifest">
      <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <title>sbt Reference Manual — Input Tasks</title>
        
        <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/blueprint/grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print"/> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href={ relativeBase + "css/blueprint/ie.css" } type="text/css" media="screen, projection"/>
        <![endif]-->
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamfletheight_80px_2em.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery.collapse.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        <link rel="stylesheet" href="css/custom.css" type="text/css" media="screen, projection"/>
        
        
      </head>
      <body class="color_scheme-github">
        <a class="page prev nav" href="Tasks.html">
            <span class="space">&nbsp;</span>
            <span class="flip arrow">&gt;</span>
          </a><a class="page next nav" href="Commands.html">
            <span class="space">&nbsp;</span>
            <span class="arrow">&gt;</span>
          </a>
        <div class="container contentswrapper">
          <div class="span-16 prepend-1 append-1 contents">
            <h2 id="Input+Tasks">Input Tasks<a href="#Input+Tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>Input Tasks parse user input and produce a task to run.
<a href="Parsing-Input.html">Parsing Input</a> describes how to use the parser
combinators that define the input syntax and tab completion. This page
describes how to hook those parser combinators into the input task
system.
</p><h3 id="Input+Keys">Input Keys<a href="#Input+Keys" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>A key for an input task is of type <code>InputKey</code> and represents the input
task like a <code>SettingKey</code> represents a setting or a <code>TaskKey</code> represents
a task. Define a new input task key using the <code>inputKey.apply</code> factory
method:
</p><pre><code class="prettyprint lang-scala">// goes in project/Build.scala or in build.sbt
val demo = inputKey[Unit](&quot;A demo input task.&quot;)
</code></pre><p>The definition of an input task is similar to that of a normal task, but
it can also use the result of a
</p><p><a href="Parsing-Input.html">Parser</a> applied to user input. Just as
the special <code>value</code> method gets the value of a setting or task, the
special <code>parsed</code> method gets the result of a <code>Parser</code>.
</p><h3 id="Basic+Input+Task+Definition">Basic Input Task Definition<a href="#Basic+Input+Task+Definition" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The simplest input task accepts a space-delimited sequence of arguments.
It does not provide useful tab completion and parsing is basic. The
built-in parser for space-delimited arguments is constructed via the
<code>spaceDelimited</code> method, which accepts as its only argument the label to
present to the user during tab completion.
</p><p>For example, the following task prints the current Scala version and
then echoes the arguments passed to it on their own line.
</p><pre><code class="prettyprint lang-scala">demo := {
    // get the result of parsing
  val args: Seq[String] = spaceDelimited(&quot;&lt;arg&gt;&quot;).parsed
    // Here, we also use the value of the `scalaVersion` setting
  println(&quot;The current Scala version is &quot; + scalaVersion.value)
  println(&quot;The arguments to demo were:&quot;)
  args foreach println
}
</code></pre><h3 id="Input+Task+using+Parsers">Input Task using Parsers<a href="#Input+Task+using+Parsers" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The Parser provided by the <code>spaceDelimited</code> method does not provide any
flexibility in defining the input syntax. Using a custom parser is just
a matter of defining your own <code>Parser</code> as described on the
<a href="Parsing-Input.html">Parsing Input</a> page.
</p><h4 id="Constructing+the+Parser">Constructing the Parser<a href="#Constructing+the+Parser" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>The first step is to construct the actual <code>Parser</code> by defining a value
of one of the following types:
</p><ul><li><code>Parser[I]</code>: a basic parser that does not use any settings
</li><li><code>Initialize[Parser[I]]</code>: a parser whose definition depends on one or
more settings
</li><li><code>Initialize[State =&gt; Parser[I]]</code>: a parser that is defined using
both settings and the current <a href="Build-State.html">state</a>
</li></ul><p>We already saw an example of the first case with <code>spaceDelimited</code>, which
doesn’t use any settings in its definition. As an example of the third
case, the following defines a contrived <code>Parser</code> that uses the project’s
Scala and sbt version settings as well as the state. To use these
settings, we need to wrap the Parser construction in <code>Def.setting</code> and
get the setting values with the special <code>value</code> method:
</p><pre><code class="prettyprint lang-scala">import complete.DefaultParsers._

val parser: Initialize[State =&gt; Parser[(String,String)]] =
Def.setting {
  (state: State) =&gt;
    ( token(&quot;scala&quot; &lt;~ Space) ~ token(scalaVersion.value) ) |
    ( token(&quot;sbt&quot; &lt;~ Space) ~ token(sbtVersion.value) ) |
    ( token(&quot;commands&quot; &lt;~ Space) ~
        token(state.remainingCommands.size.toString) )
}
</code></pre><p>This Parser definition will produce a value of type <code>(String,String)</code>.
The input syntax defined isn’t very flexible; it is just a
demonstration. It will produce one of the following values for a
successful parse (assuming the current Scala version is 2.10.3,
the current sbt version is 0.13.5, and there are 3 commands left to
run):
</p><p>Again, we were able to access the current Scala and sbt version for the
project because they are settings. Tasks cannot be used to define the
parser.
</p><h4 id="Constructing+the+Task">Constructing the Task<a href="#Constructing+the+Task" class="header-link"><span class="header-link-content">&nbsp;</span></a></h4><p>Next, we construct the actual task to execute from the result of the
<code>Parser</code>. For this, we define a task as usual, but we can access the
result of parsing via the special <code>parsed</code> method on <code>Parser</code>.
</p><p>The following contrived example uses the previous example’s output (of
type <code>(String,String)</code>) and the result of the <code>package</code> task to print
some information to the screen.
</p><pre><code class="prettyprint lang-scala">demo := {
    val (tpe, value) = parser.parsed
    println(&quot;Type: &quot; + tpe)
    println(&quot;Value: &quot; + value)
    println(&quot;Packaged: &quot; + packageBin.value.getAbsolutePath)
}
</code></pre><h3 id="The+InputTask+type">The InputTask type<a href="#The+InputTask+type" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>It helps to look at the <code>InputTask</code> type to understand more advanced
usage of input tasks. The core input task type is:
</p><pre><code class="prettyprint lang-scala">class InputTask[T](val parser: State =&gt; Parser[Task[T]])
</code></pre><p>Normally, an input task is assigned to a setting and you work with
<code>Initialize[InputTask[T]]</code>.
</p><p>Breaking this down,
</p><ol><li>You can use other settings (via Initialize) to construct an input
task.
</li><li>You can use the current State to construct the parser.
</li><li>The parser accepts user input and provides tab completion.
</li><li>The parser produces the task to run.
</li></ol><p>So, you can use settings or <code>State</code> to construct the parser that defines
an input task’s command line syntax. This was described in the previous
section. You can then use settings, <code>State</code>, or user input to construct
the task to run. This is implicit in the input task syntax.
</p><h3 id="Using+other+input+tasks">Using other input tasks<a href="#Using+other+input+tasks" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The types involved in an input task are composable, so it is possible to
reuse input tasks. The <code>.parsed</code> and <code>.evaluated</code> methods are defined on
InputTasks to make this more convenient in common situations:
</p><ul><li>Call <code>.parsed</code> on an <code>InputTask[T]</code> or <code>Initialize[InputTask[T]]</code>
to get the <code>Task[T]</code> created after parsing the command line
</li><li>Call <code>.evaluated</code> on an <code>InputTask[T]</code> or
<code>Initialize[InputTask[T]]</code> to get the value of type <code>T</code> from
evaluating that task
</li></ul><p>In both situations, the underlying <code>Parser</code> is sequenced with other
parsers in the input task definition. In the case of <code>.evaluated</code>, the
generated task is evaluated.
</p><p>The following example applies the <code>run</code> input task, a literal separator
parser <code>--</code>, and <code>run</code> again. The parsers are sequenced in order of
syntactic appearance, so that the arguments before <code>--</code> are passed to
the first <code>run</code> and the ones after are passed to the second.
</p><pre><code class="prettyprint lang-scala">val run2 = inputKey[Unit](
    &quot;Runs the main class twice with different argument lists separated by --&quot;)

val separator: Parser[String] = &quot;--&quot;

run2 := {
   val one = (run in Compile).evaluated
   val sep = separator.parsed
   val two = (run in Compile).evaluated
}
</code></pre><p>For a main class Demo that echoes its arguments, this looks like:
</p><pre><code class="">$ sbt
&gt; run2 a b -- c d
[info] Running Demo c d
[info] Running Demo a b
c
d
a
b
</code></pre><h3 id="Preapplying+input">Preapplying input<a href="#Preapplying+input" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>Because <code>InputTasks</code> are built from <code>Parsers</code>, it is possible to
generate a new <code>InputTask</code> by applying some input programmatically. (It
is also possible to generate a <code>Task</code>, which is covered in the next
section.) Two convenience methods are provided on <code>InputTask[T]</code> and
<code>Initialize[InputTask[T]]</code> that accept the String to apply.
</p><ul><li><code>partialInput</code> applies the input and allows further input, such as
from the command line
</li><li><code>fullInput</code> applies the input and terminates parsing, so that
further input is not accepted
</li></ul><p>In each case, the input is applied to the input task’s parser. Because
input tasks handle all input after the task name, they usually require
initial whitespace to be provided in the input.
</p><p>Consider the example in the previous section. We can modify it so that
we:
</p><ul><li>Explicitly specify all of the arguments to the first <code>run</code>. We use
<code>name</code> and <code>version</code> to show that settings can be used to define
and modify parsers.
</li><li>Define the initial arguments passed to the second <code>run</code>, but allow
further input on the command line.
</li></ul><blockquote><p><strong>Note</strong>: the current implementation of <code>:=</code> doesn’t actually support
applying input derived from settings yet.
</p></blockquote><pre><code class="prettyprint lang-scala">lazy val run2 = inputKey[Unit](&quot;Runs the main class twice: &quot; +
   &quot;once with the project name and version as arguments&quot;
   &quot;and once with command line arguments preceded by hard coded values.&quot;)

// The argument string for the first run task is ' &lt;name&gt; &lt;version&gt;'
lazy val firstInput: Initialize[String] =
   Def.setting(s&quot; ${name.value} ${version.value}&quot;)

// Make the first arguments to the second run task ' red blue'
lazy val secondInput: String = &quot; red blue&quot;

run2 := {
   val one = (run in Compile).fullInput(firstInput.value).evaluated
   val two = (run in Compile).partialInput(secondInput).evaluated
}
</code></pre><p>For a main class Demo that echoes its arguments, this looks like:
</p><pre><code class="">$ sbt
&gt; run2 green
[info] Running Demo demo 1.0
[info] Running Demo red blue green
demo
1.0
red
blue
green
</code></pre><h3 id="Get+a+Task+from+an+InputTask">Get a Task from an InputTask<a href="#Get+a+Task+from+an+InputTask" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><p>The previous section showed how to derive a new <code>InputTask</code> by applying
input. In this section, applying input produces a <code>Task</code>. The <code>toTask</code>
method on <code>Initialize[InputTask[T]]</code> accepts the <code>String</code> input to apply
and produces a task that can be used normally. For example, the
following defines a plain task <code>runFixed</code> that can be used by other
tasks or run directly without providing any input, :
</p><pre><code class="prettyprint lang-scala">lazy val runFixed = taskKey[Unit](&quot;A task that hard codes the values to `run`&quot;)

runFixed := {
   val _ = (run in Compile).toTask(&quot; blue green&quot;).value
   println(&quot;Done!&quot;)
}
</code></pre><p>For a main class Demo that echoes its arguments, running <code>runFixed</code>
looks like:
</p><pre><code class="">$ sbt
&gt; runFixed
[info] Running Demo blue green
blue
green
Done!
</code></pre><p>Each call to <code>toTask</code> generates a new task, but each task is configured
the same as the original <code>InputTask</code> (in this case, <code>run</code>) but with
different input applied. For example, :
</p><pre><code class="prettyprint lang-scala">lazy val runFixed2 = taskKey[Unit](&quot;A task that hard codes the values to `run`&quot;)

fork in run := true

runFixed2 := {
   val x = (run in Compile).toTask(&quot; blue green&quot;).value
   val y = (run in Compile).toTask(&quot; red orange&quot;).value
   println(&quot;Done!&quot;)
}
</code></pre><p>The different <code>toTask</code> calls define different tasks that each run the
project’s main class in a new jvm. That is, the <code>fork</code> setting
configures both, each has the same classpath, and each run the same main
class. However, each task passes different arguments to the main class.
For a main class Demo that echoes its arguments, the output of running
<code>runFixed2</code> might look like:
</p><pre><code class="">$ sbt
&gt; runFixed2
[info] Running Demo blue green
[info] Running Demo red orange
blue
green
red
orange
Done!
</code></pre><div class="bottom nav span-16">
                        <em>Next Page</em>
                        <span class="arrow">&gt;</span>
                        <a href="Commands.html"> Commands </a>                        
                        
                      </div><div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="index.html">sbt Reference Manual</a></div><ol class="toc"> <li><div><a href="General-Info.html">General Information</a></div><ol class="toc"> <li><div><a href="Credits.html">Credits</a></div></li><li><div><a href="Community-Plugins.html">Community Plugins</a></div></li><li><div><a href="Repository-Roles.html">Community Repository Policy</a></div></li><li><div><a href="Bintray-For-Plugins.html">Bintray For Plugins</a></div></li><li><div><a href="Setup-Notes.html">Setup Notes</a></div></li><li><div><a href="Using-Sonatype.html">Deploying to Sonatype</a></div></li><li><div><a href="Changes.html">Changes</a></div><ol class="toc"> <li><div><a href="ChangeSummary_0.13.0.html">sbt 0.13.0 Changes</a></div></li><li><div><a href="ChangeSummary_0.12.0.html">sbt 0.12.0 Changes</a></div></li><li><div><a href="Older-Changes.html">Older Changes</a></div></li><li><div><a href="Migrating-from-sbt-07x.html">Migrating from 0.7 to 0.10+</a></div></li> </ol></li><li><div><a href="Contibuting-to-sbt.html">Contributing to sbt</a></div></li> </ol></li><li><div><a href="Faq.html">Frequently Asked Questions</a></div><ol class="toc">  </ol></li><li><div><a href="Howto.html">How to…</a></div><ol class="toc"> <li><div><a href="Howto-Classpaths.html">Classpaths</a></div></li><li><div><a href="Howto-Customizing-Paths.html">Customizing paths</a></div></li><li><div><a href="Howto-Generating-Files.html">Generating files</a></div></li><li><div><a href="Howto-Inspect-the-Build.html">Inspect the build</a></div></li><li><div><a href="Howto-Interactive-Mode.html">Interactive mode</a></div></li><li><div><a href="Howto-Logging.html">Configure and use logging</a></div></li><li><div><a href="Howto-Project-Metadata.html">Project metadata</a></div></li><li><div><a href="Howto-Package.html">Configure packaging</a></div></li><li><div><a href="Howto-Running-Commands.html">Running commands</a></div></li><li><div><a href="Howto-Scala.html">Configure and use Scala</a></div></li><li><div><a href="Howto-Scaladoc.html">Generate API documentation</a></div></li><li><div><a href="Howto-Triggered.html">Triggered execution</a></div></li><li><div><a href="Examples.html">Examples</a></div><ol class="toc"> <li><div><a href="Basic-Def-Examples.html">.sbt build examples</a></div></li><li><div><a href="Full-Def-Example.html">.scala build example</a></div></li><li><div><a href="Advanced-Configurations-Example.html">Advanced configurations example</a></div></li><li><div><a href="Advanced-Command-Example.html">Advanced command example</a></div></li> </ol></li> </ol></li><li><div><a href="Detailed-Topics.html">Detailed Topics</a></div><ol class="toc"> <li><div><a href="Using-sbt.html">Using sbt</a></div><ol class="toc"> <li><div><a href="Command-Line-Reference.html">Command Line Reference</a></div></li><li><div><a href="Console-Project.html">Console Project</a></div></li><li><div><a href="Cross-Build.html">Cross-building</a></div></li><li><div><a href="Inspecting-Settings.html">Interacting with the Configuration System</a></div></li><li><div><a href="Triggered-Execution.html">Triggered Execution</a></div></li><li><div><a href="Scripts.html">Scripts, REPL, and Dependencies</a></div></li><li><div><a href="Understanding-Recompilation.html">Understanding Incremental Recompilation</a></div></li> </ol></li><li><div><a href="Configuration-Index.html">Configuration</a></div><ol class="toc"> <li><div><a href="Classpaths.html">Classpaths, sources, and resources</a></div></li><li><div><a href="Compiler-Plugins.html">Compiler Plugin Support</a></div></li><li><div><a href="Configuring-Scala.html">Configuring Scala</a></div></li><li><div><a href="Forking.html">Forking</a></div></li><li><div><a href="Global-Settings.html">Global Settings</a></div></li><li><div><a href="Java-Sources.html">Java Sources</a></div></li><li><div><a href="Mapping-Files.html">Mapping Files</a></div></li><li><div><a href="Local-Scala.html">Local Scala</a></div></li><li><div><a href="Macro-Projects.html">Macro Projects</a></div></li><li><div><a href="Paths.html">Paths</a></div></li><li><div><a href="Parallel-Execution.html">Parallel Execution</a></div></li><li><div><a href="Process.html">External Processes</a></div></li><li><div><a href="Running-Project-Code.html">Running Project Code</a></div></li><li><div><a href="Testing.html">Testing</a></div></li> </ol></li><li><div><a href="Dependency-Management-Index.html">Dependency Management</a></div><ol class="toc"> <li><div><a href="Artifacts.html">Artifacts</a></div></li><li><div><a href="Dependency-Management-Flow.html">Dependency Management Flow</a></div></li><li><div><a href="Library-Management.html">Library Management</a></div></li><li><div><a href="Proxy-Repositories.html">Proxy Repositories</a></div></li><li><div><a href="Publishing.html">Publishing</a></div></li><li><div><a href="Resolvers.html">Resolvers</a></div></li><li><div><a href="Update-Report.html">Update Report</a></div></li> </ol></li><li><div><a href="Tasks-and-Commands.html">Tasks and Commands</a></div><ol class="toc"> <li><div><a href="Tasks.html">Tasks</a></div></li><li><div class="current">Input Tasks</div></li><li><div><a href="Commands.html">Commands</a></div></li><li><div><a href="Parsing-Input.html">Parsing and tab completion</a></div></li><li><div><a href="Build-State.html">State and actions</a></div></li><li><div><a href="Task-Inputs.html">Tasks/Settings: Motivation</a></div></li> </ol></li><li><div><a href="Plugins-and-Best-Practices.html">Plugins and Best Practices</a></div><ol class="toc"> <li><div><a href="Best-Practices.html">General Best Practices</a></div></li><li><div><a href="Plugins.html">Plugins</a></div></li><li><div><a href="Plugins-Best-Practices.html">Plugins Best Practices</a></div></li> </ol></li><li><div><a href="Sbt-Launcher.html">Sbt Launcher</a></div><ol class="toc"> <li><div><a href="Launcher-Getting-Started.html">Getting Started with the Sbt Launcher</a></div></li><li><div><a href="Launcher-Architecture.html">Sbt Launcher Architecture</a></div></li><li><div><a href="Launcher-Configuration.html">Sbt Launcher Configuration</a></div></li> </ol></li> </ol></li><li><div><a href="Developers-Guide.html">Developer’s Guide</a></div><ol class="toc"> <li><div><a href="Core-Principles.html">Core Principles</a></div></li><li><div><a href="Settings-Core.html">Settings Core</a></div></li><li><div><a href="Setting-Initialization.html">Setting Initialization</a></div></li><li><div><a href="Build-Loaders.html">Build Loaders</a></div></li><li><div><a href="Command-Line-Applications.html">Creating Command Line Applications Using sbt</a></div></li><li><div><a href="Nightly-Builds.html">Nightly Builds</a></div></li> </ol></li><li><div><a href="Name-Index.html">Index</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol></div></div>
          </div>
        </div>
        <div class="header">
          <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,900,400italic,700italic" rel="stylesheet" type="text/css">
<div class="container navbar-static-top nav">
    <div class="logo">
      <a href="../../index.html"><img src="files/sbt-logo-white-72x50.png" alt="sbt"></a>
    </div>
    <ul class="navlist">
      <li><a href="../../documentation.html">Documentation</a></li>
      <li><a href="../../download.html">Download</a></li>
      <li><a href="../../community.html">Community</a></li>
      <li id="source-code"><a href="https://github.com/sbt/sbt"><img src="files/github-logo.png" alt="Source code"></a></li>
      <li id="twitter"><a href="https://twitter.com/scala_sbt"><img src="files/twitter-logo-white.png" alt="sbt on Twitter"></a></li>
    </ul>
</div>

        </div>
        <div class="footer">
          
        </div>
        
        
      </body>
    </html>