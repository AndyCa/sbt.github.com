<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/EvaluateConfigurations.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2011 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> java.io.File
<span class="keyword">import</span> java.net.URI
<span class="keyword">import</span> compiler.<span class="delimiter">{</span> Eval, EvalImports <span class="delimiter">}</span>
<span class="keyword">import</span> complete.<a href="complete/Parsers.scala.html#sbt.complete.DefaultParsers" title="sbt.complete.DefaultParsers.type">DefaultParsers</a>.validID
<span class="keyword">import</span> <a href="Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<span class="delimiter">{</span> ScopedKey, Setting, SettingsDefinition <span class="delimiter">}</span>
<span class="keyword">import</span> <a href="Scope.scala.html#sbt.Scope" title="sbt.Scope.type">Scope</a>.GlobalScope
<span class="keyword">import</span> scala.annotation.tailrec

<span class="comment">/**
 *  This file is responsible for compiling the .sbt files used to configure sbt builds.
 *
 *  Compilation is done in three phases:
 *
 *  1. Parsing high-level constructs (definitions, settings, imports)
 *  2. Compiling scala code into local .class files
 *  3. Evaluating the expressions and obtaining in-memory objects of the results (Setting[_] instances, or val references).
 *
 *
 */</span>
<span class="keyword">object</span> <a title="sbt.EvaluateConfigurations.type" id="sbt.EvaluateConfigurations">EvaluateConfigurations</a> <a href="#sbt.EvaluateConfigurations" title="sbt.EvaluateConfigurations.type" class="delimiter">{</a>

  <span class="keyword">type</span> <a title="[T]ClassLoader =&gt; T" id="sbt.EvaluateConfigurations;LazyClassLoaded">LazyClassLoaded</a><span class="delimiter">[</span><a title="" id="sbt.EvaluateConfigurations;LazyClassLoaded;T">T</a><span class="delimiter">]</span> = ClassLoader =&gt; T

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">case class</span> <a href="#sbt.EvaluateConfigurations;TrackedEvalResult.productElement.x$1" title="class TrackedEvalResult[T] extends AnyRef with Product with Serializable" id="sbt.EvaluateConfigurations.TrackedEvalResult.readResolve">TrackedEvalResult</a><span class="delimiter">[</span><a title="" id="sbt.EvaluateConfigurations;TrackedEvalResult;T">T</a><span class="delimiter">]</span><a href="#sbt.EvaluateConfigurations.TrackedEvalResult.readResolve" title="Product" class="delimiter">(</a><a title="Seq[java.io.File]" id="sbt.EvaluateConfigurations;TrackedEvalResult.generated">generated</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="ClassLoader =&gt; T" id="sbt.EvaluateConfigurations;TrackedEvalResult.result">result</a>: <span title="ClassLoader =&gt; T">LazyClassLoaded</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/**
   * This represents the parsed expressions in a build sbt, as well as where they were defined.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ParsedFile extends AnyRef" id="sbt.EvaluateConfigurations;ParsedFile">ParsedFile</a><a href="#sbt.EvaluateConfigurations;ParsedFile" title="sbt.EvaluateConfigurations.ParsedFile" class="delimiter">(</a><span class="keyword">val</span> <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations;ParsedFile.imports">imports</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations;ParsedFile.definitions">definitions</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations;ParsedFile.settings">settings</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** The keywords we look for when classifying a string as a definition. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="Seq[String]" id="sbt.EvaluateConfigurations.DefinitionKeywords">DefinitionKeywords</a> = <span title="(elems: String*)Seq[String]">Seq</span><span class="delimiter">(</span><span title="String(&quot;lazy val &quot;)" class="string">&quot;lazy val &quot;</span>, <span title="String(&quot;def &quot;)" class="string">&quot;def &quot;</span>, <span title="String(&quot;val &quot;)" class="string">&quot;val &quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Using an evaluating instance of the scala compiler, a sequence of files and
   *  the default imports to use, this method will take a ClassLoader of sbt-classes and
   *  return a parsed, compiled + evaluated [[LoadedSbtFile]].   The result has
   *  raw sbt-types that can be accessed and used.
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;We no longer merge build.sbt files together unless they are in the same directory.&quot;</span>, <span class="string">&quot;0.13.6&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, srcs: Seq[java.io.File], imports: Seq[String])ClassLoader =&gt; sbt.LoadedSbtFile" id="sbt.EvaluateConfigurations.apply">apply</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.apply.eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="Seq[java.io.File]" id="sbt.EvaluateConfigurations.apply.srcs">srcs</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.apply.imports">imports</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ClassLoader =&gt; sbt.LoadedSbtFile">LazyClassLoaded</span><span class="delimiter">[</span>LoadedSbtFile<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Seq[ClassLoader =&gt; sbt.LoadedSbtFile]" id="sbt.EvaluateConfigurations.apply.loadFiles">loadFiles</a> = <a href="#sbt.EvaluateConfigurations.apply.srcs" title="Seq[java.io.File]">srcs</a>.<span title="(f: java.io.File =&gt; String)(implicit ord: scala.math.Ordering[String])Seq[java.io.File]">sortBy</span><span title="scala.math.Ordering.String.type" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.apply.loadFiles.$anonfun.x$1" title="java.io.File">_</a>.<span title="()String">getName</span><span class="delimiter">)</span> <span title="(f: java.io.File =&gt; (ClassLoader =&gt; sbt.LoadedSbtFile))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.io.File],ClassLoader =&gt; sbt.LoadedSbtFile,Seq[ClassLoader =&gt; sbt.LoadedSbtFile]])Seq[ClassLoader =&gt; sbt.LoadedSbtFile]">map</span> <span class="delimiter">{</span> <a title="java.io.File" id="sbt.EvaluateConfigurations.apply.loadFiles.$anonfun.src">src</a> =&gt; <a href="#sbt.EvaluateConfigurations.evaluateSbtFile" title="(eval: sbt.compiler.Eval, file: java.io.File, lines: Seq[String], imports: Seq[String], offset: Int)ClassLoader =&gt; sbt.LoadedSbtFile">evaluateSbtFile</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.apply.eval" title="sbt.compiler.Eval">eval</a>, <a href="#sbt.EvaluateConfigurations.apply.loadFiles.$anonfun.src" title="java.io.File">src</a>, <a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.readLines(50ee8d6d9c)" title="(file: java.io.File, charset: java.nio.charset.Charset)List[String]">readLines</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.apply.loadFiles.$anonfun.src" title="java.io.File">src</a><span class="delimiter">)</span>, <a href="#sbt.EvaluateConfigurations.apply.imports" title="Seq[String]">imports</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a title="ClassLoader" id="sbt.EvaluateConfigurations.apply.$anonfun.loader">loader</a> =&gt; <span class="delimiter">(</span><a href="LoadedSbtFile.scala.html#sbt.LoadedSbtFile" title="sbt.LoadedSbtFile.type">LoadedSbtFile</a>.<a href="LoadedSbtFile.scala.html#sbt.LoadedSbtFile.empty" title="=&gt; sbt.LoadedSbtFile">empty</a> <a href="#sbt.EvaluateConfigurations.apply.$anonfun.x$2" title="(z: sbt.LoadedSbtFile)(op: (sbt.LoadedSbtFile, ClassLoader =&gt; sbt.LoadedSbtFile) =&gt; sbt.LoadedSbtFile)sbt.LoadedSbtFile">/:</a> <a href="#sbt.EvaluateConfigurations.apply.loadFiles" title="Seq[ClassLoader =&gt; sbt.LoadedSbtFile]">loadFiles</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="sbt.LoadedSbtFile" id="sbt.EvaluateConfigurations.apply.$anonfun.$anonfun.loaded">loaded</a>, <a title="ClassLoader =&gt; sbt.LoadedSbtFile" id="sbt.EvaluateConfigurations.apply.$anonfun.$anonfun.load">load</a><span class="delimiter">)</span> =&gt; <a href="#sbt.EvaluateConfigurations.apply.$anonfun.$anonfun.loaded" title="sbt.LoadedSbtFile">loaded</a> <a href="LoadedSbtFile.scala.html#sbt;LoadedSbtFile.merge" title="(o: sbt.LoadedSbtFile)sbt.LoadedSbtFile">merge</a> <a href="#sbt.EvaluateConfigurations.apply.$anonfun.$anonfun.load" title="(v1: ClassLoader)sbt.LoadedSbtFile">load</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.apply.$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Reads a given .sbt file and evaluates it into a sequence of setting values.
   *
   * Note: This ignores any non-Setting[_] values in the file.
   */</span>
  <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, src: java.io.File, imports: Seq[String])ClassLoader =&gt; Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9)">evaluateConfiguration</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="java.io.File" id="sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).src">src</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).imports">imports</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ClassLoader =&gt; Seq[sbt.Def.Setting[_]]">LazyClassLoaded</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8)" title="(eval: sbt.compiler.Eval, file: java.io.File, lines: Seq[String], imports: Seq[String], offset: Int)ClassLoader =&gt; Seq[sbt.Def.Setting[_]]">evaluateConfiguration</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).eval" title="sbt.compiler.Eval">eval</a>, <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).src" title="java.io.File">src</a>, <a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.readLines(50ee8d6d9c)" title="(file: java.io.File, charset: java.nio.charset.Charset)List[String]">readLines</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).src" title="java.io.File">src</a><span class="delimiter">)</span>, <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(10234a56a9).imports" title="Seq[String]">imports</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Parses a sequence of build.sbt lines into a [[ParsedFile]].  The result contains
   * a fragmentation of all imports, settings and definitions.
   *
   * @param buildinImports  The set of import statements to add to those parsed in the .sbt file.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(lines: Seq[String], builtinImports: Seq[String], offset: Int)sbt.EvaluateConfigurations.ParsedFile" id="sbt.EvaluateConfigurations.parseConfiguration">parseConfiguration</a><span class="delimiter">(</span><a title="Seq[String]" id="sbt.EvaluateConfigurations.parseConfiguration.lines">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.parseConfiguration.builtinImports">builtinImports</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Int" id="sbt.EvaluateConfigurations.parseConfiguration.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.EvaluateConfigurations;ParsedFile" title="sbt.EvaluateConfigurations.ParsedFile">ParsedFile</a> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#sbt.EvaluateConfigurations.parseConfiguration.importStatements" title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)])" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.parseConfiguration.x$3" title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.parseConfiguration.importStatements">importStatements</a>, <a href="#sbt.EvaluateConfigurations.parseConfiguration.x$3" title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.parseConfiguration.settingsAndDefinitions">settingsAndDefinitions</a><span class="delimiter">)</span> = <a href="#sbt.EvaluateConfigurations.splitExpressions" title="(lines: Seq[String])(Seq[(String, Int)], Seq[(String, sbt.LineRange)])">splitExpressions</a><span title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)]) @unchecked" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.parseConfiguration.lines" title="Seq[String]">lines</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.parseConfiguration.allImports">allImports</a> = <a href="#sbt.EvaluateConfigurations.parseConfiguration.builtinImports" title="Seq[String]">builtinImports</a>.<span title="(f: String =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(String, Int),Seq[(String, Int)]]" class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.parseConfiguration.allImports.$anonfun.s">s</a> =&gt; <span title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.parseConfiguration.allImports.$anonfun.s" title="String">s</a>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[(String, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">++</span> <a href="#sbt.EvaluateConfigurations.addOffset" title="(offset: Int, lines: Seq[(String, Int)])Seq[(String, Int)]">addOffset</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.parseConfiguration.offset" title="Int">offset</a>, <a href="#sbt.EvaluateConfigurations.parseConfiguration.importStatements" title="Seq[(String, Int)]">importStatements</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a href="#sbt.EvaluateConfigurations.parseConfiguration.definitions" title="(Seq[(String, sbt.LineRange)], Seq[(String, sbt.LineRange)])" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.parseConfiguration.x$4" title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.parseConfiguration.definitions">definitions</a>, <a href="#sbt.EvaluateConfigurations.parseConfiguration.x$4" title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.parseConfiguration.settings">settings</a><span class="delimiter">)</span> = <a href="#sbt.EvaluateConfigurations.splitSettingsDefinitions" title="(lines: Seq[(String, sbt.LineRange)])(Seq[(String, sbt.LineRange)], Seq[(String, sbt.LineRange)])">splitSettingsDefinitions</a><span title="(Seq[(String, sbt.LineRange)], Seq[(String, sbt.LineRange)]) @unchecked" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.addOffsetToRange" title="(offset: Int, ranges: Seq[(String, sbt.LineRange)])Seq[(String, sbt.LineRange)]">addOffsetToRange</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.parseConfiguration.offset" title="Int">offset</a>, <a href="#sbt.EvaluateConfigurations.parseConfiguration.settingsAndDefinitions" title="Seq[(String, sbt.LineRange)]">settingsAndDefinitions</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="sbt.EvaluateConfigurations.ParsedFile" class="keyword">new</span> <a href="#sbt.EvaluateConfigurations;ParsedFile" title="sbt.EvaluateConfigurations.ParsedFile">ParsedFile</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.parseConfiguration.allImports" title="Seq[(String, Int)]">allImports</a>, <a href="#sbt.EvaluateConfigurations.parseConfiguration.definitions" title="Seq[(String, sbt.LineRange)]">definitions</a>, <a href="#sbt.EvaluateConfigurations.parseConfiguration.settings" title="Seq[(String, sbt.LineRange)]">settings</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Evaluates a  parsed sbt configuration file.
   *
   * @param eval    The evaluating scala compiler instance we use to handle evaluating scala configuration.
   * @param file    The file we've parsed
   * @param imports The default imports to use in this .sbt configuration
   * @param lines   The lines of the configurtion we'd like to evaluate.
   *
   * @return Just the Setting[_] instances defined in the .sbt file.
   */</span>
  <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, file: java.io.File, lines: Seq[String], imports: Seq[String], offset: Int)ClassLoader =&gt; Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8)">evaluateConfiguration</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="java.io.File" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).file">file</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).lines">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).imports">imports</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Int" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="ClassLoader =&gt; Seq[sbt.Def.Setting[_]]">LazyClassLoaded</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ClassLoader =&gt; sbt.LoadedSbtFile" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).l">l</a> = <a href="#sbt.EvaluateConfigurations.evaluateSbtFile" title="(eval: sbt.compiler.Eval, file: java.io.File, lines: Seq[String], imports: Seq[String], offset: Int)ClassLoader =&gt; sbt.LoadedSbtFile">evaluateSbtFile</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).eval" title="sbt.compiler.Eval">eval</a>, <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).file" title="java.io.File">file</a>, <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).lines" title="Seq[String]">lines</a>, <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).imports" title="Seq[String]">imports</a>, <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).offset" title="Int">offset</a><span class="delimiter">)</span>
      <a title="ClassLoader" id="sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).$anonfun.loader">loader</a> =&gt; <a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).l" title="(v1: ClassLoader)sbt.LoadedSbtFile">l</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateConfiguration(bed97c9cb8).$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>.<a href="LoadedSbtFile.scala.html#sbt;LoadedSbtFile.settings" title="=&gt; Seq[sbt.Def.Setting[_]]">settings</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Evaluates a parsed sbt configuration file.
   *
   * @param eval    The evaluating scala compiler instance we use to handle evaluating scala configuration.
   * @param file    The file we've parsed
   * @param lines   The lines of the configurtion we'd like to evaluate.
   * @param imports The default imports to use in this .sbt configuration.
   *
   * @return A function which can take an sbt classloader and return the raw types/configuratoin
   *         which was compiled/parsed for the given file.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, file: java.io.File, lines: Seq[String], imports: Seq[String], offset: Int)ClassLoader =&gt; sbt.LoadedSbtFile" id="sbt.EvaluateConfigurations.evaluateSbtFile">evaluateSbtFile</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.evaluateSbtFile.eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="java.io.File" id="sbt.EvaluateConfigurations.evaluateSbtFile.file">file</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateSbtFile.lines">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateSbtFile.imports">imports</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Int" id="sbt.EvaluateConfigurations.evaluateSbtFile.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="ClassLoader =&gt; sbt.LoadedSbtFile">LazyClassLoaded</span><span class="delimiter">[</span>LoadedSbtFile<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="comment">// TODO - Store the file on the LoadedSbtFile (or the parent dir) so we can accurately do</span>
      <span class="comment">//        detection for which project project manipulations should be applied.</span>
      <span class="keyword">val</span> <a title="String" id="sbt.EvaluateConfigurations.evaluateSbtFile.name">name</a> = <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.file" title="java.io.File">file</a>.<span title="()String">getPath</span>
      <span class="keyword">val</span> <a title="sbt.EvaluateConfigurations.ParsedFile" id="sbt.EvaluateConfigurations.evaluateSbtFile.parsed">parsed</a> = <a href="#sbt.EvaluateConfigurations.parseConfiguration" title="(lines: Seq[String], builtinImports: Seq[String], offset: Int)sbt.EvaluateConfigurations.ParsedFile">parseConfiguration</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.lines" title="Seq[String]">lines</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.imports" title="Seq[String]">imports</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.offset" title="Int">offset</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.importDefs" title="(Seq[String], sbt.DefinedSbtValues)" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.x$6" title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateSbtFile.importDefs">importDefs</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.x$6" title="sbt.DefinedSbtValues" id="sbt.EvaluateConfigurations.evaluateSbtFile.definitions">definitions</a><span class="delimiter">)</span> =
        <span title="(Seq[String], sbt.DefinedSbtValues)" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.parsed" title="sbt.EvaluateConfigurations.ParsedFile">parsed</a>.<a href="#sbt.EvaluateConfigurations;ParsedFile.definitions" title="=&gt; Seq[(String, sbt.LineRange)]">definitions</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: sbt.DefinedSbtValues)(scala.collection.immutable.Nil.type, sbt.DefinedSbtValues)" class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="LoadedSbtFile.scala.html#sbt.DefinedSbtValues" title="sbt.DefinedSbtValues.type">DefinedSbtValues</a>.<a href="LoadedSbtFile.scala.html#sbt.DefinedSbtValues.empty" title="=&gt; sbt.DefinedSbtValues">empty</a><span class="delimiter">)</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <span title="sbt.compiler.EvalDefinitions">definitions</span> = <a href="#sbt.EvaluateConfigurations.evaluateDefinitions" title="(eval: sbt.compiler.Eval, name: String, imports: Seq[(String, Int)], definitions: Seq[(String, sbt.LineRange)], file: Option[java.io.File])sbt.compiler.EvalDefinitions">evaluateDefinitions</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.eval" title="sbt.compiler.Eval">eval</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.name" title="String">name</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.parsed" title="sbt.EvaluateConfigurations.ParsedFile">parsed</a>.<a href="#sbt.EvaluateConfigurations;ParsedFile.imports" title="=&gt; Seq[(String, Int)]">imports</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.parsed" title="sbt.EvaluateConfigurations.ParsedFile">parsed</a>.<a href="#sbt.EvaluateConfigurations;ParsedFile.definitions" title="=&gt; Seq[(String, sbt.LineRange)]">definitions</a>, <span title="(x: java.io.File)Some[java.io.File]">Some</span><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.file" title="java.io.File">file</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Seq[String]" id="sbt.EvaluateConfigurations.evaluateSbtFile.x$6.imp">imp</a> = <a href="BuildUtil.scala.html#sbt.BuildUtil" title="sbt.BuildUtil.type">BuildUtil</a>.<a href="BuildUtil.scala.html#sbt.BuildUtil.importAllRoot" title="(values: Seq[String])Seq[String]">importAllRoot</a><span class="delimiter">(</span><span title="sbt.compiler.EvalDefinitions">definitions</span>.<a href="compiler/Eval.scala.html#sbt.compiler;EvalDefinitions.enclosingModule" title="=&gt; String">enclosingModule</a> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.x$6.imp.x$5" title="(x: String)List[String]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="ClassLoader =&gt; Seq[sbt.Project]" id="sbt.EvaluateConfigurations.evaluateSbtFile.x$6.projs">projs</a> = <span class="delimiter">(</span>loader: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span> =&gt; <span title="sbt.compiler.EvalDefinitions">definitions</span>.<a href="compiler/Eval.scala.html#sbt.compiler;EvalDefinitions.values" title="(parent: ClassLoader)Seq[Any]">values</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.x$6.projs.$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>.<span title="(f: Any =&gt; sbt.Project)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Any],sbt.Project,Seq[sbt.Project]])Seq[sbt.Project]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.Project,Seq[sbt.Project]]" class="delimiter">(</span><a title="Any" id="sbt.EvaluateConfigurations.evaluateSbtFile.x$6.projs.$anonfun.$anonfun.p">p</a> =&gt; <a href="#sbt.EvaluateConfigurations.resolveBase" title="(f: java.io.File, p: sbt.Project)sbt.Project">resolveBase</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.file" title="java.io.File">file</a>.<span title="()java.io.File">getParentFile</span>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.x$6.projs.$anonfun.$anonfun.p" title="Any">p</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="sbt.Project" class="delimiter">[</span><a href="Project.scala.html#sbt;Project" title="sbt.Project">Project</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="(_1: Seq[String], _2: sbt.DefinedSbtValues)(Seq[String], sbt.DefinedSbtValues)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.x$6.imp" title="Seq[String]">imp</a>, <a href="LoadedSbtFile.scala.html#sbt.DefinedSbtValues.apply" title="(eval: sbt.compiler.EvalDefinitions)sbt.DefinedSbtValues">DefinedSbtValues</a><span class="delimiter">(</span><span title="sbt.compiler.EvalDefinitions">definitions</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.evaluateSbtFile.allImports">allImports</a> = <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.importDefs" title="Seq[String]">importDefs</a>.<span title="(f: String =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(String, Int),Seq[(String, Int)]]" class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.evaluateSbtFile.allImports.$anonfun.s">s</a> =&gt; <span title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.allImports.$anonfun.s" title="String">s</a>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[(String, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">++</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.parsed" title="sbt.EvaluateConfigurations.ParsedFile">parsed</a>.<a href="#sbt.EvaluateConfigurations;ParsedFile.imports" title="=&gt; Seq[(String, Int)]">imports</a>
      <span class="keyword">val</span> <a title="Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]]" id="sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries">dslEntries</a> = <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.parsed" title="sbt.EvaluateConfigurations.ParsedFile">parsed</a>.<a href="#sbt.EvaluateConfigurations;ParsedFile.settings" title="=&gt; Seq[(String, sbt.LineRange)]">settings</a> <span title="(f: ((String, sbt.LineRange)) =&gt; sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, sbt.LineRange)],sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry],Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]]])Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]]">map</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries.$anonfun.x0$1" title="sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries.$anonfun.dslExpression">dslExpression</a>, <a title="sbt.LineRange" id="sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries.$anonfun.range">range</a><span class="delimiter">)</span> =&gt;
          <a href="#sbt.EvaluateConfigurations.evaluateDslEntry" title="(eval: sbt.compiler.Eval, name: String, imports: Seq[(String, Int)], expression: String, range: sbt.LineRange)sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]">evaluateDslEntry</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.eval" title="sbt.compiler.Eval">eval</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.name" title="String">name</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.allImports" title="Seq[(String, Int)]">allImports</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries.$anonfun.dslExpression" title="String">dslExpression</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries.$anonfun.range" title="sbt.LineRange">range</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.eval" title="sbt.compiler.Eval">eval</a>.<a href="compiler/Eval.scala.html#sbt.compiler;Eval.unlinkDeferred" title="()Unit">unlinkDeferred</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="comment">// Tracks all the files we generated from evaluating the sbt file.</span>
      <span class="keyword">val</span> <a title="Seq[java.io.File]" id="sbt.EvaluateConfigurations.evaluateSbtFile.allGeneratedFiles">allGeneratedFiles</a> = <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.definitions" title="sbt.DefinedSbtValues">definitions</a>.<a href="LoadedSbtFile.scala.html#sbt;DefinedSbtValues.generated" title="=&gt; Seq[java.io.File]">generated</a> <span title="(that: scala.collection.GenTraversableOnce[java.io.File])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.io.File],java.io.File,Seq[java.io.File]])Seq[java.io.File]">++</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries" title="Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]]">dslEntries</a>.<span title="(f: sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry] =&gt; scala.collection.GenTraversableOnce[java.io.File])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]],java.io.File,Seq[java.io.File]])Seq[java.io.File]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,java.io.File,Seq[java.io.File]]" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.allGeneratedFiles.$anonfun.x$7" title="sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]">_</a>.<a href="#sbt.EvaluateConfigurations;TrackedEvalResult.generated" title="=&gt; Seq[java.io.File]">generated</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a title="ClassLoader" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.loader">loader</a> =&gt; <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Seq[sbt.Project]" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.projects">projects</a> =
          <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.definitions" title="sbt.DefinedSbtValues">definitions</a>.<a href="LoadedSbtFile.scala.html#sbt;DefinedSbtValues.values" title="(parent: ClassLoader)Seq[Any]">values</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>.<span title="(pf: PartialFunction[Any,sbt.Project])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Any],sbt.Project,Seq[sbt.Project]])Seq[sbt.Project]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Any,sbt.Project] with Serializable" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.projects;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
            <span class="keyword">case</span> <a title="sbt.Project" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.projects;$anonfun.isDefinedAt.p">p</a>: <a href="Project.scala.html#sbt;Project" title="sbt.Project">Project</a> =&gt; <a href="#sbt.EvaluateConfigurations.resolveBase" title="(f: java.io.File, p: sbt.Project)sbt.Project">resolveBase</a><span title="Boolean(true)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.file" title="java.io.File">file</a>.<span title="()java.io.File">getParentFile</span>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.projects;$anonfun.isDefinedAt.p" title="sbt.Project">p</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">val</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settingsRaw" title="(Seq[sbt.internals.DslEntry], Seq[sbt.internals.DslEntry])" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.x$9" title="Seq[sbt.internals.DslEntry]" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settingsRaw">settingsRaw</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.x$9" title="Seq[sbt.internals.DslEntry]" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulationsRaw">manipulationsRaw</a><span class="delimiter">)</span> =
          <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.dslEntries" title="Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]]">dslEntries</a> <span title="(f: sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry] =&gt; sbt.internals.DslEntry)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]],sbt.internals.DslEntry,Seq[sbt.internals.DslEntry]])Seq[sbt.internals.DslEntry]">map</span> <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.x$9.$anonfun.x$8" title="sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]">_</a>.<a href="#sbt.EvaluateConfigurations;TrackedEvalResult.result" title="=&gt; ClassLoader =&gt; sbt.internals.DslEntry">result</a> <span title="(v1: ClassLoader)sbt.internals.DslEntry">apply</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span> <span title="(p: sbt.internals.DslEntry =&gt; Boolean)(Seq[sbt.internals.DslEntry], Seq[sbt.internals.DslEntry])">partition</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.x$9.$anonfun.x0$2" title="Boolean" class="delimiter">{</a>
            <span class="keyword">case</span> internals.<a href="internals/DslAst.scala.html#sbt.internals.ProjectSettings.unapply" title="(e: sbt.internals.DslEntry)Option[Seq[sbt.Def.Setting[_]]]">ProjectSettings</a><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
            <span class="keyword">case</span> _                            =&gt; <span title="Boolean(false)" class="keyword">false</span>
          <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settings">settings</a> = <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settingsRaw" title="Seq[sbt.internals.DslEntry]">settingsRaw</a> <span title="(f: sbt.internals.DslEntry =&gt; scala.collection.GenTraversableOnce[sbt.Def.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.internals.DslEntry],sbt.Def.Setting[_],Seq[sbt.Def.Setting[_]]])Seq[sbt.Def.Setting[_]]">flatMap</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settings.$anonfun.x0$3" title="Seq[sbt.Def.Setting[_]]" class="delimiter">{</a>
          <span class="keyword">case</span> internals.<a href="internals/DslAst.scala.html#sbt.internals.ProjectSettings.unapply" title="(e: sbt.internals.DslEntry)Option[Seq[sbt.Def.Setting[_]]]">ProjectSettings</a><span class="delimiter">(</span><a title="Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settings.$anonfun.settings">settings</a><span class="delimiter">)</span> =&gt; <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settings.$anonfun.settings" title="Seq[sbt.Def.Setting[_]]">settings</a>
          <span class="keyword">case</span> _                                   =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Seq[sbt.Project =&gt; sbt.Project]" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulations">manipulations</a> = <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulationsRaw" title="Seq[sbt.internals.DslEntry]">manipulationsRaw</a> <span title="(f: sbt.internals.DslEntry =&gt; (sbt.Project =&gt; sbt.Project))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.internals.DslEntry],sbt.Project =&gt; sbt.Project,Seq[sbt.Project =&gt; sbt.Project]])Seq[sbt.Project =&gt; sbt.Project]">map</span> <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulations.$anonfun.x0$4" title="sbt.Project =&gt; sbt.Project" class="delimiter">{</a>
          <span class="keyword">case</span> internals.<a href="internals/DslAst.scala.html#sbt.internals.ProjectManipulation.unapply" title="(e: sbt.internals.DslEntry)Option[sbt.Project =&gt; sbt.Project]">ProjectManipulation</a><span class="delimiter">(</span><a title="sbt.Project =&gt; sbt.Project" id="sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulations.$anonfun.f">f</a><span class="delimiter">)</span> =&gt; <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulations.$anonfun.f" title="sbt.Project =&gt; sbt.Project">f</a>
        <span class="delimiter">}</span>
        <span class="comment">// TODO -get project manipulations.</span>
        <span title="sbt.LoadedSbtFile" class="keyword">new</span> <a href="LoadedSbtFile.scala.html#sbt;LoadedSbtFile" title="sbt.LoadedSbtFile">LoadedSbtFile</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.settings" title="Seq[sbt.Def.Setting[_]]">settings</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.projects" title="Seq[sbt.Project]">projects</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.importDefs" title="Seq[String]">importDefs</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.$anonfun.manipulations" title="Seq[sbt.Project =&gt; sbt.Project]">manipulations</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.definitions" title="sbt.DefinedSbtValues">definitions</a>, <a href="#sbt.EvaluateConfigurations.evaluateSbtFile.allGeneratedFiles" title="Seq[java.io.File]">allGeneratedFiles</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="comment">/** move a project to be relative to this file after we've evaluated it. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(f: java.io.File, p: sbt.Project)sbt.Project" id="sbt.EvaluateConfigurations.resolveBase">resolveBase</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.EvaluateConfigurations.resolveBase.f">f</a>: <span title="java.io.File">File</span>, <a title="sbt.Project" id="sbt.EvaluateConfigurations.resolveBase.p">p</a>: <a href="Project.scala.html#sbt;Project" title="sbt.Project">Project</a><span class="delimiter">)</span> = <a href="#sbt.EvaluateConfigurations.resolveBase.p" title="sbt.Project">p</a>.<a href="Project.scala.html#sbt;Project.copy$default$1" title="String" id="sbt.EvaluateConfigurations.resolveBase.x$36">copy</a><span class="delimiter">(</span>base = <a href="IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="IO.scala.html#sbt.IO.resolve" title="(base: java.io.File, f: java.io.File)java.io.File">resolve</a><a title="java.io.File" id="sbt.EvaluateConfigurations.resolveBase.x$29" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.resolveBase.f" title="java.io.File">f</a>, <a href="#sbt.EvaluateConfigurations.resolveBase.p" title="sbt.Project">p</a>.<a href="Project.scala.html#sbt;ProjectDefinition.base" title="=&gt; java.io.File">base</a><span class="delimiter">)</span><span class="delimiter">)</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Will no longer be public.&quot;</span>, <span class="string">&quot;0.13.6&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(mksettings: Seq[ClassLoader =&gt; Seq[sbt.Def.Setting[_]]])ClassLoader =&gt; Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.flatten">flatten</a><span class="delimiter">(</span><a title="Seq[ClassLoader =&gt; Seq[sbt.Def.Setting[_]]]" id="sbt.EvaluateConfigurations.flatten.mksettings">mksettings</a>: <span title="Seq[ClassLoader =&gt; Seq[sbt.Def.Setting[_]]]">Seq</span><span class="delimiter">[</span>ClassLoader =&gt; Seq<span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: ClassLoader =&gt; Seq<span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a title="ClassLoader" id="sbt.EvaluateConfigurations.flatten.$anonfun.loader">loader</a> =&gt; <a href="#sbt.EvaluateConfigurations.flatten.mksettings" title="Seq[ClassLoader =&gt; Seq[sbt.Def.Setting[_]]]">mksettings</a>.<span title="(f: (ClassLoader =&gt; Seq[sbt.Def.Setting[_]]) =&gt; scala.collection.GenTraversableOnce[sbt.Def.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[ClassLoader =&gt; Seq[sbt.Def.Setting[_]]],sbt.Def.Setting[_],Seq[sbt.Def.Setting[_]]])Seq[sbt.Def.Setting[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.Def.Setting[_],Seq[sbt.Def.Setting[_]]]" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.flatten.$anonfun.$anonfun.x$10" title="ClassLoader =&gt; Seq[sbt.Def.Setting[_]]">_</a> <span title="(v1: ClassLoader)Seq[sbt.Def.Setting[_]]">apply</span> <a href="#sbt.EvaluateConfigurations.flatten.$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(offset: Int, lines: Seq[(String, Int)])Seq[(String, Int)]" id="sbt.EvaluateConfigurations.addOffset">addOffset</a><span class="delimiter">(</span><a title="Int" id="sbt.EvaluateConfigurations.addOffset.offset">offset</a>: <span title="Int">Int</span>, <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.addOffset.lines">lines</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#sbt.EvaluateConfigurations.addOffset.lines" title="Seq[(String, Int)]">lines</a>.<span title="(f: ((String, Int)) =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">map</span> <a href="#sbt.EvaluateConfigurations.addOffset.$anonfun.x0$5" title="(String, Int)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.addOffset.$anonfun.s">s</a>, <a title="Int" id="sbt.EvaluateConfigurations.addOffset.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.addOffset.$anonfun.s" title="String">s</a>, <a href="#sbt.EvaluateConfigurations.addOffset.$anonfun.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <a href="#sbt.EvaluateConfigurations.addOffset.offset" title="Int">offset</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(offset: Int, ranges: Seq[(String, sbt.LineRange)])Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.addOffsetToRange">addOffsetToRange</a><span class="delimiter">(</span><a title="Int" id="sbt.EvaluateConfigurations.addOffsetToRange.offset">offset</a>: <span title="Int">Int</span>, <a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.addOffsetToRange.ranges">ranges</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#sbt.EvaluateConfigurations.addOffsetToRange.ranges" title="Seq[(String, sbt.LineRange)]">ranges</a>.<span title="(f: ((String, sbt.LineRange)) =&gt; (String, sbt.LineRange))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, sbt.LineRange)],(String, sbt.LineRange),Seq[(String, sbt.LineRange)]])Seq[(String, sbt.LineRange)]">map</span> <a href="#sbt.EvaluateConfigurations.addOffsetToRange.$anonfun.x0$6" title="(String, sbt.LineRange)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.addOffsetToRange.$anonfun.s">s</a>, <a title="sbt.LineRange" id="sbt.EvaluateConfigurations.addOffsetToRange.$anonfun.r">r</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: sbt.LineRange)(String, sbt.LineRange)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.addOffsetToRange.$anonfun.s" title="String">s</a>, <a href="#sbt.EvaluateConfigurations.addOffsetToRange.$anonfun.r" title="sbt.LineRange">r</a> <a href="Positions.scala.html#sbt;LineRange.shift" title="(n: Int)sbt.LineRange">shift</a> <a href="#sbt.EvaluateConfigurations.addOffsetToRange.offset" title="Int">offset</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * The name of the class we cast DSL &quot;setting&quot; (vs. definition) lines to.
   */</span>
  <span class="keyword">val</span> <a title="String" id="sbt.EvaluateConfigurations.SettingsDefinitionName">SettingsDefinitionName</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Class[sbt.internals.DslEntry]" id="sbt.EvaluateConfigurations.SettingsDefinitionName._">_</a> = classOf<span title="Class[sbt.internals.DslEntry](classOf[sbt.internals.DslEntry])" class="delimiter">[</span>sbt.internals.DslEntry<span class="delimiter">]</span> <span class="comment">// this line exists to try to provide a compile-time error when the following line needs to be changed</span>
    <span title="String(&quot;sbt.internals.DslEntry&quot;)" class="string">&quot;sbt.internals.DslEntry&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This actually compiles a scala expression which represents a sbt.internals.DslEntry.
   *
   * @param eval The mechanism to compile and evaluate Scala expressions.
   * @param name The name for the thing we're compiling
   * @param imports The scala imports to have in place when we compile the expression
   * @param expression The scala expression we're compiling
   * @param range The original position in source of the expression, for error messages.
   *
   * @return A method that given an sbt classloader, can return the actual [[DslEntry]] defined by
   *         the expression, and the sequence of .class files generated.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, name: String, imports: Seq[(String, Int)], expression: String, range: sbt.LineRange)sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]" id="sbt.EvaluateConfigurations.evaluateDslEntry">evaluateDslEntry</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.evaluateDslEntry.eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="String" id="sbt.EvaluateConfigurations.evaluateDslEntry.name">name</a>: <span title="String">String</span>, <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.evaluateDslEntry.imports">imports</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="String" id="sbt.EvaluateConfigurations.evaluateDslEntry.expression">expression</a>: <span title="String">String</span>, <a title="sbt.LineRange" id="sbt.EvaluateConfigurations.evaluateDslEntry.range">range</a>: <a href="Positions.scala.html#sbt;LineRange" title="sbt.LineRange">LineRange</a><span class="delimiter">)</span>: <a href="#sbt.EvaluateConfigurations.TrackedEvalResult.readResolve" title="sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]">TrackedEvalResult</a><span class="delimiter">[</span>internals.DslEntry<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// TODO - Should we try to namespace these between.sbt files?  IF they hash to the same value, they may actually be</span>
    <span class="comment">// exactly the same setting, so perhaps we don't care?</span>
    <span class="keyword">val</span> <a title="sbt.compiler.EvalResult" id="sbt.EvaluateConfigurations.evaluateDslEntry.result">result</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#sbt.EvaluateConfigurations.evaluateDslEntry.eval" title="sbt.compiler.Eval">eval</a>.<a href="compiler/Eval.scala.html#sbt.compiler;Eval.eval" title="(expression: String, imports: sbt.compiler.EvalImports, tpeName: Option[String], srcName: String, line: Int)sbt.compiler.EvalResult">eval</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.expression" title="String" id="sbt.EvaluateConfigurations.evaluateDslEntry.result.x$37">expression</a>, imports = <a title="sbt.compiler.EvalImports" id="sbt.EvaluateConfigurations.evaluateDslEntry.result.x$38" class="keyword">new</a> <a href="compiler/Eval.scala.html#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.imports" title="Seq[(String, Int)]">imports</a>, <a href="#sbt.EvaluateConfigurations.evaluateDslEntry.name" title="String">name</a><span class="delimiter">)</span>, srcName = <a href="#sbt.EvaluateConfigurations.evaluateDslEntry.name" title="String" id="sbt.EvaluateConfigurations.evaluateDslEntry.result.x$39">name</a>, tpeName = <span title="(x: String)Some[String]">Some</span><a title="Some[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.EvaluateConfigurations.evaluateDslEntry.result.x$40" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.SettingsDefinitionName" title="=&gt; String">SettingsDefinitionName</a><span class="delimiter">)</span>, line = <a href="#sbt.EvaluateConfigurations.evaluateDslEntry.range" title="sbt.LineRange">range</a>.<a href="Positions.scala.html#sbt;LineRange.start" title="Int" id="sbt.EvaluateConfigurations.evaluateDslEntry.result.x$41">start</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="sbt.compiler.EvalException" id="sbt.EvaluateConfigurations.evaluateDslEntry.result.e">e</a>: sbt.compiler.<a href="compiler/Eval.scala.html#sbt.compiler;EvalException" title="sbt.compiler.EvalException">EvalException</a> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.result.e" title="sbt.compiler.EvalException">e</a>.<span title="()String">getMessage</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="comment">// TODO - keep track of configuration classes defined.</span>
    <a href="#sbt.EvaluateConfigurations.TrackedEvalResult.readResolve" title="(generated: Seq[java.io.File], result: ClassLoader =&gt; sbt.internals.DslEntry)sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]">TrackedEvalResult</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.result" title="sbt.compiler.EvalResult">result</a>.<a href="compiler/Eval.scala.html#sbt.compiler;EvalResult.generated" title="=&gt; Seq[java.io.File]">generated</a>,
      <a title="ClassLoader" id="sbt.EvaluateConfigurations.evaluateDslEntry.$anonfun.loader">loader</a> =&gt; <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="sbt.RangePosition" id="sbt.EvaluateConfigurations.evaluateDslEntry.$anonfun.pos">pos</a> = <a href="Positions.scala.html#sbt;RangePosition" title="(path: String, range: sbt.LineRange)sbt.RangePosition">RangePosition</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.name" title="String">name</a>, <a href="#sbt.EvaluateConfigurations.evaluateDslEntry.range" title="sbt.LineRange">range</a> <a href="Positions.scala.html#sbt;LineRange.shift" title="(n: Int)sbt.LineRange">shift</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <a href="#sbt.EvaluateConfigurations.evaluateDslEntry.result" title="sbt.compiler.EvalResult">result</a>.<a href="compiler/Eval.scala.html#sbt.compiler;EvalResult.getValue" title="(v1: ClassLoader)Any">getValue</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.$anonfun.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="sbt.internals.DslEntry" class="delimiter">[</span>internals.<a href="internals/DslAst.scala.html#sbt.internals;DslEntry" title="sbt.internals.DslEntry">DslEntry</a><span class="delimiter">]</span>.<a href="internals/DslAst.scala.html#sbt.internals;DslEntry.withPos" title="(pos: sbt.RangePosition)sbt.internals.DslEntry">withPos</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDslEntry.$anonfun.pos" title="sbt.RangePosition">pos</a><span class="delimiter">)</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This actually compiles a scala expression which represents a Seq[Setting[_]], although the
   * expression may be just a single setting.
   *
   * @param eval The mechanism to compile and evaluate Scala expressions.
   * @param name The name for the thing we're compiling
   * @param imports The scala imports to have in place when we compile the expression
   * @param expression The scala expression we're compiling
   * @param range The original position in source of the expression, for error messages.
   *
   * @return A method that given an sbt classloader, can return the actual Seq[Setting[_]] defined by
   *         the expression.
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Build DSL now includes non-Setting[_] type settings.&quot;</span>, <span class="string">&quot;0.13.6&quot;</span><span class="delimiter">)</span> <span class="comment">// Note: This method is used by the SET command, so we may want to evaluate that sucker a bit.</span>
  <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, name: String, imports: Seq[(String, Int)], expression: String, range: sbt.LineRange)ClassLoader =&gt; Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.evaluateSetting">evaluateSetting</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.evaluateSetting.eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="String" id="sbt.EvaluateConfigurations.evaluateSetting.name">name</a>: <span title="String">String</span>, <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.evaluateSetting.imports">imports</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="String" id="sbt.EvaluateConfigurations.evaluateSetting.expression">expression</a>: <span title="String">String</span>, <a title="sbt.LineRange" id="sbt.EvaluateConfigurations.evaluateSetting.range">range</a>: <a href="Positions.scala.html#sbt;LineRange" title="sbt.LineRange">LineRange</a><span class="delimiter">)</span>: <span title="ClassLoader =&gt; Seq[sbt.Def.Setting[_]]">LazyClassLoaded</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <a href="#sbt.EvaluateConfigurations.evaluateDslEntry" title="(eval: sbt.compiler.Eval, name: String, imports: Seq[(String, Int)], expression: String, range: sbt.LineRange)sbt.EvaluateConfigurations.TrackedEvalResult[sbt.internals.DslEntry]">evaluateDslEntry</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateSetting.eval" title="sbt.compiler.Eval">eval</a>, <a href="#sbt.EvaluateConfigurations.evaluateSetting.name" title="String">name</a>, <a href="#sbt.EvaluateConfigurations.evaluateSetting.imports" title="Seq[(String, Int)]">imports</a>, <a href="#sbt.EvaluateConfigurations.evaluateSetting.expression" title="String">expression</a>, <a href="#sbt.EvaluateConfigurations.evaluateSetting.range" title="sbt.LineRange">range</a><span class="delimiter">)</span>.<a href="#sbt.EvaluateConfigurations;TrackedEvalResult.result" title="=&gt; ClassLoader =&gt; sbt.internals.DslEntry">result</a> <span title="(g: sbt.internals.DslEntry =&gt; Seq[sbt.Def.Setting[_]])ClassLoader =&gt; Seq[sbt.Def.Setting[_]]">andThen</span> <a href="#sbt.EvaluateConfigurations.evaluateSetting.$anonfun.x0$7" title="Seq[sbt.Def.Setting[_]]" class="delimiter">{</a>
        <span class="keyword">case</span> internals.<a href="internals/DslAst.scala.html#sbt.internals.ProjectSettings.unapply" title="(e: sbt.internals.DslEntry)Option[Seq[sbt.Def.Setting[_]]]">ProjectSettings</a><span class="delimiter">(</span><a title="Seq[sbt.Def.Setting[_]]" id="sbt.EvaluateConfigurations.evaluateSetting.$anonfun.values">values</a><span class="delimiter">)</span> =&gt; <a href="#sbt.EvaluateConfigurations.evaluateSetting.$anonfun.values" title="Seq[sbt.Def.Setting[_]]">values</a>
        <span class="keyword">case</span> _                                 =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Char =&gt; Boolean" id="sbt.EvaluateConfigurations.isSpace">isSpace</a> = <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt; <span title="Character.type">Character</span> <span title="(x$1: Char)Boolean">isWhitespace</span> <a href="#sbt.EvaluateConfigurations.isSpace.$anonfun.c" title="Char">c</a>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(f: String =&gt; Boolean)((String, Int)) =&gt; Boolean" id="sbt.EvaluateConfigurations.fstS">fstS</a><span class="delimiter">(</span><a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.fstS.f">f</a>: String =&gt; Boolean<span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; Boolean = <a href="#sbt.EvaluateConfigurations.fstS.$anonfun.x0$8" title="Boolean" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.fstS.$anonfun.s">s</a>, <a title="Int" id="sbt.EvaluateConfigurations.fstS.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#sbt.EvaluateConfigurations.fstS.f" title="(v1: String)Boolean">f</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.fstS.$anonfun.s" title="String">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(lit: String)String =&gt; Boolean" id="sbt.EvaluateConfigurations.firstNonSpaceIs">firstNonSpaceIs</a><span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.firstNonSpaceIs.lit">lit</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.firstNonSpaceIs.$anonfun.x$11" title="String">_</a>: <span title="String">String</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.SeqView[Char,String]">view</span>.<span title="(p: Char =&gt; Boolean)scala.collection.SeqView[Char,String]">dropWhile</span><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.isSpace" title="=&gt; Char =&gt; Boolean">isSpace</a><span class="delimiter">)</span>.<span title="(that: scala.collection.GenSeq[Char])Boolean">startsWith</span><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.firstNonSpaceIs.lit" title="implicit scala.LowPriorityImplicits.wrapString : (s: String)scala.collection.immutable.WrappedString">lit</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[A](a: A =&gt; Boolean, b: A =&gt; Boolean)A =&gt; Boolean" id="sbt.EvaluateConfigurations.or">or</a><span class="delimiter">[</span><a title="" id="sbt.EvaluateConfigurations.or;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; Boolean" id="sbt.EvaluateConfigurations.or.a">a</a>: A =&gt; Boolean, <a title="A =&gt; Boolean" id="sbt.EvaluateConfigurations.or.b">b</a>: A =&gt; Boolean<span class="delimiter">)</span>: A =&gt; Boolean = <a title="A" id="sbt.EvaluateConfigurations.or.$anonfun.in">in</a> =&gt; <a href="#sbt.EvaluateConfigurations.or.a" title="(v1: A)Boolean">a</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.or.$anonfun.in" title="A">in</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.EvaluateConfigurations.or.b" title="(v1: A)Boolean">b</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.or.$anonfun.in" title="A">in</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Splits a set of lines into (imports, expressions).  That is,
   * anything on the right of the tuple is a scala expression (definition or setting).
   */</span>
  <span class="keyword">def</span> <a title="(lines: Seq[String])(Seq[(String, Int)], Seq[(String, sbt.LineRange)])" id="sbt.EvaluateConfigurations.splitExpressions">splitExpressions</a><span class="delimiter">(</span><a title="Seq[String]" id="sbt.EvaluateConfigurations.splitExpressions.lines">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)])" class="delimiter">(</span>Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.splitExpressions.blank">blank</a> = <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitExpressions.blank.$anonfun.x$12" title="String">_</a>: <span title="String">String</span><span class="delimiter">)</span>.<span title="(p: Char =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.isSpace" title="=&gt; Char =&gt; Boolean">isSpace</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.splitExpressions.isImport">isImport</a> = <a href="#sbt.EvaluateConfigurations.firstNonSpaceIs" title="(lit: String)String =&gt; Boolean">firstNonSpaceIs</a><span class="delimiter">(</span><span title="String(&quot;import &quot;)" class="string">&quot;import &quot;</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.splitExpressions.comment">comment</a> = <a href="#sbt.EvaluateConfigurations.firstNonSpaceIs" title="(lit: String)String =&gt; Boolean">firstNonSpaceIs</a><span class="delimiter">(</span><span title="String(&quot;//&quot;)" class="string">&quot;//&quot;</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.splitExpressions.blankOrComment">blankOrComment</a> = <a href="#sbt.EvaluateConfigurations.or" title="(a: String =&gt; Boolean, b: String =&gt; Boolean)String =&gt; Boolean">or</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitExpressions.blank" title="String =&gt; Boolean">blank</a>, <a href="#sbt.EvaluateConfigurations.splitExpressions.comment" title="String =&gt; Boolean">comment</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="((String, Int)) =&gt; Boolean" id="sbt.EvaluateConfigurations.splitExpressions.importOrBlank">importOrBlank</a> = <a href="#sbt.EvaluateConfigurations.fstS" title="(f: String =&gt; Boolean)((String, Int)) =&gt; Boolean">fstS</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.or" title="(a: String =&gt; Boolean, b: String =&gt; Boolean)String =&gt; Boolean">or</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitExpressions.blankOrComment" title="String =&gt; Boolean">blankOrComment</a>, <a href="#sbt.EvaluateConfigurations.splitExpressions.isImport" title="String =&gt; Boolean">isImport</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a href="#sbt.EvaluateConfigurations.splitExpressions.imports" title="(Seq[(String, Int)], Seq[(String, Int)])" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.splitExpressions.x$13" title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.splitExpressions.imports">imports</a>, <a href="#sbt.EvaluateConfigurations.splitExpressions.x$13" title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.splitExpressions.settings">settings</a><span class="delimiter">)</span> = <a href="#sbt.EvaluateConfigurations.splitExpressions.lines" title="Seq[String]">lines</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">zipWithIndex</span> <span title="(p: ((String, Int)) =&gt; Boolean)(Seq[(String, Int)], Seq[(String, Int)])">span</span> <a href="#sbt.EvaluateConfigurations.splitExpressions.importOrBlank" title="((String, Int)) =&gt; Boolean">importOrBlank</a>
      <span title="(_1: Seq[(String, Int)], _2: Seq[(String, sbt.LineRange)])(Seq[(String, Int)], Seq[(String, sbt.LineRange)])" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitExpressions.imports" title="Seq[(String, Int)]">imports</a> <span title="(p: ((String, Int)) =&gt; Boolean)Seq[(String, Int)]">filterNot</span> <a href="#sbt.EvaluateConfigurations.fstS" title="(f: String =&gt; Boolean)((String, Int)) =&gt; Boolean">fstS</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitExpressions.blankOrComment" title="String =&gt; Boolean">blankOrComment</a><span class="delimiter">)</span>, <a href="#sbt.EvaluateConfigurations.groupedLines" title="(lines: Seq[(String, Int)], delimiter: String =&gt; Boolean, skipInitial: String =&gt; Boolean)Seq[(String, sbt.LineRange)]">groupedLines</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitExpressions.settings" title="Seq[(String, Int)]">settings</a>, <a href="#sbt.EvaluateConfigurations.splitExpressions.blank" title="String =&gt; Boolean">blank</a>, <a href="#sbt.EvaluateConfigurations.splitExpressions.blankOrComment" title="String =&gt; Boolean">blankOrComment</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(lines: Seq[(String, Int)], delimiter: String =&gt; Boolean, skipInitial: String =&gt; Boolean)Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.groupedLines">groupedLines</a><span class="delimiter">(</span><a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.groupedLines.lines">lines</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.groupedLines.delimiter">delimiter</a>: String =&gt; Boolean, <a title="String =&gt; Boolean" id="sbt.EvaluateConfigurations.groupedLines.skipInitial">skipInitial</a>: String =&gt; Boolean<span class="delimiter">)</span>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="((String, Int)) =&gt; Boolean" id="sbt.EvaluateConfigurations.groupedLines.fdelim">fdelim</a> = <a href="#sbt.EvaluateConfigurations.fstS" title="(f: String =&gt; Boolean)((String, Int)) =&gt; Boolean">fstS</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.delimiter" title="String =&gt; Boolean">delimiter</a><span class="delimiter">)</span>
      @tailrec <span class="keyword">def</span> <a title="(lines: Seq[(String, Int)], accum: Seq[(String, sbt.LineRange)])Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.groupedLines.group0">group0</a><span class="delimiter">(</span><a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.groupedLines.group0.lines">lines</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.groupedLines.group0.accum">accum</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span> =
        <span title="Seq[(String, sbt.LineRange)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.lines" title="Seq[(String, Int)]">lines</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.EvaluateConfigurations.groupedLines.group0.accum" title="Seq[(String, sbt.LineRange)]">accum</a>.<span title="=&gt; Seq[(String, sbt.LineRange)]">reverse</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.groupedLines.group0.start">start</a> = <a href="#sbt.EvaluateConfigurations.groupedLines.group0.lines" title="Seq[(String, Int)]">lines</a> <span title="(p: ((String, Int)) =&gt; Boolean)Seq[(String, Int)]">dropWhile</span> <a href="#sbt.EvaluateConfigurations.fstS" title="(f: String =&gt; Boolean)((String, Int)) =&gt; Boolean">fstS</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.skipInitial" title="String =&gt; Boolean">skipInitial</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a href="#sbt.EvaluateConfigurations.groupedLines.group0.next" title="(Seq[(String, Int)], Seq[(String, Int)])" class="delimiter">(</a><a href="#sbt.EvaluateConfigurations.groupedLines.group0.x$14" title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.groupedLines.group0.next">next</a>, <a href="#sbt.EvaluateConfigurations.groupedLines.group0.x$14" title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.groupedLines.group0.tail">tail</a><span class="delimiter">)</span> = <a href="#sbt.EvaluateConfigurations.groupedLines.group0.start" title="Seq[(String, Int)]">start</a>.<span title="(p: ((String, Int)) =&gt; Boolean)(Seq[(String, Int)], Seq[(String, Int)])">span</span> <a href="#sbt.EvaluateConfigurations.groupedLines.group0.x$14.$anonfun.x0$9" title="Boolean" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.groupedLines.group0.x$14.$anonfun.s">s</a>, _<span class="delimiter">)</span> =&gt; <span title="=&gt; Boolean">!</span><a href="#sbt.EvaluateConfigurations.groupedLines.delimiter" title="(v1: String)Boolean">delimiter</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.x$14.$anonfun.s" title="String">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.groupedLines.group0.grouped">grouped</a> = <span title="Seq[(String, sbt.LineRange)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.next" title="Seq[(String, Int)]">next</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.EvaluateConfigurations.groupedLines.group0.accum" title="Seq[(String, sbt.LineRange)]">accum</a> <span class="keyword">else</span> <span title="(_1: String, _2: sbt.LineRange)(String, sbt.LineRange)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.next" title="Seq[(String, Int)]">next</a>.<span title="(f: ((String, Int)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.grouped.x$16.$anonfun.x$15" title="(String, Int)">_</a>.<span title="=&gt; String">_1</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>, <a href="Positions.scala.html#sbt;LineRange" title="(start: Int, end: Int)sbt.LineRange">LineRange</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.next" title="Seq[(String, Int)]">next</a>.<span title="=&gt; (String, Int)">head</span>.<span title="=&gt; Int">_2</span>, <a href="#sbt.EvaluateConfigurations.groupedLines.group0.next" title="Seq[(String, Int)]">next</a>.<span title="=&gt; (String, Int)">last</span>.<span title="=&gt; Int">_2</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.EvaluateConfigurations.groupedLines.group0.grouped.x$16" title="(elem: (String, sbt.LineRange))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, sbt.LineRange)],(String, sbt.LineRange),Seq[(String, sbt.LineRange)]])Seq[(String, sbt.LineRange)]">+:</a> <a href="#sbt.EvaluateConfigurations.groupedLines.group0.accum" title="Seq[(String, sbt.LineRange)]">accum</a>
          <a href="#sbt.EvaluateConfigurations.groupedLines.group0" title="(lines: Seq[(String, Int)], accum: Seq[(String, sbt.LineRange)])Seq[(String, sbt.LineRange)]">group0</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.group0.tail" title="Seq[(String, Int)]">tail</a>, <a href="#sbt.EvaluateConfigurations.groupedLines.group0.grouped" title="Seq[(String, sbt.LineRange)]">grouped</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#sbt.EvaluateConfigurations.groupedLines.group0" title="(lines: Seq[(String, Int)], accum: Seq[(String, sbt.LineRange)])Seq[(String, sbt.LineRange)]">group0</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.groupedLines.lines" title="Seq[(String, Int)]">lines</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(lines: Seq[(String, sbt.LineRange)])(Seq[(String, sbt.LineRange)], Seq[(String, sbt.LineRange)])" id="sbt.EvaluateConfigurations.splitSettingsDefinitions">splitSettingsDefinitions</a><span class="delimiter">(</span><a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.splitSettingsDefinitions.lines">lines</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Seq[(String, sbt.LineRange)], Seq[(String, sbt.LineRange)])" class="delimiter">(</span>Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#sbt.EvaluateConfigurations.splitSettingsDefinitions.lines" title="Seq[(String, sbt.LineRange)]">lines</a> <span title="(p: ((String, sbt.LineRange)) =&gt; Boolean)(Seq[(String, sbt.LineRange)], Seq[(String, sbt.LineRange)])">partition</span> <a href="#sbt.EvaluateConfigurations.splitSettingsDefinitions.$anonfun.x0$10" title="Boolean" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.splitSettingsDefinitions.$anonfun.line">line</a>, <a title="sbt.LineRange" id="sbt.EvaluateConfigurations.splitSettingsDefinitions.$anonfun.range">range</a><span class="delimiter">)</span> =&gt; <a href="#sbt.EvaluateConfigurations.isDefinition" title="(line: String)Boolean">isDefinition</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.splitSettingsDefinitions.$anonfun.line" title="String">line</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(line: String)Boolean" id="sbt.EvaluateConfigurations.isDefinition">isDefinition</a><span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.isDefinition.line">line</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="sbt.EvaluateConfigurations.isDefinition.trimmed">trimmed</a> = <a href="#sbt.EvaluateConfigurations.isDefinition.line" title="String">line</a>.<span title="()String">trim</span>
      <a href="#sbt.EvaluateConfigurations.DefinitionKeywords" title="Seq[String]">DefinitionKeywords</a>.<span title="(p: String =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.isDefinition.trimmed" title="String">trimmed</a> <span title="(x$1: String)Boolean">startsWith</span> <a href="#sbt.EvaluateConfigurations.isDefinition.$anonfun.x$17" title="String">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Seq[String]" id="sbt.EvaluateConfigurations.extractedValTypes">extractedValTypes</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <span title="(elems: Class[_ &gt;: sbt.SettingKey[_$8] with sbt.TaskKey[_$7] with sbt.InputKey[_$6] with sbt.Project forSome { type _$8; type _$7; type _$6 } &lt;: Object]*)Seq[Class[_ &gt;: sbt.SettingKey[_$8] with sbt.TaskKey[_$7] with sbt.InputKey[_$6] with sbt.Project forSome { type _$8; type _$7; type _$6 } &lt;: Object]]">Seq</span><span class="delimiter">(</span>classOf<span title="Class[sbt.Project](classOf[sbt.Project])" class="delimiter">[</span>Project<span class="delimiter">]</span>, classOf<span title="Class[sbt.InputKey[_]](classOf[sbt.InputKey])" class="delimiter">[</span>InputKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, classOf<span title="Class[sbt.TaskKey[_]](classOf[sbt.TaskKey])" class="delimiter">[</span>TaskKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, classOf<span title="Class[sbt.SettingKey[_]](classOf[sbt.SettingKey])" class="delimiter">[</span>SettingKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="(f: Class[_ &gt;: sbt.SettingKey[_$8] with sbt.TaskKey[_$7] with sbt.InputKey[_$6] with sbt.Project forSome { type _$8; type _$7; type _$6 } &lt;: Object] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Class[_ &gt;: sbt.SettingKey[_$8] with sbt.TaskKey[_$7] with sbt.InputKey[_$6] with sbt.Project forSome { type _$8; type _$7; type _$6 } &lt;: Object]],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.extractedValTypes.$anonfun.x$18" title="Class[_ &gt;: sbt.SettingKey[_$8] with sbt.TaskKey[_$7] with sbt.InputKey[_$6] with sbt.Project forSome { type _$8; type _$7; type _$6 } &lt;: Object]">_</a>.<span title="()String">getName</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(eval: sbt.compiler.Eval, name: String, imports: Seq[(String, Int)], definitions: Seq[(String, sbt.LineRange)], file: Option[java.io.File])sbt.compiler.EvalDefinitions" id="sbt.EvaluateConfigurations.evaluateDefinitions">evaluateDefinitions</a><span class="delimiter">(</span><a title="sbt.compiler.Eval" id="sbt.EvaluateConfigurations.evaluateDefinitions.eval">eval</a>: <a href="compiler/Eval.scala.html#sbt.compiler;Eval" title="sbt.compiler.Eval">Eval</a>, <a title="String" id="sbt.EvaluateConfigurations.evaluateDefinitions.name">name</a>: <span title="String">String</span>, <a title="Seq[(String, Int)]" id="sbt.EvaluateConfigurations.evaluateDefinitions.imports">imports</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="Seq[(String, sbt.LineRange)]" id="sbt.EvaluateConfigurations.evaluateDefinitions.definitions">definitions</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="Option[java.io.File]" id="sbt.EvaluateConfigurations.evaluateDefinitions.file">file</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span>: compiler.<a href="compiler/Eval.scala.html#sbt.compiler;EvalDefinitions" title="sbt.compiler.EvalDefinitions">EvalDefinitions</a> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Seq[(String, scala.collection.immutable.Range.Inclusive)]" id="sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges">convertedRanges</a> = <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.definitions" title="Seq[(String, sbt.LineRange)]">definitions</a>.<span title="(f: ((String, sbt.LineRange)) =&gt; (String, scala.collection.immutable.Range.Inclusive))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, sbt.LineRange)],(String, scala.collection.immutable.Range.Inclusive),Seq[(String, scala.collection.immutable.Range.Inclusive)]])Seq[(String, scala.collection.immutable.Range.Inclusive)]">map</span> <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges.$anonfun.x0$11" title="(String, scala.collection.immutable.Range.Inclusive)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges.$anonfun.s">s</a>, <a title="sbt.LineRange" id="sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges.$anonfun.r">r</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: scala.collection.immutable.Range.Inclusive)(String, scala.collection.immutable.Range.Inclusive)" class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges.$anonfun.s" title="String">s</a>, <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges.$anonfun.r" title="sbt.LineRange">r</a>.<a href="Positions.scala.html#sbt;LineRange.start" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">start</a> <span title="(end: Int)scala.collection.immutable.Range.Inclusive">to</span> <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges.$anonfun.r" title="sbt.LineRange">r</a>.<a href="Positions.scala.html#sbt;LineRange.end" title="=&gt; Int">end</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.eval" title="sbt.compiler.Eval">eval</a>.<a href="compiler/Eval.scala.html#sbt.compiler;Eval.evalDefinitions" title="(definitions: Seq[(String, Range)], imports: sbt.compiler.EvalImports, srcName: String, file: Option[java.io.File], valTypes: Seq[String])sbt.compiler.EvalDefinitions">evalDefinitions</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDefinitions.convertedRanges" title="Seq[(String, scala.collection.immutable.Range.Inclusive)]">convertedRanges</a>, <span title="sbt.compiler.EvalImports" class="keyword">new</span> <a href="compiler/Eval.scala.html#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a><span class="delimiter">(</span><a href="#sbt.EvaluateConfigurations.evaluateDefinitions.imports" title="Seq[(String, Int)]">imports</a>, <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.name" title="String">name</a><span class="delimiter">)</span>, <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.name" title="String">name</a>, <a href="#sbt.EvaluateConfigurations.evaluateDefinitions.file" title="Option[java.io.File]">file</a>, <a href="#sbt.EvaluateConfigurations.extractedValTypes" title="=&gt; Seq[String]">extractedValTypes</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.Index.type" id="sbt.Index">Index</a> <a href="#sbt.Index" title="sbt.Index.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="(data: sbt.Settings[sbt.Scope])Map[sbt.Task[_],sbt.Def.ScopedKey[sbt.Task[_]]]" id="sbt.Index.taskToKeyMap">taskToKeyMap</a><span class="delimiter">(</span><a title="sbt.Settings[sbt.Scope]" id="sbt.Index.taskToKeyMap.data">data</a>: <a href="Settings.scala.html#sbt;Settings" title="sbt.Settings[sbt.Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[sbt.Task[_],sbt.Def.ScopedKey[sbt.Task[_]]]">Map</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span>, ScopedKey<span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="comment">// AttributeEntry + the checked type test 'value: Task[_]' ensures that the cast is correct.</span>
      <span class="comment">//  (scalac couldn't determine that 'key' is of type AttributeKey[Task[_]] on its own and a type match still required the cast)</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }]" id="sbt.Index.taskToKeyMap.pairs">pairs</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="sbt.Scope" id="sbt.Index.taskToKeyMap.pairs.$anonfun.scope">scope</a> &lt;- <a href="#sbt.Index.taskToKeyMap.data" title="sbt.Settings[sbt.Scope]">data</a>.<a href="Settings.scala.html#sbt;Settings.scopes" title="(f: sbt.Scope =&gt; scala.collection.GenTraversableOnce[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.Scope],(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ },scala.collection.immutable.Set[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }]])scala.collection.immutable.Set[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }]">scopes</a>; AttributeEntry<span class="delimiter">(</span><a title="sbt.AttributeKey[_$7]" id="sbt.Index.taskToKeyMap.pairs.$anonfun.$anonfun.key">key</a>, <a title="sbt.Task[_]" id="sbt.Index.taskToKeyMap.pairs.$anonfun.$anonfun.value">value</a>: <a href="Action.scala.html#sbt;Task" title="sbt.Task[_]">Task</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> &lt;- <a href="#sbt.Index.taskToKeyMap.data" title="sbt.Settings[sbt.Scope]">data</a>.<a href="Settings.scala.html#sbt;Settings.data" title="(key: sbt.Scope)sbt.AttributeMap">data</a><span class="delimiter">(</span><a href="#sbt.Index.taskToKeyMap.pairs.$anonfun.scope" title="sbt.Scope">scope</a><span class="delimiter">)</span>.<a href="Attributes.scala.html#sbt;AttributeMap.entries" title="(f: sbt.AttributeEntry[_] =&gt; (sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ })(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[sbt.AttributeEntry[_]],(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ },Iterable[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }]])Iterable[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }]">entries</a><span class="delimiter">)</span> <span class="keyword">yield</span> <span title="(_1: sbt.Task[_], _2: sbt.Def.ScopedKey[sbt.Task[_]])(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]])" class="delimiter">(</span><a href="#sbt.Index.taskToKeyMap.pairs.$anonfun.$anonfun.value" title="sbt.Task[_]">value</a>, <a href="Settings.scala.html#sbt;Init;ScopedKey" title="(scope: sbt.Scope, key: sbt.AttributeKey[sbt.Task[_]])sbt.Def.ScopedKey[sbt.Task[_]]">ScopedKey</a><span class="delimiter">(</span><a href="#sbt.Index.taskToKeyMap.pairs.$anonfun.scope" title="sbt.Scope">scope</a>, <a href="#sbt.Index.taskToKeyMap.pairs.$anonfun.$anonfun.key" title="sbt.AttributeKey[_$7]">key</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="sbt.AttributeKey[sbt.Task[_]]" class="delimiter">[</span><a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[sbt.Task[_]]">AttributeKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// unclear why this cast is needed even with a type test in the above filter</span>
      <a href="#sbt.Index.taskToKeyMap.pairs" title="scala.collection.immutable.Set[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ }]">pairs</a>.<span title="[T, U](implicit ev: &lt;:&lt;[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ },(T, U)])scala.collection.immutable.Map[T,U]">toMap</span><span title="(implicit ev: &lt;:&lt;[(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]]) forSome { type _ },(sbt.Task[_], sbt.Def.ScopedKey[sbt.Task[_]])])scala.collection.immutable.Map[sbt.Task[_],sbt.Def.ScopedKey[sbt.Task[_]]]" class="delimiter">[</span><a href="Action.scala.html#sbt;Task" title="sbt.Task[_]">Task</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[sbt.Task[_]]">ScopedKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(settings: Seq[sbt.Def.Setting[_]])Set[sbt.Def.ScopedKey[_]]" id="sbt.Index.allKeys">allKeys</a><span class="delimiter">(</span><a title="Seq[sbt.Def.Setting[_]]" id="sbt.Index.allKeys.settings">settings</a>: <span title="Seq[sbt.Def.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[sbt.Def.ScopedKey[_]]">Set</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt.Index.allKeys.settings" title="Seq[sbt.Def.Setting[_]]">settings</a>.<span title="(f: sbt.Def.Setting[_] =&gt; scala.collection.GenTraversableOnce[sbt.Def.ScopedKey[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.Def.Setting[_]],sbt.Def.ScopedKey[_],Seq[sbt.Def.ScopedKey[_]]])Seq[sbt.Def.ScopedKey[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.Def.ScopedKey[_],Seq[sbt.Def.ScopedKey[_]]]" class="delimiter">(</span><a title="sbt.Def.Setting[_]" id="sbt.Index.allKeys.$anonfun.s">s</a> =&gt; <span title="Seq[sbt.Def.ScopedKey[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Index.allKeys.$anonfun.s" title="sbt.Def.Setting[_]">s</a>.<a href="Settings.scala.html#sbt;Init;Setting.key" title="=&gt; sbt.Def.ScopedKey[_$14]">key</a>.<a href="Settings.scala.html#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$14]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span> <span class="keyword">else</span> <a href="#sbt.Index.allKeys.$anonfun.s" title="sbt.Def.Setting[_]">s</a>.<a href="Settings.scala.html#sbt;Init;Setting.key" title="=&gt; sbt.Def.ScopedKey[_$14]">key</a> <a href="#sbt.Index.allKeys.$anonfun.x$20" title="(elem: sbt.Def.ScopedKey[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.Def.ScopedKey[_]],sbt.Def.ScopedKey[_],Seq[sbt.Def.ScopedKey[_]]])Seq[sbt.Def.ScopedKey[_]]">+:</a> <a href="#sbt.Index.allKeys.$anonfun.s" title="sbt.Def.Setting[_]">s</a>.<a href="Settings.scala.html#sbt;Init;Setting.dependencies" title="=&gt; Seq[sbt.Def.ScopedKey[_]]">dependencies</a><span class="delimiter">)</span>.<span title="(p: sbt.Def.ScopedKey[_] =&gt; Boolean)Seq[sbt.Def.ScopedKey[_]]">filter</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Index.allKeys.$anonfun.x$21" title="sbt.Def.ScopedKey[_]">_</a>.<a href="Settings.scala.html#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$87]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.Def.ScopedKey[_]]">toSet</span>
  <span class="keyword">def</span> <a title="(settings: sbt.Settings[sbt.Scope])Set[sbt.AttributeKey[_]]" id="sbt.Index.attributeKeys">attributeKeys</a><span class="delimiter">(</span><a title="sbt.Settings[sbt.Scope]" id="sbt.Index.attributeKeys.settings">settings</a>: <a href="Settings.scala.html#sbt;Settings" title="sbt.Settings[sbt.Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[sbt.AttributeKey[_]]">Set</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt.Index.attributeKeys.settings" title="sbt.Settings[sbt.Scope]">settings</a>.<a href="Settings.scala.html#sbt;Settings.data" title="=&gt; Map[sbt.Scope,sbt.AttributeMap]">data</a>.<span title="=&gt; Iterable[sbt.AttributeMap]">values</span>.<span title="(f: sbt.AttributeMap =&gt; scala.collection.GenTraversableOnce[sbt.AttributeKey[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[sbt.AttributeMap],sbt.AttributeKey[_],Iterable[sbt.AttributeKey[_]]])Iterable[sbt.AttributeKey[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,sbt.AttributeKey[_],Iterable[sbt.AttributeKey[_]]]" class="delimiter">(</span><a href="#sbt.Index.attributeKeys.$anonfun.x$22" title="sbt.AttributeMap">_</a>.<a href="Attributes.scala.html#sbt;AttributeMap.keys" title="=&gt; Iterable[sbt.AttributeKey[_]]">keys</a><span class="delimiter">)</span>.<span title="[B &gt;: sbt.AttributeKey[_]]=&gt; scala.collection.immutable.Set[B]">toSet</span><span title="scala.collection.immutable.Set[sbt.AttributeKey[_]]" class="delimiter">[</span><a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[_]">AttributeKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(settings: Set[sbt.AttributeKey[_]])Map[String,sbt.AttributeKey[_]]" id="sbt.Index.stringToKeyMap">stringToKeyMap</a><span class="delimiter">(</span><a title="Set[sbt.AttributeKey[_]]" id="sbt.Index.stringToKeyMap.settings">settings</a>: <span title="Set[sbt.AttributeKey[_]]">Set</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[String,sbt.AttributeKey[_]]">Map</span><span class="delimiter">[</span>String, AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt.Index.stringToKeyMap0" title="(settings: Set[sbt.AttributeKey[_]])(label: sbt.AttributeKey[_] =&gt; String)Map[String,sbt.AttributeKey[_]]">stringToKeyMap0</a><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap.settings" title="Set[sbt.AttributeKey[_]]">settings</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap.$anonfun.x$23" title="sbt.AttributeKey[_]">_</a>.<a href="Attributes.scala.html#sbt;AttributeKey.rawLabel" title="=&gt; String">rawLabel</a><span class="delimiter">)</span> <span title="(xs: scala.collection.GenTraversableOnce[(String, sbt.AttributeKey[_])])scala.collection.immutable.Map[String,sbt.AttributeKey[_]]">++</span> <a href="#sbt.Index.stringToKeyMap0" title="(settings: Set[sbt.AttributeKey[_]])(label: sbt.AttributeKey[_] =&gt; String)Map[String,sbt.AttributeKey[_]]">stringToKeyMap0</a><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap.settings" title="Set[sbt.AttributeKey[_]]">settings</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap.$anonfun.x$24" title="sbt.AttributeKey[_]">_</a>.<a href="Attributes.scala.html#sbt;AttributeKey.label" title="=&gt; String">label</a><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(settings: Set[sbt.AttributeKey[_]])(label: sbt.AttributeKey[_] =&gt; String)Map[String,sbt.AttributeKey[_]]" id="sbt.Index.stringToKeyMap0">stringToKeyMap0</a><span class="delimiter">(</span><a title="Set[sbt.AttributeKey[_]]" id="sbt.Index.stringToKeyMap0.settings">settings</a>: <span title="Set[sbt.AttributeKey[_]]">Set</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="sbt.AttributeKey[_] =&gt; String" id="sbt.Index.stringToKeyMap0.label">label</a>: AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; String<span class="delimiter">)</span>: <span title="Map[String,sbt.AttributeKey[_]]">Map</span><span class="delimiter">[</span>String, AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Map[String,scala.collection.immutable.Set[sbt.AttributeKey[_]]]" id="sbt.Index.stringToKeyMap0.multiMap">multiMap</a> = <a href="#sbt.Index.stringToKeyMap0.settings" title="Set[sbt.AttributeKey[_]]">settings</a>.<span title="(f: sbt.AttributeKey[_] =&gt; String)scala.collection.immutable.Map[String,scala.collection.immutable.Set[sbt.AttributeKey[_]]]">groupBy</span><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap0.label" title="sbt.AttributeKey[_] =&gt; String">label</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]" id="sbt.Index.stringToKeyMap0.duplicates">duplicates</a> = <a href="#sbt.Index.stringToKeyMap0.multiMap" title="scala.collection.immutable.Map[String,scala.collection.immutable.Set[sbt.AttributeKey[_]]]">multiMap</a> <span title="(pf: PartialFunction[(String, scala.collection.immutable.Set[sbt.AttributeKey[_]]),(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,scala.collection.immutable.Set[sbt.AttributeKey[_]]],(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]]),scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]])scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]">collect</span> <span title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(String, scala.collection.immutable.Set[sbt.AttributeKey[_]]),(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])] with Serializable" class="delimiter">{</span> <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">k</span>, <span title="scala.collection.immutable.Set[sbt.AttributeKey[_]]">xs</span><span class="delimiter">)</span> <span class="keyword">if</span> <span title="scala.collection.immutable.Set[sbt.AttributeKey[_]]">xs</span>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span> =&gt; <span title="(_1: String, _2: scala.collection.immutable.Set[scala.reflect.Manifest[_]])(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])" class="delimiter">(</span><span title="String">k</span>, <span title="scala.collection.immutable.Set[sbt.AttributeKey[_]]">xs</span>.<span title="(f: sbt.AttributeKey[_] =&gt; scala.reflect.Manifest[_])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.AttributeKey[_]],scala.reflect.Manifest[_],scala.collection.immutable.Set[scala.reflect.Manifest[_]]])scala.collection.immutable.Set[scala.reflect.Manifest[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,scala.reflect.Manifest[_],scala.collection.immutable.Set[scala.reflect.Manifest[_]]]" class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap0.duplicates;$anonfun.applyOrElse.$anonfun.x$25" title="sbt.AttributeKey[_]">_</a>.<a href="Attributes.scala.html#sbt;AttributeKey.manifest" title="=&gt; scala.reflect.Manifest[_$20]">manifest</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="(pf: PartialFunction[(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]]),(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]],(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]]),scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]])scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]">collect</span> <span title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]]),(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])] with Serializable" class="delimiter">{</span> <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">k</span>, <span title="scala.collection.immutable.Set[scala.reflect.Manifest[_]]">xs</span><span class="delimiter">)</span> <span class="keyword">if</span> <span title="scala.collection.immutable.Set[scala.reflect.Manifest[_]]">xs</span>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span> =&gt; <span title="(_1: String, _2: scala.collection.immutable.Set[scala.reflect.Manifest[_]])(String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])" class="delimiter">(</span><span title="String">k</span>, <span title="scala.collection.immutable.Set[scala.reflect.Manifest[_]]">xs</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span title="Map[String,sbt.AttributeKey[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap0.duplicates" title="scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]">duplicates</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
        <a href="#sbt.Index.stringToKeyMap0.multiMap" title="scala.collection.immutable.Map[String,scala.collection.immutable.Set[sbt.AttributeKey[_]]]">multiMap</a>.<span title="(pf: PartialFunction[(String, scala.collection.immutable.Set[sbt.AttributeKey[_]]),(String, sbt.AttributeKey[_$20]) forSome { type _$20 }])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,scala.collection.immutable.Set[sbt.AttributeKey[_]]],(String, sbt.AttributeKey[_$20]) forSome { type _$20 },scala.collection.immutable.Iterable[(String, sbt.AttributeKey[_$20]) forSome { type _$20 }]])scala.collection.immutable.Iterable[(String, sbt.AttributeKey[_$20]) forSome { type _$20 }]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(String, scala.collection.immutable.Set[sbt.AttributeKey[_]]),(String, sbt.AttributeKey[_$20]) forSome { type _$20 }] with Serializable" id="sbt.Index.stringToKeyMap0;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.Index.stringToKeyMap0;$anonfun.isDefinedAt.k">k</a>, <a title="scala.collection.immutable.Set[sbt.AttributeKey[_]]" id="sbt.Index.stringToKeyMap0;$anonfun.isDefinedAt.v">v</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="complete/Parsers.scala.html#sbt.complete.DefaultParsers.validID" title="(s: String)Boolean">validID</a><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap0;$anonfun.isDefinedAt.k" title="String">k</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: sbt.AttributeKey[_$20])(String, sbt.AttributeKey[_$20])" class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap0;$anonfun.isDefinedAt.k" title="String">k</a>, <a href="#sbt.Index.stringToKeyMap0;$anonfun.isDefinedAt.v" title="scala.collection.immutable.Set[sbt.AttributeKey[_]]">v</a>.<span title="=&gt; sbt.AttributeKey[_]">head</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="(implicit ev: &lt;:&lt;[(String, sbt.AttributeKey[_$20]) forSome { type _$20 },(String, sbt.AttributeKey[_])])scala.collection.immutable.Map[String,sbt.AttributeKey[_]]">toMap</span>;
      <span class="keyword">else</span>
        sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><a href="#sbt.Index.stringToKeyMap0.duplicates" title="scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]]">duplicates</a> <span title="(f: ((String, scala.collection.immutable.Set[scala.reflect.Manifest[_]])) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,scala.collection.immutable.Set[scala.reflect.Manifest[_]]],String,scala.collection.immutable.Iterable[String]])scala.collection.immutable.Iterable[String]">map</span> <a href="#sbt.Index.stringToKeyMap0.$anonfun.x0$12" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.Index.stringToKeyMap0.$anonfun.k">k</a>, <a title="scala.collection.immutable.Set[scala.reflect.Manifest[_]]" id="sbt.Index.stringToKeyMap0.$anonfun.tps">tps</a><span class="delimiter">)</span> =&gt; <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Index.stringToKeyMap0.$anonfun.k" title="String">k</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\' (&quot;)" class="string">&quot;' (&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Index.stringToKeyMap0.$anonfun.tps" title="scala.collection.immutable.Set[scala.reflect.Manifest[_]]">tps</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="delimiter">}</span> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><span title="String(&quot;Some keys were defined with the same name but different types: &quot;)" class="string">&quot;Some keys were defined with the same name but different types: &quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span><span class="keyword">type</span> <a title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]" id="sbt.Index;TriggerMap">TriggerMap</a> = collection.mutable.<span title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">HashMap</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(ss: sbt.Settings[sbt.Scope])sbt.Triggers[sbt.Task]" id="sbt.Index.triggers">triggers</a><span class="delimiter">(</span><a title="sbt.Settings[sbt.Scope]" id="sbt.Index.triggers.ss">ss</a>: <a href="Settings.scala.html#sbt;Settings" title="sbt.Settings[sbt.Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Execute.scala.html#sbt;Triggers" title="sbt.Triggers[sbt.Task]">Triggers</a><span class="delimiter">[</span>Task<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]" id="sbt.Index.triggers.runBefore">runBefore</a> = <span title="()scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]" class="keyword">new</span> <a href="#sbt.Index;TriggerMap" title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">TriggerMap</a>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]" id="sbt.Index.triggers.triggeredBy">triggeredBy</a> = <span title="()scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]" class="keyword">new</span> <a href="#sbt.Index;TriggerMap" title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">TriggerMap</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span>_, <a title="sbt.AttributeMap" id="sbt.Index.triggers.$anonfun.amap">amap</a><span class="delimiter">)</span> &lt;- <a href="#sbt.Index.triggers.ss" title="sbt.Settings[sbt.Scope]">ss</a>.<a href="Settings.scala.html#sbt;Settings.data" title="(f: ((sbt.Scope, sbt.AttributeMap)) =&gt; Unit)Unit">data</a>; AttributeEntry<span class="delimiter">(</span>_, <a title="sbt.Task[_]" id="sbt.Index.triggers.$anonfun.$anonfun.value">value</a>: <a href="Action.scala.html#sbt;Task" title="sbt.Task[_]">Task</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> &lt;- <a href="#sbt.Index.triggers.$anonfun.amap" title="sbt.AttributeMap">amap</a>.<a href="Attributes.scala.html#sbt;AttributeMap.entries" title="(f: sbt.AttributeEntry[_] =&gt; Unit)Unit">entries</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="sbt.AttributeMap" id="sbt.Index.triggers.$anonfun.$anonfun.as">as</a> = <a href="#sbt.Index.triggers.$anonfun.$anonfun.value" title="sbt.Task[_]">value</a>.<a href="Action.scala.html#sbt;Task.info" title="=&gt; sbt.Info[_]">info</a>.<a href="Action.scala.html#sbt;Info.attributes" title="=&gt; sbt.AttributeMap">attributes</a>
        <a href="#sbt.Index.update" title="(map: sbt.Index.TriggerMap, base: sbt.Task[_], tasksOpt: Option[Seq[sbt.Task[_]]])Unit">update</a><span class="delimiter">(</span><a href="#sbt.Index.triggers.runBefore" title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">runBefore</a>, <a href="#sbt.Index.triggers.$anonfun.$anonfun.value" title="sbt.Task[_]">value</a>, <a href="#sbt.Index.triggers.$anonfun.$anonfun.as" title="sbt.AttributeMap">as</a> <a href="Attributes.scala.html#sbt;AttributeMap.get" title="(k: sbt.AttributeKey[Seq[sbt.Task[_]]])Option[Seq[sbt.Task[_]]]">get</a> <a href="Keys.scala.html#sbt.Keys" title="sbt.Keys.type">Keys</a>.<a href="Keys.scala.html#sbt.Keys.runBefore" title="=&gt; sbt.AttributeKey[Seq[sbt.Task[_]]]">runBefore</a><span class="delimiter">)</span>
        <a href="#sbt.Index.update" title="(map: sbt.Index.TriggerMap, base: sbt.Task[_], tasksOpt: Option[Seq[sbt.Task[_]]])Unit">update</a><span class="delimiter">(</span><a href="#sbt.Index.triggers.triggeredBy" title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">triggeredBy</a>, <a href="#sbt.Index.triggers.$anonfun.$anonfun.value" title="sbt.Task[_]">value</a>, <a href="#sbt.Index.triggers.$anonfun.$anonfun.as" title="sbt.AttributeMap">as</a> <a href="Attributes.scala.html#sbt;AttributeMap.get" title="(k: sbt.AttributeKey[Seq[sbt.Task[_]]])Option[Seq[sbt.Task[_]]]">get</a> <a href="Keys.scala.html#sbt.Keys" title="sbt.Keys.type">Keys</a>.<a href="Keys.scala.html#sbt.Keys.triggeredBy" title="=&gt; sbt.AttributeKey[Seq[sbt.Task[_]]]">triggeredBy</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="() =&gt; Unit" id="sbt.Index.triggers.onComplete">onComplete</a> = <a href="Keys.scala.html#sbt.Keys" title="sbt.Keys.type">Keys</a>.<a href="Keys.scala.html#sbt.Keys.onComplete" title="=&gt; sbt.SettingKey[() =&gt; Unit]">onComplete</a> <a href="Structure.scala.html#sbt;SettingKey.in(7e2eebbf08)" title="(scope: sbt.Scope)sbt.SettingKey[() =&gt; Unit]">in</a> <a href="Scope.scala.html#sbt.Scope.GlobalScope" title="=&gt; sbt.Scope">GlobalScope</a> <a href="Structure.scala.html#sbt.Scoped;DefinableSetting.get" title="(settings: sbt.Settings[sbt.Scope])Option[() =&gt; Unit]">get</a> <a href="#sbt.Index.triggers.ss" title="sbt.Settings[sbt.Scope]">ss</a> <span title="(default: =&gt; () =&gt; Unit)() =&gt; Unit">getOrElse</span> <span class="delimiter">{</span> <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span title="sbt.Triggers[sbt.Task]" class="keyword">new</span> <a href="Execute.scala.html#sbt;Triggers" title="sbt.Triggers[sbt.Task]">Triggers</a><span class="delimiter">[</span>Task<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.Index.triggers.runBefore" title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">runBefore</a>, <a href="#sbt.Index.triggers.triggeredBy" title="scala.collection.mutable.HashMap[sbt.Task[_],Seq[sbt.Task[_]]]">triggeredBy</a>, <a title="sbt.RMap[sbt.Task,sbt.Result]" id="sbt.Index.triggers.$anonfun.map">map</a> =&gt; <span class="delimiter">{</span> <a href="#sbt.Index.triggers.onComplete" title="()Unit">onComplete</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#sbt.Index.triggers.$anonfun.map" title="sbt.RMap[sbt.Task,sbt.Result]">map</a> <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(map: sbt.Index.TriggerMap, base: sbt.Task[_], tasksOpt: Option[Seq[sbt.Task[_]]])Unit" id="sbt.Index.update">update</a><span class="delimiter">(</span><a title="sbt.Index.TriggerMap" id="sbt.Index.update.map">map</a>: <span title="sbt.Index.TriggerMap">TriggerMap</span>, <a title="sbt.Task[_]" id="sbt.Index.update.base">base</a>: <a href="Action.scala.html#sbt;Task" title="sbt.Task[_]">Task</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Option[Seq[sbt.Task[_]]]" id="sbt.Index.update.tasksOpt">tasksOpt</a>: <span title="Option[Seq[sbt.Task[_]]]">Option</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Task<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Seq[sbt.Task[_]]" id="sbt.Index.update.$anonfun.tasks">tasks</a> &lt;- <a href="#sbt.Index.update.tasksOpt" title="(f: Seq[sbt.Task[_]] =&gt; Unit)Unit">tasksOpt</a>; <a title="sbt.Task[_]" id="sbt.Index.update.$anonfun.$anonfun.task">task</a> &lt;- <a href="#sbt.Index.update.$anonfun.tasks" title="(f: sbt.Task[_] =&gt; Unit)Unit">tasks</a><span class="delimiter">)</span>
      <a href="#sbt.Index.update.map" title="(key: sbt.Task[_], value: Seq[sbt.Task[_]])Unit">map</a><span class="delimiter">(</span><a href="#sbt.Index.update.$anonfun.$anonfun.task" title="sbt.Task[_]">task</a><span class="delimiter">)</span> = <a href="#sbt.Index.update.base" title="sbt.Task[_]">base</a> <a href="#sbt.Index.update.$anonfun.$anonfun.x$28" title="(elem: sbt.Task[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.Task[_]],sbt.Task[_],Seq[sbt.Task[_]]])Seq[sbt.Task[_]]">+:</a> <a href="#sbt.Index.update.map" title="sbt.Index.TriggerMap">map</a>.<span title="(key: sbt.Task[_], default: =&gt; Seq[sbt.Task[_]])Seq[sbt.Task[_]]">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Index.update.$anonfun.$anonfun.task" title="sbt.Task[_]">task</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
