<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Cache.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2009 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> sbinary.<span class="delimiter">{</span> CollectionTypes, DefaultProtocol, Format, Input, JavaFormats, Output =&gt; Out <span class="delimiter">}</span>
<span class="keyword">import</span> java.io.<span class="delimiter">{</span> ByteArrayInputStream, ByteArrayOutputStream, File, InputStream, OutputStream <span class="delimiter">}</span>
<span class="keyword">import</span> java.net.<span class="delimiter">{</span> URI, URL <span class="delimiter">}</span>
<span class="keyword">import</span> <a href="Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>.:+:
<span class="keyword">import</span> <span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<span class="delimiter">{</span> asProduct2, asSingleton, BooleanFormat, ByteFormat, IntFormat, wrap <span class="delimiter">}</span>
<span class="keyword">import</span> scala.xml.NodeSeq

<span class="keyword">trait</span> <a title="trait Cache[I, O] extends AnyRef" id="sbt;Cache">Cache</a><span class="delimiter">[</span><a title="" id="sbt;Cache;I">I</a>, <a title="" id="sbt;Cache;O">O</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(file: java.io.File)(i: I)Either[O,O =&gt; Unit]" id="sbt;Cache.apply">apply</a><span class="delimiter">(</span><a title="java.io.File" id="sbt;Cache.apply.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I" id="sbt;Cache.apply.i">i</a>: <a href="#sbt;Cache;I" title="I">I</a><span class="delimiter">)</span>: <span title="Either[O,O =&gt; Unit]">Either</span><span class="delimiter">[</span>O, O =&gt; Unit<span class="delimiter">]</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">trait</span> <a title="trait SBinaryFormats extends AnyRef with sbinary.CollectionTypes with sbinary.JavaFormats" id="sbt;SBinaryFormats">SBinaryFormats</a> <span title="Unit" class="keyword">extends</span> <span title="sbinary.CollectionTypes">CollectionTypes</span> <span class="keyword">with</span> <span title="sbinary.JavaFormats">JavaFormats</span> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[java.net.URL]" id="sbt;SBinaryFormats.urlFormat">urlFormat</a>: <span title="sbinary.Format[java.net.URL]">Format</span><span class="delimiter">[</span>URL<span class="delimiter">]</span> = <span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<span title="=&gt; sbinary.Format[java.net.URL]">UrlFormat</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[java.net.URI]" id="sbt;SBinaryFormats.uriFormat">uriFormat</a>: <span title="sbinary.Format[java.net.URI]">Format</span><span class="delimiter">[</span>URI<span class="delimiter">]</span> = <span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<span title="=&gt; sbinary.Format[java.net.URI]">UriFormat</span>
<span class="delimiter">}</span>
<span class="keyword">object</span> <a title="sbt.Cache.type" id="sbt.Cache">Cache</a> <a href="#sbt.Cache" title="sbt.Cache.type" class="keyword">extends</a> <a href="#sbt;CacheImplicits" title="sbt.CacheImplicits">CacheImplicits</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[I, O](implicit c: sbt.Cache[I,O])sbt.Cache[I,O]" id="sbt.Cache.cache">cache</a><span class="delimiter">[</span><a title="" id="sbt.Cache.cache;I">I</a>, <a title="" id="sbt.Cache.cache;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Cache[I,O]" id="sbt.Cache.cache.c">c</a>: <a href="#sbt;Cache" title="sbt.Cache[I,O]">Cache</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Cache" title="sbt.Cache[I,O]">Cache</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <a href="#sbt.Cache.cache.c" title="sbt.Cache[I,O]">c</a>

  <span class="keyword">def</span> <a title="[I, O](file: java.io.File)(f: I =&gt; O)(implicit cache: sbt.Cache[I,O])I =&gt; O" id="sbt.Cache.cached">cached</a><span class="delimiter">[</span><a title="" id="sbt.Cache.cached;I">I</a>, <a title="" id="sbt.Cache.cached;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.File" id="sbt.Cache.cached.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="I =&gt; O" id="sbt.Cache.cached.f">f</a>: I =&gt; O<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Cache[I,O]" id="sbt.Cache.cached.cache">cache</a>: <a href="#sbt;Cache" title="sbt.Cache[I,O]">Cache</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: I =&gt; O =
    <a title="I" id="sbt.Cache.cached.$anonfun.in">in</a> =&gt;
      <a href="#sbt;Cache.apply" title="(file: java.io.File)(i: I)Either[O,O =&gt; Unit]">cache</a><span class="delimiter">(</span><a href="#sbt.Cache.cached.file" title="java.io.File">file</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.Cache.cached.$anonfun.in" title="I">in</a><span class="delimiter">)</span> <span title="O" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="O" id="sbt.Cache.cached.$anonfun.value">value</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Cache.cached.$anonfun.value" title="O">value</a>
        <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="O =&gt; Unit" id="sbt.Cache.cached.$anonfun.store">store</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="O" id="sbt.Cache.cached.$anonfun.out">out</a> = <a href="#sbt.Cache.cached.f" title="(v1: I)O">f</a><span class="delimiter">(</span><a href="#sbt.Cache.cached.$anonfun.in" title="I">in</a><span class="delimiter">)</span>
          <a href="#sbt.Cache.cached.$anonfun.store" title="(v1: O)Unit">store</a><span class="delimiter">(</span><a href="#sbt.Cache.cached.$anonfun.out" title="O">out</a><span class="delimiter">)</span>
          <a href="#sbt.Cache.cached.$anonfun.out" title="O">out</a>
      <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[I](label: String, c: sbt.InputCache[I])sbt.InputCache[I]" id="sbt.Cache.debug">debug</a><span class="delimiter">[</span><a title="" id="sbt.Cache.debug;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="sbt.Cache.debug.label">label</a>: <span title="String">String</span>, <a title="sbt.InputCache[I]" id="sbt.Cache.debug.c">c</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[I]">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[I]">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span> =
    <a href="#sbt.Cache.debug;$anon" title="sbt.InputCache[I]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.InputCache[I]" id="sbt.Cache.debug;$anon">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="c.Internal" id="sbt.Cache.debug;$anon;Internal">Internal</a> = c.<a href="SeparatedCache.scala.html#sbt;InputCache;Internal" title="c.Internal">Internal</a>
      <span class="keyword">def</span> <a title="(i: I)c.Internal" id="sbt.Cache.debug;$anon.convert">convert</a><span class="delimiter">(</span><a title="I" id="sbt.Cache.debug;$anon.convert.i">i</a>: <a href="#sbt.Cache.debug;I" title="I">I</a><span class="delimiter">)</span> = <a href="#sbt.Cache.debug.c" title="sbt.InputCache[I]">c</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: I)c.Internal">convert</a><span class="delimiter">(</span><a href="#sbt.Cache.debug;$anon.convert.i" title="I">i</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(from: sbinary.Input)c.Internal" id="sbt.Cache.debug;$anon.read">read</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt.Cache.debug;$anon.read.from">from</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="c.Internal" id="sbt.Cache.debug;$anon.read.v">v</a> = <a href="#sbt.Cache.debug.c" title="sbt.InputCache[I]">c</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)c.Internal">read</a><span class="delimiter">(</span><a href="#sbt.Cache.debug;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
          <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#sbt.Cache.debug.label" title="String">label</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.read: &quot;)" class="string">&quot;.read: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Cache.debug;$anon.read.v" title="c.Internal">v</a><span class="delimiter">)</span>
          <a href="#sbt.Cache.debug;$anon.read.v" title="c.Internal">v</a>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(to: sbinary.Output, v: this.Internal)Unit" id="sbt.Cache.debug;$anon.write">write</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt.Cache.debug;$anon.write.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="this.Internal" id="sbt.Cache.debug;$anon.write.v">v</a>: <a href="SeparatedCache.scala.html#sbt;InputCache;Internal" title="this.Internal">Internal</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#sbt.Cache.debug.label" title="String">label</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.write: &quot;)" class="string">&quot;.write: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Cache.debug;$anon.write.v" title="this.Internal">v</a><span class="delimiter">)</span>
        <a href="#sbt.Cache.debug.c" title="sbt.InputCache[I]">c</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: c.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt.Cache.debug;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt.Cache.debug;$anon.write.v" title="this.Internal">v</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Equiv[this.Internal]" id="sbt.Cache.debug;$anon.equiv">equiv</a>: <span title="Equiv[this.Internal]">Equiv</span><span class="delimiter">[</span>Internal<span class="delimiter">]</span> = <a href="#sbt.Cache.debug;$anon.equiv;$anon" title="Equiv[this.Internal]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[this.Internal]" id="sbt.Cache.debug;$anon.equiv;$anon">Equiv</a><span class="delimiter">[</span>Internal<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(a: this.Internal, b: this.Internal)Boolean" id="sbt.Cache.debug;$anon.equiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="this.Internal" id="sbt.Cache.debug;$anon.equiv;$anon.equiv.a">a</a>: <a href="SeparatedCache.scala.html#sbt;InputCache;Internal" title="this.Internal">Internal</a>, <a title="this.Internal" id="sbt.Cache.debug;$anon.equiv;$anon.equiv.b">b</a>: <a href="SeparatedCache.scala.html#sbt;InputCache;Internal" title="this.Internal">Internal</a><span class="delimiter">)</span> =
          <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Boolean" id="sbt.Cache.debug;$anon.equiv;$anon.equiv.equ">equ</a> = <a href="#sbt.Cache.debug.c" title="sbt.InputCache[I]">c</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[c.Internal]">equiv</a>.<span title="(x: c.Internal, y: c.Internal)Boolean">equiv</span><span class="delimiter">(</span><a href="#sbt.Cache.debug;$anon.equiv;$anon.equiv.a" title="this.Internal">a</a>, <a href="#sbt.Cache.debug;$anon.equiv;$anon.equiv.b" title="this.Internal">b</a><span class="delimiter">)</span>
            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#sbt.Cache.debug.label" title="String">label</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.equiv(&quot;)" class="string">&quot;.equiv(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Cache.debug;$anon.equiv;$anon.equiv.a" title="this.Internal">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Cache.debug;$anon.equiv;$anon.equiv.b" title="this.Internal">b</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;): &quot;)" class="string">&quot;): &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Cache.debug;$anon.equiv;$anon.equiv.equ" title="Boolean">equ</a><span class="delimiter">)</span>
            <a href="#sbt.Cache.debug;$anon.equiv;$anon.equiv.equ" title="Boolean">equ</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span class="keyword">trait</span> <a title="trait CacheImplicits extends AnyRef with sbt.BasicCacheImplicits with sbt.SBinaryFormats with sbt.HListCacheImplicits with sbt.UnionImplicits" id="sbt;CacheImplicits">CacheImplicits</a> <span class="keyword">extends</span> <a href="#sbt;BasicCacheImplicits" title="sbt.BasicCacheImplicits">BasicCacheImplicits</a> <span class="keyword">with</span> <a href="#sbt;SBinaryFormats" title="sbt.SBinaryFormats">SBinaryFormats</a> <span class="keyword">with</span> <a href="#sbt;HListCacheImplicits" title="sbt.HListCacheImplicits">HListCacheImplicits</a> <span class="keyword">with</span> <a href="#sbt;UnionImplicits" title="sbt.UnionImplicits">UnionImplicits</a>
<span class="keyword">trait</span> <a title="trait BasicCacheImplicits extends AnyRef" id="sbt;BasicCacheImplicits">BasicCacheImplicits</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[I, O](implicit in: sbt.InputCache[I], implicit outFormat: sbinary.Format[O])sbt.Cache[I,O]" id="sbt;BasicCacheImplicits.basicCache">basicCache</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.basicCache;I">I</a>, <a title="" id="sbt;BasicCacheImplicits.basicCache;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.InputCache[I]" id="sbt;BasicCacheImplicits.basicCache.in">in</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[I]">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="sbinary.Format[O]" id="sbt;BasicCacheImplicits.basicCache.outFormat">outFormat</a>: <span title="sbinary.Format[O]">Format</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Cache" title="sbt.Cache[I,O]">Cache</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <span title="sbt.BasicCache[I,O]" class="keyword">new</span> <a href="SeparatedCache.scala.html#sbt;BasicCache" title="sbt.BasicCache[I,O]">BasicCache</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.basicCache.in" title="sbt.InputCache[I]">in</a>, <a href="#sbt;BasicCacheImplicits.basicCache.outFormat" title="sbinary.Format[O]">outFormat</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[I](implicit eq: Equiv[I], implicit fmt: sbinary.Format[I])sbt.InputCache[I]" id="sbt;BasicCacheImplicits.basicInput">basicInput</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.basicInput;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Equiv[I]" id="sbt;BasicCacheImplicits.basicInput.eq">eq</a>: <span title="Equiv[I]">Equiv</span><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="sbinary.Format[I]" id="sbt;BasicCacheImplicits.basicInput.fmt">fmt</a>: <span title="sbinary.Format[I]">Format</span><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[I]">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span> = <a href="SeparatedCache.scala.html#sbt.InputCache" title="sbt.InputCache.type">InputCache</a>.<a href="SeparatedCache.scala.html#sbt.InputCache.basicInputCache" title="(implicit fmt: sbinary.Format[I], implicit eqv: Equiv[I])sbt.InputCache[I]">basicInputCache</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.basicInput.fmt" title="sbinary.Format[I]">fmt</a>, <a href="#sbt;BasicCacheImplicits.basicInput.eq" title="Equiv[I]">eq</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T]=&gt; Equiv[T]" id="sbt;BasicCacheImplicits.defaultEquiv">defaultEquiv</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.defaultEquiv;T">T</a><span class="delimiter">]</span>: <span title="Equiv[T]">Equiv</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.defaultEquiv;$anon" title="Equiv[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[T]" id="sbt;BasicCacheImplicits.defaultEquiv;$anon">Equiv</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="(a: T, b: T)Boolean" id="sbt;BasicCacheImplicits.defaultEquiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.defaultEquiv;$anon.equiv.a">a</a>: <a href="#sbt;BasicCacheImplicits.defaultEquiv;T" title="T">T</a>, <a title="T" id="sbt;BasicCacheImplicits.defaultEquiv;$anon.equiv.b">b</a>: <a href="#sbt;BasicCacheImplicits.defaultEquiv;T" title="T">T</a><span class="delimiter">)</span> = <a href="#sbt;BasicCacheImplicits.defaultEquiv;$anon.equiv.a" title="T">a</a> <span title="(x$1: Any)Boolean">==</span> <a href="#sbt;BasicCacheImplicits.defaultEquiv;$anon.equiv.b" title="T">b</a> <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](implicit t: sbt.InputCache[T])sbt.InputCache[Option[T]]" id="sbt;BasicCacheImplicits.optInputCache">optInputCache</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.optInputCache;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.InputCache[T]" id="sbt;BasicCacheImplicits.optInputCache.t">t</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[T]">InputCache</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[Option[T]]">InputCache</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.optInputCache;$anon" title="sbt.InputCache[Option[T]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.InputCache[Option[T]]" id="sbt;BasicCacheImplicits.optInputCache;$anon">InputCache</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="Option[t.Internal]" id="sbt;BasicCacheImplicits.optInputCache;$anon;Internal">Internal</a> = <span title="Option[t.Internal]">Option</span><span class="delimiter">[</span>t.Internal<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(v: Option[T])this.Internal" id="sbt;BasicCacheImplicits.optInputCache;$anon.convert">convert</a><span class="delimiter">(</span><a title="Option[T]" id="sbt;BasicCacheImplicits.optInputCache;$anon.convert.v">v</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="this.Internal">Internal</span> = <a href="#sbt;BasicCacheImplicits.optInputCache;$anon.convert.v" title="Option[T]">v</a>.<span title="(f: T =&gt; t.Internal)Option[t.Internal]">map</span><span class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.optInputCache;$anon.convert.$anonfun.x">x</a> =&gt; <a href="#sbt;BasicCacheImplicits.optInputCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: T)t.Internal">convert</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache;$anon.convert.$anonfun.x" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(from: sbinary.Input)this.Internal" id="sbt;BasicCacheImplicits.optInputCache;$anon.read">read</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt;BasicCacheImplicits.optInputCache;$anon.read.from">from</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Boolean" id="sbt;BasicCacheImplicits.optInputCache;$anon.read.isDefined">isDefined</a> = <span title="sbinary.DefaultProtocol.BooleanFormat.type">BooleanFormat</span>.<span title="(in: sbinary.Input)Boolean">reads</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
          <span title="this.Internal" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache;$anon.read.isDefined" title="Boolean">isDefined</a><span class="delimiter">)</span> <span title="(x: t.Internal)Some[t.Internal]">Some</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)t.Internal">read</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="None.type">None</span>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(to: sbinary.Output, j: this.Internal)Unit" id="sbt;BasicCacheImplicits.optInputCache;$anon.write">write</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt;BasicCacheImplicits.optInputCache;$anon.write.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="this.Internal" id="sbt;BasicCacheImplicits.optInputCache;$anon.write.j">j</a>: <span title="this.Internal">Internal</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
        <span class="delimiter">{</span>
          <span title="sbinary.DefaultProtocol.BooleanFormat.type">BooleanFormat</span>.<span title="(out: sbinary.Output, t: Boolean)Unit">writes</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;BasicCacheImplicits.optInputCache;$anon.write.j" title="this.Internal">j</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>
          <a href="#sbt;BasicCacheImplicits.optInputCache;$anon.write.j" title="this.Internal">j</a> <span title="(f: t.Internal =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="t.Internal" id="sbt;BasicCacheImplicits.optInputCache;$anon.write.$anonfun.x">x</a> =&gt; <a href="#sbt;BasicCacheImplicits.optInputCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: t.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;BasicCacheImplicits.optInputCache;$anon.write.$anonfun.x" title="t.Internal">x</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Equiv[Option[t.Internal]]" id="sbt;BasicCacheImplicits.optInputCache;$anon.equiv">equiv</a> = <a href="#sbt;BasicCacheImplicits.optEquiv" title="(implicit t: Equiv[t.Internal])Equiv[Option[t.Internal]]">optEquiv</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optInputCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[t.Internal]">equiv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[S, T](f: S =&gt; T)(implicit eqT: Equiv[T])Equiv[S]" id="sbt;BasicCacheImplicits.wrapEquiv">wrapEquiv</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.wrapEquiv;S">S</a>, <a title="" id="sbt;BasicCacheImplicits.wrapEquiv;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; T" id="sbt;BasicCacheImplicits.wrapEquiv.f">f</a>: S =&gt; T<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Equiv[T]" id="sbt;BasicCacheImplicits.wrapEquiv.eqT">eqT</a>: <span title="Equiv[T]">Equiv</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Equiv[S]">Equiv</span><span class="delimiter">[</span>S<span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.wrapEquiv;$anon" title="Equiv[S]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[S]" id="sbt;BasicCacheImplicits.wrapEquiv;$anon">Equiv</a><span class="delimiter">[</span>S<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(a: S, b: S)Boolean" id="sbt;BasicCacheImplicits.wrapEquiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="S" id="sbt;BasicCacheImplicits.wrapEquiv;$anon.equiv.a">a</a>: <a href="#sbt;BasicCacheImplicits.wrapEquiv;S" title="S">S</a>, <a title="S" id="sbt;BasicCacheImplicits.wrapEquiv;$anon.equiv.b">b</a>: <a href="#sbt;BasicCacheImplicits.wrapEquiv;S" title="S">S</a><span class="delimiter">)</span> =
        <a href="#sbt;BasicCacheImplicits.wrapEquiv.eqT" title="Equiv[T]">eqT</a>.<span title="(x: T, y: T)Boolean">equiv</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapEquiv.f" title="(v1: S)T">f</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapEquiv;$anon.equiv.a" title="S">a</a><span class="delimiter">)</span>, <a href="#sbt;BasicCacheImplicits.wrapEquiv.f" title="(v1: S)T">f</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapEquiv;$anon.equiv.b" title="S">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](implicit t: Equiv[T])Equiv[Option[T]]" id="sbt;BasicCacheImplicits.optEquiv">optEquiv</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.optEquiv;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Equiv[T]" id="sbt;BasicCacheImplicits.optEquiv.t">t</a>: <span title="Equiv[T]">Equiv</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Equiv[Option[T]]">Equiv</span><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.optEquiv;$anon" title="Equiv[Option[T]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[Option[T]]" id="sbt;BasicCacheImplicits.optEquiv;$anon">Equiv</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(a: Option[T], b: Option[T])Boolean" id="sbt;BasicCacheImplicits.optEquiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="Option[T]" id="sbt;BasicCacheImplicits.optEquiv;$anon.equiv.a">a</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Option[T]" id="sbt;BasicCacheImplicits.optEquiv;$anon.equiv.b">b</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
        <span title="(_1: Option[T], _2: Option[T])(Option[T], Option[T])" class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optEquiv;$anon.equiv.a" title="Option[T]">a</a>, <a href="#sbt;BasicCacheImplicits.optEquiv;$anon.equiv.b" title="Option[T]">b</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span class="delimiter">(</span><span title="None.type">None</span>, <span title="None.type">None</span><span class="delimiter">)</span>         =&gt; <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span class="delimiter">(</span>Some<span class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.optEquiv;$anon.equiv.va">va</a><span class="delimiter">)</span>, Some<span class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.optEquiv;$anon.equiv.vb">vb</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#sbt;BasicCacheImplicits.optEquiv.t" title="Equiv[T]">t</a>.<span title="(x: T, y: T)Boolean">equiv</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.optEquiv;$anon.equiv.va" title="T">va</a>, <a href="#sbt;BasicCacheImplicits.optEquiv;$anon.equiv.vb" title="T">vb</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _                    =&gt; <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.BasicCacheImplicits.urlEquiv : (implicit uriEq: Equiv[java.net.URI])Equiv[java.net.URL]" id="sbt;BasicCacheImplicits.urlEquiv">urlEquiv</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Equiv[java.net.URI]" id="sbt;BasicCacheImplicits.urlEquiv.uriEq">uriEq</a>: <span title="Equiv[java.net.URI]">Equiv</span><span class="delimiter">[</span>URI<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Equiv[java.net.URL]">Equiv</span><span class="delimiter">[</span>URL<span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.wrapEquiv" title="[S, T](f: S =&gt; T)(implicit eqT: Equiv[T])Equiv[S]">wrapEquiv</a><span title="(f: java.net.URL =&gt; java.net.URI)(implicit eqT: Equiv[java.net.URI])Equiv[java.net.URL]" class="delimiter">[</span><span title="java.net.URL">URL</span>, <span title="java.net.URI">URI</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.urlEquiv.$anonfun.x$1" title="java.net.URL">_</a>.<span title="()java.net.URI">toURI</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.urlEquiv.uriEq" title="Equiv[java.net.URI]">uriEq</a><span class="delimiter">)</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; Equiv[java.net.URI]" id="sbt;BasicCacheImplicits.uriEquiv">uriEquiv</a>: <span title="Equiv[java.net.URI]">Equiv</span><span class="delimiter">[</span>URI<span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.defaultEquiv" title="Equiv[java.net.URI]">defaultEquiv</a>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; Equiv[Set[String]]" id="sbt;BasicCacheImplicits.stringSetEquiv">stringSetEquiv</a>: <span title="Equiv[Set[String]]">Equiv</span><span class="delimiter">[</span>Set<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.defaultEquiv" title="Equiv[Set[String]]">defaultEquiv</a>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; Equiv[Map[String,String]]" id="sbt;BasicCacheImplicits.stringMapEquiv">stringMapEquiv</a>: <span title="Equiv[Map[String,String]]">Equiv</span><span class="delimiter">[</span>Map<span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.defaultEquiv" title="Equiv[Map[String,String]]">defaultEquiv</a>

  <span class="keyword">def</span> <a title="[T](write: (T, java.io.OutputStream) =&gt; Unit, f: java.io.InputStream =&gt; T)sbinary.Format[T]" id="sbt;BasicCacheImplicits.streamFormat">streamFormat</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.streamFormat;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(T, java.io.OutputStream) =&gt; Unit" id="sbt;BasicCacheImplicits.streamFormat.write">write</a>: <span class="delimiter">(</span>T, OutputStream<span class="delimiter">)</span> =&gt; Unit, <a title="java.io.InputStream =&gt; T" id="sbt;BasicCacheImplicits.streamFormat.f">f</a>: InputStream =&gt; T<span class="delimiter">)</span>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="T =&gt; Array[Byte]" id="sbt;BasicCacheImplicits.streamFormat.toBytes">toBytes</a> = <span class="delimiter">(</span>t: <a href="#sbt;BasicCacheImplicits.streamFormat;T" title="T">T</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span> <span class="keyword">val</span> <a title="java.io.ByteArrayOutputStream" id="sbt;BasicCacheImplicits.streamFormat.toBytes.$anonfun.bos">bos</a> = <span title="java.io.ByteArrayOutputStream" class="keyword">new</span> <span title="java.io.ByteArrayOutputStream">ByteArrayOutputStream</span>; <a href="#sbt;BasicCacheImplicits.streamFormat.write" title="(v1: T, v2: java.io.OutputStream)Unit">write</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.streamFormat.toBytes.$anonfun.t" title="T">t</a>, <a href="#sbt;BasicCacheImplicits.streamFormat.toBytes.$anonfun.bos" title="java.io.ByteArrayOutputStream">bos</a><span class="delimiter">)</span>; <a href="#sbt;BasicCacheImplicits.streamFormat.toBytes.$anonfun.bos" title="java.io.ByteArrayOutputStream">bos</a>.<span title="()Array[Byte]">toByteArray</span> <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Array[Byte] =&gt; T" id="sbt;BasicCacheImplicits.streamFormat.fromBytes">fromBytes</a> = <span class="delimiter">(</span>bs: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#sbt;BasicCacheImplicits.streamFormat.f" title="(v1: java.io.InputStream)T">f</a><span class="delimiter">(</span><span title="java.io.ByteArrayInputStream" class="keyword">new</span> <span title="java.io.ByteArrayInputStream">ByteArrayInputStream</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.streamFormat.fromBytes.$anonfun.bs" title="Array[Byte]">bs</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(to: T =&gt; Array[Byte], from: Array[Byte] =&gt; T)(implicit bin: sbinary.Format[Array[Byte]])sbinary.Format[T]">wrap</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.streamFormat.toBytes" title="T =&gt; Array[Byte]">toBytes</a>, <a href="#sbt;BasicCacheImplicits.streamFormat.fromBytes" title="Array[Byte] =&gt; T">fromBytes</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<span title="sbinary.DefaultProtocol.ByteArrayFormat.type">ByteArrayFormat</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.BasicCacheImplicits.xmlInputCache : (implicit strEq: sbt.InputCache[String])sbt.InputCache[scala.xml.NodeSeq]" id="sbt;BasicCacheImplicits.xmlInputCache">xmlInputCache</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.InputCache[String]" id="sbt;BasicCacheImplicits.xmlInputCache.strEq">strEq</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[String]">InputCache</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[scala.xml.NodeSeq]">InputCache</a><span class="delimiter">[</span>NodeSeq<span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.wrapIn" title="[I, J](implicit f: I =&gt; J, implicit jCache: sbt.InputCache[J])sbt.InputCache[I]">wrapIn</a><span title="(implicit f: scala.xml.NodeSeq =&gt; String, implicit jCache: sbt.InputCache[String])sbt.InputCache[scala.xml.NodeSeq]" class="delimiter">[</span><span title="scala.xml.NodeSeq">NodeSeq</span>, <span title="String">String</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.xmlInputCache.$anonfun.x$2" title="scala.xml.NodeSeq">_</a>.<span title="()String">toString</span>, <a href="#sbt;BasicCacheImplicits.xmlInputCache.strEq" title="sbt.InputCache[String]">strEq</a><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](implicit t: sbt.InputCache[T])sbt.InputCache[Seq[T]]" id="sbt;BasicCacheImplicits.seqCache">seqCache</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.seqCache;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.InputCache[T]" id="sbt;BasicCacheImplicits.seqCache.t">t</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[T]">InputCache</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[Seq[T]]">InputCache</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.seqCache;$anon" title="sbt.InputCache[Seq[T]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.InputCache[Seq[T]]" id="sbt;BasicCacheImplicits.seqCache;$anon">InputCache</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="Seq[t.Internal]" id="sbt;BasicCacheImplicits.seqCache;$anon;Internal">Internal</a> = <span title="Seq[t.Internal]">Seq</span><span class="delimiter">[</span>t.Internal<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(v: Seq[T])this.Internal" id="sbt;BasicCacheImplicits.seqCache;$anon.convert">convert</a><span class="delimiter">(</span><a title="Seq[T]" id="sbt;BasicCacheImplicits.seqCache;$anon.convert.v">v</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;BasicCacheImplicits.seqCache;$anon.convert.v" title="Seq[T]">v</a>.<span title="(f: T =&gt; t.Internal)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],t.Internal,this.Internal])this.Internal">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,t.Internal,Seq[t.Internal]]" class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.seqCache;$anon.convert.$anonfun.x">x</a> =&gt; <a href="#sbt;BasicCacheImplicits.seqCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: T)t.Internal">convert</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.convert.$anonfun.x" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(from: sbinary.Input)this.Internal" id="sbt;BasicCacheImplicits.seqCache;$anon.read">read</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt;BasicCacheImplicits.seqCache;$anon.read.from">from</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Int" id="sbt;BasicCacheImplicits.seqCache;$anon.read.size">size</a> = <span title="sbinary.DefaultProtocol.IntFormat.type">IntFormat</span>.<span title="(in: sbinary.Input)Int">reads</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(left: Int, acc: List[t.Internal])this.Internal" id="sbt;BasicCacheImplicits.seqCache;$anon.read.next">next</a><span class="delimiter">(</span><a title="Int" id="sbt;BasicCacheImplicits.seqCache;$anon.read.next.left">left</a>: <span title="Int">Int</span>, <a title="List[t.Internal]" id="sbt;BasicCacheImplicits.seqCache;$anon.read.next.acc">acc</a>: <span title="List[t.Internal]">List</span><span class="delimiter">[</span>t.Internal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="this.Internal">Internal</span> =
            <span title="this.Internal" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next.left" title="Int">left</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next.acc" title="List[t.Internal]">acc</a>.<span title="=&gt; List[t.Internal]">reverse</span> <span class="keyword">else</span> <a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next" title="(left: Int, acc: List[t.Internal])this.Internal">next</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next.left" title="Int">left</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#sbt;BasicCacheImplicits.seqCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)t.Internal">read</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span> <a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next.x$3" title="(x: t.Internal)List[t.Internal]">::</a> <a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next.acc" title="List[t.Internal]">acc</a><span class="delimiter">)</span>
          <a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.next" title="(left: Int, acc: List[t.Internal])this.Internal">next</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.read.size" title="Int">size</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(to: sbinary.Output, vs: this.Internal)Unit" id="sbt;BasicCacheImplicits.seqCache;$anon.write">write</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt;BasicCacheImplicits.seqCache;$anon.write.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="this.Internal" id="sbt;BasicCacheImplicits.seqCache;$anon.write.vs">vs</a>: <span title="this.Internal">Internal</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Int" id="sbt;BasicCacheImplicits.seqCache;$anon.write.size">size</a> = <a href="#sbt;BasicCacheImplicits.seqCache;$anon.write.vs" title="this.Internal">vs</a>.<span title="=&gt; Int">length</span>
        <span title="sbinary.DefaultProtocol.IntFormat.type">IntFormat</span>.<span title="(out: sbinary.Output, t: Int)Unit">writes</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;BasicCacheImplicits.seqCache;$anon.write.size" title="Int">size</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="t.Internal" id="sbt;BasicCacheImplicits.seqCache;$anon.write.$anonfun.v">v</a> &lt;- <a href="#sbt;BasicCacheImplicits.seqCache;$anon.write.vs" title="(f: t.Internal =&gt; Unit)Unit">vs</a><span class="delimiter">)</span> <a href="#sbt;BasicCacheImplicits.seqCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: t.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;BasicCacheImplicits.seqCache;$anon.write.$anonfun.v" title="t.Internal">v</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Equiv[this.Internal]" id="sbt;BasicCacheImplicits.seqCache;$anon.equiv">equiv</a>: <span title="Equiv[this.Internal]">Equiv</span><span class="delimiter">[</span>Internal<span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.seqEquiv" title="(implicit t: Equiv[t.Internal])Equiv[Seq[t.Internal]]">seqEquiv</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqCache.t" title="sbt.InputCache[T]">t</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[t.Internal]">equiv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](implicit t: Equiv[T])Equiv[Array[T]]" id="sbt;BasicCacheImplicits.arrEquiv">arrEquiv</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.arrEquiv;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Equiv[T]" id="sbt;BasicCacheImplicits.arrEquiv.t">t</a>: <span title="Equiv[T]">Equiv</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Equiv[Array[T]]">Equiv</span><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.wrapEquiv" title="(f: Array[T] =&gt; Seq[T])(implicit eqT: Equiv[Seq[T]])Equiv[Array[T]]">wrapEquiv</a><span class="delimiter">(</span><span class="delimiter">(</span>x: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#sbt;BasicCacheImplicits.arrEquiv.$anonfun.x" title="(xs: Array[T])scala.collection.mutable.WrappedArray[T]">x</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqEquiv" title="[T](implicit t: Equiv[T])Equiv[Seq[T]]">seqEquiv</a><span title="(implicit t: Equiv[T])Equiv[Seq[T]]" class="delimiter">[</span><a href="#sbt;BasicCacheImplicits.arrEquiv;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.arrEquiv.t" title="Equiv[T]">t</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](implicit t: Equiv[T])Equiv[Seq[T]]" id="sbt;BasicCacheImplicits.seqEquiv">seqEquiv</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.seqEquiv;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Equiv[T]" id="sbt;BasicCacheImplicits.seqEquiv.t">t</a>: <span title="Equiv[T]">Equiv</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Equiv[Seq[T]]">Equiv</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.seqEquiv;$anon" title="Equiv[Seq[T]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[Seq[T]]" id="sbt;BasicCacheImplicits.seqEquiv;$anon">Equiv</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(a: Seq[T], b: Seq[T])Boolean" id="sbt;BasicCacheImplicits.seqEquiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="Seq[T]" id="sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.a">a</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Seq[T]" id="sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.b">b</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.a" title="Seq[T]">a</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <a href="#sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.b" title="Seq[T]">b</a>.<span title="=&gt; Int">length</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <span class="delimiter">(</span><span title="(x: (Seq[T], Seq[T]))runtime.Tuple2Zipped.Ops[Seq[T],Seq[T]]" class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.a" title="Seq[T]">a</a>, <a href="#sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.b" title="Seq[T]">b</a><span class="delimiter">)</span>.<span title="(implicit w1: Seq[T] =&gt; scala.collection.TraversableLike[T,Seq[T]], implicit w2: Seq[T] =&gt; scala.collection.IterableLike[T,Seq[T]])scala.runtime.Tuple2Zipped[T,Seq[T],T,Seq[T]]">zipped</span> <span title="(f: (T, T) =&gt; Boolean)Boolean">forall</span> <a href="#sbt;BasicCacheImplicits.seqEquiv.t" title="Equiv[T]">t</a>.<a href="#sbt;BasicCacheImplicits.seqEquiv;$anon.equiv.$anonfun.x" title="(x: T, y: T)Boolean">equiv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](implicit t: sbinary.Format[T])sbinary.Format[Seq[T]]" id="sbt;BasicCacheImplicits.seqFormat">seqFormat</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.seqFormat;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbinary.Format[T]" id="sbt;BasicCacheImplicits.seqFormat.t">t</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="sbinary.Format[Seq[T]]">Format</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="[S, T](to: S =&gt; T, from: T =&gt; S)(implicit bin: sbinary.Format[T])sbinary.Format[S]">wrap</span><span title="(to: Seq[T] =&gt; List[T], from: List[T] =&gt; Seq[T])(implicit bin: sbinary.Format[List[T]])sbinary.Format[Seq[T]]" class="delimiter">[</span><span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.seqFormat.$anonfun.x$4" title="Seq[T]">_</a>.<span title="=&gt; List[T]">toList</span>, <a href="#sbt;BasicCacheImplicits.seqFormat.$anonfun.x$5" title="List[T]">_</a>.<span title="=&gt; scala.collection.immutable.Seq[T]">toSeq</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<a href="#sbt;BasicCacheImplicits.seqFormat.t" title="(implicit bin: sbinary.Format[T])sbinary.Format[List[T]]">listFormat</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[I, J](implicit f: I =&gt; J, implicit jCache: sbt.InputCache[J])sbt.InputCache[I]" id="sbt;BasicCacheImplicits.wrapIn">wrapIn</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.wrapIn;I">I</a>, <a title="" id="sbt;BasicCacheImplicits.wrapIn;J">J</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="I =&gt; J" id="sbt;BasicCacheImplicits.wrapIn.f">f</a>: I =&gt; J, <a title="sbt.InputCache[J]" id="sbt;BasicCacheImplicits.wrapIn.jCache">jCache</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[J]">InputCache</a><span class="delimiter">[</span>J<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[I]">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.wrapIn;$anon" title="sbt.InputCache[I]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.InputCache[I]" id="sbt;BasicCacheImplicits.wrapIn;$anon">InputCache</a><span class="delimiter">[</span>I<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="jCache.Internal" id="sbt;BasicCacheImplicits.wrapIn;$anon;Internal">Internal</a> = jCache.<a href="SeparatedCache.scala.html#sbt;InputCache;Internal" title="jCache.Internal">Internal</a>
      <span class="keyword">def</span> <a title="(i: I)jCache.Internal" id="sbt;BasicCacheImplicits.wrapIn;$anon.convert">convert</a><span class="delimiter">(</span><a title="I" id="sbt;BasicCacheImplicits.wrapIn;$anon.convert.i">i</a>: <a href="#sbt;BasicCacheImplicits.wrapIn;I" title="I">I</a><span class="delimiter">)</span> = <a href="#sbt;BasicCacheImplicits.wrapIn.jCache" title="sbt.InputCache[J]">jCache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: J)jCache.Internal">convert</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapIn.f" title="(v1: I)J">f</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapIn;$anon.convert.i" title="I">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(from: sbinary.Input)jCache.Internal" id="sbt;BasicCacheImplicits.wrapIn;$anon.read">read</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt;BasicCacheImplicits.wrapIn;$anon.read.from">from</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> = <a href="#sbt;BasicCacheImplicits.wrapIn.jCache" title="sbt.InputCache[J]">jCache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)jCache.Internal">read</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapIn;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(to: sbinary.Output, j: this.Internal)Unit" id="sbt;BasicCacheImplicits.wrapIn;$anon.write">write</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt;BasicCacheImplicits.wrapIn;$anon.write.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="this.Internal" id="sbt;BasicCacheImplicits.wrapIn;$anon.write.j">j</a>: <a href="SeparatedCache.scala.html#sbt;InputCache;Internal" title="this.Internal">Internal</a><span class="delimiter">)</span> = <a href="#sbt;BasicCacheImplicits.wrapIn.jCache" title="sbt.InputCache[J]">jCache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: jCache.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.wrapIn;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;BasicCacheImplicits.wrapIn;$anon.write.j" title="this.Internal">j</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="=&gt; Equiv[jCache.Internal]" id="sbt;BasicCacheImplicits.wrapIn;$anon.equiv">equiv</a> = <a href="#sbt;BasicCacheImplicits.wrapIn.jCache" title="sbt.InputCache[J]">jCache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[jCache.Internal]">equiv</a>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T](t: T)sbt.InputCache[T]" id="sbt;BasicCacheImplicits.singleton">singleton</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.singleton;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.singleton.t">t</a>: <a href="#sbt;BasicCacheImplicits.singleton;T" title="T">T</a><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[T]">InputCache</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt;BasicCacheImplicits.basicInput" title="(implicit eq: Equiv[T], implicit fmt: sbinary.Format[T])sbt.InputCache[T]">basicInput</a><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.trueEquiv" title="trueEquiv extends AnyRef with Equiv[T]">trueEquiv</a>, <span title="(t: T)sbinary.Format[T]">asSingleton</span><span class="delimiter">(</span><a href="#sbt;BasicCacheImplicits.singleton.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T]=&gt; Equiv[T]" id="sbt;BasicCacheImplicits.trueEquiv">trueEquiv</a><span class="delimiter">[</span><a title="" id="sbt;BasicCacheImplicits.trueEquiv;T">T</a><span class="delimiter">]</span> = <a href="#sbt;BasicCacheImplicits.trueEquiv;$anon" title="Equiv[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[T]" id="sbt;BasicCacheImplicits.trueEquiv;$anon">Equiv</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="(a: T, b: T)Boolean" id="sbt;BasicCacheImplicits.trueEquiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="T" id="sbt;BasicCacheImplicits.trueEquiv;$anon.equiv.a">a</a>: <a href="#sbt;BasicCacheImplicits.trueEquiv;T" title="T">T</a>, <a title="T" id="sbt;BasicCacheImplicits.trueEquiv;$anon.equiv.b">b</a>: <a href="#sbt;BasicCacheImplicits.trueEquiv;T" title="T">T</a><span class="delimiter">)</span> = <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait HListCacheImplicits extends AnyRef" id="sbt;HListCacheImplicits">HListCacheImplicits</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H, T &lt;: sbt.HList](implicit head: sbt.InputCache[H], implicit tail: sbt.InputCache[T])sbt.InputCache[sbt.Types.:+:[H,T]]" id="sbt;HListCacheImplicits.hConsCache">hConsCache</a><span class="delimiter">[</span><a title="" id="sbt;HListCacheImplicits.hConsCache;H">H</a>, <a title=" &lt;: sbt.HList" id="sbt;HListCacheImplicits.hConsCache;T">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.InputCache[H]" id="sbt;HListCacheImplicits.hConsCache.head">head</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[H]">InputCache</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="sbt.InputCache[T]" id="sbt;HListCacheImplicits.hConsCache.tail">tail</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[T]">InputCache</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[sbt.Types.:+:[H,T]]">InputCache</a><span class="delimiter">[</span>H :+: T<span class="delimiter">]</span> =
    <a href="#sbt;HListCacheImplicits.hConsCache;$anon" title="sbt.InputCache[sbt.Types.:+:[H,T]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.InputCache[sbt.Types.:+:[H,T]]" id="sbt;HListCacheImplicits.hConsCache;$anon">InputCache</a><span class="delimiter">[</span>H :+: T<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="(head.Internal, tail.Internal)" id="sbt;HListCacheImplicits.hConsCache;$anon;Internal">Internal</a> = <span title="(head.Internal, tail.Internal)" class="delimiter">(</span>head.Internal, tail.Internal<span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(in: sbt.Types.:+:[H,T])(head.Internal, tail.Internal)" id="sbt;HListCacheImplicits.hConsCache;$anon.convert">convert</a><span class="delimiter">(</span><a title="sbt.Types.:+:[H,T]" id="sbt;HListCacheImplicits.hConsCache;$anon.convert.in">in</a>: H <a href="HList.scala.html#sbt;HCons" title="sbt.Types.:+:[H,T]">:+:</a> T<span class="delimiter">)</span> = <span title="(_1: head.Internal, _2: tail.Internal)(head.Internal, tail.Internal)" class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache.head" title="sbt.InputCache[H]">head</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: H)head.Internal">convert</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.convert.in" title="sbt.Types.:+:[H,T]">in</a>.<a href="HList.scala.html#sbt;HCons.head" title="=&gt; H">head</a><span class="delimiter">)</span>, <a href="#sbt;HListCacheImplicits.hConsCache.tail" title="sbt.InputCache[T]">tail</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: T)tail.Internal">convert</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.convert.in" title="sbt.Types.:+:[H,T]">in</a>.<a href="HList.scala.html#sbt;HCons.tail" title="=&gt; T">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(from: sbinary.Input)(head.Internal, tail.Internal)" id="sbt;HListCacheImplicits.hConsCache;$anon.read">read</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt;HListCacheImplicits.hConsCache;$anon.read.from">from</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="head.Internal" id="sbt;HListCacheImplicits.hConsCache;$anon.read.h">h</a> = <a href="#sbt;HListCacheImplicits.hConsCache.head" title="sbt.InputCache[H]">head</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)head.Internal">read</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="tail.Internal" id="sbt;HListCacheImplicits.hConsCache;$anon.read.t">t</a> = <a href="#sbt;HListCacheImplicits.hConsCache.tail" title="sbt.InputCache[T]">tail</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)tail.Internal">read</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.read.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
          <span title="(_1: head.Internal, _2: tail.Internal)(head.Internal, tail.Internal)" class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.read.h" title="head.Internal">h</a>, <a href="#sbt;HListCacheImplicits.hConsCache;$anon.read.t" title="tail.Internal">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(to: sbinary.Output, j: (head.Internal, tail.Internal))Unit" id="sbt;HListCacheImplicits.hConsCache;$anon.write">write</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt;HListCacheImplicits.hConsCache;$anon.write.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="(head.Internal, tail.Internal)" id="sbt;HListCacheImplicits.hConsCache;$anon.write.j">j</a>: <span title="(head.Internal, tail.Internal)">Internal</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#sbt;HListCacheImplicits.hConsCache.head" title="sbt.InputCache[H]">head</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: head.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;HListCacheImplicits.hConsCache;$anon.write.j" title="(head.Internal, tail.Internal)">j</a>.<span title="=&gt; head.Internal">_1</span><span class="delimiter">)</span>
        <a href="#sbt;HListCacheImplicits.hConsCache.tail" title="sbt.InputCache[T]">tail</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: tail.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;HListCacheImplicits.hConsCache;$anon.write.j" title="(head.Internal, tail.Internal)">j</a>.<span title="=&gt; tail.Internal">_2</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Equiv[(head.Internal, tail.Internal)]" id="sbt;HListCacheImplicits.hConsCache;$anon.equiv">equiv</a> = <a href="#sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon" title="Equiv[(head.Internal, tail.Internal)]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[(head.Internal, tail.Internal)]" id="sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon">Equiv</a><span class="delimiter">[</span>Internal<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(a: (head.Internal, tail.Internal), b: (head.Internal, tail.Internal))Boolean" id="sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="(head.Internal, tail.Internal)" id="sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv.a">a</a>: <span title="(head.Internal, tail.Internal)">Internal</span>, <a title="(head.Internal, tail.Internal)" id="sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv.b">b</a>: <span title="(head.Internal, tail.Internal)">Internal</span><span class="delimiter">)</span> =
          <a href="#sbt;HListCacheImplicits.hConsCache.head" title="sbt.InputCache[H]">head</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[head.Internal]">equiv</a>.<span title="(x: head.Internal, y: head.Internal)Boolean">equiv</span><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv.a" title="(head.Internal, tail.Internal)">a</a>.<span title="=&gt; head.Internal">_1</span>, <a href="#sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv.b" title="(head.Internal, tail.Internal)">b</a>.<span title="=&gt; head.Internal">_1</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#sbt;HListCacheImplicits.hConsCache.tail" title="sbt.InputCache[T]">tail</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[tail.Internal]">equiv</a>.<span title="(x: tail.Internal, y: tail.Internal)Boolean">equiv</span><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv.a" title="(head.Internal, tail.Internal)">a</a>.<span title="=&gt; tail.Internal">_2</span>, <a href="#sbt;HListCacheImplicits.hConsCache;$anon.equiv;$anon.equiv.b" title="(head.Internal, tail.Internal)">b</a>.<span title="=&gt; tail.Internal">_2</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbt.InputCache[sbt.HNil]" id="sbt;HListCacheImplicits.hNilCache">hNilCache</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[sbt.HNil]">InputCache</a><span class="delimiter">[</span>HNil<span class="delimiter">]</span> = <a href="#sbt.Cache" title="sbt.Cache.type">Cache</a>.<a href="#sbt;BasicCacheImplicits.singleton" title="(t: sbt.HNil)sbt.InputCache[sbt.HNil]">singleton</a><span class="delimiter">(</span><a href="HList.scala.html#sbt.HNil" title="sbt.HNil.type">HNil</a>: <a href="HList.scala.html#sbt;HNil" title="sbt.HNil">HNil</a><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H, T &lt;: sbt.HList](implicit head: sbinary.Format[H], implicit tail: sbinary.Format[T])sbinary.Format[sbt.Types.:+:[H,T]]" id="sbt;HListCacheImplicits.hConsFormat">hConsFormat</a><span class="delimiter">[</span><a title="" id="sbt;HListCacheImplicits.hConsFormat;H">H</a>, <a title=" &lt;: sbt.HList" id="sbt;HListCacheImplicits.hConsFormat;T">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbinary.Format[H]" id="sbt;HListCacheImplicits.hConsFormat.head">head</a>: <span title="sbinary.Format[H]">Format</span><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="sbinary.Format[T]" id="sbt;HListCacheImplicits.hConsFormat.tail">tail</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="sbinary.Format[sbt.Types.:+:[H,T]]">Format</span><span class="delimiter">[</span>H :+: T<span class="delimiter">]</span> = <a href="#sbt;HListCacheImplicits.hConsFormat;$anon" title="sbinary.Format[sbt.Types.:+:[H,T]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbinary.Format[sbt.Types.:+:[H,T]]" id="sbt;HListCacheImplicits.hConsFormat;$anon">Format</a><span class="delimiter">[</span>H :+: T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(from: sbinary.Input)sbt.HCons[H,T]" id="sbt;HListCacheImplicits.hConsFormat;$anon.reads">reads</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt;HListCacheImplicits.hConsFormat;$anon.reads.from">from</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="H" id="sbt;HListCacheImplicits.hConsFormat;$anon.reads.h">h</a> = <a href="#sbt;HListCacheImplicits.hConsFormat.head" title="sbinary.Format[H]">head</a>.<span title="(in: sbinary.Input)H">reads</span><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsFormat;$anon.reads.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="T" id="sbt;HListCacheImplicits.hConsFormat;$anon.reads.t">t</a> = <a href="#sbt;HListCacheImplicits.hConsFormat.tail" title="sbinary.Format[T]">tail</a>.<span title="(in: sbinary.Input)T">reads</span><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsFormat;$anon.reads.from" title="sbinary.Input">from</a><span class="delimiter">)</span>
        <a href="HList.scala.html#sbt;HCons" title="(head: H, tail: T)sbt.HCons[H,T]">HCons</a><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsFormat;$anon.reads.h" title="H">h</a>, <a href="#sbt;HListCacheImplicits.hConsFormat;$anon.reads.t" title="T">t</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(to: sbinary.Output, hc: sbt.Types.:+:[H,T])Unit" id="sbt;HListCacheImplicits.hConsFormat;$anon.writes">writes</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt;HListCacheImplicits.hConsFormat;$anon.writes.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="sbt.Types.:+:[H,T]" id="sbt;HListCacheImplicits.hConsFormat;$anon.writes.hc">hc</a>: H <a href="HList.scala.html#sbt;HCons" title="sbt.Types.:+:[H,T]">:+:</a> T<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt;HListCacheImplicits.hConsFormat.head" title="sbinary.Format[H]">head</a>.<span title="(out: sbinary.Output, value: H)Unit">writes</span><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsFormat;$anon.writes.to" title="sbinary.Output">to</a>, <a href="#sbt;HListCacheImplicits.hConsFormat;$anon.writes.hc" title="sbt.Types.:+:[H,T]">hc</a>.<a href="HList.scala.html#sbt;HCons.head" title="=&gt; H">head</a><span class="delimiter">)</span>
      <a href="#sbt;HListCacheImplicits.hConsFormat.tail" title="sbinary.Format[T]">tail</a>.<span title="(out: sbinary.Output, value: T)Unit">writes</span><span class="delimiter">(</span><a href="#sbt;HListCacheImplicits.hConsFormat;$anon.writes.to" title="sbinary.Output">to</a>, <a href="#sbt;HListCacheImplicits.hConsFormat;$anon.writes.hc" title="sbt.Types.:+:[H,T]">hc</a>.<a href="HList.scala.html#sbt;HCons.tail" title="=&gt; T">tail</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbinary.Format[sbt.HNil]" id="sbt;HListCacheImplicits.hNilFormat">hNilFormat</a>: <span title="sbinary.Format[sbt.HNil]">Format</span><span class="delimiter">[</span>HNil<span class="delimiter">]</span> = <span title="(t: sbt.HNil)sbinary.Format[sbt.HNil]">asSingleton</span><span class="delimiter">(</span><a href="HList.scala.html#sbt.HNil" title="sbt.HNil.type">HNil</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">trait</span> <a title="trait UnionImplicits extends AnyRef" id="sbt;UnionImplicits">UnionImplicits</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[UB, HL &lt;: sbt.HList](implicit uc: UnionImplicits.this.UnionCache[HL,UB])sbt.InputCache[UB]" id="sbt;UnionImplicits.unionInputCache">unionInputCache</a><span class="delimiter">[</span><a title="" id="sbt;UnionImplicits.unionInputCache;UB">UB</a>, <a title=" &lt;: sbt.HList" id="sbt;UnionImplicits.unionInputCache;HL">HL</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="UnionImplicits.this.UnionCache[HL,UB]" id="sbt;UnionImplicits.unionInputCache.uc">uc</a>: <a href="#sbt;UnionImplicits;UnionCache" title="UnionImplicits.this.UnionCache[HL,UB]">UnionCache</a><span class="delimiter">[</span>HL, UB<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[UB]">InputCache</a><span class="delimiter">[</span>UB<span class="delimiter">]</span> =
    <a href="#sbt;UnionImplicits.unionInputCache;$anon" title="sbt.InputCache[UB]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.InputCache[UB]" id="sbt;UnionImplicits.unionInputCache;$anon">InputCache</a><span class="delimiter">[</span>UB<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="UnionImplicits.this.Found[_]" id="sbt;UnionImplicits.unionInputCache;$anon;Internal">Internal</a> = <a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[_]">Found</a><span class="delimiter">[</span>_<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(in: UB)UnionImplicits.this.Found[_]" id="sbt;UnionImplicits.unionInputCache;$anon.convert">convert</a><span class="delimiter">(</span><a title="UB" id="sbt;UnionImplicits.unionInputCache;$anon.convert.in">in</a>: <a href="#sbt;UnionImplicits.unionInputCache;UB" title="UB">UB</a><span class="delimiter">)</span> = <a href="#sbt;UnionImplicits.unionInputCache.uc" title="UnionImplicits.this.UnionCache[HL,UB]">uc</a>.<a href="#sbt;UnionImplicits;UnionCache.find" title="(forValue: UB)UnionImplicits.this.Found[_]">find</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.convert.in" title="UB">in</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(in: sbinary.Input)UnionImplicits.this.Found[cache.Internal] forSome { val cache: sbt.InputCache[_ &lt;: UB] }" id="sbt;UnionImplicits.unionInputCache;$anon.read">read</a><span class="delimiter">(</span><a title="sbinary.Input" id="sbt;UnionImplicits.unionInputCache;$anon.read.in">in</a>: <span title="sbinary.Input">Input</span><span class="delimiter">)</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Byte" id="sbt;UnionImplicits.unionInputCache;$anon.read.index">index</a> = <span title="sbinary.DefaultProtocol.ByteFormat.type">ByteFormat</span>.<span title="(in: sbinary.Input)Byte">reads</span><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.read.in" title="sbinary.Input">in</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a href="#sbt;UnionImplicits.unionInputCache;$anon.read.cache" title="(sbt.InputCache[_0], Class[_0])" class="delimiter">(</a><a href="#sbt;UnionImplicits.unionInputCache;$anon.read.x$6" title="sbt.InputCache[_ &lt;: UB]" id="sbt;UnionImplicits.unionInputCache;$anon.read.cache">cache</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.read.x$6" title="Class[_]" id="sbt;UnionImplicits.unionInputCache;$anon.read.clazz">clazz</a><span class="delimiter">)</span> = <a href="#sbt;UnionImplicits.unionInputCache.uc" title="UnionImplicits.this.UnionCache[HL,UB]">uc</a>.<a href="#sbt;UnionImplicits;UnionCache.at" title="(i: Int)(sbt.InputCache[_ &lt;: UB], Class[_])">at</a><span title="(sbt.InputCache[_ &lt;: UB], Class[_]) @unchecked" class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.read.index" title="=&gt; Int">index</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="cache.Internal" id="sbt;UnionImplicits.unionInputCache;$anon.read.value">value</a> = <a href="#sbt;UnionImplicits.unionInputCache;$anon.read.cache" title="sbt.InputCache[_ &lt;: UB]">cache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.read" title="(from: sbinary.Input)cache.Internal">read</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.read.in" title="sbinary.Input">in</a><span class="delimiter">)</span>
          <span title="UnionImplicits.this.Found[cache.Internal]" class="keyword">new</span> <a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[cache.Internal]">Found</a><span class="delimiter">[</span>cache.Internal<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.read.cache" title="sbt.InputCache[_ &lt;: UB]">cache</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.read.clazz" title="Class[_]">clazz</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.read.value" title="cache.Internal">value</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.read.index" title="=&gt; Int">index</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(to: sbinary.Output, i: this.Internal)Unit" id="sbt;UnionImplicits.unionInputCache;$anon.write">write</a><span class="delimiter">(</span><a title="sbinary.Output" id="sbt;UnionImplicits.unionInputCache;$anon.write.to">to</a>: <span title="sbinary.Output">Out</span>, <a title="this.Internal" id="sbt;UnionImplicits.unionInputCache;$anon.write.i">i</a>: <a href="#sbt;UnionImplicits;Found" title="this.Internal">Internal</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[I](f: UnionImplicits.this.Found[I])Unit" id="sbt;UnionImplicits.unionInputCache;$anon.write.write0">write0</a><span class="delimiter">[</span><a title="" id="sbt;UnionImplicits.unionInputCache;$anon.write.write0;I">I</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="UnionImplicits.this.Found[I]" id="sbt;UnionImplicits.unionInputCache;$anon.write.write0.f">f</a>: <a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[I]">Found</a><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="sbinary.DefaultProtocol.ByteFormat.type">ByteFormat</span>.<span title="(out: sbinary.Output, value: Byte)Unit">writes</span><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.write.write0.f" title="UnionImplicits.this.Found[I]">f</a>.<a href="#sbt;UnionImplicits;Found.index" title="=&gt; Int">index</a>.<span title="=&gt; Byte">toByte</span><span class="delimiter">)</span>
          <a href="#sbt;UnionImplicits.unionInputCache;$anon.write.write0.f" title="UnionImplicits.this.Found[I]">f</a>.<a href="#sbt;UnionImplicits;Found.cache" title="=&gt; sbt.InputCache[_]{type Internal = I}">cache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.write" title="(to: sbinary.Output, j: f.cache.Internal)Unit">write</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.write.to" title="sbinary.Output">to</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.write.write0.f" title="UnionImplicits.this.Found[I]">f</a>.<a href="#sbt;UnionImplicits;Found.value" title="=&gt; I">value</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#sbt;UnionImplicits.unionInputCache;$anon.write.write0" title="(f: UnionImplicits.this.Found[_$1])Unit">write0</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.write.i" title="this.Internal">i</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Equiv[this.Internal]" id="sbt;UnionImplicits.unionInputCache;$anon.equiv">equiv</a>: <span title="Equiv[this.Internal]">Equiv</span><span class="delimiter">[</span>Internal<span class="delimiter">]</span> = <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon" title="Equiv[this.Internal]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Equiv[this.Internal]" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon">Equiv</a><span class="delimiter">[</span>Internal<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(a: this.Internal, b: this.Internal)Boolean" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv">equiv</a><span class="delimiter">(</span><a title="this.Internal" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.a">a</a>: <a href="#sbt;UnionImplicits;Found" title="this.Internal">Internal</a>, <a title="this.Internal" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.b">b</a>: <a href="#sbt;UnionImplicits;Found" title="this.Internal">Internal</a><span class="delimiter">)</span> =
          <span class="delimiter">{</span>
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.a" title="this.Internal">a</a>.<a href="#sbt;UnionImplicits;Found.clazz" title="=&gt; Class[_]">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.b" title="this.Internal">b</a>.<a href="#sbt;UnionImplicits;Found.clazz" title="=&gt; Class[_]">clazz</a><span class="delimiter">)</span>
              <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force" title="(e: Equiv[a.cache.Internal], a: Any, b: Any)Boolean">force</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.a" title="this.Internal">a</a>.<a href="#sbt;UnionImplicits;Found.cache" title="=&gt; sbt.InputCache[_]{type Internal = _$1}">cache</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.equiv" title="=&gt; Equiv[a.cache.Internal]">equiv</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.a" title="this.Internal">a</a>.<a href="#sbt;UnionImplicits;Found.value" title="=&gt; _$1">value</a>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.equiv.b" title="this.Internal">b</a>.<a href="#sbt;UnionImplicits;Found.value" title="=&gt; _$1">value</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <span title="Boolean(false)" class="keyword">false</span>
          <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="[T &lt;: UB, UB](e: Equiv[T], a: UB, b: UB)Boolean" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force">force</a><span class="delimiter">[</span><a title=" &lt;: UB" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force;T">T</a> &lt;: UB, <a title="" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force;UB">UB</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Equiv[T]" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force.e">e</a>: <span title="Equiv[T]">Equiv</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="UB" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force.a">a</a>: <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force;UB" title="UB">UB</a>, <a title="UB" id="sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force.b">b</a>: <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force;UB" title="UB">UB</a><span class="delimiter">)</span> = <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force.e" title="Equiv[T]">e</a>.<span title="(x: T, y: T)Boolean">equiv</span><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force.a" title="UB">a</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force;T" title="T">T</a><span class="delimiter">]</span>, <a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force.b" title="UB">b</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#sbt;UnionImplicits.unionInputCache;$anon.equiv;$anon.force;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H &lt;: UB, UB, T &lt;: sbt.HList](implicit head: sbt.InputCache[H], implicit mf: Manifest[H], implicit t: UnionImplicits.this.UnionCache[T,UB])UnionImplicits.this.UnionCache[sbt.Types.:+:[H,T],UB]" id="sbt;UnionImplicits.unionCons">unionCons</a><span class="delimiter">[</span><a title=" &lt;: UB" id="sbt;UnionImplicits.unionCons;H">H</a> &lt;: UB, <a title="" id="sbt;UnionImplicits.unionCons;UB">UB</a>, <a title=" &lt;: sbt.HList" id="sbt;UnionImplicits.unionCons;T">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.InputCache[H]" id="sbt;UnionImplicits.unionCons.head">head</a>: <a href="SeparatedCache.scala.html#sbt;InputCache" title="sbt.InputCache[H]">InputCache</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="Manifest[H]" id="sbt;UnionImplicits.unionCons.mf">mf</a>: <span title="Manifest[H]">Manifest</span><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a title="UnionImplicits.this.UnionCache[T,UB]" id="sbt;UnionImplicits.unionCons.t">t</a>: <a href="#sbt;UnionImplicits;UnionCache" title="UnionImplicits.this.UnionCache[T,UB]">UnionCache</a><span class="delimiter">[</span>T, UB<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;UnionImplicits;UnionCache" title="UnionImplicits.this.UnionCache[sbt.Types.:+:[H,T],UB]">UnionCache</a><span class="delimiter">[</span>H :+: T, UB<span class="delimiter">]</span> =
    <a href="#sbt;UnionImplicits.unionCons;$anon" title="UnionImplicits.this.UnionCache[sbt.Types.:+:[H,T],UB]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with UnionImplicits.this.UnionCache[sbt.Types.:+:[H,T],UB]" id="sbt;UnionImplicits.unionCons;$anon">UnionCache</a><span class="delimiter">[</span>H :+: T, UB<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt;UnionImplicits.unionCons;$anon.size">size</a> = <span title="Int(1)" class="int">1</span> <span title="(x: Int)Int">+</span> <a href="#sbt;UnionImplicits.unionCons.t" title="UnionImplicits.this.UnionCache[T,UB]">t</a>.<a href="#sbt;UnionImplicits;UnionCache.size" title="=&gt; Int">size</a>
      <span class="keyword">def</span> <a title="=&gt; Class[_]" id="sbt;UnionImplicits.unionCons;$anon.c">c</a> = <a href="#sbt;UnionImplicits.unionCons.mf" title="Manifest[H]">mf</a>.<span title="=&gt; Class[_]">runtimeClass</span>
      <span class="keyword">def</span> <a title="(value: UB)UnionImplicits.this.Found[_]" id="sbt;UnionImplicits.unionCons;$anon.find">find</a><span class="delimiter">(</span><a title="UB" id="sbt;UnionImplicits.unionCons;$anon.find.value">value</a>: <a href="#sbt;UnionImplicits.unionCons;UB" title="UB">UB</a><span class="delimiter">)</span>: <a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[_]">Found</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =
        <span title="UnionImplicits.this.Found[_1]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons;$anon.c" title="=&gt; Class[_]">c</a>.<span title="(x$1: Any)Boolean">isInstance</span><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons;$anon.find.value" title="UB">value</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="UnionImplicits.this.Found[head.Internal]" class="keyword">new</span> <a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[head.Internal]">Found</a><span class="delimiter">[</span>head.Internal<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons.head" title="sbt.InputCache[H]">head</a>, <a href="#sbt;UnionImplicits.unionCons;$anon.c" title="=&gt; Class[_]">c</a>, <a href="#sbt;UnionImplicits.unionCons.head" title="sbt.InputCache[H]">head</a>.<a href="SeparatedCache.scala.html#sbt;InputCache.convert" title="(i: H)head.Internal">convert</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons;$anon.find.value" title="UB">value</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="H" class="delimiter">[</span><a href="#sbt;UnionImplicits.unionCons;H" title="H">H</a><span class="delimiter">]</span><span class="delimiter">)</span>, <a href="#sbt;UnionImplicits.unionCons;$anon.size" title="=&gt; Int">size</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt;UnionImplicits.unionCons.t" title="UnionImplicits.this.UnionCache[T,UB]">t</a>.<a href="#sbt;UnionImplicits;UnionCache.find" title="(forValue: UB)UnionImplicits.this.Found[_]">find</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons;$anon.find.value" title="UB">value</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(i: Int)(sbt.InputCache[_ &lt;: UB], Class[_])" id="sbt;UnionImplicits.unionCons;$anon.at">at</a><span class="delimiter">(</span><a title="Int" id="sbt;UnionImplicits.unionCons;$anon.at.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="(sbt.InputCache[_ &lt;: UB], Class[_])" class="delimiter">(</span>InputCache<span class="delimiter">[</span>_ &lt;: UB<span class="delimiter">]</span>, Class<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="(sbt.InputCache[_ &lt;: UB], Class[_])" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons;$anon.size" title="=&gt; Int">size</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt;UnionImplicits.unionCons;$anon.at.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(_1: sbt.InputCache[H], _2: Class[_$1])(sbt.InputCache[H], Class[_$1])" class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons.head" title="sbt.InputCache[H]">head</a>, <a href="#sbt;UnionImplicits.unionCons;$anon.c" title="=&gt; Class[_]">c</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt;UnionImplicits.unionCons.t" title="UnionImplicits.this.UnionCache[T,UB]">t</a>.<a href="#sbt;UnionImplicits;UnionCache.at" title="(i: Int)(sbt.InputCache[_ &lt;: UB], Class[_])">at</a><span class="delimiter">(</span><a href="#sbt;UnionImplicits.unionCons;$anon.at.i" title="Int">i</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[UB]=&gt; UnionImplicits.this.UnionCache[sbt.HNil,UB]" id="sbt;UnionImplicits.unionNil">unionNil</a><span class="delimiter">[</span><a title="" id="sbt;UnionImplicits.unionNil;UB">UB</a><span class="delimiter">]</span>: <a href="#sbt;UnionImplicits;UnionCache" title="UnionImplicits.this.UnionCache[sbt.HNil,UB]">UnionCache</a><span class="delimiter">[</span>HNil, UB<span class="delimiter">]</span> = <a href="#sbt;UnionImplicits.unionNil;$anon" title="UnionImplicits.this.UnionCache[sbt.HNil,UB]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with UnionImplicits.this.UnionCache[sbt.HNil,UB]" id="sbt;UnionImplicits.unionNil;$anon">UnionCache</a><span class="delimiter">[</span>HNil, UB<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="sbt;UnionImplicits.unionNil;$anon.size">size</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">def</span> <a title="(value: UB)Nothing" id="sbt;UnionImplicits.unionNil;$anon.find">find</a><span class="delimiter">(</span><a title="UB" id="sbt;UnionImplicits.unionNil;$anon.find.value">value</a>: <a href="#sbt;UnionImplicits.unionNil;UB" title="UB">UB</a><span class="delimiter">)</span> = sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;No valid sum type for &quot;)" class="string">&quot;No valid sum type for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;UnionImplicits.unionNil;$anon.find.value" title="UB">value</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(i: Int)Nothing" id="sbt;UnionImplicits.unionNil;$anon.at">at</a><span class="delimiter">(</span><a title="Int" id="sbt;UnionImplicits.unionNil;$anon.at.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span> = sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Invalid union index &quot;)" class="string">&quot;Invalid union index &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;UnionImplicits.unionNil;$anon.at.i" title="Int">i</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Found[I] extends AnyRef" id="sbt;UnionImplicits;Found">Found</a><span class="delimiter">[</span><a title="" id="sbt;UnionImplicits;Found;I">I</a><span class="delimiter">]</span><a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[I]" class="delimiter">(</a><span class="keyword">val</span> <a title="UnionImplicits extends sbt.InputCache[_]" id="sbt;UnionImplicits;Found.cache">cache</a>: <a href="#sbt;UnionImplicits;<refinement>" title="UnionImplicits extends sbt.InputCache[_]">InputCache</a><span class="delimiter">[</span>_<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Internal = I <span class="delimiter">}</span>, <span class="keyword">val</span> <a title="Class[_]" id="sbt;UnionImplicits;Found.clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="I" id="sbt;UnionImplicits;Found.value">value</a>: <a href="#sbt;UnionImplicits;Found;I" title="I">I</a>, <span class="keyword">val</span> <a title="Int" id="sbt;UnionImplicits;Found.index">index</a>: <span title="Int">Int</span><span class="delimiter">)</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait UnionCache[HL &lt;: sbt.HList, UB] extends AnyRef" id="sbt;UnionImplicits;UnionCache">UnionCache</a><span class="delimiter">[</span><a title=" &lt;: sbt.HList" id="sbt;UnionImplicits;UnionCache;HL">HL</a> &lt;: HList, <a title="" id="sbt;UnionImplicits;UnionCache;UB">UB</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="sbt;UnionImplicits;UnionCache.size">size</a>: <span title="Int">Int</span>
    <span class="keyword">def</span> <a title="(i: Int)(sbt.InputCache[_ &lt;: UB], Class[_])" id="sbt;UnionImplicits;UnionCache.at">at</a><span class="delimiter">(</span><a title="Int" id="sbt;UnionImplicits;UnionCache.at.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="(sbt.InputCache[_ &lt;: UB], Class[_])" class="delimiter">(</span>InputCache<span class="delimiter">[</span>_ &lt;: UB<span class="delimiter">]</span>, Class<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(forValue: UB)UnionImplicits.this.Found[_]" id="sbt;UnionImplicits;UnionCache.find">find</a><span class="delimiter">(</span><a title="UB" id="sbt;UnionImplicits;UnionCache.find.forValue">forValue</a>: <a href="#sbt;UnionImplicits;UnionCache;UB" title="UB">UB</a><span class="delimiter">)</span>: <a href="#sbt;UnionImplicits;Found" title="UnionImplicits.this.Found[_]">Found</a><span class="delimiter">[</span>_<span class="delimiter">]</span>
  <span class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>
        </pre>
    </body>
</html>
