<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/AList.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> <a href="Classes.scala.html#sbt.Classes" title="sbt.Classes.type">Classes</a>.Applicative
<span class="keyword">import</span> <a href="Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._

<span class="comment">/**
 * An abstraction over a higher-order type constructor `K[x[y]]` with the purpose of abstracting
 * over heterogeneous sequences like `KList` and `TupleN` with elements with a common type
 * constructor as well as homogeneous sequences `Seq[M[T]]`.
 */</span>
<span class="keyword">trait</span> <a title="trait AList[K[L[x]]] extends AnyRef" id="sbt;AList">AList</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt;AList;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt;AList;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt;AList;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[M[_], N[_]](value: K[M], f: sbt.~&gt;[M,N])K[N]" id="sbt;AList.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt;AList.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt;AList.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;AList.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt;AList.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[M]" id="sbt;AList.transform.value">value</a>: <a href="#sbt;AList;K" title="K[M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt;AList.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span>: <a href="#sbt;AList;K" title="K[N]">K</a><span class="delimiter">[</span>N<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](value: K[M], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[K[P]]" id="sbt;AList.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt;AList.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt;AList.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;AList.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt;AList.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;AList.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt;AList.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[M]" id="sbt;AList.traverse.value">value</a>: <a href="#sbt;AList;K" title="K[M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt;AList.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt;AList.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;AList.traverse;N" title="N[K[P]]">N</a><span class="delimiter">[</span>K<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[M[_], A](value: K[M], f: (M[_], A) =&gt; A, init: A)A" id="sbt;AList.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt;AList.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt;AList.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt;AList.foldr;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[M]" id="sbt;AList.foldr.value">value</a>: <a href="#sbt;AList;K" title="K[M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], A) =&gt; A" id="sbt;AList.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, A<span class="delimiter">)</span> =&gt; A, <a title="A" id="sbt;AList.foldr.init">init</a>: <a href="#sbt;AList.foldr;A" title="A">A</a><span class="delimiter">)</span>: <a href="#sbt;AList.foldr;A" title="A">A</a>

  <span class="keyword">def</span> <a title="[M[_]](value: K[M])List[M[_]]" id="sbt;AList.toList">toList</a><span class="delimiter">[</span><a title="[_]" id="sbt;AList.toList;M">M</a><span class="delimiter">[</span><a title="" id="sbt;AList.toList;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[M]" id="sbt;AList.toList.value">value</a>: <a href="#sbt;AList;K" title="K[M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[M[_]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;AList.foldr" title="[M[_], A](value: K[M], f: (M[_], A) =&gt; A, init: A)A">foldr</a><span title="(value: K[M], f: (M[_], List[M[_]]) =&gt; List[M[_]], init: List[M[_]])List[M[_]]" class="delimiter">[</span><a href="#sbt;AList.toList;M" title="M">M</a>, <span title="List[M[_]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;AList.toList.value" title="K[M]">value</a>, <a href="#sbt;AList.toList.$anonfun.x$1" title="M[_]">_</a> <a href="#sbt;AList.toList.$anonfun.x$3" title="(x: M[_])List[M[_]]">::</a> <a href="#sbt;AList.toList.$anonfun.x$2" title="List[M[_]]">_</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[M[_], C](value: K[M], f: K[sbt.Types.Id] =&gt; C)(implicit a: sbt.Classes.Applicative[M])M[C]" id="sbt;AList.apply">apply</a><span class="delimiter">[</span><a title="[_]" id="sbt;AList.apply;M">M</a><span class="delimiter">[</span><a title="" id="sbt;AList.apply;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt;AList.apply;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[M]" id="sbt;AList.apply.value">value</a>: <a href="#sbt;AList;K" title="K[M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; C" id="sbt;AList.apply.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[M]" id="sbt;AList.apply.a">a</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;AList.apply;M" title="M[C]">M</a><span class="delimiter">[</span>C<span class="delimiter">]</span> =
    <a href="#sbt;AList.apply.a" title="sbt.Classes.Applicative[M]">a</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: K[sbt.Types.Id] =&gt; C, v: M[K[sbt.Types.Id]])M[C]">map</a><span class="delimiter">(</span><a href="#sbt;AList.apply.f" title="K[sbt.Types.Id] =&gt; C">f</a>, <a href="#sbt;AList.traverse" title="[M[_], N[_], P[_]](value: K[M], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[K[P]]">traverse</a><span title="(value: K[M], f: sbt.~&gt;[M,[T]M[sbt.Types.Id[T]]])(implicit np: sbt.Classes.Applicative[M])M[K[sbt.Types.Id]]" class="delimiter">[</span><a href="#sbt;AList.apply;M" title="M">M</a>, <a href="#sbt;AList.apply;M" title="M">M</a>, <a href="TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;AList.apply.value" title="K[M]">value</a>, <a href="TypeFunctions.scala.html#sbt;TypeFunctions.idK" title="[M[_]]=&gt; sbt.~&gt;[M,M]">idK</a><span title="sbt.~&gt;[M,M]" class="delimiter">[</span><a href="#sbt;AList.apply;M" title="M">M</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;AList.apply.a" title="sbt.Classes.Applicative[M]">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.AList.type" id="sbt.AList">AList</a> <a href="#sbt.AList" title="sbt.AList.type" class="delimiter">{</a>
  <span class="keyword">type</span> <a title="sbt.AList[[L[x]]Unit]" id="sbt.AList;Empty">Empty</a> = <a href="#sbt;AList" title="sbt.AList[[L[x]]Unit]">AList</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = Unit <span class="delimiter">}</span><span class="delimiter">)</span>#l<span class="delimiter">]</span>
  <span class="comment">/** AList for Unit, which represents a sequence that is always empty.*/</span>
  <span class="keyword">val</span> <a title="sbt.AList.Empty" id="sbt.AList.empty">empty</a>: <a href="#sbt;AList" title="sbt.AList.Empty">Empty</a> = <a href="#sbt.AList.empty;$anon" title="sbt.AList.Empty" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.Empty" id="sbt.AList.empty;$anon">Empty</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](in: Unit, f: sbt.~&gt;[M,N])Unit" id="sbt.AList.empty;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.empty;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.empty;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Unit" id="sbt.AList.empty;$anon.transform.in">in</a>: <span title="Unit">Unit</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.empty;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](in: Unit, f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.empty;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.empty;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.empty;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Unit" id="sbt.AList.empty;$anon.foldr.in">in</a>: <span title="Unit">Unit</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.empty;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.empty;$anon.foldr.init">init</a>: <a href="#sbt.AList.empty;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span> = <a href="#sbt.AList.empty;$anon.foldr.init" title="T">init</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[M[_], C](in: Unit, f: Unit =&gt; C)(implicit app: sbt.Classes.Applicative[M])M[C]" id="sbt.AList.empty;$anon.apply">apply</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.empty;$anon.apply;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.apply;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.empty;$anon.apply;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Unit" id="sbt.AList.empty;$anon.apply.in">in</a>: <span title="Unit">Unit</span>, <a title="Unit =&gt; C" id="sbt.AList.empty;$anon.apply.f">f</a>: Unit =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[M]" id="sbt.AList.empty;$anon.apply.app">app</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.empty;$anon.apply;M" title="M[C]">M</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#sbt.AList.empty;$anon.apply.app" title="sbt.Classes.Applicative[M]">app</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.pure" title="(s: =&gt; C)M[C]">pure</a><span class="delimiter">(</span><a href="#sbt.AList.empty;$anon.apply.f" title="(v1: Unit)C">f</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](in: Unit, f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[Unit]" id="sbt.AList.empty;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.empty;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.empty;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.empty;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.empty;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Unit" id="sbt.AList.empty;$anon.traverse.in">in</a>: <span title="Unit">Unit</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.empty;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.empty;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.empty;$anon.traverse;N" title="N[Unit]">N</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#sbt.AList.empty;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.pure" title="(s: =&gt; Unit)N[Unit]">pure</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[T]sbt.AList[[L[x]]List[L[T]]]" id="sbt.AList;SeqList">SeqList</a><span class="delimiter">[</span><a title="" id="sbt.AList;SeqList;T">T</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]]List[L[T]]]">AList</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = List<span class="delimiter">[</span>L<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l<span class="delimiter">]</span>
  <span class="comment">/** AList for a homogeneous sequence. */</span>
  <span class="keyword">def</span> <a title="[T]=&gt; sbt.AList.SeqList[T]" id="sbt.AList.seq">seq</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;T">T</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.SeqList[T]">SeqList</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.AList.seq;$anon" title="sbt.AList.SeqList[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.SeqList[T]" id="sbt.AList.seq;$anon">SeqList</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](s: List[M[T]], f: sbt.~&gt;[M,N])List[N[T]]" id="sbt.AList.seq;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.seq;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.seq;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[M[T]]" id="sbt.AList.seq;$anon.transform.s">s</a>: <span title="List[M[T]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.seq;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="#sbt.AList.seq;$anon.transform.s" title="List[M[T]]">s</a>.<span title="(f: M[T] =&gt; N[T])(implicit bf: scala.collection.generic.CanBuildFrom[List[M[T]],N[T],List[N[T]]])List[N[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,N[T],List[N[T]]]" class="delimiter">(</span><a href="#sbt.AList.seq;$anon.transform.f" title="sbt.~&gt;[M,N]">f</a>.<a href="TypeFunctions.scala.html#sbt;~>.fn" title="[T]=&gt; M[T] =&gt; N[T]">fn</a><span title="M[T] =&gt; N[T]" class="delimiter">[</span><a href="#sbt.AList.seq;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], A](s: List[M[T]], f: (M[_], A) =&gt; A, init: A)A" id="sbt.AList.seq;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.seq;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.seq;$anon.foldr;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[M[T]]" id="sbt.AList.seq;$anon.foldr.s">s</a>: <span title="List[M[T]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="(M[_], A) =&gt; A" id="sbt.AList.seq;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, A<span class="delimiter">)</span> =&gt; A, <a title="A" id="sbt.AList.seq;$anon.foldr.init">init</a>: <a href="#sbt.AList.seq;$anon.foldr;A" title="A">A</a><span class="delimiter">)</span>: <a href="#sbt.AList.seq;$anon.foldr;A" title="A">A</a> = <span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.foldr.init" title="A">init</a> <a href="#sbt.AList.seq;$anon.foldr.x$4" title="(z: A)(op: (A, M[T]) =&gt; A)A">/:</a> <a href="#sbt.AList.seq;$anon.foldr.s" title="List[M[T]]">s</a>.<span title="=&gt; List[M[T]]">reverse</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="sbt.AList.seq;$anon.foldr.$anonfun.t">t</a>, <a title="M[T]" id="sbt.AList.seq;$anon.foldr.$anonfun.m">m</a><span class="delimiter">)</span> =&gt; <a href="#sbt.AList.seq;$anon.foldr.f" title="(v1: M[_], v2: A)A">f</a><span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.foldr.$anonfun.m" title="M[T]">m</a>, <a href="#sbt.AList.seq;$anon.foldr.$anonfun.t" title="A">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[M[_], C](s: List[M[T]], f: List[T] =&gt; C)(implicit ap: sbt.Classes.Applicative[M])M[C]" id="sbt.AList.seq;$anon.apply">apply</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.seq;$anon.apply;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.apply;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.seq;$anon.apply;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[M[T]]" id="sbt.AList.seq;$anon.apply.s">s</a>: <span title="List[M[T]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="List[T] =&gt; C" id="sbt.AList.seq;$anon.apply.f">f</a>: List<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[M]" id="sbt.AList.seq;$anon.apply.ap">ap</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.seq;$anon.apply;M" title="M[C]">M</a><span class="delimiter">[</span>C<span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[V](in: List[M[T]], g: List[T] =&gt; V)M[V]" id="sbt.AList.seq;$anon.apply.loop">loop</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.apply.loop;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[M[T]]" id="sbt.AList.seq;$anon.apply.loop.in">in</a>: <span title="List[M[T]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="List[T] =&gt; V" id="sbt.AList.seq;$anon.apply.loop.g">g</a>: List<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; V<span class="delimiter">)</span>: <a href="#sbt.AList.seq;$anon.apply;M" title="M[V]">M</a><span class="delimiter">[</span>V<span class="delimiter">]</span> =
          <a href="#sbt.AList.seq;$anon.apply.loop.in" title="List[M[T]]">in</a> <span title="M[V]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt; <a href="#sbt.AList.seq;$anon.apply.ap" title="sbt.Classes.Applicative[M]">ap</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.pure" title="(s: =&gt; V)M[V]">pure</a><span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.apply.loop.g" title="(v1: List[T])V">g</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <a title="M[T]" id="sbt.AList.seq;$anon.apply.loop.x">x</a> :: <a title="List[M[T]]" id="sbt.AList.seq;$anon.apply.loop.xs">xs</a> =&gt;
              <span class="keyword">val</span> <a title="List[T] =&gt; (T =&gt; V)" id="sbt.AList.seq;$anon.apply.loop.h">h</a> = <span class="delimiter">(</span>ts: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>t: <a href="#sbt.AList.seq;T" title="T">T</a><span class="delimiter">)</span> =&gt; <a href="#sbt.AList.seq;$anon.apply.loop.g" title="(v1: List[T])V">g</a><span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.apply.loop.h.$anonfun.$anonfun.t" title="T">t</a> <a href="#sbt.AList.seq;$anon.apply.loop.h.$anonfun.$anonfun.x$5" title="(x: T)List[T]">::</a> <a href="#sbt.AList.seq;$anon.apply.loop.h.$anonfun.ts" title="List[T]">ts</a><span class="delimiter">)</span>
              <a href="#sbt.AList.seq;$anon.apply.ap" title="sbt.Classes.Applicative[M]">ap</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: M[T =&gt; V], v: M[T])M[V]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.apply.loop" title="(in: List[M[T]], g: List[T] =&gt; (T =&gt; V))M[T =&gt; V]">loop</a><span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.apply.loop.xs" title="List[M[T]]">xs</a>, <a href="#sbt.AList.seq;$anon.apply.loop.h" title="List[T] =&gt; (T =&gt; V)">h</a><span class="delimiter">)</span>, <a href="#sbt.AList.seq;$anon.apply.loop.x" title="M[T]">x</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <a href="#sbt.AList.seq;$anon.apply.loop" title="(in: List[M[T]], g: List[T] =&gt; C)M[C]">loop</a><span class="delimiter">(</span><a href="#sbt.AList.seq;$anon.apply.s" title="List[M[T]]">s</a>, <a href="#sbt.AList.seq;$anon.apply.f" title="List[T] =&gt; C">f</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](s: List[M[T]], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[List[P[T]]]" id="sbt.AList.seq;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.seq;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.seq;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.seq;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.seq;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[M[T]]" id="sbt.AList.seq;$anon.traverse.s">s</a>: <span title="List[M[T]]">List</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.seq;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.seq;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.seq;$anon.traverse;N" title="N[List[P[T]]]">N</a><span class="delimiter">[</span>List<span class="delimiter">[</span>P<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="=&gt; Nothing">???</span>
  <span class="delimiter">}</span>

  <span class="comment">/** AList for the abitrary arity data structure KList. */</span>
  <span class="keyword">def</span> <a title="[KL[M[_]] &lt;: sbt.KList[M]{type Transform[N[_]] = KL[N]}]=&gt; sbt.AList[KL]" id="sbt.AList.klist">klist</a><span class="delimiter">[</span><a title="[M[_]] &lt;: sbt.KList[M]{type Transform[N[_]] = KL[N]}" id="sbt.AList.klist;KL">KL</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.klist;KL;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;KL;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> &lt;: KList<span class="delimiter">[</span>M<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Transform<span class="delimiter">[</span>N<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = KL<span class="delimiter">[</span>N<span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList[KL]">AList</a><span class="delimiter">[</span>KL<span class="delimiter">]</span> = <a href="#sbt.AList.klist;$anon" title="sbt.AList[KL]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList[KL]" id="sbt.AList.klist;$anon">AList</a><span class="delimiter">[</span>KL<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](k: KL[M], f: sbt.~&gt;[M,N])k.Transform[N]" id="sbt.AList.klist;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.klist;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.klist;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="KL[M]" id="sbt.AList.klist;$anon.transform.k">k</a>: <a href="#sbt.AList.klist;KL" title="KL[M]">KL</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.klist;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="#sbt.AList.klist;$anon.transform.k" title="KL[M]">k</a>.<a href="KList.scala.html#sbt;KList.transform" title="(f: sbt.~&gt;[M,N])k.Transform[N]">transform</a><span class="delimiter">(</span><a href="#sbt.AList.klist;$anon.transform.f" title="sbt.~&gt;[M,N]">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](k: KL[M], f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.klist;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.klist;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.klist;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="KL[M]" id="sbt.AList.klist;$anon.foldr.k">k</a>: <a href="#sbt.AList.klist;KL" title="KL[M]">KL</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.klist;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.klist;$anon.foldr.init">init</a>: <a href="#sbt.AList.klist;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.klist;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.klist;$anon.foldr.k" title="KL[M]">k</a>.<a href="KList.scala.html#sbt;KList.foldr" title="(f: (M[_], T) =&gt; T, init: T)T">foldr</a><span class="delimiter">(</span><a href="#sbt.AList.klist;$anon.foldr.f" title="(M[_], T) =&gt; T">f</a>, <a href="#sbt.AList.klist;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[M[_], C](k: KL[M], f: KL[sbt.Types.Id] =&gt; C)(implicit app: sbt.Classes.Applicative[M])M[C]" id="sbt.AList.klist;$anon.apply">apply</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.klist;$anon.apply;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.apply;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.klist;$anon.apply;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="KL[M]" id="sbt.AList.klist;$anon.apply.k">k</a>: <a href="#sbt.AList.klist;KL" title="KL[M]">KL</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="KL[sbt.Types.Id] =&gt; C" id="sbt.AList.klist;$anon.apply.f">f</a>: KL<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[M]" id="sbt.AList.klist;$anon.apply.app">app</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.klist;$anon.apply;M" title="M[C]">M</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#sbt.AList.klist;$anon.apply.k" title="KL[M]">k</a>.<a href="KList.scala.html#sbt;KList.apply" title="(f: k.Transform[sbt.Types.Id] =&gt; C)(implicit ap: sbt.Classes.Applicative[[x]M[x]])M[C]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.klist;$anon.apply.f" title="KL[sbt.Types.Id] =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.AList.klist;$anon.apply.app" title="sbt.Classes.Applicative[M]">app</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](k: KL[M], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[KL[P]]" id="sbt.AList.klist;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.klist;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.klist;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.klist;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="KL[M]" id="sbt.AList.klist;$anon.traverse.k">k</a>: <a href="#sbt.AList.klist;KL" title="KL[M]">KL</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.klist;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.klist;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.klist;$anon.traverse;N" title="N[KL[P]]">N</a><span class="delimiter">[</span>KL<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.AList.klist;$anon.traverse.k" title="KL[M]">k</a>.<a href="KList.scala.html#sbt;KList.traverse" title="[N[_], P[_]](f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[k.Transform[P]]">traverse</a><span title="(f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[k.Transform[P]]" class="delimiter">[</span><a href="#sbt.AList.klist;$anon.traverse;N" title="N">N</a>, <a href="#sbt.AList.klist;$anon.traverse;P" title="P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.AList.klist;$anon.traverse.f" title="sbt.~&gt;[M,[T]N[P[T]]]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.AList.klist;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[M[_]](k: KL[M])List[M[_]]" id="sbt.AList.klist;$anon.toList">toList</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.klist;$anon.toList;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.klist;$anon.toList;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="KL[M]" id="sbt.AList.klist;$anon.toList.k">k</a>: <a href="#sbt.AList.klist;KL" title="KL[M]">KL</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.AList.klist;$anon.toList.k" title="KL[M]">k</a>.<a href="KList.scala.html#sbt;KList.toList" title="=&gt; List[M[_]]">toList</a>
  <span class="delimiter">}</span>

  <span class="comment">/** AList for a single value. */</span>
  <span class="keyword">type</span> <a title="[A]sbt.AList[[L[x]]L[A]]" id="sbt.AList;Single">Single</a><span class="delimiter">[</span><a title="" id="sbt.AList;Single;A">A</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]]L[A]]">AList</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = L<span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A]=&gt; sbt.AList.Single[A]" id="sbt.AList.single">single</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;A">A</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.Single[A]">Single</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.AList.single;$anon" title="sbt.AList.Single[A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.Single[A]" id="sbt.AList.single;$anon">Single</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](a: M[A], f: sbt.~&gt;[M,N])N[A]" id="sbt.AList.single;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.single;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.single;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[A]" id="sbt.AList.single;$anon.transform.a">a</a>: <a href="#sbt.AList.single;$anon.transform;M" title="M[A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.single;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.single;$anon.transform.a" title="M[A]">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](a: M[A], f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.single;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.single;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.single;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[A]" id="sbt.AList.single;$anon.foldr.a">a</a>: <a href="#sbt.AList.single;$anon.foldr;M" title="M[A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.single;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.single;$anon.foldr.init">init</a>: <a href="#sbt.AList.single;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.single;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.single;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.single;$anon.foldr.a" title="M[A]">a</a>, <a href="#sbt.AList.single;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](a: M[A], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[P[A]]" id="sbt.AList.single;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.single;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.single;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.single;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.single;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[A]" id="sbt.AList.single;$anon.traverse.a">a</a>: <a href="#sbt.AList.single;$anon.traverse;M" title="M[A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.single;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.single;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.single;$anon.traverse;N" title="N[P[A]]">N</a><span class="delimiter">[</span>P<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.single;$anon.traverse.a" title="M[A]">a</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[K[L[x]], B[x]]sbt.AList[[L[x]]K[[T]L[B[T]]]]" id="sbt.AList;ASplit">ASplit</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.AList;ASplit;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;ASplit;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;ASplit;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[x]" id="sbt.AList;ASplit;B">B</a><span class="delimiter">[</span><a title="" id="sbt.AList;ASplit;B;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]]K[[T]L[B[T]]]]">AList</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = K<span class="delimiter">[</span><span class="delimiter">(</span>L âˆ™ B<span class="delimiter">)</span>#l<span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l<span class="delimiter">]</span>
  <span class="comment">/** AList that operates on the outer type constructor `A` of a composition `[x] A[B[x]]` for type constructors `A` and `B`*/</span>
  <span class="keyword">def</span> <a title="[K[L[x]], B[x]](base: sbt.AList[K])sbt.AList.ASplit[K,B]" id="sbt.AList.asplit">asplit</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.AList.asplit;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList.asplit;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[x]" id="sbt.AList.asplit;B">B</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;B;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.AList[K]" id="sbt.AList.asplit.base">base</a>: <a href="#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;AList" title="sbt.AList.ASplit[K,B]">ASplit</a><span class="delimiter">[</span>K, B<span class="delimiter">]</span> = <a href="#sbt.AList.asplit;$anon" title="sbt.AList.ASplit[K,B]{type Split[L[x]] = K[[T]L[B[T]]]}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.ASplit[K,B]" id="sbt.AList.asplit;$anon">ASplit</a><span class="delimiter">[</span>K, B<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[L[x]]K[[T]L[B[T]]]" id="sbt.AList.asplit;$anon;Split">Split</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList.asplit;$anon;Split;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon;Split;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.AList.asplit;K" title="K[[T]L[B[T]]]">K</a><span class="delimiter">[</span><span class="delimiter">(</span>L âˆ™ B<span class="delimiter">)</span>#l<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](value: this.Split[M], f: sbt.~&gt;[M,N])this.Split[N]" id="sbt.AList.asplit;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.asplit;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.asplit;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="this.Split[M]" id="sbt.AList.asplit;$anon.transform.value">value</a>: <a href="#sbt.AList.asplit;K" title="this.Split[M]">Split</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.asplit;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span>: <a href="#sbt.AList.asplit;K" title="this.Split[N]">Split</a><span class="delimiter">[</span>N<span class="delimiter">]</span> =
      <a href="#sbt.AList.asplit.base" title="sbt.AList[K]">base</a>.<a href="#sbt;AList.transform" title="[M[_], N[_]](value: K[M], f: sbt.~&gt;[M,N])K[N]">transform</a><span title="(value: K[[T]M[B[T]]], f: sbt.~&gt;[[T]M[B[T]],[T]N[B[T]]])K[[T]N[B[T]]]" class="delimiter">[</span><span class="delimiter">(</span>M âˆ™ B<span class="delimiter">)</span>#<a href="#sbt.AList.asplit;$anon.transform;M" title="[T]M[B[T]]">l</a>, <span class="delimiter">(</span>N âˆ™ B<span class="delimiter">)</span>#<a href="#sbt.AList.asplit;$anon.transform;N" title="[T]N[B[T]]">l</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.AList.asplit;$anon.transform.value" title="this.Split[M]">value</a>, <a href="TypeFunctions.scala.html#sbt;TypeFunctions.nestCon" title="[M[_], N[_], G[_]](f: sbt.~&gt;[M,N])sbt.~&gt;[[T]M[G[T]],[T]N[G[T]]]">nestCon</a><span title="(f: sbt.~&gt;[M,N])sbt.~&gt;[[T]M[B[T]],[T]N[B[T]]]" class="delimiter">[</span><a href="#sbt.AList.asplit;$anon.transform;M" title="M">M</a>, <a href="#sbt.AList.asplit;$anon.transform;N" title="N">N</a>, <a href="#sbt.AList.asplit;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.AList.asplit;$anon.transform.f" title="sbt.~&gt;[M,N]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](value: this.Split[M], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[this.Split[P]]" id="sbt.AList.asplit;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.asplit;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.asplit;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.asplit;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="this.Split[M]" id="sbt.AList.asplit;$anon.traverse.value">value</a>: <a href="#sbt.AList.asplit;K" title="this.Split[M]">Split</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.asplit;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.asplit;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.asplit;$anon.traverse;N" title="N[this.Split[P]]">N</a><span class="delimiter">[</span>Split<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="sbt.~&gt;[[T]M[B[T]],[T]N[P[B[T]]]]" id="sbt.AList.asplit;$anon.traverse.g">g</a> = <a href="TypeFunctions.scala.html#sbt;TypeFunctions.nestCon" title="[M[_], N[_], G[_]](f: sbt.~&gt;[M,N])sbt.~&gt;[[T]M[G[T]],[T]N[G[T]]]">nestCon</a><span title="(f: sbt.~&gt;[M,[T]N[P[T]]])sbt.~&gt;[[T]M[B[T]],[T]N[P[B[T]]]]" class="delimiter">[</span><a href="#sbt.AList.asplit;$anon.traverse;M" title="M">M</a>, <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#<a href="#sbt.AList.asplit;$anon.traverse;N" title="[T]N[P[T]]">l</a>, <a href="#sbt.AList.asplit;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.AList.asplit;$anon.traverse.f" title="sbt.~&gt;[M,[T]N[P[T]]]">f</a><span class="delimiter">)</span>
        <a href="#sbt.AList.asplit.base" title="sbt.AList[K]">base</a>.<a href="#sbt;AList.traverse" title="[M[_], N[_], P[_]](value: K[M], f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[K[P]]">traverse</a><span title="(value: K[[T]M[B[T]]], f: sbt.~&gt;[[T]M[B[T]],[T]N[P[B[T]]]])(implicit np: sbt.Classes.Applicative[N])N[K[[T]P[B[T]]]]" class="delimiter">[</span><span class="delimiter">(</span>M âˆ™ B<span class="delimiter">)</span>#<a href="#sbt.AList.asplit;$anon.traverse;M" title="[T]M[B[T]]">l</a>, <a href="#sbt.AList.asplit;$anon.traverse;N" title="N">N</a>, <span class="delimiter">(</span>P âˆ™ B<span class="delimiter">)</span>#<a href="#sbt.AList.asplit;$anon.traverse;P" title="[T]P[B[T]]">l</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.AList.asplit;$anon.traverse.value" title="this.Split[M]">value</a>, <a href="#sbt.AList.asplit;$anon.traverse.g" title="sbt.~&gt;[[T]M[B[T]],[T]N[P[B[T]]]]">g</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.AList.asplit;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="[M[_], A](value: this.Split[M], f: (M[_], A) =&gt; A, init: A)A" id="sbt.AList.asplit;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.asplit;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.asplit;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.asplit;$anon.foldr;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="this.Split[M]" id="sbt.AList.asplit;$anon.foldr.value">value</a>: <a href="#sbt.AList.asplit;K" title="this.Split[M]">Split</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], A) =&gt; A" id="sbt.AList.asplit;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, A<span class="delimiter">)</span> =&gt; A, <a title="A" id="sbt.AList.asplit;$anon.foldr.init">init</a>: <a href="#sbt.AList.asplit;$anon.foldr;A" title="A">A</a><span class="delimiter">)</span>: <a href="#sbt.AList.asplit;$anon.foldr;A" title="A">A</a> =
      <a href="#sbt.AList.asplit.base" title="sbt.AList[K]">base</a>.<a href="#sbt;AList.foldr" title="[M[_], A](value: K[M], f: (M[_], A) =&gt; A, init: A)A">foldr</a><span title="(value: K[[T]M[B[T]]], f: (M[B[_$1]] forSome { type _$1 }, A) =&gt; A, init: A)A" class="delimiter">[</span><span class="delimiter">(</span>M âˆ™ B<span class="delimiter">)</span>#<a href="#sbt.AList.asplit;$anon.foldr;M" title="[T]M[B[T]]">l</a>, <a href="#sbt.AList.asplit;$anon.foldr;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.AList.asplit;$anon.foldr.value" title="this.Split[M]">value</a>, <a href="#sbt.AList.asplit;$anon.foldr.f" title="(M[_], A) =&gt; A">f</a>, <a href="#sbt.AList.asplit;$anon.foldr.init" title="A">init</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// TODO: auto-generate</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T2K[A, B] extends AnyRef" id="sbt.AList;T2K">T2K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T2K;A">A</a>, <a title="" id="sbt.AList;T2K;B">B</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B])" id="sbt.AList;T2K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T2K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T2K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B]sbt.AList[[L[x]](L[A], L[B])]" id="sbt.AList;T2List">T2List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T2List;A">A</a>, <a title="" id="sbt.AList;T2List;B">B</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B])]">AList</a><span class="delimiter">[</span>T2K<span class="delimiter">[</span>A, B<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B]=&gt; sbt.AList.T2List[A,B]" id="sbt.AList.tuple2">tuple2</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;A">A</a>, <a title="" id="sbt.AList.tuple2;B">B</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T2List[A,B]">T2List</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="#sbt.AList.tuple2;$anon" title="sbt.AList.T2List[A,B]{type T2[M[_]] = (M[A], M[B])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T2List[A,B]" id="sbt.AList.tuple2;$anon">T2List</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B])" id="sbt.AList.tuple2;$anon;T2">T2</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple2;$anon;T2;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon;T2;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B]), f: sbt.~&gt;[M,N])(N[A], N[B])" id="sbt.AList.tuple2;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple2;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple2;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B])" id="sbt.AList.tuple2;$anon.transform.t">t</a>: <span title="(M[A], M[B])">T2</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple2;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span>: <span title="(N[A], N[B])">T2</span><span class="delimiter">[</span>N<span class="delimiter">]</span> = <span title="(_1: N[A], _2: N[B])(N[A], N[B])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.transform.t" title="(M[A], M[B])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.transform.t" title="(M[A], M[B])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple2;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple2;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple2;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B])" id="sbt.AList.tuple2;$anon.foldr.t">t</a>: <span title="(M[A], M[B])">T2</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple2;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple2;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple2;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple2;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple2;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.foldr.t" title="(M[A], M[B])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple2;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.foldr.t" title="(M[A], M[B])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple2;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B])]" id="sbt.AList.tuple2;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple2;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple2;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple2;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple2;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B])" id="sbt.AList.tuple2;$anon.traverse.t">t</a>: <span title="(M[A], M[B])">T2</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple2;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple2;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple2;$anon.traverse;N" title="N[(P[A], P[B])]">N</a><span class="delimiter">[</span>T2<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[A], P[B]))" id="sbt.AList.tuple2;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple2.type">Tuple2</span>.<span title="[T1, T2](_1: T1, _2: T2)(T1, T2)">apply</span><a href="#sbt.AList.tuple2;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B])(P[A], P[B])" class="delimiter">[</a><a href="#sbt.AList.tuple2;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple2;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[A], P[B]))">curried</span>
        <a href="#sbt.AList.tuple2;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[A], P[B])], v: N[P[B]])N[(P[A], P[B])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[A], P[B])), v: N[P[A]])N[P[B] =&gt; (P[A], P[B])]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[A], P[B]))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.traverse.t" title="(M[A], M[B])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple2;$anon.traverse.t" title="(M[A], M[B])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T3K[A, B, C] extends AnyRef" id="sbt.AList;T3K">T3K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T3K;A">A</a>, <a title="" id="sbt.AList;T3K;B">B</a>, <a title="" id="sbt.AList;T3K;C">C</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C])" id="sbt.AList;T3K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T3K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T3K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C]sbt.AList[[L[x]](L[A], L[B], L[C])]" id="sbt.AList;T3List">T3List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T3List;A">A</a>, <a title="" id="sbt.AList;T3List;B">B</a>, <a title="" id="sbt.AList;T3List;C">C</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C])]">AList</a><span class="delimiter">[</span>T3K<span class="delimiter">[</span>A, B, C<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C]=&gt; sbt.AList.T3List[A,B,C]" id="sbt.AList.tuple3">tuple3</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;A">A</a>, <a title="" id="sbt.AList.tuple3;B">B</a>, <a title="" id="sbt.AList.tuple3;C">C</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T3List[A,B,C]">T3List</a><span class="delimiter">[</span>A, B, C<span class="delimiter">]</span> = <a href="#sbt.AList.tuple3;$anon" title="sbt.AList.T3List[A,B,C]{type T3[M[_]] = (M[A], M[B], M[C])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T3List[A,B,C]" id="sbt.AList.tuple3;$anon">T3List</a><span class="delimiter">[</span>A, B, C<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C])" id="sbt.AList.tuple3;$anon;T3">T3</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple3;$anon;T3;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon;T3;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C])" id="sbt.AList.tuple3;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple3;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple3;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C])" id="sbt.AList.tuple3;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C])">T3</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple3;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C])(N[A], N[B], N[C])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.transform.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.transform.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.transform.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple3;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple3;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple3;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C])" id="sbt.AList.tuple3;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C])">T3</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple3;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple3;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple3;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple3;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple3;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.foldr.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple3;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.foldr.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple3;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.foldr.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple3;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C])]" id="sbt.AList.tuple3;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple3;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple3;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple3;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple3;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C])" id="sbt.AList.tuple3;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C])">T3</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple3;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple3;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple3;$anon.traverse;N" title="N[(P[A], P[B], P[C])]">N</a><span class="delimiter">[</span>T3<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[A], P[B], P[C])))" id="sbt.AList.tuple3;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple3.type">Tuple3</span>.<span title="[T1, T2, T3](_1: T1, _2: T2, _3: T3)(T1, T2, T3)">apply</span><a href="#sbt.AList.tuple3;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C])(P[A], P[B], P[C])" class="delimiter">[</a><a href="#sbt.AList.tuple3;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple3;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple3;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[A], P[B], P[C])))">curried</span>
        <a href="#sbt.AList.tuple3;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[A], P[B], P[C])], v: N[P[C]])N[(P[A], P[B], P[C])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[A], P[B], P[C]))], v: N[P[B]])N[P[C] =&gt; (P[A], P[B], P[C])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[A], P[B], P[C]))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[A], P[B], P[C]))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[A], P[B], P[C])))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.traverse.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.traverse.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple3;$anon.traverse.t" title="(M[A], M[B], M[C])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T4K[A, B, C, D] extends AnyRef" id="sbt.AList;T4K">T4K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T4K;A">A</a>, <a title="" id="sbt.AList;T4K;B">B</a>, <a title="" id="sbt.AList;T4K;C">C</a>, <a title="" id="sbt.AList;T4K;D">D</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D])" id="sbt.AList;T4K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T4K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T4K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D]sbt.AList[[L[x]](L[A], L[B], L[C], L[D])]" id="sbt.AList;T4List">T4List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T4List;A">A</a>, <a title="" id="sbt.AList;T4List;B">B</a>, <a title="" id="sbt.AList;T4List;C">C</a>, <a title="" id="sbt.AList;T4List;D">D</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D])]">AList</a><span class="delimiter">[</span>T4K<span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D]=&gt; sbt.AList.T4List[A,B,C,D]" id="sbt.AList.tuple4">tuple4</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;A">A</a>, <a title="" id="sbt.AList.tuple4;B">B</a>, <a title="" id="sbt.AList.tuple4;C">C</a>, <a title="" id="sbt.AList.tuple4;D">D</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T4List[A,B,C,D]">T4List</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span> = <a href="#sbt.AList.tuple4;$anon" title="sbt.AList.T4List[A,B,C,D]{type T4[M[_]] = (M[A], M[B], M[C], M[D])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T4List[A,B,C,D]" id="sbt.AList.tuple4;$anon">T4List</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D])" id="sbt.AList.tuple4;$anon;T4">T4</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple4;$anon;T4;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon;T4;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D])" id="sbt.AList.tuple4;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple4;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple4;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D])" id="sbt.AList.tuple4;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D])">T4</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple4;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D])(N[A], N[B], N[C], N[D])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.transform.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.transform.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.transform.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.transform.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple4;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple4;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple4;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D])" id="sbt.AList.tuple4;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D])">T4</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple4;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple4;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple4;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple4;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple4;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.foldr.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple4;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.foldr.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple4;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.foldr.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple4;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.foldr.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple4;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D])]" id="sbt.AList.tuple4;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple4;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple4;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple4;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple4;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D])" id="sbt.AList.tuple4;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D])">T4</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple4;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple4;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple4;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D])]">N</a><span class="delimiter">[</span>T4<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D]))))" id="sbt.AList.tuple4;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple4.type">Tuple4</span>.<span title="[T1, T2, T3, T4](_1: T1, _2: T2, _3: T3, _4: T4)(T1, T2, T3, T4)">apply</span><a href="#sbt.AList.tuple4;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D])(P[A], P[B], P[C], P[D])" class="delimiter">[</a><a href="#sbt.AList.tuple4;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple4;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple4;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple4;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D]))))">curried</span>
        <a href="#sbt.AList.tuple4;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[A], P[B], P[C], P[D])], v: N[P[D]])N[(P[A], P[B], P[C], P[D])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D]))], v: N[P[C]])N[P[D] =&gt; (P[A], P[B], P[C], P[D])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D])))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D])))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D])))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[A], P[B], P[C], P[D]))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple4;$anon.traverse.t" title="(M[A], M[B], M[C], M[D])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T5K[A, B, C, D, E] extends AnyRef" id="sbt.AList;T5K">T5K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T5K;A">A</a>, <a title="" id="sbt.AList;T5K;B">B</a>, <a title="" id="sbt.AList;T5K;C">C</a>, <a title="" id="sbt.AList;T5K;D">D</a>, <a title="" id="sbt.AList;T5K;E">E</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E])" id="sbt.AList;T5K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T5K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T5K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E])]" id="sbt.AList;T5List">T5List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T5List;A">A</a>, <a title="" id="sbt.AList;T5List;B">B</a>, <a title="" id="sbt.AList;T5List;C">C</a>, <a title="" id="sbt.AList;T5List;D">D</a>, <a title="" id="sbt.AList;T5List;E">E</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E])]">AList</a><span class="delimiter">[</span>T5K<span class="delimiter">[</span>A, B, C, D, E<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E]=&gt; sbt.AList.T5List[A,B,C,D,E]" id="sbt.AList.tuple5">tuple5</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;A">A</a>, <a title="" id="sbt.AList.tuple5;B">B</a>, <a title="" id="sbt.AList.tuple5;C">C</a>, <a title="" id="sbt.AList.tuple5;D">D</a>, <a title="" id="sbt.AList.tuple5;E">E</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T5List[A,B,C,D,E]">T5List</a><span class="delimiter">[</span>A, B, C, D, E<span class="delimiter">]</span> = <a href="#sbt.AList.tuple5;$anon" title="sbt.AList.T5List[A,B,C,D,E]{type T5[M[_]] = (M[A], M[B], M[C], M[D], M[E])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T5List[A,B,C,D,E]" id="sbt.AList.tuple5;$anon">T5List</a><span class="delimiter">[</span>A, B, C, D, E<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E])" id="sbt.AList.tuple5;$anon;T5">T5</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple5;$anon;T5;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon;T5;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E])" id="sbt.AList.tuple5;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple5;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple5;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E])" id="sbt.AList.tuple5;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E])">T5</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple5;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E])(N[A], N[B], N[C], N[D], N[E])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple5;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple5;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple5;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E])" id="sbt.AList.tuple5;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E])">T5</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple5;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple5;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple5;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple5;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple5;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple5;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple5;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple5;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple5;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple5;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E])]" id="sbt.AList.tuple5;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple5;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple5;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple5;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple5;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E])" id="sbt.AList.tuple5;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E])">T5</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple5;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple5;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple5;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E])]">N</a><span class="delimiter">[</span>T5<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])))))" id="sbt.AList.tuple5;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple5.type">Tuple5</span>.<span title="[T1, T2, T3, T4, T5](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5)(T1, T2, T3, T4, T5)">apply</span><a href="#sbt.AList.tuple5;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E])(P[A], P[B], P[C], P[D], P[E])" class="delimiter">[</a><a href="#sbt.AList.tuple5;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple5;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple5;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple5;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple5;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])))))">curried</span>
        <a href="#sbt.AList.tuple5;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])], v: N[P[E]])N[(P[A], P[B], P[C], P[D], P[E])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E]))], v: N[P[D]])N[P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E]))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E]))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E]))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[A], P[B], P[C], P[D], P[E])))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple5;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T6K[A, B, C, D, E, F] extends AnyRef" id="sbt.AList;T6K">T6K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T6K;A">A</a>, <a title="" id="sbt.AList;T6K;B">B</a>, <a title="" id="sbt.AList;T6K;C">C</a>, <a title="" id="sbt.AList;T6K;D">D</a>, <a title="" id="sbt.AList;T6K;E">E</a>, <a title="" id="sbt.AList;T6K;F">F</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E], L[F])" id="sbt.AList;T6K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T6K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T6K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E], L[F])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span>, L<span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E, F]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F])]" id="sbt.AList;T6List">T6List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T6List;A">A</a>, <a title="" id="sbt.AList;T6List;B">B</a>, <a title="" id="sbt.AList;T6List;C">C</a>, <a title="" id="sbt.AList;T6List;D">D</a>, <a title="" id="sbt.AList;T6List;E">E</a>, <a title="" id="sbt.AList;T6List;F">F</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F])]">AList</a><span class="delimiter">[</span>T6K<span class="delimiter">[</span>A, B, C, D, E, F<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E, F]=&gt; sbt.AList.T6List[A,B,C,D,E,F]" id="sbt.AList.tuple6">tuple6</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;A">A</a>, <a title="" id="sbt.AList.tuple6;B">B</a>, <a title="" id="sbt.AList.tuple6;C">C</a>, <a title="" id="sbt.AList.tuple6;D">D</a>, <a title="" id="sbt.AList.tuple6;E">E</a>, <a title="" id="sbt.AList.tuple6;F">F</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T6List[A,B,C,D,E,F]">T6List</a><span class="delimiter">[</span>A, B, C, D, E, F<span class="delimiter">]</span> = <a href="#sbt.AList.tuple6;$anon" title="sbt.AList.T6List[A,B,C,D,E,F]{type T6[M[_]] = (M[A], M[B], M[C], M[D], M[E], M[F])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T6List[A,B,C,D,E,F]" id="sbt.AList.tuple6;$anon">T6List</a><span class="delimiter">[</span>A, B, C, D, E, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E], M[F])" id="sbt.AList.tuple6;$anon;T6">T6</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple6;$anon;T6;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon;T6;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E], M[F])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span>, M<span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E], N[F])" id="sbt.AList.tuple6;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple6;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple6;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F])" id="sbt.AList.tuple6;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F])">T6</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple6;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E], _6: N[F])(N[A], N[B], N[C], N[D], N[E], N[F])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[F]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E], M[F]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple6;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple6;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple6;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F])" id="sbt.AList.tuple6;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F])">T6</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple6;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple6;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple6;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple6;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple6;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple6;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple6;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple6;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple6;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple6;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[F]">_6</span>, <a href="#sbt.AList.tuple6;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E], P[F])]" id="sbt.AList.tuple6;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple6;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple6;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple6;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple6;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F])" id="sbt.AList.tuple6;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F])">T6</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple6;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple6;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple6;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E], P[F])]">N</a><span class="delimiter">[</span>T6<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))))))" id="sbt.AList.tuple6;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple6.type">Tuple6</span>.<span title="[T1, T2, T3, T4, T5, T6](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5, _6: T6)(T1, T2, T3, T4, T5, T6)">apply</span><a href="#sbt.AList.tuple6;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E], _6: P[F])(P[A], P[B], P[C], P[D], P[E], P[F])" class="delimiter">[</a><a href="#sbt.AList.tuple6;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple6;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple6;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple6;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple6;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span>, <a href="#sbt.AList.tuple6;$anon.traverse;P" title="P[F]">P</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))))))">curried</span>
        <a href="#sbt.AList.tuple6;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])], v: N[P[F]])N[(P[A], P[B], P[C], P[D], P[E], P[F])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))], v: N[P[E]])N[P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])))], v: N[P[D]])N[P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F])))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F]))))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[P[F]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple6;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T7K[A, B, C, D, E, F, G] extends AnyRef" id="sbt.AList;T7K">T7K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T7K;A">A</a>, <a title="" id="sbt.AList;T7K;B">B</a>, <a title="" id="sbt.AList;T7K;C">C</a>, <a title="" id="sbt.AList;T7K;D">D</a>, <a title="" id="sbt.AList;T7K;E">E</a>, <a title="" id="sbt.AList;T7K;F">F</a>, <a title="" id="sbt.AList;T7K;G">G</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G])" id="sbt.AList;T7K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T7K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T7K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E], L[F], L[G])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span>, L<span class="delimiter">[</span>F<span class="delimiter">]</span>, L<span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E, F, G]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G])]" id="sbt.AList;T7List">T7List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T7List;A">A</a>, <a title="" id="sbt.AList;T7List;B">B</a>, <a title="" id="sbt.AList;T7List;C">C</a>, <a title="" id="sbt.AList;T7List;D">D</a>, <a title="" id="sbt.AList;T7List;E">E</a>, <a title="" id="sbt.AList;T7List;F">F</a>, <a title="" id="sbt.AList;T7List;G">G</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G])]">AList</a><span class="delimiter">[</span>T7K<span class="delimiter">[</span>A, B, C, D, E, F, G<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E, F, G]=&gt; sbt.AList.T7List[A,B,C,D,E,F,G]" id="sbt.AList.tuple7">tuple7</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;A">A</a>, <a title="" id="sbt.AList.tuple7;B">B</a>, <a title="" id="sbt.AList.tuple7;C">C</a>, <a title="" id="sbt.AList.tuple7;D">D</a>, <a title="" id="sbt.AList.tuple7;E">E</a>, <a title="" id="sbt.AList.tuple7;F">F</a>, <a title="" id="sbt.AList.tuple7;G">G</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T7List[A,B,C,D,E,F,G]">T7List</a><span class="delimiter">[</span>A, B, C, D, E, F, G<span class="delimiter">]</span> = <a href="#sbt.AList.tuple7;$anon" title="sbt.AList.T7List[A,B,C,D,E,F,G]{type T7[M[_]] = (M[A], M[B], M[C], M[D], M[E], M[F], M[G])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T7List[A,B,C,D,E,F,G]" id="sbt.AList.tuple7;$anon">T7List</a><span class="delimiter">[</span>A, B, C, D, E, F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E], M[F], M[G])" id="sbt.AList.tuple7;$anon;T7">T7</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple7;$anon;T7;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon;T7;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span>, M<span class="delimiter">[</span>F<span class="delimiter">]</span>, M<span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E], N[F], N[G])" id="sbt.AList.tuple7;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple7;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple7;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])" id="sbt.AList.tuple7;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">T7</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple7;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E], _6: N[F], _7: N[G])(N[A], N[B], N[C], N[D], N[E], N[F], N[G])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[F]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[G]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple7;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple7;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple7;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])" id="sbt.AList.tuple7;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">T7</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple7;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple7;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple7;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple7;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[F]">_6</span>, <a href="#sbt.AList.tuple7;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[G]">_7</span>, <a href="#sbt.AList.tuple7;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G])]" id="sbt.AList.tuple7;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple7;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple7;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple7;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple7;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])" id="sbt.AList.tuple7;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">T7</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple7;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple7;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple7;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G])]">N</a><span class="delimiter">[</span>T7<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))))))" id="sbt.AList.tuple7;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple7.type">Tuple7</span>.<span title="[T1, T2, T3, T4, T5, T6, T7](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5, _6: T6, _7: T7)(T1, T2, T3, T4, T5, T6, T7)">apply</span><a href="#sbt.AList.tuple7;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E], _6: P[F], _7: P[G])(P[A], P[B], P[C], P[D], P[E], P[F], P[G])" class="delimiter">[</a><a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span>, <a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[F]">P</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a href="#sbt.AList.tuple7;$anon.traverse;P" title="P[G]">P</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))))))">curried</span>
        <a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])], v: N[P[G]])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))], v: N[P[F]])N[P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))], v: N[P[E]])N[P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))))], v: N[P[D]])N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G]))))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G])))))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[P[F]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[P[G]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple7;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T8K[A, B, C, D, E, F, G, H] extends AnyRef" id="sbt.AList;T8K">T8K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T8K;A">A</a>, <a title="" id="sbt.AList;T8K;B">B</a>, <a title="" id="sbt.AList;T8K;C">C</a>, <a title="" id="sbt.AList;T8K;D">D</a>, <a title="" id="sbt.AList;T8K;E">E</a>, <a title="" id="sbt.AList;T8K;F">F</a>, <a title="" id="sbt.AList;T8K;G">G</a>, <a title="" id="sbt.AList;T8K;H">H</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H])" id="sbt.AList;T8K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T8K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T8K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span>, L<span class="delimiter">[</span>F<span class="delimiter">]</span>, L<span class="delimiter">[</span>G<span class="delimiter">]</span>, L<span class="delimiter">[</span>H<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E, F, G, H]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H])]" id="sbt.AList;T8List">T8List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T8List;A">A</a>, <a title="" id="sbt.AList;T8List;B">B</a>, <a title="" id="sbt.AList;T8List;C">C</a>, <a title="" id="sbt.AList;T8List;D">D</a>, <a title="" id="sbt.AList;T8List;E">E</a>, <a title="" id="sbt.AList;T8List;F">F</a>, <a title="" id="sbt.AList;T8List;G">G</a>, <a title="" id="sbt.AList;T8List;H">H</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H])]">AList</a><span class="delimiter">[</span>T8K<span class="delimiter">[</span>A, B, C, D, E, F, G, H<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E, F, G, H]=&gt; sbt.AList.T8List[A,B,C,D,E,F,G,H]" id="sbt.AList.tuple8">tuple8</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;A">A</a>, <a title="" id="sbt.AList.tuple8;B">B</a>, <a title="" id="sbt.AList.tuple8;C">C</a>, <a title="" id="sbt.AList.tuple8;D">D</a>, <a title="" id="sbt.AList.tuple8;E">E</a>, <a title="" id="sbt.AList.tuple8;F">F</a>, <a title="" id="sbt.AList.tuple8;G">G</a>, <a title="" id="sbt.AList.tuple8;H">H</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T8List[A,B,C,D,E,F,G,H]">T8List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H<span class="delimiter">]</span> = <a href="#sbt.AList.tuple8;$anon" title="sbt.AList.T8List[A,B,C,D,E,F,G,H]{type T8[M[_]] = (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T8List[A,B,C,D,E,F,G,H]" id="sbt.AList.tuple8;$anon">T8List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])" id="sbt.AList.tuple8;$anon;T8">T8</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple8;$anon;T8;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon;T8;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span>, M<span class="delimiter">[</span>F<span class="delimiter">]</span>, M<span class="delimiter">[</span>G<span class="delimiter">]</span>, M<span class="delimiter">[</span>H<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H])" id="sbt.AList.tuple8;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple8;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple8;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])" id="sbt.AList.tuple8;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">T8</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple8;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E], _6: N[F], _7: N[G], _8: N[H])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[F]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[G]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[H]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple8;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple8;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple8;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])" id="sbt.AList.tuple8;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">T8</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple8;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple8;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple8;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple8;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[F]">_6</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[G]">_7</span>, <a href="#sbt.AList.tuple8;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[H]">_8</span>, <a href="#sbt.AList.tuple8;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])]" id="sbt.AList.tuple8;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple8;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple8;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple8;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple8;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])" id="sbt.AList.tuple8;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">T8</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple8;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple8;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple8;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])]">N</a><span class="delimiter">[</span>T8<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))))))" id="sbt.AList.tuple8;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple8.type">Tuple8</span>.<span title="[T1, T2, T3, T4, T5, T6, T7, T8](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5, _6: T6, _7: T7, _8: T8)(T1, T2, T3, T4, T5, T6, T7, T8)">apply</span><a href="#sbt.AList.tuple8;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E], _6: P[F], _7: P[G], _8: P[H])(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])" class="delimiter">[</a><a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[F]">P</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[G]">P</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a href="#sbt.AList.tuple8;$anon.traverse;P" title="P[H]">P</a><span class="delimiter">[</span>H<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))))))">curried</span>
        <a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])], v: N[P[H]])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))], v: N[P[G]])N[P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))], v: N[P[F]])N[P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))], v: N[P[E]])N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))))], v: N[P[D]])N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H])))))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H]))))))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[P[F]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[P[G]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[P[H]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple8;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T9K[A, B, C, D, E, F, G, H, I] extends AnyRef" id="sbt.AList;T9K">T9K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T9K;A">A</a>, <a title="" id="sbt.AList;T9K;B">B</a>, <a title="" id="sbt.AList;T9K;C">C</a>, <a title="" id="sbt.AList;T9K;D">D</a>, <a title="" id="sbt.AList;T9K;E">E</a>, <a title="" id="sbt.AList;T9K;F">F</a>, <a title="" id="sbt.AList;T9K;G">G</a>, <a title="" id="sbt.AList;T9K;H">H</a>, <a title="" id="sbt.AList;T9K;I">I</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I])" id="sbt.AList;T9K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T9K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T9K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span>, L<span class="delimiter">[</span>F<span class="delimiter">]</span>, L<span class="delimiter">[</span>G<span class="delimiter">]</span>, L<span class="delimiter">[</span>H<span class="delimiter">]</span>, L<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E, F, G, H, I]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I])]" id="sbt.AList;T9List">T9List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T9List;A">A</a>, <a title="" id="sbt.AList;T9List;B">B</a>, <a title="" id="sbt.AList;T9List;C">C</a>, <a title="" id="sbt.AList;T9List;D">D</a>, <a title="" id="sbt.AList;T9List;E">E</a>, <a title="" id="sbt.AList;T9List;F">F</a>, <a title="" id="sbt.AList;T9List;G">G</a>, <a title="" id="sbt.AList;T9List;H">H</a>, <a title="" id="sbt.AList;T9List;I">I</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I])]">AList</a><span class="delimiter">[</span>T9K<span class="delimiter">[</span>A, B, C, D, E, F, G, H, I<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E, F, G, H, I]=&gt; sbt.AList.T9List[A,B,C,D,E,F,G,H,I]" id="sbt.AList.tuple9">tuple9</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;A">A</a>, <a title="" id="sbt.AList.tuple9;B">B</a>, <a title="" id="sbt.AList.tuple9;C">C</a>, <a title="" id="sbt.AList.tuple9;D">D</a>, <a title="" id="sbt.AList.tuple9;E">E</a>, <a title="" id="sbt.AList.tuple9;F">F</a>, <a title="" id="sbt.AList.tuple9;G">G</a>, <a title="" id="sbt.AList.tuple9;H">H</a>, <a title="" id="sbt.AList.tuple9;I">I</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T9List[A,B,C,D,E,F,G,H,I]">T9List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H, I<span class="delimiter">]</span> = <a href="#sbt.AList.tuple9;$anon" title="sbt.AList.T9List[A,B,C,D,E,F,G,H,I]{type T9[M[_]] = (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T9List[A,B,C,D,E,F,G,H,I]" id="sbt.AList.tuple9;$anon">T9List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H, I<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])" id="sbt.AList.tuple9;$anon;T9">T9</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple9;$anon;T9;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon;T9;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span>, M<span class="delimiter">[</span>F<span class="delimiter">]</span>, M<span class="delimiter">[</span>G<span class="delimiter">]</span>, M<span class="delimiter">[</span>H<span class="delimiter">]</span>, M<span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H], N[I])" id="sbt.AList.tuple9;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple9;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple9;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])" id="sbt.AList.tuple9;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">T9</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple9;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E], _6: N[F], _7: N[G], _8: N[H], _9: N[I])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H], N[I])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[F]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[G]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[H]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[I])N[I]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[I]">_9</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple9;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple9;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple9;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])" id="sbt.AList.tuple9;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">T9</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple9;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple9;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple9;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple9;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[F]">_6</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[G]">_7</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[H]">_8</span>, <a href="#sbt.AList.tuple9;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[I]">_9</span>, <a href="#sbt.AList.tuple9;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])]" id="sbt.AList.tuple9;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple9;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple9;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple9;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple9;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])" id="sbt.AList.tuple9;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">T9</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple9;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple9;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple9;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])]">N</a><span class="delimiter">[</span>T9<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))))))" id="sbt.AList.tuple9;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple9.type">Tuple9</span>.<span title="[T1, T2, T3, T4, T5, T6, T7, T8, T9](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5, _6: T6, _7: T7, _8: T8, _9: T9)(T1, T2, T3, T4, T5, T6, T7, T8, T9)">apply</span><a href="#sbt.AList.tuple9;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E], _6: P[F], _7: P[G], _8: P[H], _9: P[I])(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])" class="delimiter">[</a><a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[F]">P</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[G]">P</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[H]">P</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a href="#sbt.AList.tuple9;$anon.traverse;P" title="P[I]">P</a><span class="delimiter">[</span>I<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))))))">curried</span>
        <a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])], v: N[P[I]])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))], v: N[P[H]])N[P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))], v: N[P[G]])N[P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))], v: N[P[F]])N[P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))], v: N[P[E]])N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))))], v: N[P[D]])N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I]))))))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I])))))))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[P[F]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[P[G]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[P[H]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[I])N[P[I]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple9;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I])">t</a>.<span title="=&gt; M[I]">_9</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T10K[A, B, C, D, E, F, G, H, I, J] extends AnyRef" id="sbt.AList;T10K">T10K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T10K;A">A</a>, <a title="" id="sbt.AList;T10K;B">B</a>, <a title="" id="sbt.AList;T10K;C">C</a>, <a title="" id="sbt.AList;T10K;D">D</a>, <a title="" id="sbt.AList;T10K;E">E</a>, <a title="" id="sbt.AList;T10K;F">F</a>, <a title="" id="sbt.AList;T10K;G">G</a>, <a title="" id="sbt.AList;T10K;H">H</a>, <a title="" id="sbt.AList;T10K;I">I</a>, <a title="" id="sbt.AList;T10K;J">J</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J])" id="sbt.AList;T10K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T10K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T10K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span>, L<span class="delimiter">[</span>F<span class="delimiter">]</span>, L<span class="delimiter">[</span>G<span class="delimiter">]</span>, L<span class="delimiter">[</span>H<span class="delimiter">]</span>, L<span class="delimiter">[</span>I<span class="delimiter">]</span>, L<span class="delimiter">[</span>J<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E, F, G, H, I, J]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J])]" id="sbt.AList;T10List">T10List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T10List;A">A</a>, <a title="" id="sbt.AList;T10List;B">B</a>, <a title="" id="sbt.AList;T10List;C">C</a>, <a title="" id="sbt.AList;T10List;D">D</a>, <a title="" id="sbt.AList;T10List;E">E</a>, <a title="" id="sbt.AList;T10List;F">F</a>, <a title="" id="sbt.AList;T10List;G">G</a>, <a title="" id="sbt.AList;T10List;H">H</a>, <a title="" id="sbt.AList;T10List;I">I</a>, <a title="" id="sbt.AList;T10List;J">J</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J])]">AList</a><span class="delimiter">[</span>T10K<span class="delimiter">[</span>A, B, C, D, E, F, G, H, I, J<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E, F, G, H, I, J]=&gt; sbt.AList.T10List[A,B,C,D,E,F,G,H,I,J]" id="sbt.AList.tuple10">tuple10</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;A">A</a>, <a title="" id="sbt.AList.tuple10;B">B</a>, <a title="" id="sbt.AList.tuple10;C">C</a>, <a title="" id="sbt.AList.tuple10;D">D</a>, <a title="" id="sbt.AList.tuple10;E">E</a>, <a title="" id="sbt.AList.tuple10;F">F</a>, <a title="" id="sbt.AList.tuple10;G">G</a>, <a title="" id="sbt.AList.tuple10;H">H</a>, <a title="" id="sbt.AList.tuple10;I">I</a>, <a title="" id="sbt.AList.tuple10;J">J</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T10List[A,B,C,D,E,F,G,H,I,J]">T10List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H, I, J<span class="delimiter">]</span> = <a href="#sbt.AList.tuple10;$anon" title="sbt.AList.T10List[A,B,C,D,E,F,G,H,I,J]{type T10[M[_]] = (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T10List[A,B,C,D,E,F,G,H,I,J]" id="sbt.AList.tuple10;$anon">T10List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H, I, J<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])" id="sbt.AList.tuple10;$anon;T10">T10</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple10;$anon;T10;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon;T10;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span>, M<span class="delimiter">[</span>F<span class="delimiter">]</span>, M<span class="delimiter">[</span>G<span class="delimiter">]</span>, M<span class="delimiter">[</span>H<span class="delimiter">]</span>, M<span class="delimiter">[</span>I<span class="delimiter">]</span>, M<span class="delimiter">[</span>J<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H], N[I], N[J])" id="sbt.AList.tuple10;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple10;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple10;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])" id="sbt.AList.tuple10;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">T10</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple10;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E], _6: N[F], _7: N[G], _8: N[H], _9: N[I], _10: N[J])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H], N[I], N[J])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[F]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[G]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[H]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[I])N[I]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[I]">_9</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[J])N[J]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[J]">_10</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple10;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple10;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple10;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])" id="sbt.AList.tuple10;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">T10</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple10;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple10;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple10;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple10;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[F]">_6</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[G]">_7</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[H]">_8</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[I]">_9</span>, <a href="#sbt.AList.tuple10;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[J]">_10</span>, <a href="#sbt.AList.tuple10;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])]" id="sbt.AList.tuple10;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple10;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple10;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple10;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple10;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])" id="sbt.AList.tuple10;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">T10</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple10;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple10;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple10;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])]">N</a><span class="delimiter">[</span>T10<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))))))" id="sbt.AList.tuple10;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple10.type">Tuple10</span>.<span title="[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5, _6: T6, _7: T7, _8: T8, _9: T9, _10: T10)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)">apply</span><a href="#sbt.AList.tuple10;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E], _6: P[F], _7: P[G], _8: P[H], _9: P[I], _10: P[J])(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])" class="delimiter">[</a><a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[F]">P</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[G]">P</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[H]">P</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[I]">P</a><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a href="#sbt.AList.tuple10;$anon.traverse;P" title="P[J]">P</a><span class="delimiter">[</span>J<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))))))">curried</span>
        <a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])], v: N[P[J]])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))], v: N[P[I]])N[P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))], v: N[P[H]])N[P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))], v: N[P[G]])N[P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))], v: N[P[F]])N[P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))], v: N[P[E]])N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))))], v: N[P[D]])N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J])))))))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J]))))))))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[P[F]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[P[G]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[P[H]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[I])N[P[I]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[I]">_9</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[J])N[P[J]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple10;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J])">t</a>.<span title="=&gt; M[J]">_10</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait T11K[A, B, C, D, E, F, G, H, I, J, K] extends AnyRef" id="sbt.AList;T11K">T11K</a><span class="delimiter">[</span><a title="" id="sbt.AList;T11K;A">A</a>, <a title="" id="sbt.AList;T11K;B">B</a>, <a title="" id="sbt.AList;T11K;C">C</a>, <a title="" id="sbt.AList;T11K;D">D</a>, <a title="" id="sbt.AList;T11K;E">E</a>, <a title="" id="sbt.AList;T11K;F">F</a>, <a title="" id="sbt.AList;T11K;G">G</a>, <a title="" id="sbt.AList;T11K;H">H</a>, <a title="" id="sbt.AList;T11K;I">I</a>, <a title="" id="sbt.AList;T11K;J">J</a>, <a title="" id="sbt.AList;T11K;K">K</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J], L[K])" id="sbt.AList;T11K;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt.AList;T11K;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt.AList;T11K;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J], L[K])" class="delimiter">(</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span>, L<span class="delimiter">[</span>B<span class="delimiter">]</span>, L<span class="delimiter">[</span>C<span class="delimiter">]</span>, L<span class="delimiter">[</span>D<span class="delimiter">]</span>, L<span class="delimiter">[</span>E<span class="delimiter">]</span>, L<span class="delimiter">[</span>F<span class="delimiter">]</span>, L<span class="delimiter">[</span>G<span class="delimiter">]</span>, L<span class="delimiter">[</span>H<span class="delimiter">]</span>, L<span class="delimiter">[</span>I<span class="delimiter">]</span>, L<span class="delimiter">[</span>J<span class="delimiter">]</span>, L<span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[A, B, C, D, E, F, G, H, I, J, K]sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J], L[K])]" id="sbt.AList;T11List">T11List</a><span class="delimiter">[</span><a title="" id="sbt.AList;T11List;A">A</a>, <a title="" id="sbt.AList;T11List;B">B</a>, <a title="" id="sbt.AList;T11List;C">C</a>, <a title="" id="sbt.AList;T11List;D">D</a>, <a title="" id="sbt.AList;T11List;E">E</a>, <a title="" id="sbt.AList;T11List;F">F</a>, <a title="" id="sbt.AList;T11List;G">G</a>, <a title="" id="sbt.AList;T11List;H">H</a>, <a title="" id="sbt.AList;T11List;I">I</a>, <a title="" id="sbt.AList;T11List;J">J</a>, <a title="" id="sbt.AList;T11List;K">K</a><span class="delimiter">]</span> = <a href="#sbt;AList" title="sbt.AList[[L[x]](L[A], L[B], L[C], L[D], L[E], L[F], L[G], L[H], L[I], L[J], L[K])]">AList</a><span class="delimiter">[</span>T11K<span class="delimiter">[</span>A, B, C, D, E, F, G, H, I, J, K<span class="delimiter">]</span>#l<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[A, B, C, D, E, F, G, H, I, J, K]=&gt; sbt.AList.T11List[A,B,C,D,E,F,G,H,I,J,K]" id="sbt.AList.tuple11">tuple11</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;A">A</a>, <a title="" id="sbt.AList.tuple11;B">B</a>, <a title="" id="sbt.AList.tuple11;C">C</a>, <a title="" id="sbt.AList.tuple11;D">D</a>, <a title="" id="sbt.AList.tuple11;E">E</a>, <a title="" id="sbt.AList.tuple11;F">F</a>, <a title="" id="sbt.AList.tuple11;G">G</a>, <a title="" id="sbt.AList.tuple11;H">H</a>, <a title="" id="sbt.AList.tuple11;I">I</a>, <a title="" id="sbt.AList.tuple11;J">J</a>, <a title="" id="sbt.AList.tuple11;K">K</a><span class="delimiter">]</span>: <a href="#sbt;AList" title="sbt.AList.T11List[A,B,C,D,E,F,G,H,I,J,K]">T11List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H, I, J, K<span class="delimiter">]</span> = <a href="#sbt.AList.tuple11;$anon" title="sbt.AList.T11List[A,B,C,D,E,F,G,H,I,J,K]{type T11[M[_]] = (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.AList.T11List[A,B,C,D,E,F,G,H,I,J,K]" id="sbt.AList.tuple11;$anon">T11List</a><span class="delimiter">[</span>A, B, C, D, E, F, G, H, I, J, K<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[M[_]](M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])" id="sbt.AList.tuple11;$anon;T11">T11</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple11;$anon;T11;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon;T11;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">[</span>B<span class="delimiter">]</span>, M<span class="delimiter">[</span>C<span class="delimiter">]</span>, M<span class="delimiter">[</span>D<span class="delimiter">]</span>, M<span class="delimiter">[</span>E<span class="delimiter">]</span>, M<span class="delimiter">[</span>F<span class="delimiter">]</span>, M<span class="delimiter">[</span>G<span class="delimiter">]</span>, M<span class="delimiter">[</span>H<span class="delimiter">]</span>, M<span class="delimiter">[</span>I<span class="delimiter">]</span>, M<span class="delimiter">[</span>J<span class="delimiter">]</span>, M<span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K]), f: sbt.~&gt;[M,N])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H], N[I], N[J], N[K])" id="sbt.AList.tuple11;$anon.transform">transform</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple11;$anon.transform;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon.transform;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple11;$anon.transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon.transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])" id="sbt.AList.tuple11;$anon.transform.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">T11</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,N]" id="sbt.AList.tuple11;$anon.transform.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <span title="(_1: N[A], _2: N[B], _3: N[C], _4: N[D], _5: N[E], _6: N[F], _7: N[G], _8: N[H], _9: N[I], _10: N[J], _11: N[K])(N[A], N[B], N[C], N[D], N[E], N[F], N[G], N[H], N[I], N[J], N[K])" class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[A]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[B]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[C]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[D]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[E]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[F]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[G]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[H]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[I])N[I]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[I]">_9</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[J])N[J]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[J]">_10</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[K])N[K]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.transform.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[K]">_11</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], T](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K]), f: (M[_], T) =&gt; T, init: T)T" id="sbt.AList.tuple11;$anon.foldr">foldr</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple11;$anon.foldr;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon.foldr;M;_">_</a><span class="delimiter">]</span>, <a title="" id="sbt.AList.tuple11;$anon.foldr;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])" id="sbt.AList.tuple11;$anon.foldr.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">T11</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="(M[_], T) =&gt; T" id="sbt.AList.tuple11;$anon.foldr.f">f</a>: <span class="delimiter">(</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T, <a title="T" id="sbt.AList.tuple11;$anon.foldr.init">init</a>: <a href="#sbt.AList.tuple11;$anon.foldr;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.AList.tuple11;$anon.foldr;T" title="T">T</a> = <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[A]">_1</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[B]">_2</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[C]">_3</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[D]">_4</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[E]">_5</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[F]">_6</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[G]">_7</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[H]">_8</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[I]">_9</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[J]">_10</span>, <a href="#sbt.AList.tuple11;$anon.foldr.f" title="(v1: M[_], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.foldr.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[K]">_11</span>, <a href="#sbt.AList.tuple11;$anon.foldr.init" title="T">init</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_], N[_], P[_]](t: (M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K]), f: sbt.~&gt;[M,[T]N[P[T]]])(implicit np: sbt.Classes.Applicative[N])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])]" id="sbt.AList.tuple11;$anon.traverse">traverse</a><span class="delimiter">[</span><a title="[_]" id="sbt.AList.tuple11;$anon.traverse;M">M</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon.traverse;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple11;$anon.traverse;N">N</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon.traverse;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.AList.tuple11;$anon.traverse;P">P</a><span class="delimiter">[</span><a title="" id="sbt.AList.tuple11;$anon.traverse;P;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])" id="sbt.AList.tuple11;$anon.traverse.t">t</a>: <span title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">T11</span><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="sbt.~&gt;[M,[T]N[P[T]]]" id="sbt.AList.tuple11;$anon.traverse.f">f</a>: M <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[M,[T]N[P[T]]]">~&gt;</a> <span class="delimiter">(</span>N âˆ™ P<span class="delimiter">)</span>#l<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[N]" id="sbt.AList.tuple11;$anon.traverse.np">np</a>: <a href="Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.AList.tuple11;$anon.traverse;N" title="N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])]">N</a><span class="delimiter">[</span>T11<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))))))" id="sbt.AList.tuple11;$anon.traverse.g">g</a> = <span class="delimiter">(</span><span title="Tuple11.type">Tuple11</span>.<span title="[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5, _6: T6, _7: T7, _8: T8, _9: T9, _10: T10, _11: T11)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)">apply</span><a href="#sbt.AList.tuple11;$anon.traverse.g.$anonfun._1" title="(_1: P[A], _2: P[B], _3: P[C], _4: P[D], _5: P[E], _6: P[F], _7: P[G], _8: P[H], _9: P[I], _10: P[J], _11: P[K])(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])" class="delimiter">[</a><a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[A]">P</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[B]">P</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[C]">P</a><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[D]">P</a><span class="delimiter">[</span>D<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[E]">P</a><span class="delimiter">[</span>E<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[F]">P</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[G]">P</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[H]">P</a><span class="delimiter">[</span>H<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[I]">P</a><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[J]">P</a><span class="delimiter">[</span>J<span class="delimiter">]</span>, <a href="#sbt.AList.tuple11;$anon.traverse;P" title="P[K]">P</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">]</span> _<span class="delimiter">)</span>.<span title="=&gt; P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))))))">curried</span>
        <a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])], v: N[P[K]])N[(P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))], v: N[P[J]])N[P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))], v: N[P[I]])N[P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))], v: N[P[H]])N[P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))], v: N[P[G]])N[P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))], v: N[P[F]])N[P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))], v: N[P[E]])N[P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))))], v: N[P[D]])N[P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))))], v: N[P[C]])N[P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.apply" title="(f: N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))))))], v: N[P[B]])N[P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))))]">apply</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.np" title="sbt.Classes.Applicative[N]">np</a>.<a href="Classes.scala.html#sbt.Classes;Applicative.map" title="(f: P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))))))), v: N[P[A]])N[P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K]))))))))))]">map</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.g" title="P[A] =&gt; (P[B] =&gt; (P[C] =&gt; (P[D] =&gt; (P[E] =&gt; (P[F] =&gt; (P[G] =&gt; (P[H] =&gt; (P[I] =&gt; (P[J] =&gt; (P[K] =&gt; (P[A], P[B], P[C], P[D], P[E], P[F], P[G], P[H], P[I], P[J], P[K])))))))))))">g</a>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[A])N[P[A]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[B])N[P[B]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[C])N[P[C]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[C]">_3</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[D])N[P[D]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[D]">_4</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[E])N[P[E]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[E]">_5</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[F])N[P[F]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[F]">_6</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[G])N[P[G]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[G]">_7</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[H])N[P[H]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[H]">_8</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[I])N[P[I]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[I]">_9</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[J])N[P[J]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[J]">_10</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: M[K])N[P[K]]">f</a><span class="delimiter">(</span><a href="#sbt.AList.tuple11;$anon.traverse.t" title="(M[A], M[B], M[C], M[D], M[E], M[F], M[G], M[H], M[I], M[J], M[K])">t</a>.<span title="=&gt; M[K]">_11</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
