<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/std/SettingMacro.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> std

<span class="keyword">import</span> <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<span class="delimiter">{</span> Initialize, Setting <span class="delimiter">}</span>
<span class="keyword">import</span> <a href="../Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>.<span class="delimiter">{</span> idFun, Id <span class="delimiter">}</span>
<span class="keyword">import</span> appmacro.<span class="delimiter">{</span> Convert, Converted, Instance, MixedBuilder, MonadInstance <span class="delimiter">}</span>

<span class="keyword">object</span> <a title="sbt.std.InitializeInstance.type" id="sbt.std.InitializeInstance">InitializeInstance</a> <a href="#sbt.std.InitializeInstance" title="sbt.std.InitializeInstance.type" class="keyword">extends</a> <a href="../appmacro/Instance.scala.html#sbt.appmacro;MonadInstance" title="sbt.appmacro.MonadInstance">MonadInstance</a> <span class="delimiter">{</span>
  <span class="keyword">type</span> <a title="[x]sbt.Def.Initialize[x]" id="sbt.std.InitializeInstance;M">M</a><span class="delimiter">[</span><a title="" id="sbt.std.InitializeInstance;M;x">x</a><span class="delimiter">]</span> = <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[x]">Initialize</a><span class="delimiter">[</span>x<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[K[L[x]], Z](in: K[sbt.Def.Initialize], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])sbt.Def.Initialize[Z]" id="sbt.std.InitializeInstance.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.std.InitializeInstance.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.std.InitializeInstance.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.std.InitializeInstance.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt.std.InitializeInstance.app;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[sbt.Def.Initialize]" id="sbt.std.InitializeInstance.app.in">in</a>: <a href="#sbt.std.InitializeInstance.app;K" title="K[sbt.Def.Initialize]">K</a><span class="delimiter">[</span>Initialize<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; Z" id="sbt.std.InitializeInstance.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt.std.InitializeInstance.app.a">a</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[Z]">Initialize</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.app" title="[K[L[x]], T](inputs: K[sbt.Def.Initialize])(f: K[sbt.Types.Id] =&gt; T)(implicit alist: sbt.AList[K])sbt.Def.Initialize[T]">app</a><span title="(inputs: K[sbt.Def.Initialize])(f: K[sbt.Types.Id] =&gt; Z)(implicit alist: sbt.AList[K])sbt.Def.Initialize[Z]" class="delimiter">[</span><a href="#sbt.std.InitializeInstance.app;K" title="K">K</a>, <a href="#sbt.std.InitializeInstance.app;Z" title="Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.app.in" title="K[sbt.Def.Initialize]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.app.f" title="K[sbt.Types.Id] =&gt; Z">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.app.a" title="sbt.AList[K]">a</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[S, T](in: sbt.Def.Initialize[S], f: S =&gt; T)sbt.Def.Initialize[T]" id="sbt.std.InitializeInstance.map">map</a><span class="delimiter">[</span><a title="" id="sbt.std.InitializeInstance.map;S">S</a>, <a title="" id="sbt.std.InitializeInstance.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.Initialize[S]" id="sbt.std.InitializeInstance.map.in">in</a>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="S =&gt; T" id="sbt.std.InitializeInstance.map.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.map" title="(in: sbt.Def.Initialize[S])(f: S =&gt; T)sbt.Def.Initialize[T]">map</a><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.map.in" title="sbt.Def.Initialize[S]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.map.f" title="S =&gt; T">f</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](in: sbt.Def.Initialize[sbt.Def.Initialize[T]])sbt.Def.Initialize[T]" id="sbt.std.InitializeInstance.flatten">flatten</a><span class="delimiter">[</span><a title="" id="sbt.std.InitializeInstance.flatten;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.Initialize[sbt.Def.Initialize[T]]" id="sbt.std.InitializeInstance.flatten.in">in</a>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Def.Initialize[T]]">Initialize</a><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.bind" title="(in: sbt.Def.Initialize[sbt.Def.Initialize[T]])(f: sbt.Def.Initialize[T] =&gt; sbt.Def.Initialize[T])sbt.Def.Initialize[T]">bind</a><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.flatten.in" title="sbt.Def.Initialize[sbt.Def.Initialize[T]]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="[T]=&gt; T =&gt; T">idFun</a><span title="sbt.Def.Initialize[T] =&gt; sbt.Def.Initialize[T]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](t: () =&gt; T)sbt.Def.Initialize[T]" id="sbt.std.InitializeInstance.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.std.InitializeInstance.pure;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; T" id="sbt.std.InitializeInstance.pure.t">t</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.pure" title="(value: () =&gt; T)sbt.Def.Initialize[T]">pure</a><span class="delimiter">(</span><a href="#sbt.std.InitializeInstance.pure.t" title="() =&gt; T">t</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">import</span> <span title="language.type">language</span>.<span title="language.experimental.type">experimental</span>.macros
<span class="keyword">import</span> scala.reflect._
<span class="keyword">import</span> reflect.macros._

<span class="keyword">object</span> <a title="sbt.std.InitializeConvert.type" id="sbt.std.InitializeConvert">InitializeConvert</a> <a href="#sbt.std.InitializeConvert" title="sbt.std.InitializeConvert.type" class="keyword">extends</a> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" id="sbt.std.InitializeConvert.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.InitializeConvert.apply;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.InitializeConvert.apply.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.InitializeConvert.apply.nme">nme</a>: <span title="String">String</span>, <a title="c.Tree" id="sbt.std.InitializeConvert.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
    <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapInit_☃☃&quot;)">WrapInitName</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="c.Expr[sbt.Def.Initialize[T]]" id="sbt.std.InitializeConvert.apply.i">i</a> = <a href="#sbt.std.InitializeConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[T]])c.Expr[sbt.Def.Initialize[T]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.InitializeConvert.apply.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[T]]" class="delimiter">(</a><a href="#sbt.std.InitializeConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="c.universe.Tree" id="sbt.std.InitializeConvert.apply.t">t</a> = <a href="#sbt.std.InitializeConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Def.Initialize[T])c.universe.Expr[sbt.Def.Initialize[T]]">reify</span><span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.i" title="c.Expr[sbt.Def.Initialize[T]]">i</a>.<span title="=&gt; sbt.Def.Initialize[T]">splice</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.t" title="c.universe.Tree">t</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapTask_☃☃&quot;)">WrapTaskName</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.std.InitializeConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapInitTask_☃☃&quot;)">WrapInitTaskName</span><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted;Failure" title="(position: c.Position, message: String)sbt.appmacro.Converted.Failure[c.type]">Failure</a><span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.in" title="c.Tree">in</a>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;A setting cannot depend on a task&quot;)" class="string">&quot;A setting cannot depend on a task&quot;</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapPrevious_☃☃&quot;)">WrapPreviousName</span><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted;Failure" title="(position: c.Position, message: String)sbt.appmacro.Converted.Failure[c.type]">Failure</a><span class="delimiter">(</span><a href="#sbt.std.InitializeConvert.apply.in" title="c.Tree">in</a>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;A setting cannot depend on a task\'s previous value.&quot;)" class="string">&quot;A setting cannot depend on a task's previous value.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="sbt.std.SettingMacro.type" id="sbt.std.SettingMacro">SettingMacro</a> <a href="#sbt.std.SettingMacro" title="sbt.std.SettingMacro.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[T])(implicit evidence$2: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[T]]" id="sbt.std.SettingMacro.settingMacroImpl">settingMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.SettingMacro.settingMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.SettingMacro.settingMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.std.SettingMacro.settingMacroImpl.t">t</a>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[T]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.SettingMacro.settingMacroImpl;T" title="T">T</a>, <a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.SettingMacro.settingMacroImpl.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.InitializeInstance" title="sbt.std.InitializeInstance.type">InitializeInstance</a>, <a href="#sbt.std.InitializeConvert" title="sbt.std.InitializeConvert.type">InitializeConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.SettingMacro.settingMacroImpl.evidence$2" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(a: c.Expr[T])scala.util.Left[c.Expr[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.std.SettingMacro.settingMacroImpl.t" title="c.Expr[T]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">idTransform</a><span title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(t: c.Expr[sbt.Def.Initialize[T]])(implicit evidence$3: c.WeakTypeTag[T])c.Expr[sbt.Def.Initialize[T]]" id="sbt.std.SettingMacro.settingDynMacroImpl">settingDynMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.std.SettingMacro.settingDynMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.SettingMacro.settingDynMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[sbt.Def.Initialize[T]]" id="sbt.std.SettingMacro.settingDynMacroImpl.t">t</a>: c.<span title="c.Expr[sbt.Def.Initialize[T]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[sbt.Def.Initialize[T]]">Expr</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.contImpl" title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]">contImpl</a><span title="(c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[sbt.Types.Id[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[sbt.Types.Id[T]]]" class="delimiter">[</span><a href="#sbt.std.SettingMacro.settingDynMacroImpl;T" title="T">T</a>, <a href="../TypeFunctions.scala.html#sbt;TypeFunctions;Id;X" title="sbt.Types.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.SettingMacro.settingDynMacroImpl.c" title="scala.reflect.macros.Context">c</a>, <a href="#sbt.std.InitializeInstance" title="sbt.std.InitializeInstance.type">InitializeInstance</a>, <a href="#sbt.std.InitializeConvert" title="sbt.std.InitializeConvert.type">InitializeConvert</a>, <a href="../appmacro/MixedBuilder.scala.html#sbt.appmacro.MixedBuilder" title="sbt.appmacro.MixedBuilder.type">MixedBuilder</a><span class="delimiter">)</span><a href="#sbt.std.SettingMacro.settingDynMacroImpl.evidence$3" title="c.WeakTypeTag[T]" class="delimiter">(</a><span title="(b: c.Expr[sbt.Def.Initialize[T]])scala.util.Right[Nothing,c.Expr[sbt.Def.Initialize[T]]]">Right</span><span class="delimiter">(</span><a href="#sbt.std.SettingMacro.settingDynMacroImpl.t" title="c.Expr[sbt.Def.Initialize[T]]">t</a><span class="delimiter">)</span>, <a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type">Instance</a>.<a href="../appmacro/Instance.scala.html#sbt.appmacro.Instance.idTransform" title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">idTransform</a><span title="sbt.appmacro.Instance.Transform[c.type,sbt.Types.Id]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
