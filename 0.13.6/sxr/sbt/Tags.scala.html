<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Tags.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> annotation.tailrec

<span class="keyword">object</span> <a title="sbt.Tags.type" id="sbt.Tags">Tags</a> <a href="#sbt.Tags" title="sbt.Tags.type" class="delimiter">{</a>
  <span class="keyword">type</span> <a title="sbt.ConcurrentRestrictions.Tag" id="sbt.Tags;Tag">Tag</a> = ConcurrentRestrictions.<a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.ConcurrentRestrictions.Tag">Tag</a>
  <span class="keyword">type</span> <a title="sbt.ConcurrentRestrictions.TagMap" id="sbt.Tags;TagMap">TagMap</a> = ConcurrentRestrictions.<span title="sbt.ConcurrentRestrictions.TagMap">TagMap</span>
  <span class="keyword">def</span> <a title="(s: String)sbt.Tags.Tag" id="sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><a title="String" id="sbt.Tags.Tag.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.Tags.Tag">Tag</a> = <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions" title="sbt.ConcurrentRestrictions.type">ConcurrentRestrictions</a>.<a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="(name: String)sbt.ConcurrentRestrictions.Tag">Tag</a><span class="delimiter">(</span><a href="#sbt.Tags.Tag.s" title="String">s</a><span class="delimiter">)</span>

  <span class="keyword">val</span> <a title="sbt.ConcurrentRestrictions.Tag" id="sbt.Tags.All">All</a> = <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions" title="sbt.ConcurrentRestrictions.type">ConcurrentRestrictions</a>.<a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions.All" title="=&gt; sbt.ConcurrentRestrictions.Tag">All</a>
  <span class="keyword">val</span> <a title="sbt.ConcurrentRestrictions.Tag" id="sbt.Tags.Untagged">Untagged</a> = <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions" title="sbt.ConcurrentRestrictions.type">ConcurrentRestrictions</a>.<a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions.Untagged" title="=&gt; sbt.ConcurrentRestrictions.Tag">Untagged</a>
  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.Compile">Compile</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;compile&quot;)" class="string">&quot;compile&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.Test">Test</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;test&quot;)" class="string">&quot;test&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.Update">Update</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;update&quot;)" class="string">&quot;update&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.Publish">Publish</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;publish&quot;)" class="string">&quot;publish&quot;</span><span class="delimiter">)</span>

  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.CPU">CPU</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;cpu&quot;)" class="string">&quot;cpu&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.Network">Network</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;network&quot;)" class="string">&quot;network&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.Disk">Disk</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;disk&quot;)" class="string">&quot;disk&quot;</span><span class="delimiter">)</span>

  <span class="keyword">val</span> <a title="sbt.Tags.Tag" id="sbt.Tags.ForkedTestGroup">ForkedTestGroup</a> = <a href="#sbt.Tags.Tag" title="(s: String)sbt.Tags.Tag">Tag</a><span class="delimiter">(</span><span title="String(&quot;forked-test-group&quot;)" class="string">&quot;forked-test-group&quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Describes a restriction on concurrently executing tasks.
   * A Rule is constructed using one of the Tags.limit* methods.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Rule extends AnyRef" id="sbt.Tags;Rule">Rule</a> <span title="Unit" class="delimiter">{</span> <span class="comment">// TODO: make this an abstract class for 0.14</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;Rule.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;Rule.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>
    <span class="keyword">def</span> <a title="(r: sbt.Tags.Rule)sbt.Tags.Rule" id="sbt.Tags;Rule.||">||</a><span class="delimiter">(</span><a title="sbt.Tags.Rule" id="sbt.Tags;Rule.||.r">r</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <span title="sbt.Tags.Or" class="keyword">new</span> <a href="#sbt.Tags;Or" title="sbt.Tags.Or">Or</a><span class="delimiter">(</span><a href="#sbt.Tags;Rule" title="sbt.Tags.Rule" class="keyword">this</a>, <a href="#sbt.Tags;Rule.||.r" title="sbt.Tags.Rule">r</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(r: sbt.Tags.Rule)sbt.Tags.Rule" id="sbt.Tags;Rule.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="sbt.Tags.Rule" id="sbt.Tags;Rule.&&.r">r</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <span title="sbt.Tags.And" class="keyword">new</span> <a href="#sbt.Tags;And" title="sbt.Tags.And">And</a><span class="delimiter">(</span><a href="#sbt.Tags;Rule" title="sbt.Tags.Rule" class="keyword">this</a>, <a href="#sbt.Tags;Rule.&&.r" title="sbt.Tags.Rule">r</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.Tags.Rule" id="sbt.Tags;Rule.unary_-">unary_-</a> : <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <span title="sbt.Tags.Not" class="keyword">new</span> <a href="#sbt.Tags;Not" title="sbt.Tags.Not">Not</a><span class="delimiter">(</span><a href="#sbt.Tags;Rule" title="sbt.Tags.Rule" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Custom extends AnyRef with sbt.Tags.Rule" id="sbt.Tags;Custom">Custom</a><a href="#sbt.Tags;Custom" title="sbt.Tags.Custom" class="delimiter">(</a><a title="sbt.Tags.TagMap =&gt; Boolean" id="sbt.Tags;Custom.f">f</a>: TagMap =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;Custom.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;Custom.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span> = <a href="#sbt.Tags;Custom.f" title="(v1: sbt.Tags.TagMap)Boolean">f</a><span class="delimiter">(</span><a href="#sbt.Tags;Custom.apply.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Single extends AnyRef with sbt.Tags.Rule" id="sbt.Tags;Single">Single</a><a href="#sbt.Tags;Single" title="sbt.Tags.Single" class="delimiter">(</a><a title="sbt.Tags.Tag" id="sbt.Tags;Single.tag">tag</a>: <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.Tags.Tag">Tag</a>, <a title="Int" id="sbt.Tags;Single.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> <span class="delimiter">{</span>
    <a href="#sbt.Tags.checkMax" title="(max: Int)Unit">checkMax</a><span class="delimiter">(</span><a href="#sbt.Tags;Single.max" title="Int">max</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;Single.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;Single.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span> = <a href="#sbt.Tags.getInt" title="(m: sbt.Tags.TagMap, tag: sbt.Tags.Tag)Int">getInt</a><span class="delimiter">(</span><a href="#sbt.Tags;Single.apply.m" title="sbt.Tags.TagMap">m</a>, <a href="#sbt.Tags;Single.tag" title="sbt.Tags.Tag">tag</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#sbt.Tags;Single.max" title="Int">max</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.Tags;Single.toString">toString</a> = <span title="String(&quot;Limit &quot;)" class="string">&quot;Limit &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Tags;Single.tag" title="sbt.Tags.Tag">tag</a>.<a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag.name" title="=&gt; String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Tags;Single.max" title="Int">max</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Sum extends AnyRef with sbt.Tags.Rule" id="sbt.Tags;Sum">Sum</a><a href="#sbt.Tags;Sum" title="sbt.Tags.Sum" class="delimiter">(</a><a title="Seq[sbt.Tags.Tag]" id="sbt.Tags;Sum.tags">tags</a>: <span title="Seq[sbt.Tags.Tag]">Seq</span><span class="delimiter">[</span>Tag<span class="delimiter">]</span>, <a title="Int" id="sbt.Tags;Sum.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> <span class="delimiter">{</span>
    <a href="#sbt.Tags.checkMax" title="(max: Int)Unit">checkMax</a><span class="delimiter">(</span><a href="#sbt.Tags;Sum.max" title="Int">max</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;Sum.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;Sum.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span> = <span class="delimiter">(</span><span title="Int(0)" class="int">0</span> <a href="#sbt.Tags;Sum.apply.x$1" title="(z: Int)(op: (Int, sbt.Tags.Tag) =&gt; Int)Int">/:</a> <a href="#sbt.Tags;Sum.tags" title="Seq[sbt.Tags.Tag]">tags</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="sbt.Tags;Sum.apply.$anonfun.sum">sum</a>, <a title="sbt.Tags.Tag" id="sbt.Tags;Sum.apply.$anonfun.t">t</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Tags;Sum.apply.$anonfun.sum" title="Int">sum</a> <span title="(x: Int)Int">+</span> <a href="#sbt.Tags.getInt" title="(m: sbt.Tags.TagMap, tag: sbt.Tags.Tag)Int">getInt</a><span class="delimiter">(</span><a href="#sbt.Tags;Sum.apply.m" title="sbt.Tags.TagMap">m</a>, <a href="#sbt.Tags;Sum.apply.$anonfun.t" title="sbt.Tags.Tag">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#sbt.Tags;Sum.max" title="Int">max</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.Tags;Sum.toString">toString</a> = <a href="#sbt.Tags;Sum.tags" title="Seq[sbt.Tags.Tag]">tags</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;Limit sum of &quot;)" class="string">&quot;Limit sum of &quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.Tags;Sum.max" title="Int">max</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Or extends AnyRef with sbt.Tags.Rule" id="sbt.Tags;Or">Or</a><a href="#sbt.Tags;Or" title="sbt.Tags.Or" class="delimiter">(</a><a title="sbt.Tags.Rule" id="sbt.Tags;Or.a">a</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a>, <a title="sbt.Tags.Rule" id="sbt.Tags;Or.b">b</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;Or.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;Or.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span> = <a href="#sbt.Tags;Rule.apply" title="(m: sbt.Tags.TagMap)Boolean">a</a><span class="delimiter">(</span><a href="#sbt.Tags;Or.apply.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.Tags;Rule.apply" title="(m: sbt.Tags.TagMap)Boolean">b</a><span class="delimiter">(</span><a href="#sbt.Tags;Or.apply.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class And extends AnyRef with sbt.Tags.Rule" id="sbt.Tags;And">And</a><a href="#sbt.Tags;And" title="sbt.Tags.And" class="delimiter">(</a><a title="sbt.Tags.Rule" id="sbt.Tags;And.a">a</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a>, <a title="sbt.Tags.Rule" id="sbt.Tags;And.b">b</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;And.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;And.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span> = <a href="#sbt.Tags;Rule.apply" title="(m: sbt.Tags.TagMap)Boolean">a</a><span class="delimiter">(</span><a href="#sbt.Tags;And.apply.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.Tags;Rule.apply" title="(m: sbt.Tags.TagMap)Boolean">b</a><span class="delimiter">(</span><a href="#sbt.Tags;And.apply.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Not extends AnyRef with sbt.Tags.Rule" id="sbt.Tags;Not">Not</a><a href="#sbt.Tags;Not" title="sbt.Tags.Not" class="delimiter">(</a><a title="sbt.Tags.Rule" id="sbt.Tags;Not.a">a</a>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap)Boolean" id="sbt.Tags;Not.apply">apply</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags;Not.apply.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span><span class="delimiter">)</span> = <span title="=&gt; Boolean">!</span><a href="#sbt.Tags;Rule.apply" title="(m: sbt.Tags.TagMap)Boolean">a</a><span class="delimiter">(</span><a href="#sbt.Tags;Not.apply.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(max: Int)Unit" id="sbt.Tags.checkMax">checkMax</a><span class="delimiter">(</span><a title="Int" id="sbt.Tags.checkMax.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.Tags.checkMax.max" title="Int">max</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(1)" class="int">1</span>, <span title="String(&quot;Limit must be at least 1.&quot;)" class="string">&quot;Limit must be at least 1.&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Converts a sequence of rules into a function that identifies whether a set of tasks are allowed to execute concurrently based on their merged tags. */</span>
  <span class="keyword">def</span> <a title="(rules: Seq[sbt.Tags.Rule])sbt.Tags.TagMap =&gt; Boolean" id="sbt.Tags.predicate">predicate</a><span class="delimiter">(</span><a title="Seq[sbt.Tags.Rule]" id="sbt.Tags.predicate.rules">rules</a>: <span title="Seq[sbt.Tags.Rule]">Seq</span><span class="delimiter">[</span>Rule<span class="delimiter">]</span><span class="delimiter">)</span>: TagMap =&gt; Boolean = <a title="sbt.Tags.TagMap" id="sbt.Tags.predicate.$anonfun.m">m</a> =&gt; <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(rules: List[sbt.Tags.Rule])Boolean" id="sbt.Tags.predicate.$anonfun.loop">loop</a><span class="delimiter">(</span><a title="List[sbt.Tags.Rule]" id="sbt.Tags.predicate.$anonfun.loop.rules">rules</a>: <span title="List[sbt.Tags.Rule]">List</span><span class="delimiter">[</span>Rule<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#sbt.Tags.predicate.$anonfun.loop.rules" title="List[sbt.Tags.Rule]">rules</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="sbt.Tags.Rule" id="sbt.Tags.predicate.$anonfun.loop.x">x</a> :: <a title="List[sbt.Tags.Rule]" id="sbt.Tags.predicate.$anonfun.loop.xs">xs</a> =&gt; <a href="#sbt.Tags;Rule.apply" title="(m: sbt.Tags.TagMap)Boolean">x</a><span class="delimiter">(</span><a href="#sbt.Tags.predicate.$anonfun.m" title="sbt.Tags.TagMap">m</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.Tags.predicate.$anonfun.loop" title="(rules: List[sbt.Tags.Rule])Boolean">loop</a><span class="delimiter">(</span><a href="#sbt.Tags.predicate.$anonfun.loop.xs" title="List[sbt.Tags.Rule]">xs</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span>     =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
    <a href="#sbt.Tags.predicate.$anonfun.loop" title="(rules: List[sbt.Tags.Rule])Boolean">loop</a><span class="delimiter">(</span><a href="#sbt.Tags.predicate.rules" title="Seq[sbt.Tags.Rule]">rules</a>.<span title="=&gt; List[sbt.Tags.Rule]">toList</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(m: sbt.Tags.TagMap, tag: sbt.Tags.Tag)Int" id="sbt.Tags.getInt">getInt</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap" id="sbt.Tags.getInt.m">m</a>: <span title="sbt.Tags.TagMap">TagMap</span>, <a title="sbt.Tags.Tag" id="sbt.Tags.getInt.tag">tag</a>: <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.Tags.Tag">Tag</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#sbt.Tags.getInt.m" title="sbt.Tags.TagMap">m</a>.<span title="(key: sbt.ConcurrentRestrictions.Tag, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Tags.getInt.tag" title="sbt.Tags.Tag">tag</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Constructs a custom Rule from the predicate `f`.
   * The input represents the weighted tags of a set of tasks.
   * The function `f` should return true if those tasks are allowed to execute concurrently and false if they are not.
   *
   * If there is only one task represented by the map, it must be allowed to execute.
   */</span>
  <span class="keyword">def</span> <a title="(f: sbt.Tags.TagMap =&gt; Boolean)sbt.Tags.Rule" id="sbt.Tags.customLimit">customLimit</a><span class="delimiter">(</span><a title="sbt.Tags.TagMap =&gt; Boolean" id="sbt.Tags.customLimit.f">f</a>: TagMap =&gt; Boolean<span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <span title="sbt.Tags.Custom" class="keyword">new</span> <a href="#sbt.Tags;Custom" title="sbt.Tags.Custom">Custom</a><span class="delimiter">(</span><a href="#sbt.Tags.customLimit.f" title="sbt.Tags.TagMap =&gt; Boolean">f</a><span class="delimiter">)</span>

  <span class="comment">/** Returns a Rule that limits the maximum number of concurrently executing tasks to `max`, regardless of tags. */</span>
  <span class="keyword">def</span> <a title="(max: Int)sbt.Tags.Rule" id="sbt.Tags.limitAll">limitAll</a><span class="delimiter">(</span><a title="Int" id="sbt.Tags.limitAll.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <a href="#sbt.Tags.limit" title="(tag: sbt.Tags.Tag, max: Int)sbt.Tags.Rule">limit</a><span class="delimiter">(</span><a href="#sbt.Tags.All" title="=&gt; sbt.ConcurrentRestrictions.Tag">All</a>, <a href="#sbt.Tags.limitAll.max" title="Int">max</a><span class="delimiter">)</span>

  <span class="comment">/** Returns a Rule that limits the maximum number of concurrently executing tasks without a tag to `max`.  */</span>
  <span class="keyword">def</span> <a title="(max: Int)sbt.Tags.Rule" id="sbt.Tags.limitUntagged">limitUntagged</a><span class="delimiter">(</span><a title="Int" id="sbt.Tags.limitUntagged.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <a href="#sbt.Tags.limit" title="(tag: sbt.Tags.Tag, max: Int)sbt.Tags.Rule">limit</a><span class="delimiter">(</span><a href="#sbt.Tags.Untagged" title="=&gt; sbt.ConcurrentRestrictions.Tag">Untagged</a>, <a href="#sbt.Tags.limitUntagged.max" title="Int">max</a><span class="delimiter">)</span>

  <span class="comment">/** Returns a Rule that limits the maximum number of concurrent executings tasks tagged with `tag` to `max`.*/</span>
  <span class="keyword">def</span> <a title="(tag: sbt.Tags.Tag, max: Int)sbt.Tags.Rule" id="sbt.Tags.limit">limit</a><span class="delimiter">(</span><a title="sbt.Tags.Tag" id="sbt.Tags.limit.tag">tag</a>: <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.Tags.Tag">Tag</a>, <a title="Int" id="sbt.Tags.limit.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <span title="sbt.Tags.Single" class="keyword">new</span> <a href="#sbt.Tags;Single" title="sbt.Tags.Single">Single</a><span class="delimiter">(</span><a href="#sbt.Tags.limit.tag" title="sbt.Tags.Tag">tag</a>, <a href="#sbt.Tags.limit.max" title="Int">max</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(max: Int, tags: sbt.Tags.Tag*)sbt.Tags.Rule" id="sbt.Tags.limitSum">limitSum</a><span class="delimiter">(</span><a title="Int" id="sbt.Tags.limitSum.max">max</a>: <span title="Int">Int</span>, <a title="sbt.Tags.Tag*" id="sbt.Tags.limitSum.tags">tags</a>: <span title="sbt.Tags.Tag*">Tag</span>*<span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <span title="sbt.Tags.Sum" class="keyword">new</span> <a href="#sbt.Tags;Sum" title="sbt.Tags.Sum">Sum</a><span class="delimiter">(</span><a href="#sbt.Tags.limitSum.tags" title="sbt.Tags.Tag*">tags</a>, <a href="#sbt.Tags.limitSum.max" title="Int">max</a><span class="delimiter">)</span>
  <span class="comment">/** Ensure that a task with the given tag always executes in isolation.*/</span>
  <span class="keyword">def</span> <a title="(exclusiveTag: sbt.Tags.Tag)sbt.Tags.Rule" id="sbt.Tags.exclusive">exclusive</a><span class="delimiter">(</span><a title="sbt.Tags.Tag" id="sbt.Tags.exclusive.exclusiveTag">exclusiveTag</a>: <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.Tags.Tag">Tag</a><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <a href="#sbt.Tags.customLimit" title="(f: sbt.Tags.TagMap =&gt; Boolean)sbt.Tags.Rule">customLimit</a> <span class="delimiter">{</span> <span class="delimiter">(</span>tags: <span title="Map[sbt.Tags.Tag,Int]">Map</span><span class="delimiter">[</span>Tag, Int<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
    <span class="comment">// if there are no exclusive tasks in this group, this rule adds no restrictions</span>
    <a href="#sbt.Tags.exclusive.$anonfun.tags" title="Map[sbt.Tags.Tag,Int]">tags</a>.<span title="(key: sbt.Tags.Tag, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Tags.exclusive.exclusiveTag" title="sbt.Tags.Tag">exclusiveTag</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span>
      <span class="comment">// If there is only one task, allow it to execute.</span>
      <a href="#sbt.Tags.exclusive.$anonfun.tags" title="Map[sbt.Tags.Tag,Int]">tags</a>.<span title="(key: sbt.Tags.Tag, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Tags" title="sbt.Tags.type">Tags</a>.<a href="#sbt.Tags.All" title="=&gt; sbt.ConcurrentRestrictions.Tag">All</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Ensure that a task with the given tag only executes with tasks also tagged with the given tag.*/</span>
  <span class="keyword">def</span> <a title="(exclusiveTag: sbt.Tags.Tag)sbt.Tags.Rule" id="sbt.Tags.exclusiveGroup">exclusiveGroup</a><span class="delimiter">(</span><a title="sbt.Tags.Tag" id="sbt.Tags.exclusiveGroup.exclusiveTag">exclusiveTag</a>: <a href="ConcurrentRestrictions.scala.html#sbt.ConcurrentRestrictions;Tag" title="sbt.Tags.Tag">Tag</a><span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <a href="#sbt.Tags.customLimit" title="(f: sbt.Tags.TagMap =&gt; Boolean)sbt.Tags.Rule">customLimit</a> <span class="delimiter">{</span> <span class="delimiter">(</span>tags: <span title="Map[sbt.Tags.Tag,Int]">Map</span><span class="delimiter">[</span>Tag, Int<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
    <span class="keyword">val</span> <a title="Int" id="sbt.Tags.exclusiveGroup.$anonfun.exclusiveCount">exclusiveCount</a> = <a href="#sbt.Tags.exclusiveGroup.$anonfun.tags" title="Map[sbt.Tags.Tag,Int]">tags</a>.<span title="(key: sbt.Tags.Tag, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Tags.exclusiveGroup.exclusiveTag" title="sbt.Tags.Tag">exclusiveTag</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.Tags.exclusiveGroup.$anonfun.allCount">allCount</a> = <a href="#sbt.Tags.exclusiveGroup.$anonfun.tags" title="Map[sbt.Tags.Tag,Int]">tags</a>.<span title="(key: sbt.Tags.Tag, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Tags" title="sbt.Tags.type">Tags</a>.<a href="#sbt.Tags.All" title="=&gt; sbt.ConcurrentRestrictions.Tag">All</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="comment">// If there are no exclusive tasks in this group, this rule adds no restrictions.</span>
    <a href="#sbt.Tags.exclusiveGroup.$anonfun.exclusiveCount" title="Int">exclusiveCount</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span>
      <span class="comment">// If all tasks have this tag, allow them to execute.</span>
      <a href="#sbt.Tags.exclusiveGroup.$anonfun.exclusiveCount" title="Int">exclusiveCount</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.Tags.exclusiveGroup.$anonfun.allCount" title="Int">allCount</a> <span title="(x: Boolean)Boolean">||</span>
      <span class="comment">// Always allow a group containing only one task to execute (fallthrough case).</span>
      <a href="#sbt.Tags.exclusiveGroup.$anonfun.allCount" title="Int">allCount</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A task tagged with one of `exclusiveTags` will not execute with another task with any of the other tags in `exclusiveTags`.*/</span>
  <span class="keyword">def</span> <a title="(exclusiveTags: sbt.Tags.Tag*)sbt.Tags.Rule" id="sbt.Tags.exclusiveGroups">exclusiveGroups</a><span class="delimiter">(</span><a title="sbt.Tags.Tag*" id="sbt.Tags.exclusiveGroups.exclusiveTags">exclusiveTags</a>: <span title="sbt.Tags.Tag*">Tag</span>*<span class="delimiter">)</span>: <a href="#sbt.Tags;Rule" title="sbt.Tags.Rule">Rule</a> = <a href="#sbt.Tags.customLimit" title="(f: sbt.Tags.TagMap =&gt; Boolean)sbt.Tags.Rule">customLimit</a> <span class="delimiter">{</span> <span class="delimiter">(</span>tags: <span title="Map[sbt.Tags.Tag,Int]">Map</span><span class="delimiter">[</span>Tag, Int<span class="delimiter">]</span><span class="delimiter">)</span> =&gt;
    <span class="keyword">val</span> <a title="Int" id="sbt.Tags.exclusiveGroups.$anonfun.groups">groups</a> = <a href="#sbt.Tags.exclusiveGroups.exclusiveTags" title="sbt.Tags.Tag*">exclusiveTags</a>.<span title="(p: sbt.Tags.Tag =&gt; Boolean)Int">count</span><span class="delimiter">(</span><a title="sbt.Tags.Tag" id="sbt.Tags.exclusiveGroups.$anonfun.groups.$anonfun.tag">tag</a> =&gt; <a href="#sbt.Tags.exclusiveGroups.$anonfun.tags" title="Map[sbt.Tags.Tag,Int]">tags</a>.<span title="(key: sbt.Tags.Tag, default: =&gt; Int)Int">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Tags.exclusiveGroups.$anonfun.groups.$anonfun.tag" title="sbt.Tags.Tag">tag</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <a href="#sbt.Tags.exclusiveGroups.$anonfun.groups" title="Int">groups</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(1)" class="int">1</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
