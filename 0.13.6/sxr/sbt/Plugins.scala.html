<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Plugins.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="comment">/*
TODO:
- index all available AutoPlugins to get the tasks that will be added
- error message when a task doesn't exist that it would be provided by plugin x, enabled by natures y,z, blocked by a, b
*/</span>

<span class="keyword">import</span> logic.<span class="delimiter">{</span>Atom, Clause, Clauses, Formula, Literal, Logic, Negated<span class="delimiter">}</span>
<span class="keyword">import</span> <a href="logic/Logic.scala.html#sbt.logic.Logic" title="sbt.logic.Logic.type">Logic</a>.<span class="delimiter">{</span>CyclicNegation, InitialContradictions, InitialOverlap, LogicException<span class="delimiter">}</span>
<span class="keyword">import</span> <a href="Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.Setting
<span class="keyword">import</span> <a href="#sbt.Plugins" title="sbt.Plugins.type">Plugins</a>._
<span class="keyword">import</span> annotation.tailrec

<span class="comment">/**
An AutoPlugin defines a group of settings and the conditions where the settings are automatically added to a build (called &quot;activation&quot;).
The `requires` and `trigger` methods together define the conditions, and a method like `projectSettings` defines the settings to add.

Steps for plugin authors:
1. Determine if the AutoPlugin should automatically be activated when all requirements are met, or should be opt-in.
2. Determine the [[AutoPlugins]]s that, when present (or absent), act as the requirements for the AutoPlugin.
3. Determine the settings/configurations to that the AutoPlugin injects when activated.
4. Determine the keys and other names to be automatically imported to *.sbt scripts.

For example, the following will automatically add the settings in `projectSettings`
  to a project that has both the `Web` and `Javascript` plugins enabled.

    object Plugin extends sbt.AutoPlugin {
        override def requires = Web &amp;&amp; Javascript
        override def trigger = allRequirements
        override def projectSettings = Seq(...)
        
        object autoImport {
      lazy val obfuscate = taskKey[Seq[File]](&quot;Obfuscates the source.&quot;)
        }
    }

Steps for users:
1. Add dependencies on plugins in `project/plugins.sbt` as usual with `addSbtPlugin`
2. Add key plugins to Projects, which will automatically select the plugin + dependent plugin settings to add for those Projects.
3. Exclude plugins, if desired.

For example, given plugins Web and Javascript (perhaps provided by plugins added with addSbtPlugin),

  &lt;Project&gt;.enablePlugins( Web &amp;&amp; Javascript )

will activate `MyPlugin` defined above and have its settings automatically added.  If the user instead defines

  &lt;Project&gt;.enablePlugins( Web &amp;&amp; Javascript ).disablePlugins(MyPlugin)

then the `MyPlugin` settings (and anything that activates only when `MyPlugin` is activated) will not be added.

*/</span>
<span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AutoPlugin extends sbt.Plugins.Basic with sbt.PluginsFunctions" id="sbt;AutoPlugin">AutoPlugin</a> <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin" class="keyword">extends</a> <a href="#sbt.Plugins" title="sbt.Plugins.type">Plugins</a>.<a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> <span class="keyword">with</span> <a href="#sbt;PluginsFunctions" title="sbt.PluginsFunctions">PluginsFunctions</a> <span class="delimiter">{</span>
  <span class="comment">/** Determines whether this AutoPlugin will be activated for this project when the `requires` clause is satisfied.
   *
   * When this method returns `allRequirements`, and `requires` method returns `Web &amp;&amp; Javascript`, this plugin
   * instance will be added automatically if the `Web` and `Javascript` plugins are enabled.
   * 
   * When this method returns `noTrigger`, and `requires` method returns `Web &amp;&amp; Javascript`, this plugin
   * instance will be added only if the build user enables it, but it will automatically add both `Web` and `Javascript`. */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.PluginTrigger" id="sbt;AutoPlugin.trigger">trigger</a>: <a href="#sbt;PluginTrigger" title="sbt.PluginTrigger">PluginTrigger</a> = <a href="#sbt;PluginsFunctions.noTrigger" title="=&gt; sbt.PluginTrigger">noTrigger</a>

  <span class="comment">/** This AutoPlugin requires the plugins the [[Plugins]] matcher returned by this method. See [[trigger]].
   */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.Plugins" id="sbt;AutoPlugin.requires">requires</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> = <a href="#sbt;PluginsFunctions.empty" title="=&gt; sbt.Plugins">empty</a>

  <span class="keyword">val</span> <a title="String" id="sbt;AutoPlugin.label">label</a>: <span title="String">String</span> = <a href="#sbt;AutoPlugin" title="()Class[_]">getClass</a>.<span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">getName</span>.<span title="(suffix: String)String">stripSuffix</span><span class="delimiter">(</span><span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;AutoPlugin.toString">toString</a>: <span title="String">String</span> = <a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a>

  <span class="comment">/** The [[Configuration]]s to add to each project that activates this AutoPlugin.*/</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[sbt.Configuration]" id="sbt;AutoPlugin.projectConfigurations">projectConfigurations</a>: <span title="Seq[sbt.Configuration]">Seq</span><span class="delimiter">[</span>Configuration<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  <span class="comment">/** The [[Setting]]s to add in the scope of each project that activates this AutoPlugin. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[sbt.Def.Setting[_]]" id="sbt;AutoPlugin.projectSettings">projectSettings</a>: <span title="Seq[sbt.Def.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  <span class="comment">/** The [[Setting]]s to add to the build scope for each project that activates this AutoPlugin.
  * The settings returned here are guaranteed to be added to a given build scope only once
  * regardless of how many projects for that build activate this AutoPlugin. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[sbt.Def.Setting[_]]" id="sbt;AutoPlugin.buildSettings">buildSettings</a>: <span title="Seq[sbt.Def.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  <span class="comment">/** The [[Setting]]s to add to the global scope exactly once if any project activates this AutoPlugin. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[sbt.Def.Setting[_]]" id="sbt;AutoPlugin.globalSettings">globalSettings</a>: <span title="Seq[sbt.Def.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>

  <span class="comment">// TODO?: def commands: Seq[Command]</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; sbt.Plugins.Exclude" id="sbt;AutoPlugin.unary_!">unary_!</a> : <a href="#sbt.Plugins.Exclude.readResolve" title="sbt.Plugins.Exclude">Exclude</a> = <a href="#sbt.Plugins.Exclude.readResolve" title="(n: sbt.AutoPlugin)sbt.Plugins.Exclude">Exclude</a><span class="delimiter">(</span><a href="#sbt;AutoPlugin" title="sbt.AutoPlugin" class="keyword">this</a><span class="delimiter">)</span>


  <span class="comment">/** If this plugin does not have any requirements, it means it is actually a root plugin. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;AutoPlugin.isRoot">isRoot</a>: <span title="Boolean">Boolean</span> = 
    <a href="#sbt;AutoPlugin.requires" title="=&gt; sbt.Plugins">requires</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> _ =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>

  <span class="comment">/** If this plugin does not have any requirements, it means it is actually a root plugin. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;AutoPlugin.isAlwaysEnabled">isAlwaysEnabled</a>: <span title="Boolean">Boolean</span> =
    <a href="#sbt;AutoPlugin.isRoot" title="=&gt; Boolean">isRoot</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt;AutoPlugin.trigger" title="=&gt; sbt.PluginTrigger">trigger</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.AllRequirements.readResolve" title="sbt.AllRequirements.type">AllRequirements</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/** An error that occurs when auto-plugins aren't configured properly.
* It translates the error from the underlying logic system to be targeted at end users. */</span>
<span class="keyword">final</span> <span class="keyword">class</span> <a title="class AutoPluginException extends RuntimeException" id="sbt;AutoPluginException">AutoPluginException</a> <a href="#sbt;AutoPluginException" title="sbt.AutoPluginException" class="keyword">private</a><span class="delimiter">(</span><span class="keyword">val</span> <a title="String" id="sbt;AutoPluginException.message">message</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="Option[sbt.logic.Logic.LogicException]" id="sbt;AutoPluginException.origin">origin</a>: <span title="Option[sbt.logic.Logic.LogicException]">Option</span><span class="delimiter">[</span>LogicException<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><a href="#sbt;AutoPluginException.message" title="String">message</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="comment">/** Prepends `p` to the error message derived from `origin`. */</span>
  <span class="keyword">def</span> <a title="(p: String)sbt.AutoPluginException" id="sbt;AutoPluginException.withPrefix">withPrefix</a><span class="delimiter">(</span><a title="String" id="sbt;AutoPluginException.withPrefix.p">p</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="sbt.AutoPluginException" class="keyword">new</span> <a href="#sbt;AutoPluginException" title="sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><a href="#sbt;AutoPluginException.withPrefix.p" title="String">p</a> <span title="(x$1: Any)String">+</span> <a href="#sbt;AutoPluginException.message" title="=&gt; String">message</a>, <a href="#sbt;AutoPluginException.origin" title="=&gt; Option[sbt.logic.Logic.LogicException]">origin</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="keyword">object</span> <a title="sbt.AutoPluginException.type" id="sbt.AutoPluginException.readResolve">AutoPluginException</a> <a href="#sbt.AutoPluginException.readResolve" title="sbt.AutoPluginException.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="(msg: String)sbt.AutoPluginException" id="sbt.AutoPluginException.apply(ba934e7f21)">apply</a><span class="delimiter">(</span><a title="String" id="sbt.AutoPluginException.apply(ba934e7f21).msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt;AutoPluginException" title="sbt.AutoPluginException">AutoPluginException</a> = <span title="sbt.AutoPluginException" class="keyword">new</span> <a href="#sbt;AutoPluginException" title="sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><a href="#sbt.AutoPluginException.apply(ba934e7f21).msg" title="String">msg</a>, <span title="None.type">None</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(origin: sbt.logic.Logic.LogicException)sbt.AutoPluginException" id="sbt.AutoPluginException.apply(fafe7c9b35)">apply</a><span class="delimiter">(</span><a title="sbt.logic.Logic.LogicException" id="sbt.AutoPluginException.apply(fafe7c9b35).origin">origin</a>: <a href="logic/Logic.scala.html#sbt.logic.Logic;LogicException" title="sbt.logic.Logic.LogicException">LogicException</a><span class="delimiter">)</span>: <a href="#sbt;AutoPluginException" title="sbt.AutoPluginException">AutoPluginException</a> = <span title="sbt.AutoPluginException" class="keyword">new</span> <a href="#sbt;AutoPluginException" title="sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><a href="#sbt.Plugins" title="sbt.Plugins.type">Plugins</a>.<a href="#sbt.Plugins.translateMessage" title="(e: sbt.logic.Logic.LogicException)String">translateMessage</a><span class="delimiter">(</span><a href="#sbt.AutoPluginException.apply(fafe7c9b35).origin" title="sbt.logic.Logic.LogicException">origin</a><span class="delimiter">)</span>, <span title="(x: sbt.logic.Logic.LogicException)Some[sbt.logic.Logic.LogicException]">Some</span><span class="delimiter">(</span><a href="#sbt.AutoPluginException.apply(fafe7c9b35).origin" title="sbt.logic.Logic.LogicException">origin</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait PluginTrigger extends AnyRef" id="sbt;PluginTrigger">PluginTrigger</a>
<span title="AnyRef" class="keyword">case object</span> <a href="#sbt.AllRequirements.productElement.x$1" title="sbt.AllRequirements.type" id="sbt.AllRequirements.readResolve">AllRequirements</a> <span title="Product" class="keyword">extends</span> <a href="#sbt;PluginTrigger" title="sbt.PluginTrigger">PluginTrigger</a>
<span class="keyword">case object</span> <a href="#sbt.NoTrigger.productElement.x$1" title="sbt.NoTrigger.type" id="sbt.NoTrigger.readResolve">NoTrigger</a> <span title="Product" class="keyword">extends</span> <a href="#sbt;PluginTrigger" title="sbt.PluginTrigger">PluginTrigger</a> 

<span class="comment">/** An expression that matches `AutoPlugin`s. */</span>
<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Plugins extends AnyRef" id="sbt;Plugins">Plugins</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(o: sbt.Plugins.Basic)sbt.Plugins" id="sbt;Plugins.&&">&amp;&amp;</a> <span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt;Plugins.&&.o">o</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a><span class="delimiter">)</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>
<span class="delimiter">}</span>


<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait PluginsFunctions extends AnyRef" id="sbt;PluginsFunctions">PluginsFunctions</a> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/** [[Plugins]] instance that doesn't require any [[Plugins]]s. */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.Plugins" id="sbt;PluginsFunctions.empty">empty</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> = <a href="#sbt.Plugins" title="sbt.Plugins.type">Plugins</a>.<a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a>

  <span class="comment">/** This plugin is activated when all required plugins are present. */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.PluginTrigger" id="sbt;PluginsFunctions.allRequirements">allRequirements</a>: <a href="#sbt;PluginTrigger" title="sbt.PluginTrigger">PluginTrigger</a> = <a href="#sbt.AllRequirements.readResolve" title="sbt.AllRequirements.type">AllRequirements</a>
  <span class="comment">/** This plugin is activated only when it is manually activated. */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.PluginTrigger" id="sbt;PluginsFunctions.noTrigger">noTrigger</a>: <a href="#sbt;PluginTrigger" title="sbt.PluginTrigger">PluginTrigger</a> = <a href="#sbt.NoTrigger.readResolve" title="sbt.NoTrigger.type">NoTrigger</a>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="sbt.Plugins.type" id="sbt.Plugins">Plugins</a> <a href="#sbt.Plugins" title="sbt.Plugins.type" class="keyword">extends</a> <a href="#sbt;PluginsFunctions" title="sbt.PluginsFunctions">PluginsFunctions</a> <span class="delimiter">{</span>
  <span class="comment">/** Given the available auto plugins `defined`, returns a function that selects [[AutoPlugin]]s for the provided [[AutoPlugin]]s.
  * The [[AutoPlugin]]s are topologically sorted so that a required [[AutoPlugin]] comes before its requiring [[AutoPlugin]].*/</span>
  <span class="keyword">def</span> <a title="(defined0: List[sbt.AutoPlugin])(sbt.Plugins, sbt.Logger) =&gt; Seq[sbt.AutoPlugin]" id="sbt.Plugins.deducer">deducer</a><span class="delimiter">(</span><a title="List[sbt.AutoPlugin]" id="sbt.Plugins.deducer.defined0">defined0</a>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span><span class="delimiter">)</span>: <span class="delimiter">(</span>Plugins, Logger<span class="delimiter">)</span> =&gt; Seq<span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> =
    <span title="(sbt.Plugins, sbt.Logger) =&gt; Seq[sbt.AutoPlugin]" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.defined0" title="List[sbt.AutoPlugin]">defined0</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.deducer.$anonfun.x$1">_</a>, <a title="sbt.Logger" id="sbt.Plugins.deducer.$anonfun.x$2">_</a><span class="delimiter">)</span> =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="comment">// TODO: defined should return all the plugins</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.AutoPlugin]" id="sbt.Plugins.deducer.allReqs">allReqs</a> = <span class="delimiter">(</span><a href="#sbt.Plugins.deducer.defined0" title="List[sbt.AutoPlugin]">defined0</a> <span title="(f: sbt.AutoPlugin =&gt; scala.collection.GenTraversableOnce[sbt.AutoPlugin])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.AutoPlugin],sbt.AutoPlugin,List[sbt.AutoPlugin]])List[sbt.AutoPlugin]">flatMap</span> <span class="delimiter">{</span> <a href="#sbt.Plugins.asRequirements" title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]">asRequirements</a> <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.AutoPlugin]">toSet</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.AutoPlugin]" id="sbt.Plugins.deducer.diff">diff</a> = <a href="#sbt.Plugins.deducer.allReqs" title="scala.collection.immutable.Set[sbt.AutoPlugin]">allReqs</a> <span title="(that: scala.collection.GenSet[sbt.AutoPlugin])scala.collection.immutable.Set[sbt.AutoPlugin]">diff</span> <a href="#sbt.Plugins.deducer.defined0" title="List[sbt.AutoPlugin]">defined0</a>.<span title="scala.collection.immutable.Set[sbt.AutoPlugin]">toSet</span>
      <span class="keyword">val</span> <a title="List[sbt.AutoPlugin]" id="sbt.Plugins.deducer.defined">defined</a> = <span title="List[sbt.AutoPlugin]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Plugins.deducer.diff" title="scala.collection.immutable.Set[sbt.AutoPlugin]">diff</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.Plugins.deducer.diff" title="scala.collection.immutable.Set[sbt.AutoPlugin]">diff</a>.<span title="=&gt; List[sbt.AutoPlugin]">toList</span> <a href="#sbt.Plugins.deducer.defined.x$3" title="(prefix: List[sbt.AutoPlugin])List[sbt.AutoPlugin]">:::</a> <a href="#sbt.Plugins.deducer.defined0" title="List[sbt.AutoPlugin]">defined0</a>
              <span class="keyword">else</span> <a href="#sbt.Plugins.deducer.defined0" title="List[sbt.AutoPlugin]">defined0</a>

      <span class="keyword">val</span> <a title="List[(sbt.logic.Atom, sbt.AutoPlugin)]" id="sbt.Plugins.deducer.byAtom">byAtom</a> = <a href="#sbt.Plugins.deducer.defined" title="List[sbt.AutoPlugin]">defined</a> <span title="(f: sbt.AutoPlugin =&gt; (sbt.logic.Atom, sbt.AutoPlugin))(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.AutoPlugin],(sbt.logic.Atom, sbt.AutoPlugin),List[(sbt.logic.Atom, sbt.AutoPlugin)]])List[(sbt.logic.Atom, sbt.AutoPlugin)]">map</span> <span class="delimiter">{</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.deducer.byAtom.$anonfun.x">x</a> =&gt; <span title="(_1: sbt.logic.Atom, _2: sbt.AutoPlugin)(sbt.logic.Atom, sbt.AutoPlugin)" class="delimiter">(</span><a href="logic/Logic.scala.html#sbt.logic;Atom" title="(label: String)sbt.logic.Atom">Atom</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.byAtom.$anonfun.x" title="sbt.AutoPlugin">x</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">)</span>, <a href="#sbt.Plugins.deducer.byAtom.$anonfun.x" title="sbt.AutoPlugin">x</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Map[sbt.logic.Atom,sbt.AutoPlugin]" id="sbt.Plugins.deducer.byAtomMap">byAtomMap</a> = <a href="#sbt.Plugins.deducer.byAtom" title="List[(sbt.logic.Atom, sbt.AutoPlugin)]">byAtom</a>.<span title="(implicit ev: &lt;:&lt;[(sbt.logic.Atom, sbt.AutoPlugin),(sbt.logic.Atom, sbt.AutoPlugin)])scala.collection.immutable.Map[sbt.logic.Atom,sbt.AutoPlugin]">toMap</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.byAtom" title="List[(sbt.logic.Atom, sbt.AutoPlugin)]">byAtom</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#sbt.Plugins.deducer.byAtomMap" title="scala.collection.immutable.Map[sbt.logic.Atom,sbt.AutoPlugin]">byAtomMap</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <a href="#sbt.Plugins.duplicateProvidesError" title="(byAtom: Seq[(sbt.logic.Atom, sbt.AutoPlugin)])Unit">duplicateProvidesError</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.byAtom" title="List[(sbt.logic.Atom, sbt.AutoPlugin)]">byAtom</a><span class="delimiter">)</span>
      <span class="comment">// Ignore clauses for plugins that does not require anything else.</span>
      <span class="comment">// Avoids the requirement for pure Nature strings *and* possible</span>
      <span class="comment">// circular dependencies in the logic.</span>
      <span class="keyword">val</span> <a title="List[sbt.logic.Clause]" id="sbt.Plugins.deducer.allRequirementsClause">allRequirementsClause</a> = <a href="#sbt.Plugins.deducer.defined" title="List[sbt.AutoPlugin]">defined</a>.<span title="(p: sbt.AutoPlugin =&gt; Boolean)List[sbt.AutoPlugin]">filterNot</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.allRequirementsClause.$anonfun.x$4" title="sbt.AutoPlugin">_</a>.<a href="#sbt;AutoPlugin.isRoot" title="=&gt; Boolean">isRoot</a><span class="delimiter">)</span>.<span title="(f: sbt.AutoPlugin =&gt; scala.collection.GenTraversableOnce[sbt.logic.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.AutoPlugin],sbt.logic.Clause,List[sbt.logic.Clause]])List[sbt.logic.Clause]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,sbt.logic.Clause,List[sbt.logic.Clause]]" class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.deducer.allRequirementsClause.$anonfun.d">d</a> =&gt; <a href="#sbt.Plugins.asRequirementsClauses" title="(ap: sbt.AutoPlugin)List[sbt.logic.Clause]">asRequirementsClauses</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.allRequirementsClause.$anonfun.d" title="sbt.AutoPlugin">d</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[sbt.logic.Clause]" id="sbt.Plugins.deducer.allEnabledByClause">allEnabledByClause</a> = <a href="#sbt.Plugins.deducer.defined" title="List[sbt.AutoPlugin]">defined</a>.<span title="(p: sbt.AutoPlugin =&gt; Boolean)List[sbt.AutoPlugin]">filterNot</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.allEnabledByClause.$anonfun.x$5" title="sbt.AutoPlugin">_</a>.<a href="#sbt;AutoPlugin.isRoot" title="=&gt; Boolean">isRoot</a><span class="delimiter">)</span>.<span title="(f: sbt.AutoPlugin =&gt; scala.collection.GenTraversableOnce[sbt.logic.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.AutoPlugin],sbt.logic.Clause,List[sbt.logic.Clause]])List[sbt.logic.Clause]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,sbt.logic.Clause,List[sbt.logic.Clause]]" class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.deducer.allEnabledByClause.$anonfun.d">d</a> =&gt; <a href="#sbt.Plugins.asEnabledByClauses" title="(ap: sbt.AutoPlugin)List[sbt.logic.Clause]">asEnabledByClauses</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.allEnabledByClause.$anonfun.d" title="sbt.AutoPlugin">d</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// Note: Here is where the function begins.  We're given a list of plugins now.</span>
      <span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.deducer.$anonfun.requestedPlugins">requestedPlugins</a>, <a title="sbt.Logger" id="sbt.Plugins.deducer.$anonfun.log">log</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(p: sbt.AutoPlugin)Boolean" id="sbt.Plugins.deducer.$anonfun.explicitlyDisabled">explicitlyDisabled</a><span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.deducer.$anonfun.explicitlyDisabled.p">p</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#sbt.Plugins.hasExclude" title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean">hasExclude</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.requestedPlugins" title="sbt.Plugins">requestedPlugins</a>, <a href="#sbt.Plugins.deducer.$anonfun.explicitlyDisabled.p" title="sbt.AutoPlugin">p</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[sbt.AutoPlugin]" id="sbt.Plugins.deducer.$anonfun.alwaysEnabled">alwaysEnabled</a>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> = <a href="#sbt.Plugins.deducer.defined" title="List[sbt.AutoPlugin]">defined</a>.<span title="(p: sbt.AutoPlugin =&gt; Boolean)List[sbt.AutoPlugin]">filter</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.alwaysEnabled.$anonfun.x$6" title="sbt.AutoPlugin">_</a>.<a href="#sbt;AutoPlugin.isAlwaysEnabled" title="=&gt; Boolean">isAlwaysEnabled</a><span class="delimiter">)</span>.<span title="(p: sbt.AutoPlugin =&gt; Boolean)List[sbt.AutoPlugin]">filterNot</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.explicitlyDisabled" title="(p: sbt.AutoPlugin)Boolean">explicitlyDisabled</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Set[sbt.logic.Atom]" id="sbt.Plugins.deducer.$anonfun.knowlege0">knowlege0</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#sbt.Plugins.flatten" title="(n: sbt.Plugins)Seq[sbt.Plugins.Basic]">flatten</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.requestedPlugins" title="sbt.Plugins">requestedPlugins</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[sbt.Plugins.Basic])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.Plugins.Basic],sbt.Plugins.Basic,Seq[sbt.Plugins.Basic]])Seq[sbt.Plugins.Basic]">++</span> <a href="#sbt.Plugins.deducer.$anonfun.alwaysEnabled" title="List[sbt.AutoPlugin]">alwaysEnabled</a><span class="delimiter">)</span> <span title="(pf: PartialFunction[sbt.Plugins.Basic,sbt.logic.Atom])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.Plugins.Basic],sbt.logic.Atom,Seq[sbt.logic.Atom]])Seq[sbt.logic.Atom]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[sbt.Plugins.Basic,sbt.logic.Atom] with Serializable" id="sbt.Plugins.deducer.$anonfun.knowlege0;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
          <span class="keyword">case</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.deducer.$anonfun.knowlege0;$anonfun.isDefinedAt.x">x</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a> =&gt; <a href="logic/Logic.scala.html#sbt.logic;Atom" title="(label: String)sbt.logic.Atom">Atom</a><span title="Boolean(true)" class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.knowlege0;$anonfun.isDefinedAt.x" title="sbt.AutoPlugin">x</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">)</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">toSet</span>
        <span class="keyword">val</span> <a title="sbt.logic.Clauses" id="sbt.Plugins.deducer.$anonfun.clauses">clauses</a> = <a href="logic/Logic.scala.html#sbt.logic;Clauses" title="(clauses: List[sbt.logic.Clause])sbt.logic.Clauses">Clauses</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.allRequirementsClause" title="List[sbt.logic.Clause]">allRequirementsClause</a> <a href="#sbt.Plugins.deducer.$anonfun.clauses.x$7" title="(prefix: List[sbt.logic.Clause])List[sbt.logic.Clause]">:::</a> <a href="#sbt.Plugins.deducer.allEnabledByClause" title="List[sbt.logic.Clause]">allEnabledByClause</a><span class="delimiter">)</span> <span title="(p: sbt.logic.Clause =&gt; Boolean)List[sbt.logic.Clause]">filterNot</span> <span class="delimiter">{</span> <a href="#sbt.Plugins.deducer.$anonfun.clauses.$anonfun.x$8" title="sbt.logic.Clause">_</a>.<a href="logic/Logic.scala.html#sbt.logic;Clause.head" title="=&gt; Set[sbt.logic.Atom]">head</a> <span title="(that: scala.collection.GenSet[sbt.logic.Atom])Boolean">subsetOf</span> <a href="#sbt.Plugins.deducer.$anonfun.knowlege0" title="Set[sbt.logic.Atom]">knowlege0</a> <span class="delimiter">}</span><span class="delimiter">)</span>
        <a href="#sbt.Plugins.deducer.$anonfun.log" title="sbt.Logger">log</a>.<a href="Logger.scala.html#sbt;Logger.debug(83d3728a3c)" title="(message: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;deducing auto plugins based on known facts &quot;)">deducing auto plugins based on known facts $</span><span class="delimiter">{</span><a href="#sbt.Plugins.deducer.$anonfun.knowlege0" title="Set[sbt.logic.Atom]">knowlege0</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot; and clauses &quot;)"> and clauses $</span><span class="delimiter">{</span><a href="#sbt.Plugins.deducer.$anonfun.clauses" title="sbt.logic.Clauses">clauses</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
        <a href="logic/Logic.scala.html#sbt.logic.Logic" title="sbt.logic.Logic.type">Logic</a>.<a href="logic/Logic.scala.html#sbt.logic.Logic.reduce" title="(clauses: sbt.logic.Clauses, initialFacts: Set[sbt.logic.Literal])Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]">reduce</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.clauses" title="sbt.logic.Clauses">clauses</a>, <span class="delimiter">(</span><a href="#sbt.Plugins.flattenConvert" title="(n: sbt.Plugins)Seq[sbt.logic.Literal]">flattenConvert</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.requestedPlugins" title="sbt.Plugins">requestedPlugins</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[sbt.logic.Literal])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.logic.Literal],sbt.logic.Literal,Seq[sbt.logic.Literal]])Seq[sbt.logic.Literal]">++</span> <a href="#sbt.Plugins.convertAll" title="(ns: Seq[sbt.Plugins.Basic])Seq[sbt.logic.Literal]">convertAll</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.alwaysEnabled" title="List[sbt.AutoPlugin]">alwaysEnabled</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.logic.Literal]">toSet</span><span class="delimiter">)</span> <span title="Seq[sbt.AutoPlugin]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="sbt.logic.Logic.LogicException" id="sbt.Plugins.deducer.$anonfun.problem">problem</a><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <a href="#sbt.AutoPluginException.apply(fafe7c9b35)" title="(origin: sbt.logic.Logic.LogicException)sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.problem" title="sbt.logic.Logic.LogicException">problem</a><span class="delimiter">)</span>
          <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="sbt.logic.Logic.Matched" id="sbt.Plugins.deducer.$anonfun.results">results</a><span class="delimiter">)</span> =&gt;
            <a href="#sbt.Plugins.deducer.$anonfun.log" title="sbt.Logger">log</a>.<a href="Logger.scala.html#sbt;Logger.debug(83d3728a3c)" title="(message: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;  :: deduced result: &quot;)">  :: deduced result: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.deducer.$anonfun.results" title="sbt.logic.Logic.Matched">results</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="List[sbt.logic.Atom]" id="sbt.Plugins.deducer.$anonfun.selectedAtoms">selectedAtoms</a>: <span title="List[sbt.logic.Atom]">List</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> = <a href="#sbt.Plugins.deducer.$anonfun.results" title="sbt.logic.Logic.Matched">results</a>.<a href="logic/Logic.scala.html#sbt.logic.Logic;Matched.ordered" title="=&gt; List[sbt.logic.Atom]">ordered</a>
            <span class="keyword">val</span> <a title="List[sbt.AutoPlugin]" id="sbt.Plugins.deducer.$anonfun.selectedPlugins">selectedPlugins</a> = <a href="#sbt.Plugins.deducer.$anonfun.selectedAtoms" title="List[sbt.logic.Atom]">selectedAtoms</a> <span title="(f: sbt.logic.Atom =&gt; sbt.AutoPlugin)(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.logic.Atom],sbt.AutoPlugin,List[sbt.AutoPlugin]])List[sbt.AutoPlugin]">map</span> <span class="delimiter">{</span> <a title="sbt.logic.Atom" id="sbt.Plugins.deducer.$anonfun.selectedPlugins.$anonfun.a">a</a> =&gt;
              <a href="#sbt.Plugins.deducer.byAtomMap" title="scala.collection.immutable.Map[sbt.logic.Atom,sbt.AutoPlugin]">byAtomMap</a>.<span title="(key: sbt.logic.Atom, default: =&gt; sbt.AutoPlugin)sbt.AutoPlugin">getOrElse</span><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.selectedPlugins.$anonfun.a" title="sbt.logic.Atom">a</a>, <span title="Nothing" class="keyword">throw</span> <a href="#sbt.AutoPluginException.apply(ba934e7f21)" title="(msg: String)sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#sbt.Plugins.deducer.$anonfun.selectedPlugins.$anonfun.a" title="sbt.logic.Atom">a</a><span class="delimiter">}</span><span title="String(&quot; was not found in atom map.&quot;)" class="string"> was not found in atom map.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Set[sbt.AutoPlugin]" id="sbt.Plugins.deducer.$anonfun.forbidden">forbidden</a>: <span title="Set[sbt.AutoPlugin]">Set</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.selectedPlugins" title="List[sbt.AutoPlugin]">selectedPlugins</a> <span title="(f: sbt.AutoPlugin =&gt; scala.collection.GenTraversableOnce[sbt.AutoPlugin])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.AutoPlugin],sbt.AutoPlugin,List[sbt.AutoPlugin]])List[sbt.AutoPlugin]">flatMap</span> <span class="delimiter">{</span> <a href="#sbt.Plugins" title="sbt.Plugins.type">Plugins</a>.<a href="#sbt.Plugins.asExclusions" title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]">asExclusions</a> <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.AutoPlugin]">toSet</span>
            <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.AutoPlugin]" id="sbt.Plugins.deducer.$anonfun.c">c</a> = <a href="#sbt.Plugins.deducer.$anonfun.selectedPlugins" title="List[sbt.AutoPlugin]">selectedPlugins</a>.<span title="scala.collection.immutable.Set[sbt.AutoPlugin]">toSet</span> <span title="(that: scala.collection.GenSet[sbt.AutoPlugin])scala.collection.immutable.Set[sbt.AutoPlugin]">&amp;</span> <a href="#sbt.Plugins.deducer.$anonfun.forbidden" title="Set[sbt.AutoPlugin]">forbidden</a>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Plugins.deducer.$anonfun.c" title="scala.collection.immutable.Set[sbt.AutoPlugin]">c</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#sbt.Plugins.exlusionConflictError" title="(requested: sbt.Plugins, selected: Seq[sbt.AutoPlugin], conflicting: Seq[sbt.AutoPlugin])Unit">exlusionConflictError</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.requestedPlugins" title="sbt.Plugins">requestedPlugins</a>, <a href="#sbt.Plugins.deducer.$anonfun.selectedPlugins" title="List[sbt.AutoPlugin]">selectedPlugins</a>, <a href="#sbt.Plugins.deducer.$anonfun.c" title="scala.collection.immutable.Set[sbt.AutoPlugin]">c</a>.<span title="=&gt; Seq[sbt.AutoPlugin]">toSeq</span> <span title="(f: sbt.AutoPlugin =&gt; String)(implicit ord: scala.math.Ordering[String])Seq[sbt.AutoPlugin]">sortBy</span> <span class="delimiter">{</span><a href="#sbt.Plugins.deducer.$anonfun.$anonfun.x$9" title="sbt.AutoPlugin">_</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">}</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="List[sbt.AutoPlugin]" id="sbt.Plugins.deducer.$anonfun.retval">retval</a> = <a href="#sbt.Plugins.topologicalSort" title="(ns: List[sbt.AutoPlugin], log: sbt.Logger)List[sbt.AutoPlugin]">topologicalSort</a><span class="delimiter">(</span><a href="#sbt.Plugins.deducer.$anonfun.selectedPlugins" title="List[sbt.AutoPlugin]">selectedPlugins</a>, <a href="#sbt.Plugins.deducer.$anonfun.log" title="sbt.Logger">log</a><span class="delimiter">)</span>
            <a href="#sbt.Plugins.deducer.$anonfun.log" title="sbt.Logger">log</a>.<a href="Logger.scala.html#sbt;Logger.debug(83d3728a3c)" title="(message: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;  :: sorted deduced result: &quot;)">  :: sorted deduced result: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.deducer.$anonfun.retval" title="List[sbt.AutoPlugin]">retval</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
            <a href="#sbt.Plugins.deducer.$anonfun.retval" title="List[sbt.AutoPlugin]">retval</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ns: List[sbt.AutoPlugin], log: sbt.Logger)List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort">topologicalSort</a><span class="delimiter">(</span><a title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.ns">ns</a>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span>, <a title="sbt.Logger" id="sbt.Plugins.topologicalSort.log">log</a>: <a href="Logger.scala.html#sbt;Logger" title="sbt.Logger">Logger</a><span class="delimiter">)</span>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#sbt.Plugins.topologicalSort.log" title="sbt.Logger">log</a>.<a href="Logger.scala.html#sbt;Logger.debug(83d3728a3c)" title="(message: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;sorting: ns: &quot;)">sorting: ns: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.topologicalSort.ns" title="List[sbt.AutoPlugin]">ns</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
    @tailrec <span class="keyword">def</span> <a title="(found0: List[sbt.AutoPlugin], notFound0: List[sbt.AutoPlugin], limit0: Int)List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.doSort">doSort</a><span class="delimiter">(</span><a title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.doSort.found0">found0</a>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span>, <a title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.doSort.notFound0">notFound0</a>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span>, <a title="Int" id="sbt.Plugins.topologicalSort.doSort.limit0">limit0</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#sbt.Plugins.topologicalSort.log" title="sbt.Logger">log</a>.<a href="Logger.scala.html#sbt;Logger.debug(83d3728a3c)" title="(message: =&gt; String)Unit">debug</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;  :: sorting:: found: &quot;)">  :: sorting:: found: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.topologicalSort.doSort.found0" title="List[sbt.AutoPlugin]">found0</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot; not found &quot;)"> not found $</span><span class="delimiter">{</span><a href="#sbt.Plugins.topologicalSort.doSort.notFound0" title="List[sbt.AutoPlugin]">notFound0</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <span title="List[sbt.AutoPlugin]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Plugins.topologicalSort.doSort.limit0" title="Int">limit0</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#sbt.AutoPluginException.apply(ba934e7f21)" title="(msg: String)sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Failed to sort &quot;)">Failed to sort $</span><span class="delimiter">{</span><a href="#sbt.Plugins.topologicalSort.ns" title="List[sbt.AutoPlugin]">ns</a><span class="delimiter">}</span><span title="String(&quot; topologically&quot;)" class="string"> topologically&quot;</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="List[sbt.AutoPlugin]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Plugins.topologicalSort.doSort.notFound0" title="List[sbt.AutoPlugin]">notFound0</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.Plugins.topologicalSort.doSort.found0" title="List[sbt.AutoPlugin]">found0</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#sbt.Plugins.topologicalSort.doSort.found1" title="(List[sbt.AutoPlugin], List[sbt.AutoPlugin])" class="delimiter">(</a><a href="#sbt.Plugins.topologicalSort.doSort.x$10" title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.doSort.found1">found1</a>, <a href="#sbt.Plugins.topologicalSort.doSort.x$10" title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.doSort.notFound1">notFound1</a><span class="delimiter">)</span> = <a href="#sbt.Plugins.topologicalSort.doSort.notFound0" title="List[sbt.AutoPlugin]">notFound0</a> <span title="(p: sbt.AutoPlugin =&gt; Boolean)(List[sbt.AutoPlugin], List[sbt.AutoPlugin])">partition</span> <span class="delimiter">{</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.topologicalSort.doSort.x$10.$anonfun.n">n</a> =&gt; <a href="#sbt.Plugins.asRequirements" title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]">asRequirements</a><span class="delimiter">(</span><a href="#sbt.Plugins.topologicalSort.doSort.x$10.$anonfun.n" title="sbt.AutoPlugin">n</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.AutoPlugin]">toSet</span> <span title="(that: scala.collection.GenSet[sbt.AutoPlugin])Boolean">subsetOf</span> <a href="#sbt.Plugins.topologicalSort.doSort.found0" title="List[sbt.AutoPlugin]">found0</a>.<span title="scala.collection.immutable.Set[sbt.AutoPlugin]">toSet</span> <span class="delimiter">}</span>
        <a href="#sbt.Plugins.topologicalSort.doSort" title="(found0: List[sbt.AutoPlugin], notFound0: List[sbt.AutoPlugin], limit0: Int)List[sbt.AutoPlugin]">doSort</a><span class="delimiter">(</span><a href="#sbt.Plugins.topologicalSort.doSort.found0" title="List[sbt.AutoPlugin]">found0</a> <a href="#sbt.Plugins.topologicalSort.doSort.x$11" title="(prefix: List[sbt.AutoPlugin])List[sbt.AutoPlugin]">:::</a> <a href="#sbt.Plugins.topologicalSort.doSort.found1" title="List[sbt.AutoPlugin]">found1</a>, <a href="#sbt.Plugins.topologicalSort.doSort.notFound1" title="List[sbt.AutoPlugin]">notFound1</a>, <a href="#sbt.Plugins.topologicalSort.doSort.limit0" title="Int">limit0</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a href="#sbt.Plugins.topologicalSort.roots" title="(List[sbt.AutoPlugin], List[sbt.AutoPlugin])" class="delimiter">(</a><a href="#sbt.Plugins.topologicalSort.x$13" title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.roots">roots</a>, <a href="#sbt.Plugins.topologicalSort.x$13" title="List[sbt.AutoPlugin]" id="sbt.Plugins.topologicalSort.nonRoots">nonRoots</a><span class="delimiter">)</span> = <a href="#sbt.Plugins.topologicalSort.ns" title="List[sbt.AutoPlugin]">ns</a> <span title="(p: sbt.AutoPlugin =&gt; Boolean)(List[sbt.AutoPlugin], List[sbt.AutoPlugin])">partition</span> <span class="delimiter">(</span><a href="#sbt.Plugins.topologicalSort.x$13.$anonfun.x$12" title="sbt.AutoPlugin">_</a>.<a href="#sbt;AutoPlugin.isRoot" title="=&gt; Boolean">isRoot</a><span class="delimiter">)</span>
    <a href="#sbt.Plugins.topologicalSort.doSort" title="(found0: List[sbt.AutoPlugin], notFound0: List[sbt.AutoPlugin], limit0: Int)List[sbt.AutoPlugin]">doSort</a><span class="delimiter">(</span><a href="#sbt.Plugins.topologicalSort.roots" title="List[sbt.AutoPlugin]">roots</a>, <a href="#sbt.Plugins.topologicalSort.nonRoots" title="List[sbt.AutoPlugin]">nonRoots</a>, <a href="#sbt.Plugins.topologicalSort.ns" title="List[sbt.AutoPlugin]">ns</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Int">*</span> <a href="#sbt.Plugins.topologicalSort.ns" title="List[sbt.AutoPlugin]">ns</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(e: sbt.logic.Logic.LogicException)String" id="sbt.Plugins.translateMessage">translateMessage</a><span class="delimiter">(</span><a title="sbt.logic.Logic.LogicException" id="sbt.Plugins.translateMessage.e">e</a>: <a href="logic/Logic.scala.html#sbt.logic.Logic;LogicException" title="sbt.logic.Logic.LogicException">LogicException</a><span class="delimiter">)</span> = <a href="#sbt.Plugins.translateMessage.e" title="sbt.logic.Logic.LogicException">e</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a title="sbt.logic.Logic.InitialContradictions" id="sbt.Plugins.translateMessage.ic">ic</a>: <a href="logic/Logic.scala.html#sbt.logic.Logic;InitialContradictions" title="sbt.logic.Logic.InitialContradictions">InitialContradictions</a> =&gt; <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Contradiction in selected plugins.  These plugins were both included and excluded: &quot;)">Contradiction in selected plugins.  These plugins were both included and excluded: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.literalsString" title="(lits: Seq[sbt.logic.Literal])String">literalsString</a><span class="delimiter">(</span><a href="#sbt.Plugins.translateMessage.ic" title="sbt.logic.Logic.InitialContradictions">ic</a>.<a href="logic/Logic.scala.html#sbt.logic.Logic;InitialContradictions.literals" title="=&gt; Set[sbt.logic.Atom]">literals</a>.<span title="=&gt; Seq[sbt.logic.Atom]">toSeq</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
    <span class="keyword">case</span> <a title="sbt.logic.Logic.InitialOverlap" id="sbt.Plugins.translateMessage.io">io</a>: <a href="logic/Logic.scala.html#sbt.logic.Logic;InitialOverlap" title="sbt.logic.Logic.InitialOverlap">InitialOverlap</a> =&gt; <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Cannot directly enable plugins.  Plugins are enabled when their required plugins are satisifed.  The directly selected plugins were: &quot;)">Cannot directly enable plugins.  Plugins are enabled when their required plugins are satisifed.  The directly selected plugins were: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.literalsString" title="(lits: Seq[sbt.logic.Literal])String">literalsString</a><span class="delimiter">(</span><a href="#sbt.Plugins.translateMessage.io" title="sbt.logic.Logic.InitialOverlap">io</a>.<a href="logic/Logic.scala.html#sbt.logic.Logic;InitialOverlap.literals" title="=&gt; Set[sbt.logic.Atom]">literals</a>.<span title="=&gt; Seq[sbt.logic.Atom]">toSeq</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
    <span class="keyword">case</span> <a title="sbt.logic.Logic.CyclicNegation" id="sbt.Plugins.translateMessage.cn">cn</a>: <a href="logic/Logic.scala.html#sbt.logic.Logic;CyclicNegation" title="sbt.logic.Logic.CyclicNegation">CyclicNegation</a> =&gt; <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Cycles in plugin requirements cannot involve excludes.  The problematic cycle is: &quot;)">Cycles in plugin requirements cannot involve excludes.  The problematic cycle is: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.literalsString" title="(lits: Seq[sbt.logic.Literal])String">literalsString</a><span class="delimiter">(</span><a href="#sbt.Plugins.translateMessage.cn" title="sbt.logic.Logic.CyclicNegation">cn</a>.<a href="logic/Logic.scala.html#sbt.logic.Logic;CyclicNegation.cycle" title="=&gt; List[sbt.logic.Literal]">cycle</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(lits: Seq[sbt.logic.Literal])String" id="sbt.Plugins.literalsString">literalsString</a><span class="delimiter">(</span><a title="Seq[sbt.logic.Literal]" id="sbt.Plugins.literalsString.lits">lits</a>: <span title="Seq[sbt.logic.Literal]">Seq</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <a href="#sbt.Plugins.literalsString.lits" title="Seq[sbt.logic.Literal]">lits</a> <span title="(f: sbt.logic.Literal =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.logic.Literal],String,Seq[String]])Seq[String]">map</span> <a href="#sbt.Plugins.literalsString.$anonfun.x0$1" title="String" class="delimiter">{</a> <span class="keyword">case</span> Atom<span class="delimiter">(</span><span title="String">l</span><span class="delimiter">)</span> =&gt; <span title="String">l</span>; <span class="keyword">case</span> Negated<span class="delimiter">(</span>Atom<span class="delimiter">(</span><span title="String">l</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="String">l</span> <span class="delimiter">}</span> <span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(byAtom: Seq[(sbt.logic.Atom, sbt.AutoPlugin)])Unit" id="sbt.Plugins.duplicateProvidesError">duplicateProvidesError</a><span class="delimiter">(</span><a title="Seq[(sbt.logic.Atom, sbt.AutoPlugin)]" id="sbt.Plugins.duplicateProvidesError.byAtom">byAtom</a>: <span title="Seq[(sbt.logic.Atom, sbt.AutoPlugin)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>Atom, AutoPlugin<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[sbt.logic.Atom,Seq[sbt.AutoPlugin]]" id="sbt.Plugins.duplicateProvidesError.dupsByAtom">dupsByAtom</a> = <a href="#sbt.Plugins.duplicateProvidesError.byAtom" title="Seq[(sbt.logic.Atom, sbt.AutoPlugin)]">byAtom</a>.<span title="(f: ((sbt.logic.Atom, sbt.AutoPlugin)) =&gt; sbt.logic.Atom)scala.collection.immutable.Map[sbt.logic.Atom,Seq[(sbt.logic.Atom, sbt.AutoPlugin)]]">groupBy</span><span class="delimiter">(</span><a href="#sbt.Plugins.duplicateProvidesError.dupsByAtom.$anonfun.x$14" title="(sbt.logic.Atom, sbt.AutoPlugin)">_</a>.<span title="=&gt; sbt.logic.Atom">_1</span><span class="delimiter">)</span>.<span title="(f: Seq[(sbt.logic.Atom, sbt.AutoPlugin)] =&gt; Seq[sbt.AutoPlugin])scala.collection.immutable.Map[sbt.logic.Atom,Seq[sbt.AutoPlugin]]">mapValues</span><span class="delimiter">(</span><a href="#sbt.Plugins.duplicateProvidesError.dupsByAtom.$anonfun.x$15" title="Seq[(sbt.logic.Atom, sbt.AutoPlugin)]">_</a>.<span title="(f: ((sbt.logic.Atom, sbt.AutoPlugin)) =&gt; sbt.AutoPlugin)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(sbt.logic.Atom, sbt.AutoPlugin)],sbt.AutoPlugin,Seq[sbt.AutoPlugin]])Seq[sbt.AutoPlugin]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.AutoPlugin,Seq[sbt.AutoPlugin]]" class="delimiter">(</span><a href="#sbt.Plugins.duplicateProvidesError.dupsByAtom.$anonfun.$anonfun.x$16" title="(sbt.logic.Atom, sbt.AutoPlugin)">_</a>.<span title="=&gt; sbt.AutoPlugin">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Iterable[String]" id="sbt.Plugins.duplicateProvidesError.dupStrings">dupStrings</a> = <span class="keyword">for</span><span class="delimiter">(</span> <span class="delimiter">(</span><a title="sbt.logic.Atom" id="sbt.Plugins.duplicateProvidesError.dupStrings.$anonfun.atom">atom</a>, <a title="Seq[sbt.AutoPlugin]" id="sbt.Plugins.duplicateProvidesError.dupStrings.$anonfun.dups">dups</a><span class="delimiter">)</span> &lt;- <a href="#sbt.Plugins.duplicateProvidesError.dupsByAtom" title="(f: ((sbt.logic.Atom, Seq[sbt.AutoPlugin])) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[sbt.logic.Atom,Seq[sbt.AutoPlugin]],String,scala.collection.immutable.Iterable[String]])scala.collection.immutable.Iterable[String]">dupsByAtom</a> <span class="keyword">if</span> <a href="#sbt.Plugins.duplicateProvidesError.dupStrings.$anonfun.dups" title="Seq[sbt.AutoPlugin]">dups</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span> <span class="delimiter">)</span> <span class="keyword">yield</span>
      <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#sbt.Plugins.duplicateProvidesError.dupStrings.$anonfun.atom" title="sbt.logic.Atom">atom</a>.<a href="logic/Logic.scala.html#sbt.logic;Atom.label" title="=&gt; String">label</a><span class="delimiter">}</span><span title="String(&quot; by &quot;)"> by $</span><span class="delimiter">{</span><a href="#sbt.Plugins.duplicateProvidesError.dupStrings.$anonfun.dups" title="Seq[sbt.AutoPlugin]">dups</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
    <span class="keyword">val</span> <a href="#sbt.Plugins.duplicateProvidesError.ns" title="(String, String)" class="delimiter">(</a><a href="#sbt.Plugins.duplicateProvidesError.x$19" title="String" id="sbt.Plugins.duplicateProvidesError.ns">ns</a>, <a href="#sbt.Plugins.duplicateProvidesError.x$19" title="String" id="sbt.Plugins.duplicateProvidesError.nl">nl</a><span class="delimiter">)</span> = <span title="(String, String)" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.Plugins.duplicateProvidesError.dupStrings" title="scala.collection.immutable.Iterable[String]">dupStrings</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;s&quot;)" class="string">&quot;s&quot;</span>, <span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="String" id="sbt.Plugins.duplicateProvidesError.message">message</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Plugin&quot;)">Plugin$</span><a href="#sbt.Plugins.duplicateProvidesError.ns" title="String">ns</a><span title="String(&quot; provided by multiple AutoPlugins:&quot;)"> provided by multiple AutoPlugins:$</span><a href="#sbt.Plugins.duplicateProvidesError.nl" title="String">nl</a><span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#sbt.Plugins.duplicateProvidesError.dupStrings" title="scala.collection.immutable.Iterable[String]">dupStrings</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><a href="#sbt.Plugins.duplicateProvidesError.nl" title="String">nl</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
    <span title="Nothing" class="keyword">throw</span> <a href="#sbt.AutoPluginException.apply(ba934e7f21)" title="(msg: String)sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><a href="#sbt.Plugins.duplicateProvidesError.message" title="String">message</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(requested: sbt.Plugins, selected: Seq[sbt.AutoPlugin], conflicting: Seq[sbt.AutoPlugin])Unit" id="sbt.Plugins.exlusionConflictError">exlusionConflictError</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.exlusionConflictError.requested">requested</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>, <a title="Seq[sbt.AutoPlugin]" id="sbt.Plugins.exlusionConflictError.selected">selected</a>: <span title="Seq[sbt.AutoPlugin]">Seq</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span>, <a title="Seq[sbt.AutoPlugin]" id="sbt.Plugins.exlusionConflictError.conflicting">conflicting</a>: <span title="Seq[sbt.AutoPlugin]">Seq</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ns: Seq[sbt.AutoPlugin])String" id="sbt.Plugins.exlusionConflictError.listConflicts">listConflicts</a><span class="delimiter">(</span><a title="Seq[sbt.AutoPlugin]" id="sbt.Plugins.exlusionConflictError.listConflicts.ns">ns</a>: <span title="Seq[sbt.AutoPlugin]">Seq</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.ns" title="Seq[sbt.AutoPlugin]">ns</a> <span title="(f: sbt.AutoPlugin =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.AutoPlugin],String,Seq[String]])Seq[String]">map</span> <span class="delimiter">{</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c">c</a> =&gt;
      <span class="keyword">val</span> <a title="List[String]" id="sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons">reasons</a> = <span class="delimiter">(</span><span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Plugins.flatten" title="(n: sbt.Plugins)Seq[sbt.Plugins.Basic]">flatten</a><span class="delimiter">(</span><a href="#sbt.Plugins.exlusionConflictError.requested" title="sbt.Plugins">requested</a><span class="delimiter">)</span> <span title="(elem: Any)Boolean">contains</span> <a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a><span class="delimiter">)</span> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><span title="String(&quot;requested&quot;)" class="string">&quot;requested&quot;</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[String],String,List[String]])List[String]">++</span>
        <span class="delimiter">(</span><span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a>.<a href="#sbt;AutoPlugin.requires" title="=&gt; sbt.Plugins">requires</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt;PluginsFunctions.empty" title="=&gt; sbt.Plugins">empty</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a>.<a href="#sbt;AutoPlugin.trigger" title="=&gt; sbt.PluginTrigger">trigger</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;PluginsFunctions.allRequirements" title="=&gt; sbt.PluginTrigger">allRequirements</a><span class="delimiter">)</span> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;enabled by &quot;)">enabled by $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a>.<a href="#sbt;AutoPlugin.requires" title="=&gt; sbt.Plugins">requires</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[String],String,List[String]])List[String]">++</span>
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Seq[sbt.AutoPlugin]" id="sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.reqs">reqs</a> = <a href="#sbt.Plugins.exlusionConflictError.selected" title="Seq[sbt.AutoPlugin]">selected</a> <span title="(p: sbt.AutoPlugin =&gt; Boolean)Seq[sbt.AutoPlugin]">filter</span> <span class="delimiter">{</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.reqs.$anonfun.x">x</a> =&gt; <a href="#sbt.Plugins.asRequirements" title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]">asRequirements</a><span class="delimiter">(</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.reqs.$anonfun.x" title="sbt.AutoPlugin">x</a><span class="delimiter">)</span> <span title="(elem: Any)Boolean">contains</span> <a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a> <span class="delimiter">}</span>
          <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.reqs" title="Seq[sbt.AutoPlugin]">reqs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;&quot;&quot;<span title="String(&quot;required by &quot;)">required by $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.reqs" title="Seq[sbt.AutoPlugin]">reqs</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
        <span class="delimiter">}</span> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[String],String,List[String]])List[String]">++</span>
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Seq[sbt.AutoPlugin]" id="sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.exs">exs</a> = <a href="#sbt.Plugins.exlusionConflictError.selected" title="Seq[sbt.AutoPlugin]">selected</a> <span title="(p: sbt.AutoPlugin =&gt; Boolean)Seq[sbt.AutoPlugin]">filter</span> <span class="delimiter">{</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.exs.$anonfun.x">x</a> =&gt; <a href="#sbt.Plugins.asExclusions" title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]">asExclusions</a><span class="delimiter">(</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.exs.$anonfun.x" title="sbt.AutoPlugin">x</a><span class="delimiter">)</span> <span title="(elem: Any)Boolean">contains</span> <a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a> <span class="delimiter">}</span>
          <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.exs" title="Seq[sbt.AutoPlugin]">exs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;&quot;&quot;<span title="String(&quot;excluded by &quot;)">excluded by $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons.exs" title="Seq[sbt.AutoPlugin]">exs</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
        <span class="delimiter">}</span>
      <span title="(args: Any*)String">s</span>&quot;&quot;&quot;<span title="String(&quot;  - conflict: &quot;)">  - conflict: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.c" title="sbt.AutoPlugin">c</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">}</span><span title="String(&quot; is &quot;)"> is $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts.$anonfun.reasons" title="List[String]">reasons</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>
    <span title="Nothing" class="keyword">throw</span> <a href="#sbt.AutoPluginException.apply(ba934e7f21)" title="(msg: String)sbt.AutoPluginException">AutoPluginException</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;&quot;&quot;<span title="String(&quot;Contradiction in enabled plugins:\n  - requested: &quot;)">Contradiction in enabled plugins:
  - requested: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.requested" title="sbt.Plugins">requested</a>.<span title="()String">toString</span><span class="delimiter">}</span><span title="String(&quot;\n  - enabled: &quot;)">
  - enabled: $</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.selected" title="Seq[sbt.AutoPlugin]">selected</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;\n&quot;)">
$</span><span class="delimiter">{</span><a href="#sbt.Plugins.exlusionConflictError.listConflicts" title="(ns: Seq[sbt.AutoPlugin])String">listConflicts</a><span class="delimiter">(</span><a href="#sbt.Plugins.exlusionConflictError.conflicting" title="Seq[sbt.AutoPlugin]">conflicting</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">object</span> <a title="sbt.Plugins.Empty.type" id="sbt.Plugins.Empty">Empty</a> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type" class="keyword">extends</a> <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(o: sbt.Plugins.Basic)sbt.Plugins" id="sbt.Plugins.Empty.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt.Plugins.Empty.&&.o">o</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a><span class="delimiter">)</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> = <a href="#sbt.Plugins.Empty.&&.o" title="sbt.Plugins.Basic">o</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.Plugins.Empty.toString">toString</a> = <span title="String(&quot;&lt;none&gt;&quot;)" class="string">&quot;&lt;none&gt;&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An included or excluded Nature/Plugin.  TODO: better name than Basic.  Also, can we dump
   *  this class.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Basic extends AnyRef with sbt.Plugins" id="sbt.Plugins;Basic">Basic</a> <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic" class="keyword">extends</a> <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(o: sbt.Plugins.Basic)sbt.Plugins" id="sbt.Plugins;Basic.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt.Plugins;Basic.&&.o">o</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a><span class="delimiter">)</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> = <a href="#sbt.Plugins.And.readResolve" title="(plugins: List[sbt.Plugins.Basic])sbt.Plugins.And">And</a><span class="delimiter">(</span><a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic" class="keyword">this</a> <a href="#sbt.Plugins;Basic.&&.x$21" title="(x: sbt.Plugins.Basic)List[sbt.Plugins.Basic]">::</a> <a href="#sbt.Plugins;Basic.&&.o" title="sbt.Plugins.Basic">o</a> <a href="#sbt.Plugins;Basic.&&.x$20" title="(x: sbt.Plugins.Basic)List[sbt.Plugins.Basic]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Exclude extends sbt.Plugins.Basic with Product with Serializable" id="sbt.Plugins.Exclude.readResolve">Exclude</a><a href="#sbt.Plugins.Exclude.readResolve" title="Product" class="delimiter">(</a><a title="sbt.AutoPlugin" id="sbt.Plugins;Exclude.n">n</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a>  <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.Plugins;Exclude.toString">toString</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;!&quot;)">!$</span><a href="#sbt.Plugins;Exclude.n" title="=&gt; sbt.AutoPlugin">n</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class And extends AnyRef with sbt.Plugins with Product with Serializable" id="sbt.Plugins.And.readResolve">And</a><a href="#sbt.Plugins.And.readResolve" title="Product" class="delimiter">(</a><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins;And.plugins">plugins</a>: <span title="List[sbt.Plugins.Basic]">List</span><span class="delimiter">[</span>Basic<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(o: sbt.Plugins.Basic)sbt.Plugins" id="sbt.Plugins;And.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt.Plugins;And.&&.o">o</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a><span class="delimiter">)</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> = <a href="#sbt.Plugins.And.readResolve" title="(plugins: List[sbt.Plugins.Basic])sbt.Plugins.And">And</a><span class="delimiter">(</span><a href="#sbt.Plugins;And.&&.o" title="sbt.Plugins.Basic">o</a> <a href="#sbt.Plugins;And.&&.x$22" title="(x: sbt.Plugins.Basic)List[sbt.Plugins.Basic]">::</a> <a href="#sbt.Plugins;And.plugins" title="=&gt; List[sbt.Plugins.Basic]">plugins</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.Plugins;And.toString">toString</a> = <a href="#sbt.Plugins;And.plugins" title="=&gt; List[sbt.Plugins.Basic]">plugins</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; &amp;&amp; &quot;)" class="string">&quot; &amp;&amp; &quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(a: sbt.Plugins, b: sbt.Plugins)sbt.Plugins" id="sbt.Plugins.and">and</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.and.a">a</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>, <span title="sbt.Plugins">b</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a><span class="delimiter">)</span> = <span title="sbt.Plugins">b</span> <span title="sbt.Plugins" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <a href="#sbt.Plugins.and.a" title="sbt.Plugins">a</a>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.and.ns">ns</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="#sbt.Plugins.and.a" title="sbt.Plugins">a</a> <a href="#sbt.Plugins.and.x$23" title="(z: sbt.Plugins)(op: (sbt.Plugins, sbt.Plugins.Basic) =&gt; sbt.Plugins)sbt.Plugins">/:</a> <a href="#sbt.Plugins.and.ns" title="List[sbt.Plugins.Basic]">ns</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.Plugins.and.$anonfun.x$24" title="sbt.Plugins">_</a> <a href="#sbt;Plugins.&&" title="(o: sbt.Plugins.Basic)sbt.Plugins">&amp;&amp;</a> <a href="#sbt.Plugins.and.$anonfun.x$25" title="sbt.Plugins.Basic">_</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="sbt.Plugins.Basic">b</span>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <a href="#sbt.Plugins.and.a" title="sbt.Plugins">a</a> <a href="#sbt;Plugins.&&" title="(o: sbt.Plugins.Basic)sbt.Plugins">&amp;&amp;</a> <span title="sbt.Plugins.Basic">b</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(a: sbt.Plugins, del: Set[sbt.Plugins.Basic])sbt.Plugins" id="sbt.Plugins.remove">remove</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.remove.a">a</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>, <a title="Set[sbt.Plugins.Basic]" id="sbt.Plugins.remove.del">del</a>: <span title="Set[sbt.Plugins.Basic]">Set</span><span class="delimiter">[</span>Basic<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a> = <a href="#sbt.Plugins.remove.a" title="sbt.Plugins">a</a> <span title="sbt.Plugins" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a title="sbt.Plugins.Basic" id="sbt.Plugins.remove.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <span title="sbt.Plugins" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.Plugins.remove.del" title="(elem: sbt.Plugins.Basic)Boolean">del</a><span class="delimiter">(</span><a href="#sbt.Plugins.remove.b" title="sbt.Plugins.Basic">b</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> <span class="keyword">else</span> <a href="#sbt.Plugins.remove.b" title="sbt.Plugins.Basic">b</a>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.remove.ns">ns</a><span class="delimiter">)</span> =&gt;
      <span class="keyword">val</span> <a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.remove.removed">removed</a> = <a href="#sbt.Plugins.remove.ns" title="List[sbt.Plugins.Basic]">ns</a>.<span title="(p: sbt.Plugins.Basic =&gt; Boolean)List[sbt.Plugins.Basic]">filterNot</span><span class="delimiter">(</span><a href="#sbt.Plugins.remove.del" title="Set[sbt.Plugins.Basic]">del</a><span class="delimiter">)</span>
      <span title="sbt.Plugins" class="keyword">if</span><span class="delimiter">(</span><a href="#sbt.Plugins.remove.removed" title="List[sbt.Plugins.Basic]">removed</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> <span class="keyword">else</span> <a href="#sbt.Plugins.And.readResolve" title="(plugins: List[sbt.Plugins.Basic])sbt.Plugins.And">And</a><span class="delimiter">(</span><a href="#sbt.Plugins.remove.removed" title="List[sbt.Plugins.Basic]">removed</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Defines enabled-by clauses for `ap`. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ap: sbt.AutoPlugin)List[sbt.logic.Clause]" id="sbt.Plugins.asEnabledByClauses">asEnabledByClauses</a><span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.asEnabledByClauses.ap">ap</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="List[sbt.logic.Clause]">List</span><span class="delimiter">[</span>Clause<span class="delimiter">]</span> =
    <span class="comment">// `ap` is the head and the required plugins for `ap` is the body.</span>
    <span title="List[sbt.logic.Clause]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.Plugins.asEnabledByClauses.ap" title="sbt.AutoPlugin">ap</a>.<a href="#sbt;AutoPlugin.trigger" title="=&gt; sbt.PluginTrigger">trigger</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.AllRequirements.readResolve" title="sbt.AllRequirements.type">AllRequirements</a><span class="delimiter">)</span> <a href="logic/Logic.scala.html#sbt.logic;Clause" title="(body: sbt.logic.Formula, head: Set[sbt.logic.Atom])sbt.logic.Clause">Clause</a><span class="delimiter">(</span> <a href="#sbt.Plugins.convert" title="(n: sbt.Plugins)sbt.logic.Formula">convert</a><span class="delimiter">(</span><a href="#sbt.Plugins.asEnabledByClauses.ap" title="sbt.AutoPlugin">ap</a>.<a href="#sbt;AutoPlugin.requires" title="=&gt; sbt.Plugins">requires</a><span class="delimiter">)</span>, <span title="(elems: sbt.logic.Atom*)scala.collection.immutable.Set[sbt.logic.Atom]">Set</span><span class="delimiter">(</span><a href="logic/Logic.scala.html#sbt.logic;Atom" title="(label: String)sbt.logic.Atom">Atom</a><span class="delimiter">(</span><a href="#sbt.Plugins.asEnabledByClauses.ap" title="sbt.AutoPlugin">ap</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span> <a href="#sbt.Plugins.asEnabledByClauses.x$26" title="(x: sbt.logic.Clause)List[sbt.logic.Clause]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="comment">/** Defines requirements clauses for `ap`. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ap: sbt.AutoPlugin)List[sbt.logic.Clause]" id="sbt.Plugins.asRequirementsClauses">asRequirementsClauses</a><span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.asRequirementsClauses.ap">ap</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="List[sbt.logic.Clause]">List</span><span class="delimiter">[</span>Clause<span class="delimiter">]</span> =
    <span class="comment">// required plugin is the head and `ap` is the body.</span>
    <a href="#sbt.Plugins.asRequirements" title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]">asRequirements</a><span class="delimiter">(</span><a href="#sbt.Plugins.asRequirementsClauses.ap" title="sbt.AutoPlugin">ap</a><span class="delimiter">)</span> <span title="(f: sbt.AutoPlugin =&gt; sbt.logic.Clause)(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.AutoPlugin],sbt.logic.Clause,List[sbt.logic.Clause]])List[sbt.logic.Clause]">map</span> <span class="delimiter">{</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.asRequirementsClauses.$anonfun.x">x</a> =&gt; <a href="logic/Logic.scala.html#sbt.logic;Clause" title="(body: sbt.logic.Formula, head: Set[sbt.logic.Atom])sbt.logic.Clause">Clause</a><span class="delimiter">(</span> <a href="#sbt.Plugins.convert" title="(n: sbt.Plugins)sbt.logic.Formula">convert</a><span class="delimiter">(</span><a href="#sbt.Plugins.asRequirementsClauses.ap" title="sbt.AutoPlugin">ap</a><span class="delimiter">)</span>, <span title="(elems: sbt.logic.Atom*)scala.collection.immutable.Set[sbt.logic.Atom]">Set</span><span class="delimiter">(</span><a href="logic/Logic.scala.html#sbt.logic;Atom" title="(label: String)sbt.logic.Atom">Atom</a><span class="delimiter">(</span><a href="#sbt.Plugins.asRequirementsClauses.$anonfun.x" title="sbt.AutoPlugin">x</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]" id="sbt.Plugins.asRequirements">asRequirements</a><span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.asRequirements.ap">ap</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> = <a href="#sbt.Plugins.flatten" title="(n: sbt.Plugins)Seq[sbt.Plugins.Basic]">flatten</a><span class="delimiter">(</span><a href="#sbt.Plugins.asRequirements.ap" title="sbt.AutoPlugin">ap</a>.<a href="#sbt;AutoPlugin.requires" title="=&gt; sbt.Plugins">requires</a><span class="delimiter">)</span>.<span title="=&gt; List[sbt.Plugins.Basic]">toList</span> <span title="(pf: PartialFunction[sbt.Plugins.Basic,sbt.AutoPlugin])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.Plugins.Basic],sbt.AutoPlugin,List[sbt.AutoPlugin]])List[sbt.AutoPlugin]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[sbt.Plugins.Basic,sbt.AutoPlugin] with Serializable" id="sbt.Plugins.asRequirements;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    <span class="keyword">case</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.asRequirements;$anonfun.isDefinedAt.x">x</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a> =&gt; <a href="#sbt.Plugins.asRequirements;$anonfun.isDefinedAt.x" title="sbt.AutoPlugin">x</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ap: sbt.AutoPlugin)List[sbt.AutoPlugin]" id="sbt.Plugins.asExclusions">asExclusions</a><span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.asExclusions.ap">ap</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="List[sbt.AutoPlugin]">List</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span> = <a href="#sbt.Plugins.flatten" title="(n: sbt.Plugins)Seq[sbt.Plugins.Basic]">flatten</a><span class="delimiter">(</span><a href="#sbt.Plugins.asExclusions.ap" title="sbt.AutoPlugin">ap</a>.<a href="#sbt;AutoPlugin.requires" title="=&gt; sbt.Plugins">requires</a><span class="delimiter">)</span>.<span title="=&gt; List[sbt.Plugins.Basic]">toList</span> <span title="(pf: PartialFunction[sbt.Plugins.Basic,sbt.AutoPlugin])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.Plugins.Basic],sbt.AutoPlugin,List[sbt.AutoPlugin]])List[sbt.AutoPlugin]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[sbt.Plugins.Basic,sbt.AutoPlugin] with Serializable" id="sbt.Plugins.asExclusions;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    <span class="keyword">case</span> Exclude<span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.asExclusions;$anonfun.isDefinedAt.x">x</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.asExclusions;$anonfun.isDefinedAt.x" title="sbt.AutoPlugin">x</a>
  <span class="delimiter">}</span>
  <span class="comment">// TODO - This doesn't handle nested AND boolean logic...</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean" id="sbt.Plugins.hasExclude">hasExclude</a><span class="delimiter">(</span><span title="sbt.Plugins">n</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>, <a title="sbt.AutoPlugin" id="sbt.Plugins.hasExclude.p">p</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="sbt.Plugins">n</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.hasExclude.p" title="sbt.AutoPlugin">`p`</a> =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">case</span> Exclude<span class="delimiter">(</span><a href="#sbt.Plugins.hasExclude.p" title="sbt.AutoPlugin">`p`</a><span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="comment">// TODO - This is stupidly advanced.  We do a nested check through possible and-ed</span>
    <span class="comment">// lists of plugins exclusions to see if the plugin ever winds up in an excluded=true case.</span>
    <span class="comment">// This would handle things like !!p or !(p &amp;&amp; z)</span>
    <span class="keyword">case</span> Exclude<span class="delimiter">(</span><span title="sbt.AutoPlugin">n</span><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.hasInclude" title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean">hasInclude</a><span class="delimiter">(</span><span title="sbt.AutoPlugin">n</span>, <a href="#sbt.Plugins.hasExclude.p" title="sbt.AutoPlugin">p</a><span class="delimiter">)</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.hasExclude.ns">ns</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.hasExclude.ns" title="List[sbt.Plugins.Basic]">ns</a>.<span title="(p: sbt.Plugins.Basic =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt.Plugins.hasExclude.$anonfun.n">n</a> =&gt; <a href="#sbt.Plugins.hasExclude" title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean">hasExclude</a><span class="delimiter">(</span><a href="#sbt.Plugins.hasExclude.$anonfun.n" title="sbt.Plugins.Basic">n</a>, <a href="#sbt.Plugins.hasExclude.p" title="sbt.AutoPlugin">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.Plugins.Basic" id="sbt.Plugins.hasExclude.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean" id="sbt.Plugins.hasInclude">hasInclude</a><span class="delimiter">(</span><span title="sbt.Plugins">n</span>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>, <a title="sbt.AutoPlugin" id="sbt.Plugins.hasInclude.p">p</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="sbt.Plugins">n</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.hasInclude.p" title="sbt.AutoPlugin">`p`</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> Exclude<span class="delimiter">(</span><span title="sbt.AutoPlugin">n</span><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.hasExclude" title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean">hasExclude</a><span class="delimiter">(</span><span title="sbt.AutoPlugin">n</span>, <a href="#sbt.Plugins.hasInclude.p" title="sbt.AutoPlugin">p</a><span class="delimiter">)</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.hasInclude.ns">ns</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.hasInclude.ns" title="List[sbt.Plugins.Basic]">ns</a>.<span title="(p: sbt.Plugins.Basic =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt.Plugins.hasInclude.$anonfun.n">n</a> =&gt; <a href="#sbt.Plugins.hasInclude" title="(n: sbt.Plugins, p: sbt.AutoPlugin)Boolean">hasInclude</a><span class="delimiter">(</span><a href="#sbt.Plugins.hasInclude.$anonfun.n" title="sbt.Plugins.Basic">n</a>, <a href="#sbt.Plugins.hasInclude.p" title="sbt.AutoPlugin">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.Plugins.Basic" id="sbt.Plugins.hasInclude.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(n: sbt.Plugins)Seq[sbt.logic.Literal]" id="sbt.Plugins.flattenConvert">flattenConvert</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.flattenConvert.n">n</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a><span class="delimiter">)</span>: <span title="Seq[sbt.logic.Literal]">Seq</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.Plugins.flattenConvert.n" title="sbt.Plugins">n</a> <span title="Seq[sbt.logic.Literal]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.flattenConvert.ns">ns</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.convertAll" title="(ns: Seq[sbt.Plugins.Basic])Seq[sbt.logic.Literal]">convertAll</a><span class="delimiter">(</span><a href="#sbt.Plugins.flattenConvert.ns" title="List[sbt.Plugins.Basic]">ns</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.Plugins.Basic" id="sbt.Plugins.flattenConvert.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <a href="#sbt.Plugins.convertBasic" title="(b: sbt.Plugins.Basic)sbt.logic.Literal">convertBasic</a><span class="delimiter">(</span><a href="#sbt.Plugins.flattenConvert.b" title="sbt.Plugins.Basic">b</a><span class="delimiter">)</span> <a href="#sbt.Plugins.flattenConvert.x$27" title="(x: sbt.logic.Literal)List[sbt.logic.Literal]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(n: sbt.Plugins)Seq[sbt.Plugins.Basic]" id="sbt.Plugins.flatten">flatten</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.flatten.n">n</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a><span class="delimiter">)</span>: <span title="Seq[sbt.Plugins.Basic]">Seq</span><span class="delimiter">[</span>Basic<span class="delimiter">]</span> = <a href="#sbt.Plugins.flatten.n" title="sbt.Plugins">n</a> <span title="Seq[sbt.Plugins.Basic]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.flatten.ns">ns</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.flatten.ns" title="List[sbt.Plugins.Basic]">ns</a>
    <span class="keyword">case</span> <a title="sbt.Plugins.Basic" id="sbt.Plugins.flatten.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <a href="#sbt.Plugins.flatten.b" title="sbt.Plugins.Basic">b</a> <a href="#sbt.Plugins.flatten.x$28" title="(x: sbt.Plugins.Basic)List[sbt.Plugins.Basic]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(n: sbt.Plugins)sbt.logic.Formula" id="sbt.Plugins.convert">convert</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.convert.n">n</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a><span class="delimiter">)</span>: <a href="logic/Logic.scala.html#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a> = <a href="#sbt.Plugins.convert.n" title="sbt.Plugins">n</a> <span title="sbt.logic.Formula" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="List[sbt.Plugins.Basic]" id="sbt.Plugins.convert.ns">ns</a><span class="delimiter">)</span> =&gt; <a href="#sbt.Plugins.convertAll" title="(ns: Seq[sbt.Plugins.Basic])Seq[sbt.logic.Literal]">convertAll</a><span class="delimiter">(</span><a href="#sbt.Plugins.convert.ns" title="List[sbt.Plugins.Basic]">ns</a><span class="delimiter">)</span>.<span title="[A1 &gt;: sbt.logic.Literal](op: (A1, A1) =&gt; A1)A1">reduce</span><span title="(op: (sbt.logic.Formula, sbt.logic.Formula) =&gt; sbt.logic.Formula)sbt.logic.Formula" class="delimiter">[</span><a href="logic/Logic.scala.html#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.Plugins.convert.$anonfun.x$29" title="sbt.logic.Formula">_</a> <a href="logic/Logic.scala.html#sbt.logic;Formula.&&" title="(f: sbt.logic.Formula)sbt.logic.Formula">&amp;&amp;</a> <a href="#sbt.Plugins.convert.$anonfun.x$30" title="sbt.logic.Formula">_</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.Plugins.Basic" id="sbt.Plugins.convert.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a> =&gt; <a href="#sbt.Plugins.convertBasic" title="(b: sbt.Plugins.Basic)sbt.logic.Literal">convertBasic</a><span class="delimiter">(</span><a href="#sbt.Plugins.convert.b" title="sbt.Plugins.Basic">b</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#sbt.Plugins.Empty" title="sbt.Plugins.Empty.type">Empty</a> =&gt; <a href="logic/Logic.scala.html#sbt.logic.Formula" title="sbt.logic.Formula.type">Formula</a>.<a href="logic/Logic.scala.html#sbt.logic.Formula.True" title="sbt.logic.Formula.True.type">True</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(b: sbt.Plugins.Basic)sbt.logic.Literal" id="sbt.Plugins.convertBasic">convertBasic</a><span class="delimiter">(</span><a title="sbt.Plugins.Basic" id="sbt.Plugins.convertBasic.b">b</a>: <a href="#sbt.Plugins;Basic" title="sbt.Plugins.Basic">Basic</a><span class="delimiter">)</span>: <a href="logic/Logic.scala.html#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a> = <a href="#sbt.Plugins.convertBasic.b" title="sbt.Plugins.Basic">b</a> <span title="sbt.logic.Literal" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Exclude<span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.convertBasic.n">n</a><span class="delimiter">)</span> =&gt; <a href="logic/Logic.scala.html#sbt.logic;Literal.unary_!" title="=&gt; sbt.logic.Literal">!</a><a href="#sbt.Plugins.convertBasic" title="(b: sbt.Plugins.Basic)sbt.logic.Literal">convertBasic</a><span class="delimiter">(</span><a href="#sbt.Plugins.convertBasic.n" title="sbt.AutoPlugin">n</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.convertBasic.a">a</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a> =&gt; <a href="logic/Logic.scala.html#sbt.logic;Atom" title="(label: String)sbt.logic.Atom">Atom</a><span class="delimiter">(</span><a href="#sbt.Plugins.convertBasic.a" title="sbt.AutoPlugin">a</a>.<a href="#sbt;AutoPlugin.label" title="=&gt; String">label</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ns: Seq[sbt.Plugins.Basic])Seq[sbt.logic.Literal]" id="sbt.Plugins.convertAll">convertAll</a><span class="delimiter">(</span><a title="Seq[sbt.Plugins.Basic]" id="sbt.Plugins.convertAll.ns">ns</a>: <span title="Seq[sbt.Plugins.Basic]">Seq</span><span class="delimiter">[</span>Basic<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[sbt.logic.Literal]">Seq</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.Plugins.convertAll.ns" title="Seq[sbt.Plugins.Basic]">ns</a> <span title="(f: sbt.Plugins.Basic =&gt; sbt.logic.Literal)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.Plugins.Basic],sbt.logic.Literal,Seq[sbt.logic.Literal]])Seq[sbt.logic.Literal]">map</span> <a href="#sbt.Plugins.convertBasic" title="(b: sbt.Plugins.Basic)sbt.logic.Literal">convertBasic</a>

  <span class="comment">/** True if the trigger clause `n` is satisifed by `model`. */</span>
  <span class="keyword">def</span> <a title="(n: sbt.Plugins, model: Set[sbt.AutoPlugin])Boolean" id="sbt.Plugins.satisfied">satisfied</a><span class="delimiter">(</span><a title="sbt.Plugins" id="sbt.Plugins.satisfied.n">n</a>: <a href="#sbt;Plugins" title="sbt.Plugins">Plugins</a>, <a title="Set[sbt.AutoPlugin]" id="sbt.Plugins.satisfied.model">model</a>: <span title="Set[sbt.AutoPlugin]">Set</span><span class="delimiter">[</span>AutoPlugin<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#sbt.Plugins.flatten" title="(n: sbt.Plugins)Seq[sbt.Plugins.Basic]">flatten</a><span class="delimiter">(</span><a href="#sbt.Plugins.satisfied.n" title="sbt.Plugins">n</a><span class="delimiter">)</span> <span title="(p: sbt.Plugins.Basic =&gt; Boolean)Boolean">forall</span> <a href="#sbt.Plugins.satisfied.$anonfun.x0$2" title="Boolean" class="delimiter">{</a>
      <span class="keyword">case</span> Exclude<span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.satisfied.$anonfun.a">a</a><span class="delimiter">)</span> =&gt; <span title="=&gt; Boolean">!</span><a href="#sbt.Plugins.satisfied.model" title="(elem: sbt.AutoPlugin)Boolean">model</a><span class="delimiter">(</span><a href="#sbt.Plugins.satisfied.$anonfun.a" title="sbt.AutoPlugin">a</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="sbt.AutoPlugin" id="sbt.Plugins.satisfied.$anonfun.ap">ap</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a> =&gt; <a href="#sbt.Plugins.satisfied.model" title="(elem: sbt.AutoPlugin)Boolean">model</a><span class="delimiter">(</span><a href="#sbt.Plugins.satisfied.$anonfun.ap" title="sbt.AutoPlugin">ap</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ap: sbt.AutoPlugin, loader: ClassLoader)Boolean" id="sbt.Plugins.hasAutoImportGetter">hasAutoImportGetter</a><span class="delimiter">(</span><a title="sbt.AutoPlugin" id="sbt.Plugins.hasAutoImportGetter.ap">ap</a>: <a href="#sbt;AutoPlugin" title="sbt.AutoPlugin">AutoPlugin</a>, <a title="ClassLoader" id="sbt.Plugins.hasAutoImportGetter.loader">loader</a>: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> reflect.runtime.<span class="delimiter">{</span>universe =&gt; ru<span class="delimiter">}</span>
    <span class="keyword">import</span> util.control.<span title="scala.util.control.Exception.type">Exception</span>.catching
    <span class="keyword">val</span> <a title="reflect.runtime.universe.Mirror" id="sbt.Plugins.hasAutoImportGetter.m">m</a> = <span title="=&gt; scala.reflect.api.JavaUniverse">ru</span>.<span title="(cl: ClassLoader)reflect.runtime.universe.Mirror">runtimeMirror</span><span class="delimiter">(</span><a href="#sbt.Plugins.hasAutoImportGetter.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="reflect.runtime.universe.InstanceMirror" id="sbt.Plugins.hasAutoImportGetter.im">im</a> = <a href="#sbt.Plugins.hasAutoImportGetter.m" title="reflect.runtime.universe.Mirror">m</a>.<span title="(obj: sbt.AutoPlugin)(implicit evidence$1: scala.reflect.ClassTag[sbt.AutoPlugin])reflect.runtime.universe.InstanceMirror">reflect</span><span title="()scala.reflect.ClassTag[sbt.AutoPlugin]" class="delimiter">(</span><a href="#sbt.Plugins.hasAutoImportGetter.ap" title="sbt.AutoPlugin">ap</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Option[Boolean]" id="sbt.Plugins.hasAutoImportGetter.hasGetterOpt">hasGetterOpt</a> = <span title="(exceptions: Class[_]*)util.control.Exception.Catch[Nothing]">catching</span><span class="delimiter">(</span>classOf<span title="Class[ScalaReflectionException](classOf[scala.ScalaReflectionException])" class="delimiter">[</span>ScalaReflectionException<span class="delimiter">]</span><span class="delimiter">)</span> <span title="(body: =&gt; Boolean)Option[Boolean]">opt</span> <span class="delimiter">{</span>
      <a href="#sbt.Plugins.hasAutoImportGetter.im" title="reflect.runtime.universe.InstanceMirror">im</a>.<span title="=&gt; reflect.runtime.universe.ClassSymbol">symbol</span>.<span title="=&gt; reflect.runtime.universe.TypeSymbol">asType</span>.<span title="=&gt; reflect.runtime.universe.Type">toType</span>.<span title="(name: reflect.runtime.universe.Name)reflect.runtime.universe.Symbol">declaration</span><span class="delimiter">(</span><span title="=&gt; scala.reflect.api.JavaUniverse">ru</span>.<span title="(s: String)reflect.runtime.universe.TermName">newTermName</span><span class="delimiter">(</span><span title="String(&quot;autoImport&quot;)" class="string">&quot;autoImport&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="=&gt; scala.reflect.api.JavaUniverse">ru</span>.<span title="=&gt; reflect.runtime.universe.Symbol">NoSymbol</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <a title="reflect.runtime.universe.Symbol" id="sbt.Plugins.hasAutoImportGetter.hasGetterOpt.sym">sym</a> =&gt; <a href="#sbt.Plugins.hasAutoImportGetter.hasGetterOpt.sym" title="reflect.runtime.universe.Symbol">sym</a>.<span title="=&gt; reflect.runtime.universe.TermSymbol">asTerm</span>.<span title="=&gt; Boolean">isGetter</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.Plugins.hasAutoImportGetter.hasGetterOpt.sym" title="reflect.runtime.universe.Symbol">sym</a>.<span title="=&gt; reflect.runtime.universe.TermSymbol">asTerm</span>.<span title="=&gt; Boolean">isModule</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#sbt.Plugins.hasAutoImportGetter.hasGetterOpt" title="Option[Boolean]">hasGetterOpt</a> <span title="(default: =&gt; Boolean)Boolean">getOrElse</span> <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
