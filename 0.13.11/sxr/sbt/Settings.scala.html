<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Settings.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2011 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> <a href="Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._

<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Settings[Scope] extends AnyRef" id="sbt;Settings">Settings</a><span class="delimiter">[</span><a title="" id="sbt;Settings;Scope">Scope</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; Map[Scope,sbt.AttributeMap]" id="sbt;Settings.data">data</a>: <span title="Map[Scope,sbt.AttributeMap]">Map</span><span class="delimiter">[</span>Scope, AttributeMap<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(scope: Scope)Set[sbt.AttributeKey[_]]" id="sbt;Settings.keys">keys</a><span class="delimiter">(</span><a title="Scope" id="sbt;Settings.keys.scope">scope</a>: <a href="#sbt;Settings;Scope" title="Scope">Scope</a><span class="delimiter">)</span>: <span title="Set[sbt.AttributeKey[_]]">Set</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Set[Scope]" id="sbt;Settings.scopes">scopes</a>: <span title="Set[Scope]">Set</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(scope: Scope, key: sbt.AttributeKey[_])Option[Scope]" id="sbt;Settings.definingScope">definingScope</a><span class="delimiter">(</span><a title="Scope" id="sbt;Settings.definingScope.scope">scope</a>: <a href="#sbt;Settings;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[_]" id="sbt;Settings.definingScope.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[_]">AttributeKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Scope]">Option</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](f: (Scope, sbt.AttributeKey[_]) =&gt; T)Seq[T]" id="sbt;Settings.allKeys">allKeys</a><span class="delimiter">[</span><a title="" id="sbt;Settings.allKeys;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(Scope, sbt.AttributeKey[_]) =&gt; T" id="sbt;Settings.allKeys.f">f</a>: <span class="delimiter">(</span>Scope, AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](scope: Scope, key: sbt.AttributeKey[T])Option[T]" id="sbt;Settings.get">get</a><span class="delimiter">[</span><a title="" id="sbt;Settings.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings.get.scope">scope</a>: <a href="#sbt;Settings;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Settings.get.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](scope: Scope, key: sbt.AttributeKey[T])Option[T]" id="sbt;Settings.getDirect">getDirect</a><span class="delimiter">[</span><a title="" id="sbt;Settings.getDirect;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings.getDirect.scope">scope</a>: <a href="#sbt;Settings;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Settings.getDirect.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](scope: Scope, key: sbt.AttributeKey[T], value: T)sbt.Settings[Scope]" id="sbt;Settings.set">set</a><span class="delimiter">[</span><a title="" id="sbt;Settings.set;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings.set.scope">scope</a>: <a href="#sbt;Settings;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Settings.set.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T" id="sbt;Settings.set.value">value</a>: <a href="#sbt;Settings.set;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Settings0[Scope] extends AnyRef with sbt.Settings[Scope]" id="sbt;Settings0">Settings0</a><span class="delimiter">[</span><a title="" id="sbt;Settings0;Scope">Scope</a><span class="delimiter">]</span><a href="#sbt;Settings0" title="sbt.Settings0[Scope]" class="delimiter">(</a><span class="keyword">val</span> <a title="Map[Scope,sbt.AttributeMap]" id="sbt;Settings0.data">data</a>: <span title="Map[Scope,sbt.AttributeMap]">Map</span><span class="delimiter">[</span>Scope, AttributeMap<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Settings0.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; Set[Scope]" id="sbt;Settings0.scopes">scopes</a>: <span title="Set[Scope]">Set</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#sbt;Settings0.data" title="=&gt; Map[Scope,sbt.AttributeMap]">data</a>.<span title="=&gt; scala.collection.immutable.Set[Scope]">keySet</span>
  <span class="keyword">def</span> <a title="(scope: Scope)scala.collection.immutable.Set[sbt.AttributeKey[_]]" id="sbt;Settings0.keys">keys</a><span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.keys.scope">scope</a>: <a href="#sbt;Settings0;Scope" title="Scope">Scope</a><span class="delimiter">)</span> = <a href="#sbt;Settings0.data" title="(key: Scope)sbt.AttributeMap">data</a><span class="delimiter">(</span><a href="#sbt;Settings0.keys.scope" title="Scope">scope</a><span class="delimiter">)</span>.<a href="Attributes.scala.html#sbt;AttributeMap.keys" title="=&gt; Iterable[sbt.AttributeKey[_]]">keys</a>.<span title="scala.collection.immutable.Set[sbt.AttributeKey[_]]">toSet</span>
  <span class="keyword">def</span> <a title="[T](f: (Scope, sbt.AttributeKey[_]) =&gt; T)Seq[T]" id="sbt;Settings0.allKeys">allKeys</a><span class="delimiter">[</span><a title="" id="sbt;Settings0.allKeys;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(Scope, sbt.AttributeKey[_]) =&gt; T" id="sbt;Settings0.allKeys.f">f</a>: <span class="delimiter">(</span>Scope, AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Settings0.data" title="=&gt; Map[Scope,sbt.AttributeMap]">data</a>.<span title="(f: ((Scope, sbt.AttributeMap)) =&gt; scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Scope,sbt.AttributeMap],T,scala.collection.immutable.Iterable[T]])scala.collection.immutable.Iterable[T]">flatMap</span> <a href="#sbt;Settings0.allKeys.$anonfun.x0$1" title="Iterable[T]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.allKeys.$anonfun.scope">scope</a>, <a title="sbt.AttributeMap" id="sbt;Settings0.allKeys.$anonfun.map">map</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Settings0.allKeys.$anonfun.map" title="sbt.AttributeMap">map</a>.<a href="Attributes.scala.html#sbt;AttributeMap.keys" title="=&gt; Iterable[sbt.AttributeKey[_]]">keys</a>.<span title="(f: sbt.AttributeKey[_] =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[sbt.AttributeKey[_]],T,Iterable[T]])Iterable[T]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,T,Iterable[T]]" class="delimiter">(</span><a title="sbt.AttributeKey[_]" id="sbt;Settings0.allKeys.$anonfun.$anonfun.k">k</a> =&gt; <a href="#sbt;Settings0.allKeys.f" title="(v1: Scope, v2: sbt.AttributeKey[_])T">f</a><span class="delimiter">(</span><a href="#sbt;Settings0.allKeys.$anonfun.scope" title="Scope">scope</a>, <a href="#sbt;Settings0.allKeys.$anonfun.$anonfun.k" title="sbt.AttributeKey[_]">k</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span title="=&gt; Seq[T]">toSeq</span>

  <span class="keyword">def</span> <a title="[T](scope: Scope, key: sbt.AttributeKey[T])Option[T]" id="sbt;Settings0.get">get</a><span class="delimiter">[</span><a title="" id="sbt;Settings0.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.get.scope">scope</a>: <a href="#sbt;Settings0;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Settings0.get.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt;Settings0.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Settings0.get.scope" title="Scope">scope</a><span class="delimiter">)</span>.<span title="=&gt; scala.collection.immutable.Stream[Scope]">toStream</span>.<span title="(f: Scope =&gt; scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[Scope],T,scala.collection.immutable.Stream[T]])scala.collection.immutable.Stream[T]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream.Coll,T,scala.collection.immutable.Stream[T]]" class="delimiter">(</span><a title="Scope" id="sbt;Settings0.get.$anonfun.sc">sc</a> =&gt; <a href="#sbt;Settings0.getDirect" title="(scope: Scope, key: sbt.AttributeKey[T])Option[T]">getDirect</a><span title="(xo: Option[T])Iterable[T]" class="delimiter">(</span><a href="#sbt;Settings0.get.$anonfun.sc" title="Scope">sc</a>, <a href="#sbt;Settings0.get.key" title="sbt.AttributeKey[T]">key</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; Option[T]">headOption</span>
  <span class="keyword">def</span> <a title="(scope: Scope, key: sbt.AttributeKey[_])Option[Scope]" id="sbt;Settings0.definingScope">definingScope</a><span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.definingScope.scope">scope</a>: <a href="#sbt;Settings0;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[_]" id="sbt;Settings0.definingScope.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[_]">AttributeKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Scope]">Option</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> =
    <a href="#sbt;Settings0.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Settings0.definingScope.scope" title="Scope">scope</a><span class="delimiter">)</span>.<span title="=&gt; scala.collection.immutable.Stream[Scope]">toStream</span>.<span title="(p: Scope =&gt; Boolean)Option[Scope]">find</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.definingScope.$anonfun.sc">sc</a> =&gt; <a href="#sbt;Settings0.getDirect" title="(scope: Scope, key: sbt.AttributeKey[_$5])Option[_$5]">getDirect</a><span class="delimiter">(</span><a href="#sbt;Settings0.definingScope.$anonfun.sc" title="Scope">sc</a>, <a href="#sbt;Settings0.definingScope.key" title="sbt.AttributeKey[_]">key</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](scope: Scope, key: sbt.AttributeKey[T])Option[T]" id="sbt;Settings0.getDirect">getDirect</a><span class="delimiter">[</span><a title="" id="sbt;Settings0.getDirect;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.getDirect.scope">scope</a>: <a href="#sbt;Settings0;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Settings0.getDirect.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">(</span><a href="#sbt;Settings0.data" title="=&gt; Map[Scope,sbt.AttributeMap]">data</a> <span title="(key: Scope)Option[sbt.AttributeMap]">get</span> <a href="#sbt;Settings0.getDirect.scope" title="Scope">scope</a><span class="delimiter">)</span>.<span title="(f: sbt.AttributeMap =&gt; Option[T])Option[T]">flatMap</span><span class="delimiter">(</span><a href="#sbt;Settings0.getDirect.$anonfun.x$1" title="sbt.AttributeMap">_</a> <a href="Attributes.scala.html#sbt;AttributeMap.get" title="(k: sbt.AttributeKey[T])Option[T]">get</a> <a href="#sbt;Settings0.getDirect.key" title="sbt.AttributeKey[T]">key</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](scope: Scope, key: sbt.AttributeKey[T], value: T)sbt.Settings[Scope]" id="sbt;Settings0.set">set</a><span class="delimiter">[</span><a title="" id="sbt;Settings0.set;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Scope" id="sbt;Settings0.set.scope">scope</a>: <a href="#sbt;Settings0;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Settings0.set.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T" id="sbt;Settings0.set.value">value</a>: <a href="#sbt;Settings0.set;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.AttributeMap" id="sbt;Settings0.set.map">map</a> = <a href="#sbt;Settings0.data" title="=&gt; Map[Scope,sbt.AttributeMap]">data</a> <span title="(key: Scope, default: =&gt; sbt.AttributeMap)sbt.AttributeMap">getOrElse</span> <span class="delimiter">(</span><a href="#sbt;Settings0.set.scope" title="Scope">scope</a>, <a href="Attributes.scala.html#sbt.AttributeMap" title="sbt.AttributeMap.type">AttributeMap</a>.<a href="Attributes.scala.html#sbt.AttributeMap.empty" title="=&gt; sbt.AttributeMap">empty</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Scope,sbt.AttributeMap]" id="sbt;Settings0.set.newData">newData</a> = <a href="#sbt;Settings0.data" title="=&gt; Map[Scope,sbt.AttributeMap]">data</a>.<span title="(key: Scope, value: sbt.AttributeMap)scala.collection.immutable.Map[Scope,sbt.AttributeMap]">updated</span><span class="delimiter">(</span><a href="#sbt;Settings0.set.scope" title="Scope">scope</a>, <a href="#sbt;Settings0.set.map" title="sbt.AttributeMap">map</a>.<a href="Attributes.scala.html#sbt;AttributeMap.put" title="(k: sbt.AttributeKey[T], value: T)sbt.AttributeMap">put</a><span class="delimiter">(</span><a href="#sbt;Settings0.set.key" title="sbt.AttributeKey[T]">key</a>, <a href="#sbt;Settings0.set.value" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="sbt.Settings0[Scope]" class="keyword">new</span> <a href="#sbt;Settings0" title="sbt.Settings0[Scope]">Settings0</a><span class="delimiter">(</span><a href="#sbt;Settings0.set.newData" title="scala.collection.immutable.Map[Scope,sbt.AttributeMap]">newData</a>, <a href="#sbt;Settings0.delegates" title="=&gt; Scope =&gt; Seq[Scope]">delegates</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span class="comment">// delegates should contain the input Scope as the first entry</span>
<span class="comment">// this trait is intended to be mixed into an object</span>
<span class="keyword">trait</span> <a title="trait Init[Scope] extends AnyRef" id="sbt;Init">Init</a><span class="delimiter">[</span><a title="" id="sbt;Init;Scope">Scope</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/** The Show instance used when a detailed String needs to be generated.  It is typically used when no context is available.*/</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.Show[Init.this.ScopedKey[_]]" id="sbt;Init.showFullKey">showFullKey</a>: <a href="Show.scala.html#sbt;Show" title="sbt.Show[Init.this.ScopedKey[_]]">Show</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">final</span> <span class="keyword">case class</span> <a href="#sbt;Init;ScopedKey.productElement.x$1" title="class ScopedKey[T] extends AnyRef with Init.this.KeyedInitialize[T] with Product with Serializable" id="sbt;Init.ScopedKey.readResolve">ScopedKey</a><span class="delimiter">[</span><a title="" id="sbt;Init;ScopedKey;T">T</a><span class="delimiter">]</span><a href="#sbt;Init.ScopedKey.readResolve" title="Product" class="delimiter">(</a><a title="Scope" id="sbt;Init;ScopedKey.scope">scope</a>: <a href="#sbt;Init;Scope" title="Scope">Scope</a>, <a title="sbt.AttributeKey[T]" id="sbt;Init;ScopedKey.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[T]">AttributeKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;KeyedInitialize" title="Init.this.KeyedInitialize[T]">KeyedInitialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Init.this.ScopedKey[T]" id="sbt;Init;ScopedKey.scopedKey">scopedKey</a> = <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]" class="keyword">this</a>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[T]Seq[Init.this.Setting[T]]" id="sbt;Init;SettingSeq">SettingSeq</a><span class="delimiter">[</span><a title="" id="sbt;Init;SettingSeq;T">T</a><span class="delimiter">]</span> = <span title="Seq[Init.this.Setting[T]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]" id="sbt;Init;ScopedMap">ScopedMap</a> = <a href="PMap.scala.html#sbt;IMap" title="sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]">IMap</a><span class="delimiter">[</span>ScopedKey, SettingSeq<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="Map[Init.this.ScopedKey[_],Init.this.Compiled[_]]" id="sbt;Init;CompiledMap">CompiledMap</a> = <span title="Map[Init.this.ScopedKey[_],Init.this.Compiled[_]]">Map</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span>, Compiled<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="sbt.~&gt;[Init.this.ScopedKey,Init.this.ScopedKey]" id="sbt;Init;MapScoped">MapScoped</a> = ScopedKey <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ScopedKey,Init.this.ScopedKey]">~&gt;</a> ScopedKey
  <span class="keyword">type</span> <a title="[T]Either[Init.this.Undefined,Init.this.ScopedKey[T]]" id="sbt;Init;ValidatedRef">ValidatedRef</a><span class="delimiter">[</span><a title="" id="sbt;Init;ValidatedRef;T">T</a><span class="delimiter">]</span> = <span title="Either[Init.this.Undefined,Init.this.ScopedKey[T]]">Either</span><span class="delimiter">[</span>Undefined, ScopedKey<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[T]Either[Seq[Init.this.Undefined],Init.this.Initialize[T]]" id="sbt;Init;ValidatedInit">ValidatedInit</a><span class="delimiter">[</span><a title="" id="sbt;Init;ValidatedInit;T">T</a><span class="delimiter">]</span> = <span title="Either[Seq[Init.this.Undefined],Init.this.Initialize[T]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Undefined<span class="delimiter">]</span>, Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="sbt.~&gt;[Init.this.ScopedKey,Init.this.ValidatedRef]" id="sbt;Init;ValidateRef">ValidateRef</a> = ScopedKey <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ScopedKey,Init.this.ValidatedRef]">~&gt;</a> ValidatedRef
  <span class="keyword">type</span> <a title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]" id="sbt;Init;ScopeLocal">ScopeLocal</a> = ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; Seq<span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="sbt.~&gt;[Init.this.ScopedKey,Option]" id="sbt;Init;MapConstant">MapConstant</a> = ScopedKey <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ScopedKey,Option]">~&gt;</a> Option

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ValidateKeyRef extends AnyRef" id="sbt;Init;ValidateKeyRef">ValidateKeyRef</a> <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], selfRefOk: Boolean)Init.this.ValidatedRef[T]" id="sbt;Init;ValidateKeyRef.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;ValidateKeyRef.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init;ValidateKeyRef.apply.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init;ValidateKeyRef.apply.selfRefOk">selfRefOk</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Init.this.ValidatedRef[T]">ValidatedRef</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The result of this initialization is the composition of applied transformations.
   * This can be useful when dealing with dynamic Initialize values.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Init.this.Initialize[sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]]" id="sbt;Init.capturedTransformations">capturedTransformations</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]]">Initialize</a><span class="delimiter">[</span>Initialize ~&gt; Initialize<span class="delimiter">]</span> = <span title="Init.this.TransformCapture" class="keyword">new</span> <a href="#sbt;Init;TransformCapture" title="Init.this.TransformCapture">TransformCapture</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;TypeFunctions.idK" title="[M[_]]=&gt; sbt.~&gt;[M,M]">idK</a><span title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" class="delimiter">[</span><a href="#sbt;Init;Initialize" title="Init.this.Initialize">Initialize</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]" id="sbt;Init.setting">setting</a><span class="delimiter">[</span><a title="" id="sbt;Init.setting$default$3;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.setting.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Init.this.Initialize[T]" id="sbt;Init.setting.init">init</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.SourcePosition" id="sbt;Init.setting$default$3">pos</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a> = <a href="Positions.scala.html#sbt.NoPosition" title="sbt.NoPosition.type">NoPosition</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Setting[T]" class="keyword">new</span> <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.setting.key" title="Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init.setting.init" title="Init.this.Initialize[T]">init</a>, <a href="#sbt;Init.setting$default$3" title="sbt.SourcePosition">pos</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](value: T)Init.this.Initialize[T]" id="sbt;Init.valueStrict">valueStrict</a><span class="delimiter">[</span><a title="" id="sbt;Init.valueStrict;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt;Init.valueStrict.value">value</a>: <a href="#sbt;Init.valueStrict;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.pure" title="(value: () =&gt; T)Init.this.Initialize[T]">pure</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#sbt;Init.valueStrict.value" title="T">value</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](value: =&gt; T)Init.this.Initialize[T]" id="sbt;Init.value">value</a><span class="delimiter">[</span><a title="" id="sbt;Init.value;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="sbt;Init.value.value">value</a>: =&gt; T<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.pure" title="(value: () =&gt; T)Init.this.Initialize[T]">pure</a><span class="delimiter">(</span><a href="#sbt;Init.value.value" title="=&gt; T">value</a> _<span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](value: () =&gt; T)Init.this.Initialize[T]" id="sbt;Init.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt;Init.pure;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; T" id="sbt;Init.pure.value">value</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Value[T]" class="keyword">new</span> <a href="#sbt;Init;Value" title="Init.this.Value[T]">Value</a><span class="delimiter">(</span><a href="#sbt;Init.pure.value" title="() =&gt; T">value</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T, U](i: Init.this.Initialize[T])(f: Option[T] =&gt; U)Init.this.Initialize[U]" id="sbt;Init.optional">optional</a><span class="delimiter">[</span><a title="" id="sbt;Init.optional;T">T</a>, <a title="" id="sbt;Init.optional;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init.optional.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Option[T] =&gt; U" id="sbt;Init.optional.f">f</a>: Option<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; U<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[U]">Initialize</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span title="Init.this.Optional[T,U]" class="keyword">new</span> <a href="#sbt;Init;Optional" title="Init.this.Optional[T,U]">Optional</a><span class="delimiter">(</span><span title="(x: Init.this.Initialize[T])Some[Init.this.Initialize[T]]">Some</span><span class="delimiter">(</span><a href="#sbt;Init.optional.i" title="Init.this.Initialize[T]">i</a><span class="delimiter">)</span>, <a href="#sbt;Init.optional.f" title="Option[T] =&gt; U">f</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T])(f: T =&gt; T)Init.this.Setting[T]" id="sbt;Init.update">update</a><span class="delimiter">[</span><a title="" id="sbt;Init.update;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.update.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="T =&gt; T" id="sbt;Init.update.f">f</a>: T =&gt; T<span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.setting" title="[T](key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">setting</a><span title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]" class="delimiter">[</span><a href="#sbt;Init.update;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.update.key" title="Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init.map" title="(in: Init.this.Initialize[T])(f: T =&gt; T)Init.this.Initialize[T]">map</a><span class="delimiter">(</span><a href="#sbt;Init.update.key" title="Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.update.f" title="T =&gt; T">f</a><span class="delimiter">)</span>, <a href="Positions.scala.html#sbt.NoPosition" title="sbt.NoPosition.type">NoPosition</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[S, T](in: Init.this.Initialize[S])(f: S =&gt; Init.this.Initialize[T])Init.this.Initialize[T]" id="sbt;Init.bind">bind</a><span class="delimiter">[</span><a title="" id="sbt;Init.bind;S">S</a>, <a title="" id="sbt;Init.bind;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init.bind.in">in</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="S =&gt; Init.this.Initialize[T]" id="sbt;Init.bind.f">f</a>: S =&gt; Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Bind[S,T]" class="keyword">new</span> <a href="#sbt;Init;Bind" title="Init.this.Bind[S,T]">Bind</a><span class="delimiter">(</span><a href="#sbt;Init.bind.f" title="S =&gt; Init.this.Initialize[T]">f</a>, <a href="#sbt;Init.bind.in" title="Init.this.Initialize[S]">in</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[S, T](in: Init.this.Initialize[S])(f: S =&gt; T)Init.this.Initialize[T]" id="sbt;Init.map">map</a><span class="delimiter">[</span><a title="" id="sbt;Init.map;S">S</a>, <a title="" id="sbt;Init.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init.map.in">in</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="S =&gt; T" id="sbt;Init.map.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Apply[[L[x]]L[S],T]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[[L[x]]L[S],T]">Apply</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = L<span class="delimiter">[</span>S<span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l, T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.map.f" title="S =&gt; T">f</a>, <a href="#sbt;Init.map.in" title="Init.this.Initialize[S]">in</a>, <a href="AList.scala.html#sbt.AList" title="sbt.AList.type">AList</a>.<a href="AList.scala.html#sbt.AList.single" title="[A]=&gt; sbt.AList.Single[A]">single</a><span title="sbt.AList.Single[S]" class="delimiter">[</span><a href="#sbt;Init.map;S" title="S">S</a><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[K[L[x]], T](inputs: K[Init.this.Initialize])(f: K[sbt.Types.Id] =&gt; T)(implicit alist: sbt.AList[K])Init.this.Initialize[T]" id="sbt;Init.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt;Init.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt;Init.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt;Init.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt;Init.app;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[Init.this.Initialize]" id="sbt;Init.app.inputs">inputs</a>: <a href="#sbt;Init.app;K" title="K[Init.this.Initialize]">K</a><span class="delimiter">[</span>Initialize<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="K[sbt.Types.Id] =&gt; T" id="sbt;Init.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; T<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt;Init.app.alist">alist</a>: <a href="AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Apply[K,T]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[K,T]">Apply</a><span class="delimiter">[</span>K, T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.app.f" title="K[sbt.Types.Id] =&gt; T">f</a>, <a href="#sbt;Init.app.inputs" title="K[Init.this.Initialize]">inputs</a>, <a href="#sbt;Init.app.alist" title="sbt.AList[K]">alist</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[S, T](inputs: Seq[Init.this.Initialize[S]])(f: Seq[S] =&gt; T)Init.this.Initialize[T]" id="sbt;Init.uniform">uniform</a><span class="delimiter">[</span><a title="" id="sbt;Init.uniform;S">S</a>, <a title="" id="sbt;Init.uniform;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Init.this.Initialize[S]]" id="sbt;Init.uniform.inputs">inputs</a>: <span title="Seq[Init.this.Initialize[S]]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Seq[S] =&gt; T" id="sbt;Init.uniform.f">f</a>: Seq<span class="delimiter">[</span>S<span class="delimiter">]</span> =&gt; T<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span title="Init.this.Apply[[L[x]]List[L[S]],T]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[[L[x]]List[L[S]],T]">Apply</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = List<span class="delimiter">[</span>L<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l, T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.uniform.f" title="Seq[S] =&gt; T">f</a>, <a href="#sbt;Init.uniform.inputs" title="Seq[Init.this.Initialize[S]]">inputs</a>.<span title="=&gt; List[Init.this.Initialize[S]]">toList</span>, <a href="AList.scala.html#sbt.AList" title="sbt.AList.type">AList</a>.<a href="AList.scala.html#sbt.AList.seq" title="[T]=&gt; sbt.AList.SeqList[T]">seq</a><span title="sbt.AList.SeqList[S]" class="delimiter">[</span><a href="#sbt;Init.uniform;S" title="S">S</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The result of this initialization is the validated `key`.
   * No dependency is introduced on `key`.  If `selfRefOk` is true, validation will not fail if the key is referenced by a definition of `key`.
   * That is, key := f(validated(key).value) is allowed only if `selfRefOk == true`.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], selfRefOk: Boolean)Init.this.ValidationCapture[T]" id="sbt;Init.validated">validated</a><span class="delimiter">[</span><a title="" id="sbt;Init.validated;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.validated.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.validated.selfRefOk">selfRefOk</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]">ValidationCapture</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.ValidationCapture[T]" class="keyword">new</span> <a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]">ValidationCapture</a><span class="delimiter">(</span><a href="#sbt;Init.validated.key" title="Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init.validated.selfRefOk" title="Boolean">selfRefOk</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use the version with default arguments and default parameter.&quot;</span>, <span class="string">&quot;0.13.7&quot;</span><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](s: Init.this.Setting[T], allowDynamic: Boolean, filter: Scope =&gt; Boolean, trigger: sbt.AttributeKey[_] =&gt; Boolean)Init.this.Setting[T]" id="sbt;Init.derive(bd16471fec)">derive</a><span class="delimiter">[</span><a title="" id="sbt;Init.derive(bd16471fec);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Setting[T]" id="sbt;Init.derive(bd16471fec).s">s</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.derive(bd16471fec).allowDynamic">allowDynamic</a>: <span title="Boolean">Boolean</span>, <a title="Scope =&gt; Boolean" id="sbt;Init.derive(bd16471fec).filter">filter</a>: Scope =&gt; Boolean, <a title="sbt.AttributeKey[_] =&gt; Boolean" id="sbt;Init.derive(bd16471fec).trigger">trigger</a>: AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; Boolean<span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt;Init.derive(16b0a737d1)" title="(s: Init.this.Setting[T], allowDynamic: Boolean, filter: Scope =&gt; Boolean, trigger: sbt.AttributeKey[_] =&gt; Boolean, default: Boolean)Init.this.Setting[T]">derive</a><span class="delimiter">(</span><a href="#sbt;Init.derive(bd16471fec).s" title="Init.this.Setting[T]">s</a>, <a href="#sbt;Init.derive(bd16471fec).allowDynamic" title="Boolean">allowDynamic</a>, <a href="#sbt;Init.derive(bd16471fec).filter" title="Scope =&gt; Boolean">filter</a>, <a href="#sbt;Init.derive(bd16471fec).trigger" title="sbt.AttributeKey[_] =&gt; Boolean">trigger</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="comment">/**
   * Constructs a derived setting that will be automatically defined in every scope where one of its dependencies
   * is explicitly defined and the where the scope matches `filter`.
   * A setting initialized with dynamic dependencies is only allowed if `allowDynamic` is true.
   * Only the static dependencies are tracked, however.  Dependencies on previous values do not introduce a derived setting either.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](s: Init.this.Setting[T], allowDynamic: Boolean, filter: Scope =&gt; Boolean, trigger: sbt.AttributeKey[_] =&gt; Boolean, default: Boolean)Init.this.Setting[T]" id="sbt;Init.derive(16b0a737d1)">derive</a><span class="delimiter">[</span><a title="" id="sbt;Init.derive$default$5;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Setting[T]" id="sbt;Init.derive(16b0a737d1).s">s</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.derive$default$2">allowDynamic</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>, <a title="Scope =&gt; Boolean" id="sbt;Init.derive$default$3">filter</a>: Scope =&gt; Boolean = <a href="TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: Boolean)Scope =&gt; Boolean">const</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>, <a title="sbt.AttributeKey[_] =&gt; Boolean" id="sbt;Init.derive$default$4">trigger</a>: AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; Boolean = <a href="TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: Boolean)sbt.AttributeKey[_] =&gt; Boolean">const</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>, <a title="Boolean" id="sbt;Init.derive$default$5">default</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#sbt;Init.deriveAllowed" title="(s: Init.this.Setting[T], allowDynamic: Boolean)Option[String]">deriveAllowed</a><span class="delimiter">(</span><a href="#sbt;Init.derive(16b0a737d1).s" title="Init.this.Setting[T]">s</a>, <a href="#sbt;Init.derive$default$2" title="Boolean">allowDynamic</a><span class="delimiter">)</span> <span title="(f: String =&gt; Nothing)Unit">foreach</span> sys.<a href="#sbt;Init.derive(16b0a737d1).$anonfun.message" title="(message: String)Nothing">error</a>
    <span class="keyword">val</span> <a title="Init.this.DerivedSetting[T]" id="sbt;Init.derive(16b0a737d1).d">d</a> = <span title="Init.this.DerivedSetting[T]" class="keyword">new</span> <a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[T]">DerivedSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.derive(16b0a737d1).s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init.derive(16b0a737d1).s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>, <a href="#sbt;Init.derive(16b0a737d1).s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a>, <a href="#sbt;Init.derive$default$3" title="Scope =&gt; Boolean">filter</a>, <a href="#sbt;Init.derive$default$4" title="sbt.AttributeKey[_] =&gt; Boolean">trigger</a><span class="delimiter">)</span>
    <span title="Init.this.Setting[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.derive$default$5" title="Boolean">default</a><span class="delimiter">)</span> <a href="#sbt;Init.derive(16b0a737d1).d" title="Init.this.DerivedSetting[T]">d</a>.<a href="#sbt;Init;DerivedSetting.default" title="(_id: =&gt; Long)Init.this.DefaultSetting[T]">default</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt;Init.derive(16b0a737d1).d" title="Init.this.DerivedSetting[T]">d</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[T](s: Init.this.Setting[T], allowDynamic: Boolean)Option[String]" id="sbt;Init.deriveAllowed">deriveAllowed</a><span class="delimiter">[</span><a title="" id="sbt;Init.deriveAllowed;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Setting[T]" id="sbt;Init.deriveAllowed.s">s</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.deriveAllowed.allowDynamic">allowDynamic</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#sbt;Init.deriveAllowed.s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a> <span title="Option[String]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> _: <a href="#sbt;Init;Bind" title="Init.this.Bind[_,_]">Bind</a><span class="delimiter">[</span>_, _<span class="delimiter">]</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#sbt;Init.deriveAllowed.allowDynamic" title="Boolean">allowDynamic</a> =&gt; <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><span title="String(&quot;Cannot derive from dynamic dependencies.&quot;)" class="string">&quot;Cannot derive from dynamic dependencies.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">case</span> _                              =&gt; <span title="None.type">None</span>
  <span class="delimiter">}</span>
  <span class="comment">// id is used for equality</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](s: Init.this.Setting[T])Init.this.Setting[T]" id="sbt;Init.defaultSetting">defaultSetting</a><span class="delimiter">[</span><a title="" id="sbt;Init.defaultSetting;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Setting[T]" id="sbt;Init.defaultSetting.s">s</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.defaultSetting.s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.default" title="(id: =&gt; Long)Init.this.DefaultSetting[T]">default</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ss: Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]" id="sbt;Init.defaultSettings">defaultSettings</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.defaultSettings.ss">ss</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.defaultSettings.ss" title="Seq[Init.this.Setting[_]]">ss</a>.<span title="(f: Init.this.Setting[_] =&gt; Init.this.Setting[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Init.this.Setting[_],Seq[Init.this.Setting[_]]]" class="delimiter">(</span><a title="Init.this.Setting[_]" id="sbt;Init.defaultSettings.$anonfun.s">s</a> =&gt; <a href="#sbt;Init.defaultSetting" title="(s: Init.this.Setting[_$13])Init.this.Setting[_$13]">defaultSetting</a><span class="delimiter">(</span><a href="#sbt;Init.defaultSettings.$anonfun.s" title="Init.this.Setting[_]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="java.util.concurrent.atomic.AtomicLong" id="sbt;Init.nextID">nextID</a> = <span title="()java.util.concurrent.atomic.AtomicLong" class="keyword">new</span> java.util.concurrent.atomic.<span title="java.util.concurrent.atomic.AtomicLong">AtomicLong</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="()Long" id="sbt;Init.nextDefaultID">nextDefaultID</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#sbt;Init.nextID" title="java.util.concurrent.atomic.AtomicLong">nextID</a>.<span title="()Long">incrementAndGet</span><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(implicit delegates: Scope =&gt; Seq[Scope])sbt.Settings[Scope]" id="sbt;Init.empty">empty</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.empty.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <span title="sbt.Settings0[Scope]" class="keyword">new</span> <a href="#sbt;Settings0" title="sbt.Settings0[Scope]">Settings0</a><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[Scope,Nothing]">empty</span>, <a href="#sbt;Init.empty.delegates" title="Scope =&gt; Seq[Scope]">delegates</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(s: sbt.Settings[Scope])sbt.~&gt;[Init.this.ScopedKey,sbt.Types.Id]" id="sbt;Init.asTransform">asTransform</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init.asTransform.s">s</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: ScopedKey <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ScopedKey,sbt.Types.Id]">~&gt;</a> Id = <a href="#sbt;Init.asTransform;$anon" title="sbt.~&gt;[Init.this.ScopedKey,sbt.Types.Id]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.ScopedKey,sbt.Types.Id]" id="sbt;Init.asTransform;$anon" class="delimiter">(</a>ScopedKey <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ScopedKey,sbt.Types.Id]">~&gt;</a> Id<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](k: Init.this.ScopedKey[T])T" id="sbt;Init.asTransform;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.asTransform;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.asTransform;$anon.apply.k">k</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init.asTransform;$anon.apply;T" title="T">T</a> = <a href="#sbt;Init.getValue" title="(s: sbt.Settings[Scope], k: Init.this.ScopedKey[T])T">getValue</a><span class="delimiter">(</span><a href="#sbt;Init.asTransform.s" title="sbt.Settings[Scope]">s</a>, <a href="#sbt;Init.asTransform;$anon.apply.k" title="Init.this.ScopedKey[T]">k</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[T](s: sbt.Settings[Scope], k: Init.this.ScopedKey[T])T" id="sbt;Init.getValue">getValue</a><span class="delimiter">[</span><a title="" id="sbt;Init.getValue;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init.getValue.s">s</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[T]" id="sbt;Init.getValue.k">k</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.getValue.s" title="sbt.Settings[Scope]">s</a>.<a href="#sbt;Settings.get" title="(scope: Scope, key: sbt.AttributeKey[T])Option[T]">get</a><span class="delimiter">(</span><a href="#sbt;Init.getValue.k" title="Init.this.ScopedKey[T]">k</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a>, <a href="#sbt;Init.getValue.k" title="Init.this.ScopedKey[T]">k</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[T]">key</a><span class="delimiter">)</span> <span title="(default: =&gt; T)T">getOrElse</span> <span class="delimiter">(</span><span title="Nothing" class="keyword">throw</span> <span title="Init.this.InvalidReference" class="keyword">new</span> <a href="#sbt;Init;InvalidReference" title="Init.this.InvalidReference">InvalidReference</a><span class="delimiter">(</span><a href="#sbt;Init.getValue.k" title="Init.this.ScopedKey[T]">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](s: sbt.Settings[Scope])Init.this.ScopedKey[T] =&gt; T" id="sbt;Init.asFunction">asFunction</a><span class="delimiter">[</span><a title="" id="sbt;Init.asFunction;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init.asFunction.s">s</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: ScopedKey<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; T = <a title="Init.this.ScopedKey[T]" id="sbt;Init.asFunction.$anonfun.k">k</a> =&gt; <a href="#sbt;Init.getValue" title="(s: sbt.Settings[Scope], k: Init.this.ScopedKey[T])T">getValue</a><span class="delimiter">(</span><a href="#sbt;Init.asFunction.s" title="sbt.Settings[Scope]">s</a>, <a href="#sbt;Init.asFunction.$anonfun.k" title="Init.this.ScopedKey[T]">k</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(f: Scope =&gt; Scope)Init.this.MapScoped" id="sbt;Init.mapScope">mapScope</a><span class="delimiter">(</span><a title="Scope =&gt; Scope" id="sbt;Init.mapScope.f">f</a>: Scope =&gt; Scope<span class="delimiter">)</span>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a> = <a href="#sbt;Init.mapScope;$anon" title="Init.this.MapScoped" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Init.this.MapScoped" id="sbt;Init.mapScope;$anon">MapScoped</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](k: Init.this.ScopedKey[T])Init.this.ScopedKey[T]" id="sbt;Init.mapScope;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.mapScope;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.mapScope;$anon.apply.k">k</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.mapScope;$anon.apply.k" title="Init.this.ScopedKey[T]">k</a>.<a href="#sbt;Init.ScopedKey.readResolve" title="(scope: Scope, key: sbt.AttributeKey[T])Init.this.ScopedKey[T]">copy</a><span class="delimiter">(</span>scope = <a href="#sbt;Init.mapScope.f" title="(v1: Scope)Scope">f</a><span class="delimiter">(</span><a href="#sbt;Init.mapScope;$anon.apply.k" title="Init.this.ScopedKey[T]">k</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class InvalidReference extends RuntimeException" id="sbt;Init;InvalidReference">InvalidReference</a><a href="#sbt;Init;InvalidReference" title="Init.this.InvalidReference" class="delimiter">(</a><span class="keyword">val</span> <a title="Init.this.ScopedKey[_]" id="sbt;Init;InvalidReference.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="String(&quot;Internal settings error: invalid reference to &quot;)" class="string">&quot;Internal settings error: invalid reference to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="Show.scala.html#sbt;Show.apply" title="(t: Init.this.ScopedKey[_])String">showFullKey</a><span class="delimiter">(</span><a href="#sbt;Init;InvalidReference.key" title="Init.this.ScopedKey[_]">key</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ss: Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]" id="sbt;Init.applyDefaults">applyDefaults</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.applyDefaults.ss">ss</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#sbt;Init.applyDefaults.defaults" title="(Seq[Init.this.DefaultSetting[_]], Seq[Init.this.Setting[_]])" class="delimiter">(</a><a href="#sbt;Init.applyDefaults.x$2" title="Seq[Init.this.DefaultSetting[_]]" id="sbt;Init.applyDefaults.defaults">defaults</a>, <a href="#sbt;Init.applyDefaults.x$2" title="Seq[Init.this.Setting[_]]" id="sbt;Init.applyDefaults.others">others</a><span class="delimiter">)</span> = <a href="Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<a href="Util.scala.html#sbt.Util.separate" title="[T, A, B](ps: Seq[T])(f: T =&gt; Either[A,B])(Seq[A], Seq[B])">separate</a><span title="(ps: Seq[Init.this.Setting[_]])(f: Init.this.Setting[_] =&gt; Either[Init.this.DefaultSetting[_],Init.this.Setting[_]])(Seq[Init.this.DefaultSetting[_]], Seq[Init.this.Setting[_]])" class="delimiter">[</span><a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[_]">DefaultSetting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.applyDefaults.ss" title="Seq[Init.this.Setting[_]]">ss</a><span class="delimiter">)</span> <a href="#sbt;Init.applyDefaults.x$2.$anonfun.x0$2" title="Either[Init.this.DefaultSetting[_],Init.this.Setting[_]]" class="delimiter">{</a> <span class="keyword">case</span> <a title="Init.this.DefaultSetting[_]" id="sbt;Init.applyDefaults.x$2.$anonfun.u">u</a>: <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[_]">DefaultSetting</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span title="(a: Init.this.DefaultSetting[_])scala.util.Left[Init.this.DefaultSetting[_],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;Init.applyDefaults.x$2.$anonfun.u" title="Init.this.DefaultSetting[_]">u</a><span class="delimiter">)</span>; <span class="keyword">case</span> <a title="Init.this.Setting[_$18]" id="sbt;Init.applyDefaults.x$2.$anonfun.s">s</a> =&gt; <span title="(b: Init.this.Setting[_$18])scala.util.Right[Nothing,Init.this.Setting[_$18]]">Right</span><span class="delimiter">(</span><a href="#sbt;Init.applyDefaults.x$2.$anonfun.s" title="Init.this.Setting[_$18]">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="#sbt;Init.applyDefaults.defaults" title="Seq[Init.this.DefaultSetting[_]]">defaults</a>.<span title="=&gt; Seq[Init.this.DefaultSetting[_]]">distinct</span> <span title="(that: scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.DefaultSetting[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">++</span> <a href="#sbt;Init.applyDefaults.others" title="Seq[Init.this.Setting[_]]">others</a>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(init: Seq[Init.this.Setting[_]], actual: Boolean)(implicit delegates: Scope =&gt; Seq[Scope], implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]], implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.CompiledMap" id="sbt;Init.compiled">compiled</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.compiled.init">init</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.compiled$default$2">actual</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.compiled.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]" id="sbt;Init.compiled.scopeLocal">scopeLocal</a>: <span title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">ScopeLocal</span>, <a title="sbt.Show[Init.this.ScopedKey[_]]" id="sbt;Init.compiled.display">display</a>: <a href="Show.scala.html#sbt;Show" title="sbt.Show[Init.this.ScopedKey[_]]">Show</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Init.this.CompiledMap">CompiledMap</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init.compiled.initDefaults">initDefaults</a> = <a href="#sbt;Init.applyDefaults" title="(ss: Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]">applyDefaults</a><span class="delimiter">(</span><a href="#sbt;Init.compiled.init" title="Seq[Init.this.Setting[_]]">init</a><span class="delimiter">)</span>
      <span class="comment">// inject derived settings into scopes where their dependencies are directly defined</span>
      <span class="comment">// and prepend per-scope settings</span>
      <span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init.compiled.derived">derived</a> = <a href="#sbt;Init.deriveAndLocal" title="(init: Seq[Init.this.Setting[_]])(implicit delegates: Scope =&gt; Seq[Scope], implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]">deriveAndLocal</a><a href="#sbt;Init.compiled.delegates" title="Scope =&gt; Seq[Scope]" class="delimiter">(</a><a href="#sbt;Init.compiled.initDefaults" title="Seq[Init.this.Setting[_]]">initDefaults</a><span class="delimiter">)</span>
      <span class="comment">// group by Scope/Key, dropping dead initializations</span>
      <span class="keyword">val</span> <a title="Init.this.ScopedMap" id="sbt;Init.compiled.sMap">sMap</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a> = <a href="#sbt;Init.grouped" title="(init: Seq[Init.this.Setting[_]])Init.this.ScopedMap">grouped</a><span class="delimiter">(</span><a href="#sbt;Init.compiled.derived" title="Seq[Init.this.Setting[_]]">derived</a><span class="delimiter">)</span>
      <span class="comment">// delegate references to undefined values according to 'delegates'</span>
      <span class="keyword">val</span> <a title="Init.this.ScopedMap" id="sbt;Init.compiled.dMap">dMap</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a> = <span title="Init.this.ScopedMap" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.compiled$default$2" title="Boolean">actual</a><span class="delimiter">)</span> <a href="#sbt;Init.delegate" title="(sMap: Init.this.ScopedMap)(implicit delegates: Scope =&gt; Seq[Scope], implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.ScopedMap">delegate</a><span class="delimiter">(</span><a href="#sbt;Init.compiled.sMap" title="Init.this.ScopedMap">sMap</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.compiled.delegates" title="Scope =&gt; Seq[Scope]">delegates</a>, <a href="#sbt;Init.compiled.display" title="sbt.Show[Init.this.ScopedKey[_]]">display</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt;Init.compiled.sMap" title="Init.this.ScopedMap">sMap</a>
      <span class="comment">// merge Seq[Setting[_]] into Compiled</span>
      <a href="#sbt;Init.compile" title="(sMap: Init.this.ScopedMap)Init.this.CompiledMap">compile</a><span class="delimiter">(</span><a href="#sbt;Init.compiled.dMap" title="Init.this.ScopedMap">dMap</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(init: Seq[Init.this.Setting[_]])(implicit delegates: Scope =&gt; Seq[Scope], implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]], implicit display: sbt.Show[Init.this.ScopedKey[_]])sbt.Settings[Scope]" id="sbt;Init.make">make</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.make.init">init</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.make.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]" id="sbt;Init.make.scopeLocal">scopeLocal</a>: <span title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">ScopeLocal</span>, <a title="sbt.Show[Init.this.ScopedKey[_]]" id="sbt;Init.make.display">display</a>: <a href="Show.scala.html#sbt;Show" title="sbt.Show[Init.this.ScopedKey[_]]">Show</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Init.this.CompiledMap" id="sbt;Init.make.cMap">cMap</a> = <a href="#sbt;Init.compiled" title="(init: Seq[Init.this.Setting[_]], actual: Boolean)(implicit delegates: Scope =&gt; Seq[Scope], implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]], implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.CompiledMap">compiled</a><span class="delimiter">(</span><a href="#sbt;Init.make.init" title="Seq[Init.this.Setting[_]]">init</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.make.delegates" title="Scope =&gt; Seq[Scope]">delegates</a>, <a href="#sbt;Init.make.scopeLocal" title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">scopeLocal</a>, <a href="#sbt;Init.make.display" title="sbt.Show[Init.this.ScopedKey[_]]">display</a><span class="delimiter">)</span>
      <span class="comment">// order the initializations.  cyclic references are detected here.</span>
      <span class="keyword">val</span> <a title="Seq[Init.this.Compiled[_]]" id="sbt;Init.make.ordered">ordered</a>: <span title="Seq[Init.this.Compiled[_]]">Seq</span><span class="delimiter">[</span>Compiled<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.sort" title="(cMap: Init.this.CompiledMap)Seq[Init.this.Compiled[_]]">sort</a><span class="delimiter">(</span><a href="#sbt;Init.make.cMap" title="Init.this.CompiledMap">cMap</a><span class="delimiter">)</span>
      <span class="comment">// evaluation: apply the initializations.</span>
      <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt;Init.applyInits" title="(ordered: Seq[Init.this.Compiled[_]])(implicit delegates: Scope =&gt; Seq[Scope])sbt.Settings[Scope]">applyInits</a><a href="#sbt;Init.make.delegates" title="Scope =&gt; Seq[Scope]" class="delimiter">(</a><a href="#sbt;Init.make.ordered" title="Seq[Init.this.Compiled[_]]">ordered</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Init.this.RuntimeUndefined" id="sbt;Init.make.rru">rru</a>: <a href="#sbt;Init;RuntimeUndefined" title="Init.this.RuntimeUndefined">RuntimeUndefined</a> =&gt; <span title="Nothing" class="keyword">throw</span> <a href="#sbt;Init.Uninitialized" title="(validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope], keys: Seq[Init.this.Undefined], runtime: Boolean)(implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.Uninitialized">Uninitialized</a><a href="#sbt;Init.make.display" title="sbt.Show[Init.this.ScopedKey[_]]" class="delimiter">(</a><a href="#sbt;Init.make.cMap" title="Init.this.CompiledMap">cMap</a>.<span title="=&gt; Iterable[Init.this.ScopedKey[_]]">keys</span>.<span title="=&gt; Seq[Init.this.ScopedKey[_]]">toSeq</span>, <a href="#sbt;Init.make.delegates" title="Scope =&gt; Seq[Scope]">delegates</a>, <a href="#sbt;Init.make.rru" title="Init.this.RuntimeUndefined">rru</a>.<a href="#sbt;Init;RuntimeUndefined.undefined" title="=&gt; Seq[Init.this.Undefined]">undefined</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(cMap: Init.this.CompiledMap)Seq[Init.this.Compiled[_]]" id="sbt;Init.sort">sort</a><span class="delimiter">(</span><a title="Init.this.CompiledMap" id="sbt;Init.sort.cMap">cMap</a>: <span title="Init.this.CompiledMap">CompiledMap</span><span class="delimiter">)</span>: <span title="Seq[Init.this.Compiled[_]]">Seq</span><span class="delimiter">[</span>Compiled<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="Dag.scala.html#sbt.Dag" title="sbt.Dag.type">Dag</a>.<a href="Dag.scala.html#sbt.Dag.topologicalSort(99aedd81e8)" title="(nodes: Iterable[Init.this.Compiled[_]])(dependencies: Init.this.Compiled[_] =&gt; Iterable[Init.this.Compiled[_]])List[Init.this.Compiled[_]]">topologicalSort</a><span class="delimiter">(</span><a href="#sbt;Init.sort.cMap" title="Init.this.CompiledMap">cMap</a>.<span title="=&gt; Iterable[Init.this.Compiled[_]]">values</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.sort.$anonfun.x$3" title="Init.this.Compiled[_]">_</a>.<a href="#sbt;Init;Compiled.dependencies" title="=&gt; Iterable[Init.this.ScopedKey[_]]">dependencies</a>.<span title="(f: Init.this.ScopedKey[_] =&gt; Init.this.Compiled[_])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Init.this.ScopedKey[_]],Init.this.Compiled[_],Iterable[Init.this.Compiled[_]]])Iterable[Init.this.Compiled[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Init.this.Compiled[_],Iterable[Init.this.Compiled[_]]]" class="delimiter">(</span><a href="#sbt;Init.sort.cMap" title="Init.this.CompiledMap">cMap</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(sMap: Init.this.ScopedMap)Init.this.CompiledMap" id="sbt;Init.compile">compile</a><span class="delimiter">(</span><a title="Init.this.ScopedMap" id="sbt;Init.compile.sMap">sMap</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a><span class="delimiter">)</span>: <span title="Init.this.CompiledMap">CompiledMap</span> =
    <a href="#sbt;Init.compile.sMap" title="Init.this.ScopedMap">sMap</a>.<a href="PMap.scala.html#sbt;RMap.toTypedSeq" title="=&gt; Seq[sMap.TPair[_]]">toTypedSeq</a>.<span title="(f: sMap.TPair[_] =&gt; (Init.this.ScopedKey[_$3], Init.this.Compiled[_$3]) forSome { type _$3 })(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sMap.TPair[_]],(Init.this.ScopedKey[_$3], Init.this.Compiled[_$3]) forSome { type _$3 },Seq[(Init.this.ScopedKey[_$3], Init.this.Compiled[_$3]) forSome { type _$3 }]])Seq[(Init.this.ScopedKey[_$3], Init.this.Compiled[_$3]) forSome { type _$3 }]">map</span> <a href="#sbt;Init.compile.$anonfun.x0$3" title="(Init.this.ScopedKey[_$3], Init.this.Compiled[_$3])" class="delimiter">{</a>
      <span class="keyword">case</span> sMap.TPair<span class="delimiter">(</span><a title="Init.this.ScopedKey[_$3]" id="sbt;Init.compile.$anonfun.k">k</a>, <a title="Init.this.SettingSeq[_$3]" id="sbt;Init.compile.$anonfun.ss">ss</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Init.this.ScopedKey[_]]" id="sbt;Init.compile.$anonfun.deps">deps</a> = <a href="#sbt;Init.compile.$anonfun.ss" title="Init.this.SettingSeq[_$3]">ss</a> <span title="(f: Init.this.Setting[_$3] =&gt; scala.collection.GenTraversableOnce[Init.this.ScopedKey[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_$3]],Init.this.ScopedKey[_],Seq[Init.this.ScopedKey[_]]])Seq[Init.this.ScopedKey[_]]">flatMap</span> <span class="delimiter">{</span> <a href="#sbt;Init.compile.$anonfun.deps.$anonfun.x$4" title="Init.this.Setting[_$3]">_</a>.<a href="#sbt;Init;Setting.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a> <span class="delimiter">}</span> <span title="scala.collection.immutable.Set[Init.this.ScopedKey[_]]">toSet</span>;
        <span title="(_1: Init.this.ScopedKey[_$3], _2: Init.this.Compiled[_$3])(Init.this.ScopedKey[_$3], Init.this.Compiled[_$3])" class="delimiter">(</span><a href="#sbt;Init.compile.$anonfun.k" title="Init.this.ScopedKey[_$3]">k</a>, <span title="Init.this.Compiled[_$3]" class="keyword">new</span> <a href="#sbt;Init;Compiled" title="Init.this.Compiled[_$3]">Compiled</a><span class="delimiter">(</span><a href="#sbt;Init.compile.$anonfun.k" title="Init.this.ScopedKey[_$3]">k</a>, <a href="#sbt;Init.compile.$anonfun.deps" title="scala.collection.immutable.Set[Init.this.ScopedKey[_]]">deps</a>, <a href="#sbt;Init.compile.$anonfun.ss" title="Init.this.SettingSeq[_$3]">ss</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span title="(implicit ev: &lt;:&lt;[(Init.this.ScopedKey[_$3], Init.this.Compiled[_$3]) forSome { type _$3 },(Init.this.ScopedKey[_], Init.this.Compiled[_])])scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Compiled[_]]">toMap</span>;

  <span class="keyword">def</span> <a title="(init: Seq[Init.this.Setting[_]])Init.this.ScopedMap" id="sbt;Init.grouped">grouped</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.grouped.init">init</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a> =
    <span class="delimiter">(</span><span class="delimiter">(</span><a href="PMap.scala.html#sbt.IMap" title="sbt.IMap.type">IMap</a>.<a href="PMap.scala.html#sbt.IMap.empty" title="sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]">empty</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a><span class="delimiter">)</span> <a href="#sbt;Init.grouped.x$5" title="(z: Init.this.ScopedMap)(op: (Init.this.ScopedMap, Init.this.Setting[_]) =&gt; Init.this.ScopedMap)Init.this.ScopedMap">/:</a> <a href="#sbt;Init.grouped.init" title="Seq[Init.this.Setting[_]]">init</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Init.this.ScopedMap" id="sbt;Init.grouped.$anonfun.m">m</a>, <a title="Init.this.Setting[_]" id="sbt;Init.grouped.$anonfun.s">s</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Init.add" title="(m: Init.this.ScopedMap, s: Init.this.Setting[_$27])Init.this.ScopedMap">add</a><span class="delimiter">(</span><a href="#sbt;Init.grouped.$anonfun.m" title="Init.this.ScopedMap">m</a>, <a href="#sbt;Init.grouped.$anonfun.s" title="Init.this.Setting[_]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](m: Init.this.ScopedMap, s: Init.this.Setting[T])Init.this.ScopedMap" id="sbt;Init.add">add</a><span class="delimiter">[</span><a title="" id="sbt;Init.add;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedMap" id="sbt;Init.add.m">m</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a>, <a title="Init.this.Setting[T]" id="sbt;Init.add.s">s</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a> =
    <a href="#sbt;Init.add.m" title="Init.this.ScopedMap">m</a>.<a href="PMap.scala.html#sbt;IMap.mapValue" title="[T](k: Init.this.ScopedKey[T], init: Init.this.SettingSeq[T], f: Init.this.SettingSeq[T] =&gt; Init.this.SettingSeq[T])sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]">mapValue</a><span title="(k: Init.this.ScopedKey[T], init: Init.this.SettingSeq[T], f: Init.this.SettingSeq[T] =&gt; Init.this.SettingSeq[T])sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]" class="delimiter">[</span><a href="#sbt;Init.add;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.add.s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <span title="scala.collection.immutable.Nil.type">Nil</span>, <a title="Init.this.SettingSeq[T]" id="sbt;Init.add.$anonfun.ss">ss</a> =&gt; <a href="#sbt;Init.append" title="(ss: Seq[Init.this.Setting[T]], s: Init.this.Setting[T])Seq[Init.this.Setting[T]]">append</a><span class="delimiter">(</span><a href="#sbt;Init.add.$anonfun.ss" title="Init.this.SettingSeq[T]">ss</a>, <a href="#sbt;Init.add.s" title="Init.this.Setting[T]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](ss: Seq[Init.this.Setting[T]], s: Init.this.Setting[T])Seq[Init.this.Setting[T]]" id="sbt;Init.append">append</a><span class="delimiter">[</span><a title="" id="sbt;Init.append;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Init.this.Setting[T]]" id="sbt;Init.append.ss">ss</a>: <span title="Seq[Init.this.Setting[T]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Init.this.Setting[T]" id="sbt;Init.append.s">s</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[T]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="Seq[Init.this.Setting[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.append.s" title="Init.this.Setting[T]">s</a>.<a href="#sbt;Init;Setting.definitive" title="=&gt; Boolean">definitive</a><span class="delimiter">)</span> <a href="#sbt;Init.append.s" title="Init.this.Setting[T]">s</a> <a href="#sbt;Init.append.x$6" title="(x: Init.this.Setting[T])List[Init.this.Setting[T]]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span> <span class="keyword">else</span> <a href="#sbt;Init.append.ss" title="Seq[Init.this.Setting[T]]">ss</a> <span title="(elem: Init.this.Setting[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[T]],Init.this.Setting[T],Seq[Init.this.Setting[T]]])Seq[Init.this.Setting[T]]">:+</span> <a href="#sbt;Init.append.s" title="Init.this.Setting[T]">s</a>

  <span class="keyword">def</span> <a title="(init: Seq[Init.this.Setting[_]])(implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]" id="sbt;Init.addLocal">addLocal</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.addLocal.init">init</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]" id="sbt;Init.addLocal.scopeLocal">scopeLocal</a>: <span title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">ScopeLocal</span><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;Init.addLocal.init" title="Seq[Init.this.Setting[_]]">init</a>.<span title="(f: Init.this.Setting[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Init.this.Setting[_],Seq[Init.this.Setting[_]]]" class="delimiter">(</span><a href="#sbt;Init.addLocal.$anonfun.x$7" title="Init.this.Setting[_]">_</a>.<a href="#sbt;Init;Setting.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a> <span title="(f: Init.this.ScopedKey[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.ScopedKey[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">flatMap</span> <a href="#sbt;Init.addLocal.scopeLocal" title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">scopeLocal</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">++</span> <a href="#sbt;Init.addLocal.init" title="Seq[Init.this.Setting[_]]">init</a>

  <span class="keyword">def</span> <a title="(sMap: Init.this.ScopedMap)(implicit delegates: Scope =&gt; Seq[Scope], implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.ScopedMap" id="sbt;Init.delegate">delegate</a><span class="delimiter">(</span><a title="Init.this.ScopedMap" id="sbt;Init.delegate.sMap">sMap</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.delegate.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="sbt.Show[Init.this.ScopedKey[_]]" id="sbt;Init.delegate.display">display</a>: <a href="Show.scala.html#sbt;Show" title="sbt.Show[Init.this.ScopedKey[_]]">Show</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a> =
    <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(ref: Init.this.Setting[_], isFirst: Boolean)Init.this.ValidateKeyRef" id="sbt;Init.delegate.refMap">refMap</a><span class="delimiter">(</span><a title="Init.this.Setting[_]" id="sbt;Init.delegate.refMap.ref">ref</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.delegate.refMap.isFirst">isFirst</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> = <a href="#sbt;Init.delegate.refMap;$anon" title="Init.this.ValidateKeyRef" class="keyword">new</a> <a href="#sbt;Init;ValidateKeyRef" title="anonymous class $anon extends Init.this.ValidateKeyRef" id="sbt;Init.delegate.refMap;$anon">ValidateKeyRef</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[T](k: Init.this.ScopedKey[T], selfRefOk: Boolean)Either[Init.this.Undefined,Init.this.ScopedKey[T]]" id="sbt;Init.delegate.refMap;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.delegate.refMap;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.delegate.refMap;$anon.apply.k">k</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.delegate.refMap;$anon.apply.selfRefOk">selfRefOk</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> =
          <a href="#sbt;Init.delegateForKey" title="(sMap: Init.this.ScopedMap, k: Init.this.ScopedKey[T], scopes: Seq[Scope], ref: Init.this.Setting[_], selfRefOk: Boolean)Either[Init.this.Undefined,Init.this.ScopedKey[T]]">delegateForKey</a><span class="delimiter">(</span><a href="#sbt;Init.delegate.sMap" title="Init.this.ScopedMap">sMap</a>, <a href="#sbt;Init.delegate.refMap;$anon.apply.k" title="Init.this.ScopedKey[T]">k</a>, <a href="#sbt;Init.delegate.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Init.delegate.refMap;$anon.apply.k" title="Init.this.ScopedKey[T]">k</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a><span class="delimiter">)</span>, <a href="#sbt;Init.delegate.refMap.ref" title="Init.this.Setting[_]">ref</a>, <a href="#sbt;Init.delegate.refMap;$anon.apply.selfRefOk" title="Boolean">selfRefOk</a> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#sbt;Init.delegate.refMap.isFirst" title="Boolean">isFirst</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">type</span> <a title="[T]Either[Seq[Init.this.Undefined],Init.this.SettingSeq[T]]" id="sbt;Init.delegate;ValidatedSettings">ValidatedSettings</a><span class="delimiter">[</span><a title="" id="sbt;Init.delegate;ValidatedSettings;T">T</a><span class="delimiter">]</span> = <span title="Either[Seq[Init.this.Undefined],Init.this.SettingSeq[T]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Undefined<span class="delimiter">]</span>, SettingSeq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="f extends AnyRef with sbt.~&gt;[Init.this.SettingSeq,ValidatedSettings]" id="sbt;Init.delegate.f">f</a> = <a href="#sbt;Init.delegate.f;$anon" title="sbt.~&gt;[Init.this.SettingSeq,ValidatedSettings]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.SettingSeq,ValidatedSettings]" id="sbt;Init.delegate.f;$anon" class="delimiter">(</a>SettingSeq <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.SettingSeq,ValidatedSettings]">~&gt;</a> ValidatedSettings<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[T](ks: Seq[Init.this.Setting[T]])ValidatedSettings[T]" id="sbt;Init.delegate.f;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.delegate.f;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Init.this.Setting[T]]" id="sbt;Init.delegate.f;$anon.apply.ks">ks</a>: <span title="Seq[Init.this.Setting[T]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a href="#sbt;Init.delegate.f;$anon.apply.undefs" title="(Seq[Seq[Init.this.Undefined]], Seq[Init.this.Setting[T]])" class="delimiter">(</a><a href="#sbt;Init.delegate.f;$anon.apply.x$8" title="Seq[Seq[Init.this.Undefined]]" id="sbt;Init.delegate.f;$anon.apply.undefs">undefs</a>, <a href="#sbt;Init.delegate.f;$anon.apply.x$8" title="Seq[Init.this.Setting[T]]" id="sbt;Init.delegate.f;$anon.apply.valid">valid</a><span class="delimiter">)</span> = <a href="Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<a href="Util.scala.html#sbt.Util.separate" title="(ps: Seq[(Init.this.Setting[T], Int)])(f: ((Init.this.Setting[T], Int)) =&gt; Either[Seq[Init.this.Undefined],Init.this.Setting[T]])(Seq[Seq[Init.this.Undefined]], Seq[Init.this.Setting[T]])">separate</a><span class="delimiter">(</span><a href="#sbt;Init.delegate.f;$anon.apply.ks" title="Seq[Init.this.Setting[T]]">ks</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[T]],(Init.this.Setting[T], Int),Seq[(Init.this.Setting[T], Int)]])Seq[(Init.this.Setting[T], Int)]">zipWithIndex</span><span class="delimiter">)</span> <a href="#sbt;Init.delegate.f;$anon.apply.x$8.$anonfun.x0$4" title="Either[Seq[Init.this.Undefined],Init.this.Setting[T]]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="Init.this.Setting[T]" id="sbt;Init.delegate.f;$anon.apply.x$8.$anonfun.s">s</a>, <a title="Int" id="sbt;Init.delegate.f;$anon.apply.x$8.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Init.delegate.f;$anon.apply.x$8.$anonfun.s" title="Init.this.Setting[T]">s</a> <a href="#sbt;Init;Setting.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Either[Seq[Init.this.Undefined],Init.this.Setting[T]]">validateKeyReferenced</a> <a href="#sbt;Init.delegate.refMap" title="(ref: Init.this.Setting[_], isFirst: Boolean)Init.this.ValidateKeyRef">refMap</a><span class="delimiter">(</span><a href="#sbt;Init.delegate.f;$anon.apply.x$8.$anonfun.s" title="Init.this.Setting[T]">s</a>, <a href="#sbt;Init.delegate.f;$anon.apply.x$8.$anonfun.i" title="Int">i</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">}</span>
          <span title="ValidatedSettings[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.delegate.f;$anon.apply.undefs" title="Seq[Seq[Init.this.Undefined]]">undefs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(b: Seq[Init.this.Setting[T]])scala.util.Right[Nothing,Seq[Init.this.Setting[T]]]">Right</span><span class="delimiter">(</span><a href="#sbt;Init.delegate.f;$anon.apply.valid" title="Seq[Init.this.Setting[T]]">valid</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="(a: Seq[Init.this.Undefined])scala.util.Left[Seq[Init.this.Undefined],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;Init.delegate.f;$anon.apply.undefs" title="Seq[Seq[Init.this.Undefined]]">undefs</a>.<span title="(implicit asTraversable: Seq[Init.this.Undefined] =&gt; scala.collection.GenTraversableOnce[Init.this.Undefined])Seq[Init.this.Undefined]">flatten</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">type</span> <a title="[_]Seq[Init.this.Undefined]" id="sbt;Init.delegate;Undefs">Undefs</a><span class="delimiter">[</span><a title="" id="sbt;Init.delegate;Undefs;_">_</a><span class="delimiter">]</span> = <span title="Seq[Init.this.Undefined]">Seq</span><span class="delimiter">[</span>Undefined<span class="delimiter">]</span>
      <span class="keyword">val</span> <a href="#sbt;Init.delegate.undefineds" title="(sbt.IMap[Init.this.ScopedKey,Undefs], sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq])" class="delimiter">(</a><a href="#sbt;Init.delegate.x$9" title="sbt.IMap[Init.this.ScopedKey,Undefs]" id="sbt;Init.delegate.undefineds">undefineds</a>, <a href="#sbt;Init.delegate.x$9" title="sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]" id="sbt;Init.delegate.result">result</a><span class="delimiter">)</span> = <a href="#sbt;Init.delegate.sMap" title="Init.this.ScopedMap">sMap</a>.<a href="PMap.scala.html#sbt;IMap.mapSeparate" title="[VL[_], VR[_]](f: sbt.~&gt;[Init.this.SettingSeq,[T]scala.util.Either[VL[T],VR[T]]])(sbt.IMap[Init.this.ScopedKey,VL], sbt.IMap[Init.this.ScopedKey,VR])">mapSeparate</a><span title="(f: sbt.~&gt;[Init.this.SettingSeq,[T]scala.util.Either[Undefs[T],Init.this.SettingSeq[T]]])(sbt.IMap[Init.this.ScopedKey,Undefs], sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq])" class="delimiter">[</span><span title="Undefs">Undefs</span>, <span title="Init.this.SettingSeq">SettingSeq</span><span class="delimiter">]</span><span title="(sbt.IMap[Init.this.ScopedKey,Undefs], sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]) @unchecked" class="delimiter">(</span><a href="#sbt;Init.delegate.f" title="f extends AnyRef with sbt.~&gt;[Init.this.SettingSeq,ValidatedSettings]">f</a><span class="delimiter">)</span>
      <span title="Init.this.ScopedMap" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.delegate.undefineds" title="sbt.IMap[Init.this.ScopedKey,Undefs]">undefineds</a>.<a href="PMap.scala.html#sbt;RMap.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
        <a href="#sbt;Init.delegate.result" title="sbt.IMap[Init.this.ScopedKey,Init.this.SettingSeq]">result</a>
      <span class="keyword">else</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#sbt;Init.Uninitialized" title="(validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope], keys: Seq[Init.this.Undefined], runtime: Boolean)(implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.Uninitialized">Uninitialized</a><a href="#sbt;Init.delegate.display" title="sbt.Show[Init.this.ScopedKey[_]]" class="delimiter">(</a><a href="#sbt;Init.delegate.sMap" title="Init.this.ScopedMap">sMap</a>.<a href="PMap.scala.html#sbt;RMap.keys" title="=&gt; Iterable[Init.this.ScopedKey[_]]">keys</a>.<span title="=&gt; Seq[Init.this.ScopedKey[_]]">toSeq</span>, <a href="#sbt;Init.delegate.delegates" title="Scope =&gt; Seq[Scope]">delegates</a>, <a href="#sbt;Init.delegate.undefineds" title="sbt.IMap[Init.this.ScopedKey,Undefs]">undefineds</a>.<a href="PMap.scala.html#sbt;RMap.values" title="=&gt; Iterable[Undefs[_]]">values</a>.<span title="(implicit asTraversable: Undefs[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Undefined])Iterable[Init.this.Undefined]">flatten</span>.<span title="=&gt; List[Init.this.Undefined]">toList</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](sMap: Init.this.ScopedMap, k: Init.this.ScopedKey[T], scopes: Seq[Scope], ref: Init.this.Setting[_], selfRefOk: Boolean)Either[Init.this.Undefined,Init.this.ScopedKey[T]]" id="sbt;Init.delegateForKey">delegateForKey</a><span class="delimiter">[</span><a title="" id="sbt;Init.delegateForKey;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedMap" id="sbt;Init.delegateForKey.sMap">sMap</a>: <a href="PMap.scala.html#sbt;IMap" title="Init.this.ScopedMap">ScopedMap</a>, <a title="Init.this.ScopedKey[T]" id="sbt;Init.delegateForKey.k">k</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Seq[Scope]" id="sbt;Init.delegateForKey.scopes">scopes</a>: <span title="Seq[Scope]">Seq</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.Setting[_]" id="sbt;Init.delegateForKey.ref">ref</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.delegateForKey.selfRefOk">selfRefOk</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Either[Init.this.Undefined,Init.this.ScopedKey[T]]">Either</span><span class="delimiter">[</span>Undefined, ScopedKey<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Iterator[Init.this.ScopedKey[T]]" id="sbt;Init.delegateForKey.skeys">skeys</a> = <a href="#sbt;Init.delegateForKey.scopes" title="Seq[Scope]">scopes</a>.<span title="=&gt; Iterator[Scope]">iterator</span>.<span title="(f: Scope =&gt; Init.this.ScopedKey[T])Iterator[Init.this.ScopedKey[T]]">map</span><span class="delimiter">(</span><a title="Scope" id="sbt;Init.delegateForKey.skeys.$anonfun.x">x</a> =&gt; <a href="#sbt;Init.ScopedKey.readResolve" title="(scope: Scope, key: sbt.AttributeKey[T])Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">(</span><a href="#sbt;Init.delegateForKey.skeys.$anonfun.x" title="Scope">x</a>, <a href="#sbt;Init.delegateForKey.k" title="Init.this.ScopedKey[T]">k</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[T]">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Option[Init.this.ScopedKey[T]]" id="sbt;Init.delegateForKey.definedAt">definedAt</a> = <a href="#sbt;Init.delegateForKey.skeys" title="Iterator[Init.this.ScopedKey[T]]">skeys</a>.<span title="(p: Init.this.ScopedKey[T] =&gt; Boolean)Option[Init.this.ScopedKey[T]]">find</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.delegateForKey.definedAt.$anonfun.sk">sk</a> =&gt; <span class="delimiter">(</span><a href="#sbt;Init.delegateForKey.selfRefOk" title="Boolean">selfRefOk</a> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt;Init.delegateForKey.ref" title="Init.this.Setting[_]">ref</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$32]">key</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt;Init.delegateForKey.definedAt.$anonfun.sk" title="Init.this.ScopedKey[T]">sk</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt;Init.delegateForKey.sMap" title="Init.this.ScopedMap">sMap</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: Init.this.ScopedKey[T])Boolean">contains</a> <a href="#sbt;Init.delegateForKey.definedAt.$anonfun.sk" title="Init.this.ScopedKey[T]">sk</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt;Init.delegateForKey.definedAt" title="Option[Init.this.ScopedKey[T]]">definedAt</a>.<span title="(left: =&gt; Init.this.Undefined)Product with Serializable with scala.util.Either[Init.this.Undefined,Init.this.ScopedKey[T]]">toRight</span><span class="delimiter">(</span><a href="#sbt;Init.Undefined(9f9849da31)" title="(defining: Init.this.Setting[_], referencedKey: Init.this.ScopedKey[_])Init.this.Undefined">Undefined</a><span class="delimiter">(</span><a href="#sbt;Init.delegateForKey.ref" title="Init.this.Setting[_]">ref</a>, <a href="#sbt;Init.delegateForKey.k" title="Init.this.ScopedKey[T]">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ordered: Seq[Init.this.Compiled[_]])(implicit delegates: Scope =&gt; Seq[Scope])sbt.Settings[Scope]" id="sbt;Init.applyInits">applyInits</a><span class="delimiter">(</span><a title="Seq[Init.this.Compiled[_]]" id="sbt;Init.applyInits.ordered">ordered</a>: <span title="Seq[Init.this.Compiled[_]]">Seq</span><span class="delimiter">[</span>Compiled<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.applyInits.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.util.concurrent.ExecutorService" id="sbt;Init.applyInits.x">x</a> = java.util.concurrent.<span title="java.util.concurrent.Executors.type">Executors</span>.<span title="(x$1: Int)java.util.concurrent.ExecutorService">newFixedThreadPool</span><span class="delimiter">(</span><span title="Runtime.type">Runtime</span>.<span title="()Runtime">getRuntime</span>.<span title="()Int">availableProcessors</span><span class="delimiter">)</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="sbt.EvaluateSettings[Scope]" id="sbt;Init.applyInits.eval">eval</a>: <a href="INode.scala.html#sbt;EvaluateSettings" title="sbt.EvaluateSettings[Scope]">EvaluateSettings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#sbt;Init.applyInits.eval;$anon" title="sbt.EvaluateSettings[Scope]{}" class="keyword">new</a> <a title="anonymous class $anon extends sbt.EvaluateSettings[Scope]" id="sbt;Init.applyInits.eval;$anon">EvaluateSettings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">override</span> <span class="keyword">val</span> <a title="Init.this.type" id="sbt;Init.applyInits.eval;$anon.init">init</a>: Init.<span class="keyword">this</span>.<span class="keyword">type</span> = <a href="#sbt;Init" title="Init.this.type">Init</a>.<span class="keyword">this</span>
          <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.Compiled[_]]" id="sbt;Init.applyInits.eval;$anon.compiledSettings">compiledSettings</a> = <a href="#sbt;Init.applyInits.ordered" title="Seq[Init.this.Compiled[_]]">ordered</a>
          <span class="keyword">def</span> <a title="=&gt; java.util.concurrent.ExecutorService" id="sbt;Init.applyInits.eval;$anon.executor">executor</a> = <a href="#sbt;Init.applyInits.x" title="java.util.concurrent.ExecutorService">x</a>
        <span class="delimiter">}</span>
        <a href="#sbt;Init.applyInits.eval" title="sbt.EvaluateSettings[Scope]">eval</a>.<a href="INode.scala.html#sbt;EvaluateSettings.run" title="(implicit delegates: Scope =&gt; Seq[Scope])sbt.Settings[Scope]">run</a>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#sbt;Init.applyInits.x" title="java.util.concurrent.ExecutorService">x</a>.<span title="()Unit">shutdown</span><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(u: Init.this.Undefined, validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope])(implicit display: sbt.Show[Init.this.ScopedKey[_]])String" id="sbt;Init.showUndefined">showUndefined</a><span class="delimiter">(</span><a title="Init.this.Undefined" id="sbt;Init.showUndefined.u">u</a>: <a href="#sbt;Init;Undefined" title="Init.this.Undefined">Undefined</a>, <a title="Seq[Init.this.ScopedKey[_]]" id="sbt;Init.showUndefined.validKeys">validKeys</a>: <span title="Seq[Init.this.ScopedKey[_]]">Seq</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.showUndefined.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Show[Init.this.ScopedKey[_]]" id="sbt;Init.showUndefined.display">display</a>: <a href="Show.scala.html#sbt;Show" title="sbt.Show[Init.this.ScopedKey[_]]">Show</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Option[Init.this.ScopedKey[_]]" id="sbt;Init.showUndefined.guessed">guessed</a> = <a href="#sbt;Init.guessIntendedScope" title="(validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope], key: Init.this.ScopedKey[_])Option[Init.this.ScopedKey[_]]">guessIntendedScope</a><span class="delimiter">(</span><a href="#sbt;Init.showUndefined.validKeys" title="Seq[Init.this.ScopedKey[_]]">validKeys</a>, <a href="#sbt;Init.showUndefined.delegates" title="Scope =&gt; Seq[Scope]">delegates</a>, <a href="#sbt;Init.showUndefined.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.referencedKey" title="=&gt; Init.this.ScopedKey[_]">referencedKey</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="sbt;Init.showUndefined.derived">derived</a> = <a href="#sbt;Init.showUndefined.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.defining" title="=&gt; Init.this.Setting[_]">defining</a>.<a href="#sbt;Init;Setting.isDerived" title="=&gt; Boolean">isDerived</a>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.showUndefined.refString">refString</a> = <a href="Show.scala.html#sbt;Show.apply" title="(t: Init.this.ScopedKey[_])String">display</a><span class="delimiter">(</span><a href="#sbt;Init.showUndefined.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.defining" title="=&gt; Init.this.Setting[_]">defining</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$42]">key</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.showUndefined.sourceString">sourceString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.showUndefined.derived" title="Boolean">derived</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#sbt;Init.parenPosString" title="(s: Init.this.Setting[_])String">parenPosString</a><span class="delimiter">(</span><a href="#sbt;Init.showUndefined.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.defining" title="=&gt; Init.this.Setting[_]">defining</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.showUndefined.guessedString">guessedString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.showUndefined.derived" title="Boolean">derived</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#sbt;Init.showUndefined.guessed" title="Option[Init.this.ScopedKey[_]]">guessed</a>.<span title="(f: Init.this.ScopedKey[_] =&gt; String)Option[String]">map</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init.showUndefined.guessedString.$anonfun.g">g</a> =&gt; <span title="String(&quot;\n     Did you mean &quot;)" class="string">&quot;\n     Did you mean &quot;</span> <span title="(x$1: Any)String">+</span> <a href="Show.scala.html#sbt;Show.apply" title="(t: Init.this.ScopedKey[_])String">display</a><span class="delimiter">(</span><a href="#sbt;Init.showUndefined.guessedString.$anonfun.g" title="Init.this.ScopedKey[_]">g</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; ?&quot;)" class="string">&quot; ?&quot;</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span>.<span title="=&gt; String">mkString</span>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.showUndefined.derivedString">derivedString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.showUndefined.derived" title="Boolean">derived</a><span class="delimiter">)</span> <span title="String(&quot;, which is a derived setting that needs this key to be defined in this scope.&quot;)" class="string">&quot;, which is a derived setting that needs this key to be defined in this scope.&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <a href="Show.scala.html#sbt;Show.apply" title="(t: Init.this.ScopedKey[_])String">display</a><span class="delimiter">(</span><a href="#sbt;Init.showUndefined.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.referencedKey" title="=&gt; Init.this.ScopedKey[_]">referencedKey</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; from &quot;)" class="string">&quot; from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.showUndefined.refString" title="String">refString</a> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.showUndefined.sourceString" title="String">sourceString</a> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.showUndefined.derivedString" title="String">derivedString</a> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.showUndefined.guessedString" title="String">guessedString</a>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(s: Init.this.Setting[_])String" id="sbt;Init.parenPosString">parenPosString</a><span class="delimiter">(</span><span title="Init.this.Setting[_]">s</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <span title="Init.this.Setting[_]">s</span>.<a href="#sbt;Init;Setting.positionString" title="=&gt; Option[String]">positionString</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>; <span class="keyword">case</span> Some<span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span> =&gt; <span title="String(&quot; (&quot;)" class="string">&quot; (&quot;</span> <span title="(x$1: Any)String">+</span> <span title="String">s</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope], key: Init.this.ScopedKey[_])Option[Init.this.ScopedKey[_]]" id="sbt;Init.guessIntendedScope">guessIntendedScope</a><span class="delimiter">(</span><a title="Seq[Init.this.ScopedKey[_]]" id="sbt;Init.guessIntendedScope.validKeys">validKeys</a>: <span title="Seq[Init.this.ScopedKey[_]]">Seq</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.guessIntendedScope.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init.guessIntendedScope.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Init.this.ScopedKey[_]]">Option</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]" id="sbt;Init.guessIntendedScope.distances">distances</a> = <a href="#sbt;Init.guessIntendedScope.validKeys" title="Seq[Init.this.ScopedKey[_]]">validKeys</a>.<span title="(f: Init.this.ScopedKey[_] =&gt; scala.collection.GenTraversableOnce[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.ScopedKey[_]],(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 },Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]])Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]">flatMap</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 },Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]]" class="delimiter">{</span> <a title="Init.this.ScopedKey[_]" id="sbt;Init.guessIntendedScope.distances.$anonfun.validKey">validKey</a> =&gt; <a href="#sbt;Init.refinedDistance" title="(delegates: Scope =&gt; Seq[Scope], a: Init.this.ScopedKey[_], b: Init.this.ScopedKey[_])Option[Int]">refinedDistance</a><span class="delimiter">(</span><a href="#sbt;Init.guessIntendedScope.delegates" title="Scope =&gt; Seq[Scope]">delegates</a>, <a href="#sbt;Init.guessIntendedScope.distances.$anonfun.validKey" title="Init.this.ScopedKey[_]">validKey</a>, <a href="#sbt;Init.guessIntendedScope.key" title="Init.this.ScopedKey[_]">key</a><span class="delimiter">)</span>.<span title="(f: Int =&gt; (Int, Init.this.ScopedKey[_$37]) forSome { type _$37 })Option[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]">map</span><span title="(xo: Option[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }])Iterable[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]" class="delimiter">(</span><a title="Int" id="sbt;Init.guessIntendedScope.distances.$anonfun.$anonfun.dist">dist</a> =&gt; <span title="(_1: Int, _2: Init.this.ScopedKey[_$37])(Int, Init.this.ScopedKey[_$37])" class="delimiter">(</span><a href="#sbt;Init.guessIntendedScope.distances.$anonfun.$anonfun.dist" title="Int">dist</a>, <a href="#sbt;Init.guessIntendedScope.distances.$anonfun.validKey" title="Init.this.ScopedKey[_]">validKey</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="#sbt;Init.guessIntendedScope.distances" title="Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]">distances</a>.<span title="(f: (Int, Init.this.ScopedKey[_$37]) forSome { type _$37 } =&gt; Int)(implicit ord: scala.math.Ordering[Int])Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }]">sortBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><a href="#sbt;Init.guessIntendedScope.$anonfun.x$10" title="(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }">_</a>.<span title="=&gt; Int">_1</span><span class="delimiter">)</span>.<span title="(f: (Int, Init.this.ScopedKey[_$37]) forSome { type _$37 } =&gt; Init.this.ScopedKey[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }],Init.this.ScopedKey[_],Seq[Init.this.ScopedKey[_]]])Seq[Init.this.ScopedKey[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Init.this.ScopedKey[_],Seq[Init.this.ScopedKey[_]]]" class="delimiter">(</span><a href="#sbt;Init.guessIntendedScope.$anonfun.x$11" title="(Int, Init.this.ScopedKey[_$37]) forSome { type _$37 }">_</a>.<span title="=&gt; Init.this.ScopedKey[_$37]">_2</span><span class="delimiter">)</span>.<span title="=&gt; Option[Init.this.ScopedKey[_]]">headOption</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(delegates: Scope =&gt; Seq[Scope], a: Init.this.ScopedKey[_], b: Init.this.ScopedKey[_])Option[Int]" id="sbt;Init.refinedDistance">refinedDistance</a><span class="delimiter">(</span><a title="Scope =&gt; Seq[Scope]" id="sbt;Init.refinedDistance.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init.refinedDistance.a">a</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init.refinedDistance.b">b</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
    <span title="Option[Int]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.refinedDistance.a" title="Init.this.ScopedKey[_]">a</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$40]">key</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt;Init.refinedDistance.b" title="Init.this.ScopedKey[_]">b</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$41]">key</a> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt;Init.refinedDistance.a" title="Init.this.ScopedKey[_]">a</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;Init.refinedDistance.b" title="Init.this.ScopedKey[_]">b</a><span class="delimiter">)</span> <span title="None.type">None</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt;Init.refinedDistance.dist">dist</a> = <a href="#sbt;Init.refinedDistance.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Init.refinedDistance.a" title="Init.this.ScopedKey[_]">a</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a><span class="delimiter">)</span>.<span title="(elem: Scope)Int">indexOf</span><span class="delimiter">(</span><a href="#sbt;Init.refinedDistance.b" title="Init.this.ScopedKey[_]">b</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a><span class="delimiter">)</span>
      <span title="Option[Int]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.refinedDistance.dist" title="Int">dist</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="None.type">None</span> <span class="keyword">else</span> <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#sbt;Init.refinedDistance.dist" title="Int">dist</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Uninitialized extends Exception" id="sbt;Init;Uninitialized">Uninitialized</a><a href="#sbt;Init;Uninitialized" title="Init.this.Uninitialized" class="delimiter">(</a><span class="keyword">val</span> <a title="Seq[Init.this.Undefined]" id="sbt;Init;Uninitialized.undefined">undefined</a>: <span title="Seq[Init.this.Undefined]">Seq</span><span class="delimiter">[</span>Undefined<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="String" id="sbt;Init;Uninitialized.toString">toString</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Exception">Exception</span><span class="delimiter">(</span><a href="#sbt;Init;Uninitialized.toString" title="String">toString</a><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Undefined extends AnyRef" id="sbt;Init;Undefined">Undefined</a> <a href="#sbt;Init;Undefined" title="Init.this.Undefined" class="keyword">private</a><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="delimiter">(</span><span class="keyword">val</span> <a title="Init.this.Setting[_]" id="sbt;Init;Undefined.defining">defining</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Init.this.ScopedKey[_]" id="sbt;Init;Undefined.referencedKey">referencedKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;For compatibility only, use `defining` directly.&quot;</span>, <span class="string">&quot;0.13.1&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Init.this.ScopedKey[_]" id="sbt;Init;Undefined.definingKey">definingKey</a> = <a href="#sbt;Init;Undefined.defining" title="=&gt; Init.this.Setting[_]">defining</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$42]">key</a>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;For compatibility only, use `defining` directly.&quot;</span>, <span class="string">&quot;0.13.1&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Boolean" id="sbt;Init;Undefined.derived">derived</a>: <span title="Boolean">Boolean</span> = <a href="#sbt;Init;Undefined.defining" title="=&gt; Init.this.Setting[_]">defining</a>.<a href="#sbt;Init;Setting.isDerived" title="=&gt; Boolean">isDerived</a>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use the non-deprecated Undefined factory method.&quot;</span>, <span class="string">&quot;0.13.1&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(definingKey: Init.this.ScopedKey[_], referencedKey: Init.this.ScopedKey[_], derived: Boolean)Init.this.Undefined" id="sbt;Init;Undefined.<init>(8ff10564c0)" class="keyword">this</a><span class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init;Undefined.<init>(8ff10564c0).definingKey">definingKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init;Undefined.<init>(8ff10564c0).referencedKey">referencedKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init;Undefined.<init>(8ff10564c0).derived">derived</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> = <a href="#sbt;Init;Undefined" title="Undefined.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#sbt;Init.fakeUndefinedSetting" title="(definingKey: Init.this.ScopedKey[_$44], d: Boolean)Init.this.Setting[_$44]">fakeUndefinedSetting</a><span class="delimiter">(</span><a href="#sbt;Init;Undefined.<init>(8ff10564c0).definingKey" title="Init.this.ScopedKey[_]">definingKey</a>, <a href="#sbt;Init;Undefined.<init>(8ff10564c0).derived" title="Boolean">derived</a><span class="delimiter">)</span>, <a href="#sbt;Init;Undefined.<init>(8ff10564c0).referencedKey" title="Init.this.ScopedKey[_]">referencedKey</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class RuntimeUndefined extends RuntimeException" id="sbt;Init;RuntimeUndefined">RuntimeUndefined</a><a href="#sbt;Init;RuntimeUndefined" title="Init.this.RuntimeUndefined" class="delimiter">(</a><span class="keyword">val</span> <a title="Seq[Init.this.Undefined]" id="sbt;Init;RuntimeUndefined.undefined">undefined</a>: <span title="Seq[Init.this.Undefined]">Seq</span><span class="delimiter">[</span>Undefined<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="String(&quot;References to undefined settings at runtime.&quot;)" class="string">&quot;References to undefined settings at runtime.&quot;</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;Init;RuntimeUndefined.getMessage">getMessage</a> =
      <a href="#sbt;Init;RuntimeUndefined" title="Init.this.RuntimeUndefined" class="keyword">super</a>.<span title="()String">getMessage</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;RuntimeUndefined.undefined" title="=&gt; Seq[Init.this.Undefined]">undefined</a>.<span title="(f: Init.this.Undefined =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Undefined],String,Seq[String]])Seq[String]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">{</span> <a title="Init.this.Undefined" id="sbt;Init;RuntimeUndefined.getMessage.$anonfun.u">u</a> =&gt;
        <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;RuntimeUndefined.getMessage.$anonfun.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.defining" title="=&gt; Init.this.Setting[_]">defining</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; referenced from &quot;)" class="string">&quot; referenced from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;RuntimeUndefined.getMessage.$anonfun.u" title="Init.this.Undefined">u</a>.<a href="#sbt;Init;Undefined.referencedKey" title="=&gt; Init.this.ScopedKey[_]">referencedKey</a>
      <span class="delimiter">}</span>.<span title="=&gt; String">mkString</span>
  <span class="delimiter">}</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use the other overload.&quot;</span>, <span class="string">&quot;0.13.1&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(definingKey: Init.this.ScopedKey[_], referencedKey: Init.this.ScopedKey[_], derived: Boolean)Init.this.Undefined" id="sbt;Init.Undefined(8ff10564c0)">Undefined</a><span class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init.Undefined(8ff10564c0).definingKey">definingKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init.Undefined(8ff10564c0).referencedKey">referencedKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.Undefined(8ff10564c0).derived">derived</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#sbt;Init;Undefined" title="Init.this.Undefined">Undefined</a> =
    <span title="Init.this.Undefined" class="keyword">new</span> <a href="#sbt;Init;Undefined" title="Init.this.Undefined">Undefined</a><span class="delimiter">(</span><a href="#sbt;Init.fakeUndefinedSetting" title="(definingKey: Init.this.ScopedKey[_$46], d: Boolean)Init.this.Setting[_$46]">fakeUndefinedSetting</a><span class="delimiter">(</span><a href="#sbt;Init.Undefined(8ff10564c0).definingKey" title="Init.this.ScopedKey[_]">definingKey</a>, <a href="#sbt;Init.Undefined(8ff10564c0).derived" title="Boolean">derived</a><span class="delimiter">)</span>, <a href="#sbt;Init.Undefined(8ff10564c0).referencedKey" title="Init.this.ScopedKey[_]">referencedKey</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](definingKey: Init.this.ScopedKey[T], d: Boolean)Init.this.Setting[T]" id="sbt;Init.fakeUndefinedSetting">fakeUndefinedSetting</a><span class="delimiter">[</span><a title="" id="sbt;Init.fakeUndefinedSetting;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.fakeUndefinedSetting.definingKey">definingKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.fakeUndefinedSetting.d">d</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Init.this.Initialize[T]" id="sbt;Init.fakeUndefinedSetting.init">init</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.pure" title="(value: () =&gt; T)Init.this.Initialize[T]">pure</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Dummy setting for compatibility only.&quot;)" class="string">&quot;Dummy setting for compatibility only.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt;Init.fakeUndefinedSetting;$anon" title="Init.this.Setting[T]" class="keyword">new</a> <a title="anonymous class $anon extends Init.this.Setting[T]" id="sbt;Init.fakeUndefinedSetting;$anon">Setting</a><span class="delimiter">(</span><a href="#sbt;Init.fakeUndefinedSetting.definingKey" title="Init.this.ScopedKey[T]">definingKey</a>, <a href="#sbt;Init.fakeUndefinedSetting.init" title="Init.this.Initialize[T]">init</a>, <a href="Positions.scala.html#sbt.NoPosition" title="sbt.NoPosition.type">NoPosition</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Init.fakeUndefinedSetting;$anon.isDerived">isDerived</a> = <a href="#sbt;Init.fakeUndefinedSetting.d" title="Boolean">d</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(defining: Init.this.Setting[_], referencedKey: Init.this.ScopedKey[_])Init.this.Undefined" id="sbt;Init.Undefined(9f9849da31)">Undefined</a><span class="delimiter">(</span><a title="Init.this.Setting[_]" id="sbt;Init.Undefined(9f9849da31).defining">defining</a>: <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init.Undefined(9f9849da31).referencedKey">referencedKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Undefined" title="Init.this.Undefined">Undefined</a> = <span title="Init.this.Undefined" class="keyword">new</span> <a href="#sbt;Init;Undefined" title="Init.this.Undefined">Undefined</a><span class="delimiter">(</span><a href="#sbt;Init.Undefined(9f9849da31).defining" title="Init.this.Setting[_]">defining</a>, <a href="#sbt;Init.Undefined(9f9849da31).referencedKey" title="Init.this.ScopedKey[_]">referencedKey</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope], keys: Seq[Init.this.Undefined], runtime: Boolean)(implicit display: sbt.Show[Init.this.ScopedKey[_]])Init.this.Uninitialized" id="sbt;Init.Uninitialized">Uninitialized</a><span class="delimiter">(</span><a title="Seq[Init.this.ScopedKey[_]]" id="sbt;Init.Uninitialized.validKeys">validKeys</a>: <span title="Seq[Init.this.ScopedKey[_]]">Seq</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.Uninitialized.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Seq[Init.this.Undefined]" id="sbt;Init.Uninitialized.keys">keys</a>: <span title="Seq[Init.this.Undefined]">Seq</span><span class="delimiter">[</span>Undefined<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init.Uninitialized.runtime">runtime</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Show[Init.this.ScopedKey[_]]" id="sbt;Init.Uninitialized.display">display</a>: <a href="Show.scala.html#sbt;Show" title="sbt.Show[Init.this.ScopedKey[_]]">Show</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Uninitialized" title="Init.this.Uninitialized">Uninitialized</a> =
    <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Init.Uninitialized.keys" title="Seq[Init.this.Undefined]">keys</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.Uninitialized.suffix">suffix</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.Uninitialized.keys" title="Seq[Init.this.Undefined]">keys</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;s&quot;)" class="string">&quot;s&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.Uninitialized.prefix">prefix</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.Uninitialized.runtime" title="Boolean">runtime</a><span class="delimiter">)</span> <span title="String(&quot;Runtime reference&quot;)" class="string">&quot;Runtime reference&quot;</span> <span class="keyword">else</span> <span title="String(&quot;Reference&quot;)" class="string">&quot;Reference&quot;</span>
      <span class="keyword">val</span> <a title="String" id="sbt;Init.Uninitialized.keysString">keysString</a> = <a href="#sbt;Init.Uninitialized.keys" title="Seq[Init.this.Undefined]">keys</a>.<span title="(f: Init.this.Undefined =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Undefined],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a title="Init.this.Undefined" id="sbt;Init.Uninitialized.keysString.$anonfun.u">u</a> =&gt; <a href="#sbt;Init.showUndefined" title="(u: Init.this.Undefined, validKeys: Seq[Init.this.ScopedKey[_]], delegates: Scope =&gt; Seq[Scope])(implicit display: sbt.Show[Init.this.ScopedKey[_]])String">showUndefined</a><a href="#sbt;Init.Uninitialized.display" title="sbt.Show[Init.this.ScopedKey[_]]" class="delimiter">(</a><a href="#sbt;Init.Uninitialized.keysString.$anonfun.u" title="Init.this.Undefined">u</a>, <a href="#sbt;Init.Uninitialized.validKeys" title="Seq[Init.this.ScopedKey[_]]">validKeys</a>, <a href="#sbt;Init.Uninitialized.delegates" title="Scope =&gt; Seq[Scope]">delegates</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n\n  &quot;)" class="string">&quot;\n\n  &quot;</span>, <span title="String(&quot;\n\n  &quot;)" class="string">&quot;\n\n  &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
      <span title="Init.this.Uninitialized" class="keyword">new</span> <a href="#sbt;Init;Uninitialized" title="Init.this.Uninitialized">Uninitialized</a><span class="delimiter">(</span><a href="#sbt;Init.Uninitialized.keys" title="Seq[Init.this.Undefined]">keys</a>, <a href="#sbt;Init.Uninitialized.prefix" title="String">prefix</a> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.Uninitialized.suffix" title="String">suffix</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; to undefined setting&quot;)" class="string">&quot; to undefined setting&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.Uninitialized.suffix" title="String">suffix</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init.Uninitialized.keysString" title="String">keysString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n &quot;)" class="string">&quot;\n &quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Compiled[T] extends AnyRef" id="sbt;Init;Compiled">Compiled</a><span class="delimiter">[</span><a title="" id="sbt;Init;Compiled;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;Compiled" title="Init.this.Compiled[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="Init.this.ScopedKey[T]" id="sbt;Init;Compiled.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Iterable[Init.this.ScopedKey[_]]" id="sbt;Init;Compiled.dependencies">dependencies</a>: <span title="Iterable[Init.this.ScopedKey[_]]">Iterable</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Seq[Init.this.Setting[T]]" id="sbt;Init;Compiled.settings">settings</a>: <span title="Seq[Init.this.Setting[T]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;Init;Compiled.toString">toString</a> = <a href="Show.scala.html#sbt;Show.apply" title="(t: Init.this.ScopedKey[_])String">showFullKey</a><span class="delimiter">(</span><a href="#sbt;Init;Compiled.key" title="=&gt; Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Flattened extends AnyRef" id="sbt;Init;Flattened">Flattened</a><a href="#sbt;Init;Flattened" title="Init.this.Flattened" class="delimiter">(</a><span class="keyword">val</span> <a title="Init.this.ScopedKey[_]" id="sbt;Init;Flattened.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Iterable[Init.this.ScopedKey[_]]" id="sbt;Init;Flattened.dependencies">dependencies</a>: <span title="Iterable[Init.this.ScopedKey[_]]">Iterable</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(compiled: Init.this.CompiledMap)Map[Init.this.ScopedKey[_],Init.this.Flattened]" id="sbt;Init.flattenLocals">flattenLocals</a><span class="delimiter">(</span><a title="Init.this.CompiledMap" id="sbt;Init.flattenLocals.compiled">compiled</a>: <span title="Init.this.CompiledMap">CompiledMap</span><span class="delimiter">)</span>: <span title="Map[Init.this.ScopedKey[_],Init.this.Flattened]">Map</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span>, Flattened<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">import</span> collection.breakOut
      <span class="keyword">val</span> <a title="scala.collection.immutable.Iterable[Init.this.Compiled[_]]" id="sbt;Init.flattenLocals.locals">locals</a> = <a href="#sbt;Init.flattenLocals.compiled" title="Init.this.CompiledMap">compiled</a> <span title="(f: ((Init.this.ScopedKey[_], Init.this.Compiled[_])) =&gt; scala.collection.GenTraversableOnce[Init.this.Compiled[_]])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Compiled[_]],Init.this.Compiled[_],scala.collection.immutable.Iterable[Init.this.Compiled[_]]])scala.collection.immutable.Iterable[Init.this.Compiled[_]]">flatMap</span> <a href="#sbt;Init.flattenLocals.locals.$anonfun.x0$5" title="Seq[Init.this.Compiled[_]]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init.flattenLocals.locals.$anonfun.key">key</a>, <a title="Init.this.Compiled[_]" id="sbt;Init.flattenLocals.locals.$anonfun.comp">comp</a><span class="delimiter">)</span> =&gt; <span title="Seq[Init.this.Compiled[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.locals.$anonfun.key" title="Init.this.ScopedKey[_]">key</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_0]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span> <span title="[A](elems: A*)Seq[A]">Seq</span><span title="(elems: Init.this.Compiled[_]*)Seq[Init.this.Compiled[_]]" class="delimiter">[</span><a href="#sbt;Init;Compiled" title="Init.this.Compiled[_]">Compiled</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.locals.$anonfun.comp" title="Init.this.Compiled[_]">comp</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span> <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="List[Init.this.Compiled[_]]" id="sbt;Init.flattenLocals.ordered">ordered</a> = <a href="Dag.scala.html#sbt.Dag" title="sbt.Dag.type">Dag</a>.<a href="Dag.scala.html#sbt.Dag.topologicalSort(99aedd81e8)" title="(nodes: Iterable[Init.this.Compiled[_]])(dependencies: Init.this.Compiled[_] =&gt; Iterable[Init.this.Compiled[_]])List[Init.this.Compiled[_]]">topologicalSort</a><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.locals" title="scala.collection.immutable.Iterable[Init.this.Compiled[_]]">locals</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.ordered.$anonfun.x$12" title="Init.this.Compiled[_]">_</a>.<a href="#sbt;Init;Compiled.dependencies" title="=&gt; Iterable[Init.this.ScopedKey[_]]">dependencies</a>.<span title="(f: Init.this.ScopedKey[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Compiled[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Init.this.ScopedKey[_]],Init.this.Compiled[_],Iterable[Init.this.Compiled[_]]])Iterable[Init.this.Compiled[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Init.this.Compiled[_],Iterable[Init.this.Compiled[_]]]" class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init.flattenLocals.ordered.$anonfun.$anonfun.dep">dep</a> =&gt; <span title="Seq[Init.this.Compiled[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.ordered.$anonfun.$anonfun.dep" title="Init.this.ScopedKey[_]">dep</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$52]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span> <span title="[A](elems: A*)Seq[A]">Seq</span><span title="(elems: Init.this.Compiled[_]*)Seq[Init.this.Compiled[_]]" class="delimiter">[</span><a href="#sbt;Init;Compiled" title="Init.this.Compiled[_]">Compiled</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.compiled" title="(key: Init.this.ScopedKey[_])Init.this.Compiled[_]">compiled</a><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.ordered.$anonfun.$anonfun.dep" title="Init.this.ScopedKey[_]">dep</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(cmap: Map[Init.this.ScopedKey[_],Init.this.Flattened], key: Init.this.ScopedKey[_], deps: Iterable[Init.this.ScopedKey[_]])Init.this.Flattened" id="sbt;Init.flattenLocals.flatten">flatten</a><span class="delimiter">(</span><a title="Map[Init.this.ScopedKey[_],Init.this.Flattened]" id="sbt;Init.flattenLocals.flatten.cmap">cmap</a>: <span title="Map[Init.this.ScopedKey[_],Init.this.Flattened]">Map</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span>, Flattened<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_]" id="sbt;Init.flattenLocals.flatten.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Iterable[Init.this.ScopedKey[_]]" id="sbt;Init.flattenLocals.flatten.deps">deps</a>: <span title="Iterable[Init.this.ScopedKey[_]]">Iterable</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Flattened" title="Init.this.Flattened">Flattened</a> =
        <span title="Init.this.Flattened" class="keyword">new</span> <a href="#sbt;Init;Flattened" title="Init.this.Flattened">Flattened</a><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.flatten.key" title="Init.this.ScopedKey[_]">key</a>, <a href="#sbt;Init.flattenLocals.flatten.deps" title="Iterable[Init.this.ScopedKey[_]]">deps</a>.<span title="(f: Init.this.ScopedKey[_] =&gt; scala.collection.GenTraversableOnce[Init.this.ScopedKey[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Init.this.ScopedKey[_]],Init.this.ScopedKey[_],Iterable[Init.this.ScopedKey[_]]])Iterable[Init.this.ScopedKey[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Init.this.ScopedKey[_],Iterable[Init.this.ScopedKey[_]]]" class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init.flattenLocals.flatten.$anonfun.dep">dep</a> =&gt; <span title="Iterable[Init.this.ScopedKey[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.flatten.$anonfun.dep" title="Init.this.ScopedKey[_]">dep</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$60]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span> <a href="#sbt;Init.flattenLocals.flatten.cmap" title="(key: Init.this.ScopedKey[_])Init.this.Flattened">cmap</a><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.flatten.$anonfun.dep" title="Init.this.ScopedKey[_]">dep</a><span class="delimiter">)</span>.<a href="#sbt;Init;Flattened.dependencies" title="=&gt; Iterable[Init.this.ScopedKey[_]]">dependencies</a> <span class="keyword">else</span> <a href="#sbt;Init.flattenLocals.flatten.$anonfun.dep" title="Init.this.ScopedKey[_]">dep</a> <a href="#sbt;Init.flattenLocals.flatten.$anonfun.x$13" title="(x: Init.this.ScopedKey[_$60])List[Init.this.ScopedKey[_$60]]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]" id="sbt;Init.flattenLocals.empty">empty</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]" class="delimiter">[</span><a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="#sbt;Init;Flattened" title="Init.this.Flattened">Flattened</a><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]" id="sbt;Init.flattenLocals.flattenedLocals">flattenedLocals</a> = <span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.empty" title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]">empty</a> <a href="#sbt;Init.flattenLocals.flattenedLocals.x$14" title="(z: scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened])(op: (scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened], Init.this.Compiled[_]) =&gt; scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened])scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]">/:</a> <a href="#sbt;Init.flattenLocals.ordered" title="List[Init.this.Compiled[_]]">ordered</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]" id="sbt;Init.flattenLocals.flattenedLocals.$anonfun.cmap">cmap</a>, <a title="Init.this.Compiled[_]" id="sbt;Init.flattenLocals.flattenedLocals.$anonfun.c">c</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Init.flattenLocals.flattenedLocals.$anonfun.cmap" title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]">cmap</a>.<span title="(key: Init.this.ScopedKey[_], value: Init.this.Flattened)scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]">updated</span><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.flattenedLocals.$anonfun.c" title="Init.this.Compiled[_]">c</a>.<a href="#sbt;Init;Compiled.key" title="=&gt; Init.this.ScopedKey[_$56]">key</a>, <a href="#sbt;Init.flattenLocals.flatten" title="(cmap: Map[Init.this.ScopedKey[_],Init.this.Flattened], key: Init.this.ScopedKey[_], deps: Iterable[Init.this.ScopedKey[_]])Init.this.Flattened">flatten</a><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.flattenedLocals.$anonfun.cmap" title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]">cmap</a>, <a href="#sbt;Init.flattenLocals.flattenedLocals.$anonfun.c" title="Init.this.Compiled[_]">c</a>.<a href="#sbt;Init;Compiled.key" title="=&gt; Init.this.ScopedKey[_$56]">key</a>, <a href="#sbt;Init.flattenLocals.flattenedLocals.$anonfun.c" title="Init.this.Compiled[_]">c</a>.<a href="#sbt;Init;Compiled.dependencies" title="=&gt; Iterable[Init.this.ScopedKey[_]]">dependencies</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="#sbt;Init.flattenLocals.compiled" title="Init.this.CompiledMap">compiled</a> <span title="(f: ((Init.this.ScopedKey[_], Init.this.Compiled[_])) =&gt; scala.collection.GenTraversableOnce[(Init.this.ScopedKey[_], Init.this.Flattened)])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Compiled[_]],(Init.this.ScopedKey[_], Init.this.Flattened),Map[Init.this.ScopedKey[_],Init.this.Flattened]])Map[Init.this.ScopedKey[_],Init.this.Flattened]">flatMap</span> <a href="#sbt;Init.flattenLocals.$anonfun.x0$6" title="Seq[(Init.this.ScopedKey[_], Init.this.Flattened)]" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a title="Init.this.ScopedKey[_]" id="sbt;Init.flattenLocals.$anonfun.key">key</a>, <a title="Init.this.Compiled[_]" id="sbt;Init.flattenLocals.$anonfun.comp">comp</a><span class="delimiter">)</span> =&gt;
          <span title="Seq[(Init.this.ScopedKey[_], Init.this.Flattened)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.$anonfun.key" title="Init.this.ScopedKey[_]">key</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_0]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.isLocal" title="=&gt; Boolean">isLocal</a><span class="delimiter">)</span>
            <span title="scala.collection.immutable.Nil.type">Nil</span>
          <span class="keyword">else</span>
            <span title="[A](elems: A*)Seq[A]">Seq</span><span title="(elems: (Init.this.ScopedKey[_], Init.this.Flattened)*)Seq[(Init.this.ScopedKey[_], Init.this.Flattened)]" class="delimiter">[</span><span title="(Init.this.ScopedKey[_], Init.this.Flattened)" class="delimiter">(</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span>, Flattened<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: Init.this.ScopedKey[_0], _2: Init.this.Flattened)(Init.this.ScopedKey[_0], Init.this.Flattened)" class="delimiter">(</span><a href="#sbt;Init.flattenLocals.$anonfun.key" title="Init.this.ScopedKey[_]">key</a>, <a href="#sbt;Init.flattenLocals.flatten" title="(cmap: Map[Init.this.ScopedKey[_],Init.this.Flattened], key: Init.this.ScopedKey[_], deps: Iterable[Init.this.ScopedKey[_]])Init.this.Flattened">flatten</a><span class="delimiter">(</span><a href="#sbt;Init.flattenLocals.flattenedLocals" title="scala.collection.immutable.Map[Init.this.ScopedKey[_],Init.this.Flattened]">flattenedLocals</a>, <a href="#sbt;Init.flattenLocals.$anonfun.key" title="Init.this.ScopedKey[_]">key</a>, <a href="#sbt;Init.flattenLocals.$anonfun.comp" title="Init.this.Compiled[_]">comp</a>.<a href="#sbt;Init;Compiled.dependencies" title="=&gt; Iterable[Init.this.ScopedKey[_]]">dependencies</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(settings: Seq[Init.this.Setting[_]])String" id="sbt;Init.definedAtString">definedAtString</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.definedAtString.settings">settings</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Seq[String]" id="sbt;Init.definedAtString.posDefined">posDefined</a> = <a href="#sbt;Init.definedAtString.settings" title="Seq[Init.this.Setting[_]]">settings</a>.<span title="(f: Init.this.Setting[_] =&gt; scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],String,Seq[String]])Seq[String]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#sbt;Init.definedAtString.posDefined.$anonfun.x$15" title="Init.this.Setting[_]">_</a>.<a href="#sbt;Init;Setting.positionString" title="=&gt; Option[String]">positionString</a>.<span title="=&gt; List[String]">toList</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.definedAtString.posDefined" title="Seq[String]">posDefined</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="sbt;Init.definedAtString.header">header</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.definedAtString.posDefined" title="Seq[String]">posDefined</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <a href="#sbt;Init.definedAtString.settings" title="Seq[Init.this.Setting[_]]">settings</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span title="String(&quot;defined at:&quot;)" class="string">&quot;defined at:&quot;</span> <span class="keyword">else</span>
          <span title="String(&quot;some of the defining occurrences:&quot;)" class="string">&quot;some of the defining occurrences:&quot;</span>
        <a href="#sbt;Init.definedAtString.header" title="String">header</a> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#sbt;Init.definedAtString.posDefined" title="Seq[String]">posDefined</a>.<span title="=&gt; Seq[String]">distinct</span> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span>, <span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Intersects two scopes, returning the more specific one if they intersect, or None otherwise.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(s1: Scope, s2: Scope)(implicit delegates: Scope =&gt; Seq[Scope])Option[Scope]" id="sbt;Init.intersect">intersect</a><span class="delimiter">(</span><a title="Scope" id="sbt;Init.intersect.s1">s1</a>: <a href="#sbt;Init;Scope" title="Scope">Scope</a>, <a title="Scope" id="sbt;Init.intersect.s2">s2</a>: <a href="#sbt;Init;Scope" title="Scope">Scope</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.intersect.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[Scope]">Option</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> =
    <span title="Option[Scope]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.intersect.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Init.intersect.s1" title="Scope">s1</a><span class="delimiter">)</span>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt;Init.intersect.s2" title="Scope">s2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Scope)Some[Scope]">Some</span><span class="delimiter">(</span><a href="#sbt;Init.intersect.s1" title="Scope">s1</a><span class="delimiter">)</span> <span class="comment">// s1 is more specific</span>
    <span class="keyword">else</span> <span title="Option[Scope]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.intersect.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Init.intersect.s2" title="Scope">s2</a><span class="delimiter">)</span>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt;Init.intersect.s1" title="Scope">s1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Scope)Some[Scope]">Some</span><span class="delimiter">(</span><a href="#sbt;Init.intersect.s2" title="Scope">s2</a><span class="delimiter">)</span> <span class="comment">// s2 is more specific</span>
    <span class="keyword">else</span> <span title="None.type">None</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(init: Seq[Init.this.Setting[_]])(implicit delegates: Scope =&gt; Seq[Scope], implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal">deriveAndLocal</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.init">init</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Scope =&gt; Seq[Scope]" id="sbt;Init.deriveAndLocal.delegates">delegates</a>: Scope =&gt; Seq<span class="delimiter">[</span>Scope<span class="delimiter">]</span>, <a title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.scopeLocal">scopeLocal</a>: <span title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">ScopeLocal</span><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">import</span> collection.mutable

      <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Derived extends AnyRef" id="sbt;Init.deriveAndLocal;Derived">Derived</a><a href="#sbt;Init.deriveAndLocal;Derived" title="Derived" class="delimiter">(</a><span class="keyword">val</span> <a title="Init.this.DerivedSetting[_]" id="sbt;Init.deriveAndLocal;Derived.setting">setting</a>: <a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[_]">DerivedSetting</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Seq[sbt.AttributeKey[_]]" id="sbt;Init.deriveAndLocal;Derived.dependencies">dependencies</a> = <a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a>.<a href="#sbt;Init;Setting.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a>.<span title="(f: Init.this.ScopedKey[_] =&gt; sbt.AttributeKey[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.ScopedKey[_]],sbt.AttributeKey[_],Seq[sbt.AttributeKey[_]]])Seq[sbt.AttributeKey[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.AttributeKey[_],Seq[sbt.AttributeKey[_]]]" class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal;Derived.dependencies.$anonfun.x$16" title="Init.this.ScopedKey[_]">_</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$88]">key</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="=&gt; Seq[sbt.AttributeKey[_]]" id="sbt;Init.deriveAndLocal;Derived.triggeredBy">triggeredBy</a> = <a href="#sbt;Init.deriveAndLocal;Derived.dependencies" title="=&gt; Seq[sbt.AttributeKey[_]]">dependencies</a>.<span title="(p: sbt.AttributeKey[_] =&gt; Boolean)Seq[sbt.AttributeKey[_]]">filter</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a>.<a href="#sbt;Init;DerivedSetting.trigger" title="=&gt; sbt.AttributeKey[_] =&gt; Boolean">trigger</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Scope]" id="sbt;Init.deriveAndLocal;Derived.inScopes">inScopes</a> = <span title="()scala.collection.mutable.HashSet[Scope]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Scope]">HashSet</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal;Derived.outputs">outputs</a> = <span title="scala.collection.mutable.ListBuffer[Init.this.Setting[_]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.ListBuffer[Init.this.Setting[_]]">ListBuffer</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="delimiter">}</span>
      <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Deriveds extends AnyRef" id="sbt;Init.deriveAndLocal;Deriveds">Deriveds</a><a href="#sbt;Init.deriveAndLocal;Deriveds" title="Deriveds" class="delimiter">(</a><span class="keyword">val</span> <a title="sbt.AttributeKey[_]" id="sbt;Init.deriveAndLocal;Deriveds.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[_]">AttributeKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Derived]" id="sbt;Init.deriveAndLocal;Deriveds.settings">settings</a>: mutable.<span title="scala.collection.mutable.ListBuffer[Derived]">ListBuffer</span><span class="delimiter">[</span>Derived<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="=&gt; scala.collection.mutable.ListBuffer[sbt.AttributeKey[_]]" id="sbt;Init.deriveAndLocal;Deriveds.dependencies">dependencies</a> = <a href="#sbt;Init.deriveAndLocal;Deriveds.settings" title="=&gt; scala.collection.mutable.ListBuffer[Derived]">settings</a>.<span title="(f: Derived =&gt; scala.collection.GenTraversableOnce[sbt.AttributeKey[_]])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer[Derived],sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[sbt.AttributeKey[_]]])scala.collection.mutable.ListBuffer[sbt.AttributeKey[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer.Coll,sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[sbt.AttributeKey[_]]]" class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal;Deriveds.dependencies.$anonfun.x$17" title="Derived">_</a>.<a href="#sbt;Init.deriveAndLocal;Derived.dependencies" title="=&gt; Seq[sbt.AttributeKey[_]]">dependencies</a><span class="delimiter">)</span>
        <span class="comment">// This is mainly for use in the cyclic reference error message</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;Init.deriveAndLocal;Deriveds.toString">toString</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Derived settings for &quot;)">Derived settings for $</span><span class="delimiter">{</span><a href="#sbt;Init.deriveAndLocal;Deriveds.key" title="=&gt; sbt.AttributeKey[_]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.label" title="=&gt; String">label</a><span class="delimiter">}</span><span title="String(&quot;, &quot;)">, $</span><span class="delimiter">{</span><a href="#sbt;Init.definedAtString" title="(settings: Seq[Init.this.Setting[_]])String">definedAtString</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal;Deriveds.settings" title="=&gt; scala.collection.mutable.ListBuffer[Derived]">settings</a>.<span title="(f: Derived =&gt; Init.this.DerivedSetting[_])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer[Derived],Init.this.DerivedSetting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer.Coll,Init.this.DerivedSetting[_],scala.collection.mutable.ListBuffer[Init.this.DerivedSetting[_]]]" class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal;Deriveds.toString.$anonfun.x$18" title="Derived">_</a>.<a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
      <span class="delimiter">}</span>

      <span class="comment">// separate `derived` settings from normal settings (`defs`)</span>
      <span class="keyword">val</span> <a href="#sbt;Init.deriveAndLocal.derived" title="(Seq[Derived], Seq[Init.this.Setting[_]])" class="delimiter">(</a><a href="#sbt;Init.deriveAndLocal.x$19" title="Seq[Derived]" id="sbt;Init.deriveAndLocal.derived">derived</a>, <a href="#sbt;Init.deriveAndLocal.x$19" title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.rawDefs">rawDefs</a><span class="delimiter">)</span> = <a href="Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<a href="Util.scala.html#sbt.Util.separate" title="[T, A, B](ps: Seq[T])(f: T =&gt; Either[A,B])(Seq[A], Seq[B])">separate</a><span title="(ps: Seq[Init.this.Setting[_]])(f: Init.this.Setting[_] =&gt; Either[Derived,Init.this.Setting[_]])(Seq[Derived], Seq[Init.this.Setting[_]])" class="delimiter">[</span><a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="#sbt;Init.deriveAndLocal;Derived" title="Derived">Derived</a>, <a href="#sbt;Init;Setting" title="Init.this.Setting[_]">Setting</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.init" title="Seq[Init.this.Setting[_]]">init</a><span class="delimiter">)</span> <a href="#sbt;Init.deriveAndLocal.x$19.$anonfun.x0$7" title="Either[Derived,Init.this.Setting[_]]" class="delimiter">{</a> <span class="keyword">case</span> <a title="Init.this.DerivedSetting[_]" id="sbt;Init.deriveAndLocal.x$19.$anonfun.d">d</a>: <a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[_]">DerivedSetting</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span title="(a: Derived)scala.util.Left[Derived,Nothing]">Left</span><span class="delimiter">(</span><span title="Derived" class="keyword">new</span> <a href="#sbt;Init.deriveAndLocal;Derived" title="Derived">Derived</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.x$19.$anonfun.d" title="Init.this.DerivedSetting[_]">d</a><span class="delimiter">)</span><span class="delimiter">)</span>; <span class="keyword">case</span> <a title="Init.this.Setting[_$69]" id="sbt;Init.deriveAndLocal.x$19.$anonfun.s">s</a> =&gt; <span title="(b: Init.this.Setting[_$69])scala.util.Right[Nothing,Init.this.Setting[_$69]]">Right</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.x$19.$anonfun.s" title="Init.this.Setting[_$69]">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.defs">defs</a> = <a href="#sbt;Init.addLocal" title="(init: Seq[Init.this.Setting[_]])(implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]">addLocal</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.rawDefs" title="Seq[Init.this.Setting[_]]">rawDefs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.scopeLocal" title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">scopeLocal</a><span class="delimiter">)</span>

      <span class="comment">// group derived settings by the key they define</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],Deriveds]" id="sbt;Init.deriveAndLocal.derivsByDef">derivsByDef</a> = <span title="()scala.collection.mutable.HashMap[sbt.AttributeKey[_],Deriveds]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],Deriveds]">HashMap</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span>, Deriveds<span class="delimiter">]</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span title="Derived">s</span> &lt;- <a href="#sbt;Init.deriveAndLocal.derived" title="(f: Derived =&gt; scala.collection.mutable.ListBuffer[Derived])Unit">derived</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="sbt.AttributeKey[_]" id="sbt;Init.deriveAndLocal.$anonfun.key">key</a> = <span title="Derived">s</span>.<a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$66]">key</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$66]">key</a>
        <a href="#sbt;Init.deriveAndLocal.derivsByDef" title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],Deriveds]">derivsByDef</a>.<span title="(key: sbt.AttributeKey[_], op: =&gt; Deriveds)Deriveds">getOrElseUpdate</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.$anonfun.key" title="sbt.AttributeKey[_]">key</a>, <span title="Deriveds" class="keyword">new</span> <a href="#sbt;Init.deriveAndLocal;Deriveds" title="Deriveds">Deriveds</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.$anonfun.key" title="sbt.AttributeKey[_]">key</a>, <span title="scala.collection.mutable.ListBuffer[Derived]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.ListBuffer[Derived]">ListBuffer</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#sbt;Init.deriveAndLocal;Deriveds.settings" title="=&gt; scala.collection.mutable.ListBuffer[Derived]">settings</a> <span title="(x: Derived)scala.collection.mutable.ListBuffer[Derived]">+=</span> <span title="Derived">s</span>
      <span class="delimiter">}</span>

      <span class="comment">// sort derived settings so that dependencies come first</span>
      <span class="comment">// this is necessary when verifying that a derived setting's dependencies exist</span>
      <span class="keyword">val</span> <a title="Deriveds =&gt; scala.collection.mutable.ListBuffer[Deriveds]" id="sbt;Init.deriveAndLocal.ddeps">ddeps</a> = <span class="delimiter">(</span>d: <a href="#sbt;Init.deriveAndLocal;Deriveds" title="Deriveds">Deriveds</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Init.deriveAndLocal.ddeps.$anonfun.d" title="Deriveds">d</a>.<a href="#sbt;Init.deriveAndLocal;Deriveds.dependencies" title="=&gt; scala.collection.mutable.ListBuffer[sbt.AttributeKey[_]]">dependencies</a>.<span title="(f: sbt.AttributeKey[_] =&gt; scala.collection.GenTraversableOnce[Deriveds])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer[sbt.AttributeKey[_]],Deriveds,scala.collection.mutable.ListBuffer[Deriveds]])scala.collection.mutable.ListBuffer[Deriveds]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.ListBuffer.Coll,Deriveds,scala.collection.mutable.ListBuffer[Deriveds]]" class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.derivsByDef" title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],Deriveds]">derivsByDef</a>.<a href="#sbt;Init.deriveAndLocal.ddeps.$anonfun.$anonfun.key" title="(xo: Option[Deriveds])Iterable[Deriveds]">get</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Deriveds]" id="sbt;Init.deriveAndLocal.sortedDerivs">sortedDerivs</a> = <a href="Dag.scala.html#sbt.Dag" title="sbt.Dag.type">Dag</a>.<a href="Dag.scala.html#sbt.Dag.topologicalSort(99aedd81e8)" title="(nodes: Iterable[Deriveds])(dependencies: Deriveds =&gt; Iterable[Deriveds])List[Deriveds]">topologicalSort</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.derivsByDef" title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],Deriveds]">derivsByDef</a>.<span title="=&gt; Iterable[Deriveds]">values</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.ddeps" title="Deriveds =&gt; scala.collection.mutable.ListBuffer[Deriveds]">ddeps</a><span class="delimiter">)</span>

      <span class="comment">// index derived settings by triggering key.  This maps a key to the list of settings potentially derived from it.</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[Derived]]" id="sbt;Init.deriveAndLocal.derivedBy">derivedBy</a> = <span title="()scala.collection.mutable.HashMap[sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[Derived]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[Derived]]">HashMap</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span>, mutable.ListBuffer<span class="delimiter">[</span>Derived<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span title="Derived">s</span> &lt;- <a href="#sbt;Init.deriveAndLocal.derived" title="(f: Derived =&gt; Unit)Unit">derived</a>; <a title="sbt.AttributeKey[_]" id="sbt;Init.deriveAndLocal.$anonfun.$anonfun.d">d</a> &lt;- <span title="Derived">s</span>.<a href="#sbt;Init.deriveAndLocal;Derived.triggeredBy" title="(f: sbt.AttributeKey[_] =&gt; scala.collection.mutable.ListBuffer[Derived])Unit">triggeredBy</a><span class="delimiter">)</span>
        <a href="#sbt;Init.deriveAndLocal.derivedBy" title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[Derived]]">derivedBy</a>.<span title="(key: sbt.AttributeKey[_], op: =&gt; scala.collection.mutable.ListBuffer[Derived])scala.collection.mutable.ListBuffer[Derived]">getOrElseUpdate</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.$anonfun.$anonfun.d" title="sbt.AttributeKey[_]">d</a>, <span title="scala.collection.mutable.ListBuffer[Derived]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.ListBuffer[Derived]">ListBuffer</span><span class="delimiter">)</span> <span title="(x: Derived)scala.collection.mutable.ListBuffer[Derived]">+=</span> <span title="Derived">s</span>

      <span class="comment">// Map a DerivedSetting[_] to the `Derived` struct wrapping it. Used to ultimately replace a DerivedSetting with</span>
      <span class="comment">// the `Setting`s that were actually derived from it: `Derived.outputs`</span>
      <span class="keyword">val</span> <a title="Map[Init.this.DerivedSetting[_],Derived]" id="sbt;Init.deriveAndLocal.derivedToStruct">derivedToStruct</a>: <span title="Map[Init.this.DerivedSetting[_],Derived]">Map</span><span class="delimiter">[</span>DerivedSetting<span class="delimiter">[</span>_<span class="delimiter">]</span>, Derived<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.derived" title="Seq[Derived]">derived</a> <span title="(f: Derived =&gt; (Init.this.DerivedSetting[_$66], Derived) forSome { type _$66 })(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Derived],(Init.this.DerivedSetting[_$66], Derived) forSome { type _$66 },Seq[(Init.this.DerivedSetting[_$66], Derived) forSome { type _$66 }]])Seq[(Init.this.DerivedSetting[_$66], Derived) forSome { type _$66 }]">map</span> <span class="delimiter">{</span> <a title="Derived" id="sbt;Init.deriveAndLocal.derivedToStruct.$anonfun.s">s</a> =&gt; <a href="#sbt;Init.deriveAndLocal.derivedToStruct.$anonfun.s" title="Derived">s</a>.<a href="#sbt;Init.deriveAndLocal;Derived.setting" title="(x: Init.this.DerivedSetting[_$66])ArrowAssoc[Init.this.DerivedSetting[_$66]]">setting</a> <span title="(y: Derived)(Init.this.DerivedSetting[_$66], Derived)">-&gt;</span> <a href="#sbt;Init.deriveAndLocal.derivedToStruct.$anonfun.s" title="Derived">s</a> <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(Init.this.DerivedSetting[_$66], Derived) forSome { type _$66 },(Init.this.DerivedSetting[_], Derived)])scala.collection.immutable.Map[Init.this.DerivedSetting[_],Derived]">toMap</span>

      <span class="comment">// set of defined scoped keys, used to ensure a derived setting is only added if all dependencies are present</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]" id="sbt;Init.deriveAndLocal.defined">defined</a> = <span title="()scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]">HashSet</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(ss: Seq[Init.this.Setting[_]])Unit" id="sbt;Init.deriveAndLocal.addDefs">addDefs</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.addDefs.ss">ss</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span> <span class="keyword">for</span> <span class="delimiter">(</span><a title="Init.this.Setting[_]" id="sbt;Init.deriveAndLocal.addDefs.$anonfun.s">s</a> &lt;- <a href="#sbt;Init.deriveAndLocal.addDefs.ss" title="(f: Init.this.Setting[_] =&gt; scala.collection.mutable.HashSet[Init.this.ScopedKey[_]])Unit">ss</a><span class="delimiter">)</span> <a href="#sbt;Init.deriveAndLocal.defined" title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]">defined</a> <span title="(elem: Init.this.ScopedKey[_])defined.type">+=</span> <a href="#sbt;Init.deriveAndLocal.addDefs.$anonfun.s" title="Init.this.Setting[_]">s</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$75]">key</a> <span class="delimiter">}</span>
      <a href="#sbt;Init.deriveAndLocal.addDefs" title="(ss: Seq[Init.this.Setting[_]])Unit">addDefs</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.defs" title="Seq[Init.this.Setting[_]]">defs</a><span class="delimiter">)</span>

      <span class="comment">// true iff the scoped key is in `defined`, taking delegation into account</span>
      <span class="keyword">def</span> <a title="(key: sbt.AttributeKey[_], scope: Scope)Boolean" id="sbt;Init.deriveAndLocal.isDefined">isDefined</a><span class="delimiter">(</span><a title="sbt.AttributeKey[_]" id="sbt;Init.deriveAndLocal.isDefined.key">key</a>: <a href="Attributes.scala.html#sbt;AttributeKey" title="sbt.AttributeKey[_]">AttributeKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Scope" id="sbt;Init.deriveAndLocal.isDefined.scope">scope</a>: <a href="#sbt;Init;Scope" title="Scope">Scope</a><span class="delimiter">)</span> =
        <a href="#sbt;Init.deriveAndLocal.delegates" title="(v1: Scope)Seq[Scope]">delegates</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.isDefined.scope" title="Scope">scope</a><span class="delimiter">)</span>.<span title="(p: Scope =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="Scope" id="sbt;Init.deriveAndLocal.isDefined.$anonfun.s">s</a> =&gt; <a href="#sbt;Init.deriveAndLocal.defined" title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]">defined</a>.<span title="(elem: Init.this.ScopedKey[_])Boolean">contains</span><span class="delimiter">(</span><a href="#sbt;Init.ScopedKey.readResolve" title="(scope: Scope, key: sbt.AttributeKey[_$76])Init.this.ScopedKey[_$76]">ScopedKey</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.isDefined.$anonfun.s" title="Scope">s</a>, <a href="#sbt;Init.deriveAndLocal.isDefined.key" title="sbt.AttributeKey[_]">key</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// true iff all dependencies of derived setting `d` have a value (potentially via delegation) in `scope`</span>
      <span class="keyword">def</span> <a title="(d: Derived, scope: Scope, local: Set[sbt.AttributeKey[_]])Boolean" id="sbt;Init.deriveAndLocal.allDepsDefined">allDepsDefined</a><span class="delimiter">(</span><a title="Derived" id="sbt;Init.deriveAndLocal.allDepsDefined.d">d</a>: <a href="#sbt;Init.deriveAndLocal;Derived" title="Derived">Derived</a>, <a title="Scope" id="sbt;Init.deriveAndLocal.allDepsDefined.scope">scope</a>: <a href="#sbt;Init;Scope" title="Scope">Scope</a>, <a title="Set[sbt.AttributeKey[_]]" id="sbt;Init.deriveAndLocal.allDepsDefined.local">local</a>: <span title="Set[sbt.AttributeKey[_]]">Set</span><span class="delimiter">[</span>AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
        <a href="#sbt;Init.deriveAndLocal.allDepsDefined.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.dependencies" title="=&gt; Seq[sbt.AttributeKey[_]]">dependencies</a>.<span title="(p: sbt.AttributeKey[_] =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a title="sbt.AttributeKey[_]" id="sbt;Init.deriveAndLocal.allDepsDefined.$anonfun.dep">dep</a> =&gt; <a href="#sbt;Init.deriveAndLocal.allDepsDefined.local" title="(elem: sbt.AttributeKey[_])Boolean">local</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.allDepsDefined.$anonfun.dep" title="sbt.AttributeKey[_]">dep</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt;Init.deriveAndLocal.isDefined" title="(key: sbt.AttributeKey[_], scope: Scope)Boolean">isDefined</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.allDepsDefined.$anonfun.dep" title="sbt.AttributeKey[_]">dep</a>, <a href="#sbt;Init.deriveAndLocal.allDepsDefined.scope" title="Scope">scope</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// Returns the list of injectable derived settings and their local settings for `sk`.</span>
      <span class="comment">// The settings are to be injected under `outputScope` = whichever scope is more specific of:</span>
      <span class="comment">//   * the dependency's (`sk`) scope</span>
      <span class="comment">//   * the DerivedSetting's scope in which it has been declared, `definingScope`</span>
      <span class="comment">// provided that these two scopes intersect.</span>
      <span class="comment">//  A derived setting is injectable if:</span>
      <span class="comment">//   1. it has not been previously injected into outputScope</span>
      <span class="comment">//   2. it applies to outputScope (as determined by its `filter`)</span>
      <span class="comment">//   3. all of its dependencies are defined for outputScope (allowing for delegation)</span>
      <span class="comment">// This needs to handle local settings because a derived setting wouldn't be injected if it's local setting didn't exist yet.</span>
      <span class="keyword">val</span> <a title="Init.this.ScopedKey[_] =&gt; List[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.deriveFor">deriveFor</a> = <span class="delimiter">(</span>sk: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[Derived]" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.derivedForKey">derivedForKey</a>: <span title="List[Derived]">List</span><span class="delimiter">[</span>Derived<span class="delimiter">]</span> = <a href="#sbt;Init.deriveAndLocal.derivedBy" title="scala.collection.mutable.HashMap[sbt.AttributeKey[_],scala.collection.mutable.ListBuffer[Derived]]">derivedBy</a>.<span title="(key: sbt.AttributeKey[_])Option[scala.collection.mutable.ListBuffer[Derived]]">get</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.sk" title="Init.this.ScopedKey[_]">sk</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$78]">key</a><span class="delimiter">)</span>.<span title="=&gt; List[scala.collection.mutable.ListBuffer[Derived]]">toList</span>.<span title="(implicit asTraversable: scala.collection.mutable.ListBuffer[Derived] =&gt; scala.collection.GenTraversableOnce[Derived])List[Derived]">flatten</span>
        <span class="keyword">val</span> <a title="Scope" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.scope">scope</a> = <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.sk" title="Init.this.ScopedKey[_]">sk</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a>
        <span class="keyword">def</span> <a title="(d: Derived)Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived">localAndDerived</a><span class="delimiter">(</span><a title="Derived" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d">d</a>: <a href="#sbt;Init.deriveAndLocal;Derived" title="Derived">Derived</a><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="=&gt; Scope" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.definingScope">definingScope</a> = <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$66]">key</a>.<a href="#sbt;Init;ScopedKey.scope" title="=&gt; Scope">scope</a>
          <span class="keyword">val</span> <a title="Option[Scope]" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.outputScope">outputScope</a> = <a href="#sbt;Init.intersect" title="(s1: Scope, s2: Scope)(implicit delegates: Scope =&gt; Seq[Scope])Option[Scope]">intersect</a><a href="#sbt;Init.deriveAndLocal.delegates" title="Scope =&gt; Seq[Scope]" class="delimiter">(</a><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.scope" title="Scope">scope</a>, <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.definingScope" title="=&gt; Scope">definingScope</a><span class="delimiter">)</span>
          <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.outputScope" title="Option[Scope]">outputScope</a> <span title="(pf: PartialFunction[Scope,Seq[Init.this.Setting[_]]])Option[Seq[Init.this.Setting[_]]]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Scope,Seq[Init.this.Setting[_]]] with Serializable" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
            <span class="keyword">case</span> <a title="Scope" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s">s</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.inScopes" title="=&gt; scala.collection.mutable.HashSet[Scope]">inScopes</a>.<span title="(elem: Scope)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s" title="Scope">s</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a>.<a href="#sbt;Init;DerivedSetting.filter" title="(v1: Scope)Boolean">filter</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s" title="Scope">s</a><span class="delimiter">)</span> =&gt;
              <span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.local">local</a> = <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.dependencies" title="=&gt; Seq[sbt.AttributeKey[_]]">dependencies</a>.<span title="(f: sbt.AttributeKey[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.AttributeKey[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Init.this.Setting[_],Seq[Init.this.Setting[_]]]" class="delimiter">(</span><a title="sbt.AttributeKey[_]" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.local.$anonfun.dep">dep</a> =&gt; <a href="#sbt;Init.deriveAndLocal.scopeLocal" title="(v1: Init.this.ScopedKey[_])Seq[Init.this.Setting[_]]">scopeLocal</a><span class="delimiter">(</span><a href="#sbt;Init.ScopedKey.readResolve" title="(scope: Scope, key: sbt.AttributeKey[_$88])Init.this.ScopedKey[_$88]">ScopedKey</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s" title="Scope">s</a>, <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.local.$anonfun.dep" title="sbt.AttributeKey[_]">dep</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Seq[Init.this.Setting[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.allDepsDefined" title="(d: Derived, scope: Scope, local: Set[sbt.AttributeKey[_]])Boolean">allDepsDefined</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>, <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s" title="Scope">s</a>, <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.local" title="Seq[Init.this.Setting[_]]">local</a>.<span title="(f: Init.this.Setting[_] =&gt; sbt.AttributeKey[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],sbt.AttributeKey[_],Seq[sbt.AttributeKey[_]]])Seq[sbt.AttributeKey[_]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.AttributeKey[_],Seq[sbt.AttributeKey[_]]]" class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.$anonfun.x$20" title="Init.this.Setting[_]">_</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_$10]">key</a>.<a href="#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[_$10]">key</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.AttributeKey[_]]">toSet</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.inScopes" title="=&gt; scala.collection.mutable.HashSet[Scope]">inScopes</a>.<span title="(elem: Scope)Boolean">add</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s" title="Scope">s</a><span class="delimiter">)</span>
                <span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.out">out</a> = <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.local" title="Seq[Init.this.Setting[_]]">local</a> <span title="(elem: Init.this.Setting[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">:+</span> <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.setting" title="=&gt; Init.this.DerivedSetting[_]">setting</a>.<a href="#sbt;Init;Setting.setScope" title="(s: Scope)Init.this.Setting[_$66]">setScope</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.isDefinedAt.s" title="Scope">s</a><span class="delimiter">)</span>
                <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived.d" title="Derived">d</a>.<a href="#sbt;Init.deriveAndLocal;Derived.outputs" title="=&gt; scala.collection.mutable.ListBuffer[Init.this.Setting[_]]">outputs</a> <span title="(xs: scala.collection.TraversableOnce[Init.this.Setting[_]])d.outputs.type">++=</span> <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.out" title="Seq[Init.this.Setting[_]]">out</a>
                <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived;$anonfun.applyOrElse.out" title="Seq[Init.this.Setting[_]]">out</a>
              <span class="delimiter">}</span> <span class="keyword">else</span>
                <span title="scala.collection.immutable.Nil.type">Nil</span>
          <span class="delimiter">}</span> <span title="(default: =&gt; Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]">getOrElse</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
        <span class="delimiter">}</span>
        <a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.derivedForKey" title="List[Derived]">derivedForKey</a>.<span title="(f: Derived =&gt; scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Derived],Init.this.Setting[_],List[Init.this.Setting[_]]])List[Init.this.Setting[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Init.this.Setting[_],List[Init.this.Setting[_]]]" class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.deriveFor.$anonfun.localAndDerived" title="(d: Derived)Seq[Init.this.Setting[_]]">localAndDerived</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]" id="sbt;Init.deriveAndLocal.processed">processed</a> = <span title="()scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]">HashSet</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

      <span class="comment">// derives settings, transitively so that a derived setting can trigger another</span>
      <span class="keyword">def</span> <a title="(rem: List[Init.this.Setting[_]])Unit" id="sbt;Init.deriveAndLocal.process">process</a><span class="delimiter">(</span><a title="List[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.process.rem">rem</a>: <span title="List[Init.this.Setting[_]]">List</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt;Init.deriveAndLocal.process.rem" title="List[Init.this.Setting[_]]">rem</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="Init.this.Setting[_]" id="sbt;Init.deriveAndLocal.process.s">s</a> :: <a title="List[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.process.ss">ss</a> =&gt;
          <span class="keyword">val</span> <a title="Init.this.ScopedKey[_]" id="sbt;Init.deriveAndLocal.process.sk">sk</a> = <a href="#sbt;Init.deriveAndLocal.process.s" title="Init.this.Setting[_]">s</a>.<a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[_0]">key</a>
          <span class="keyword">val</span> <a title="List[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.process.ds">ds</a> = <span title="List[Init.this.Setting[_]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.processed" title="scala.collection.mutable.HashSet[Init.this.ScopedKey[_]]">processed</a>.<span title="(elem: Init.this.ScopedKey[_])Boolean">add</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.process.sk" title="Init.this.ScopedKey[_]">sk</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt;Init.deriveAndLocal.deriveFor" title="(v1: Init.this.ScopedKey[_])List[Init.this.Setting[_]]">deriveFor</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.process.sk" title="Init.this.ScopedKey[_]">sk</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
          <a href="#sbt;Init.deriveAndLocal.addDefs" title="(ss: Seq[Init.this.Setting[_]])Unit">addDefs</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.process.ds" title="List[Init.this.Setting[_]]">ds</a><span class="delimiter">)</span>
          <a href="#sbt;Init.deriveAndLocal.process" title="(rem: List[Init.this.Setting[_]])Unit">process</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.process.ds" title="List[Init.this.Setting[_]]">ds</a> <a href="#sbt;Init.deriveAndLocal.process.x$21" title="(prefix: List[Init.this.Setting[_]])List[Init.this.Setting[_]]">:::</a> <a href="#sbt;Init.deriveAndLocal.process.ss" title="List[Init.this.Setting[_]]">ss</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt;
      <span class="delimiter">}</span>
      <a href="#sbt;Init.deriveAndLocal.process" title="(rem: List[Init.this.Setting[_]])Unit">process</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.defs" title="Seq[Init.this.Setting[_]]">defs</a>.<span title="=&gt; List[Init.this.Setting[_]]">toList</span><span class="delimiter">)</span>

      <span class="comment">// Take all the original defs and DerivedSettings along with locals, replace each DerivedSetting with the actual</span>
      <span class="comment">// settings that were derived.</span>
      <span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init.deriveAndLocal.allDefs">allDefs</a> = <a href="#sbt;Init.addLocal" title="(init: Seq[Init.this.Setting[_]])(implicit scopeLocal: Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]])Seq[Init.this.Setting[_]]">addLocal</a><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.init" title="Seq[Init.this.Setting[_]]">init</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.scopeLocal" title="Init.this.ScopedKey[_] =&gt; Seq[Init.this.Setting[_]]">scopeLocal</a><span class="delimiter">)</span>
      <a href="#sbt;Init.deriveAndLocal.allDefs" title="Seq[Init.this.Setting[_]]">allDefs</a> <span title="(f: Init.this.Setting[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Setting[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Setting[_]],Init.this.Setting[_],Seq[Init.this.Setting[_]]])Seq[Init.this.Setting[_]]">flatMap</span> <a href="#sbt;Init.deriveAndLocal.$anonfun.x0$8" title="scala.collection.immutable.Stream[Init.this.Setting[_]]" class="delimiter">{</a> <span class="keyword">case</span> <a title="Init.this.DerivedSetting[_]" id="sbt;Init.deriveAndLocal.$anonfun.d">d</a>: <a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[_]">DerivedSetting</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.derivedToStruct" title="Map[Init.this.DerivedSetting[_],Derived]">derivedToStruct</a> <span title="(key: Init.this.DerivedSetting[_])Option[Derived]">get</span> <a href="#sbt;Init.deriveAndLocal.$anonfun.d" title="Init.this.DerivedSetting[_]">d</a> <span title="(xo: Option[scala.collection.mutable.ListBuffer[Init.this.Setting[_]]])Iterable[scala.collection.mutable.ListBuffer[Init.this.Setting[_]]]">map</span> <span class="delimiter">(</span><a href="#sbt;Init.deriveAndLocal.$anonfun.$anonfun.x$22" title="Derived">_</a>.<a href="#sbt;Init.deriveAndLocal;Derived.outputs" title="=&gt; scala.collection.mutable.ListBuffer[Init.this.Setting[_]]">outputs</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; scala.collection.immutable.Stream[scala.collection.mutable.ListBuffer[Init.this.Setting[_]]]">toStream</span>.<span title="(implicit asTraversable: scala.collection.mutable.ListBuffer[Init.this.Setting[_]] =&gt; scala.collection.GenTraversableOnce[Init.this.Setting[_]])scala.collection.immutable.Stream[Init.this.Setting[_]]">flatten</span>; <span class="keyword">case</span> <span title="Init.this.Setting[_$29]">s</span> =&gt; <span title="(xs: Init.this.Setting[_$29]*)scala.collection.immutable.Stream[Init.this.Setting[_$29]]">Stream</span><span class="delimiter">(</span><span title="Init.this.Setting[_$29]">s</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Initialize[T] extends AnyRef" id="sbt;Init;Initialize">Initialize</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize;T">T</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.ScopedKey[_]]" id="sbt;Init;Initialize.dependencies">dependencies</a>: <span title="Seq[Init.this.ScopedKey[_]]">Seq</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[S](g: T =&gt; S)Init.this.Initialize[S]" id="sbt;Init;Initialize.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize.apply;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; S" id="sbt;Init;Initialize.apply.g">g</a>: T =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span>

    @deprecated<span class="delimiter">(</span><span class="string">&quot;Will be made private.&quot;</span>, <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Initialize[T]" id="sbt;Init;Initialize.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Initialize.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Will be made private.&quot;</span>, <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Initialize[T]" id="sbt;Init;Initialize.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Initialize.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    @deprecated<span class="delimiter">(</span><span class="string">&quot;Will be made private.&quot;</span>, <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateRef)Init.this.ValidatedInit[T]" id="sbt;Init;Initialize.validateReferenced">validateReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateRef" id="sbt;Init;Initialize.validateReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.ValidateRef">ValidateRef</a><span class="delimiter">)</span>: <span title="Init.this.ValidatedInit[T]">ValidatedInit</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <a href="#sbt;Init;Initialize.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]">validateKeyReferenced</a><span class="delimiter">(</span><a href="#sbt;Init;Initialize.validateReferenced;$anon" title="Init.this.ValidateKeyRef" class="keyword">new</a> <a href="#sbt;Init;ValidateKeyRef" title="anonymous class $anon extends Init.this.ValidateKeyRef" id="sbt;Init;Initialize.validateReferenced;$anon">ValidateKeyRef</a> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], selfRefOk: Boolean)Init.this.ValidatedRef[T]" id="sbt;Init;Initialize.validateReferenced;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize.validateReferenced;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init;Initialize.validateReferenced;$anon.apply.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Boolean" id="sbt;Init;Initialize.validateReferenced;$anon.apply.selfRefOk">selfRefOk</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> = <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: Init.this.ScopedKey[T])Init.this.ValidatedRef[T]">g</a><span class="delimiter">(</span><a href="#sbt;Init;Initialize.validateReferenced;$anon.apply.key" title="Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>

    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]" id="sbt;Init;Initialize.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Initialize.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span>: <span title="Init.this.ValidatedInit[T]">ValidatedInit</span><span class="delimiter">[</span>T<span class="delimiter">]</span>

    <span class="keyword">def</span> <a title="(map: sbt.Settings[Scope])T" id="sbt;Init;Initialize.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;Initialize.evaluate.map">map</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize;T" title="T">T</a>
    <span class="keyword">def</span> <a title="[S](o: Init.this.Initialize[S])Init.this.Initialize[(T, S)]" id="sbt;Init;Initialize.zip">zip</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize.zip;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init;Initialize.zip.o">o</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[(T, S)]">Initialize</a><span class="delimiter">[</span><span class="delimiter">(</span>T, S<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#sbt;Init;Initialize.zipTupled" title="(o: Init.this.Initialize[S])(f: ((T, S)) =&gt; (T, S))Init.this.Initialize[(T, S)]">zipTupled</a><span class="delimiter">(</span><a href="#sbt;Init;Initialize.zip.o" title="Init.this.Initialize[S]">o</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="((T, S)) =&gt; (T, S)">idFun</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S, U](o: Init.this.Initialize[S])(f: (T, S) =&gt; U)Init.this.Initialize[U]" id="sbt;Init;Initialize.zipWith">zipWith</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize.zipWith;S">S</a>, <a title="" id="sbt;Init;Initialize.zipWith;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init;Initialize.zipWith.o">o</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(T, S) =&gt; U" id="sbt;Init;Initialize.zipWith.f">f</a>: <span class="delimiter">(</span>T, S<span class="delimiter">)</span> =&gt; U<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[U]">Initialize</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#sbt;Init;Initialize.zipTupled" title="(o: Init.this.Initialize[S])(f: ((T, S)) =&gt; U)Init.this.Initialize[U]">zipTupled</a><span class="delimiter">(</span><a href="#sbt;Init;Initialize.zipWith.o" title="Init.this.Initialize[S]">o</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;Initialize.zipWith.f" title="(T, S) =&gt; U">f</a>.<span title="=&gt; ((T, S)) =&gt; U">tupled</span><span class="delimiter">)</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S, U](o: Init.this.Initialize[S])(f: ((T, S)) =&gt; U)Init.this.Initialize[U]" id="sbt;Init;Initialize.zipTupled">zipTupled</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize.zipTupled;S">S</a>, <a title="" id="sbt;Init;Initialize.zipTupled;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init;Initialize.zipTupled.o">o</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="((T, S)) =&gt; U" id="sbt;Init;Initialize.zipTupled.f">f</a>: <span class="delimiter">(</span><span class="delimiter">(</span>T, S<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; U<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[U]">Initialize</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =
      <span title="Init.this.Apply[[L[x]](L[T], L[S]),U]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[[L[x]](L[T], L[S]),U]">Apply</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span>L<span class="delimiter">[</span>T<span class="delimiter">]</span>, L<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l, U<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init;Initialize.zipTupled.f" title="((T, S)) =&gt; U">f</a>, <span title="(_1: Init.this.Initialize[T], _2: Init.this.Initialize[S])(Init.this.Initialize[T], Init.this.Initialize[S])" class="delimiter">(</span><a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]" class="keyword">this</a>, <a href="#sbt;Init;Initialize.zipTupled.o" title="Init.this.Initialize[S]">o</a><span class="delimiter">)</span>, <a href="AList.scala.html#sbt.AList" title="sbt.AList.type">AList</a>.<a href="AList.scala.html#sbt.AList.tuple2" title="[A, B]=&gt; sbt.AList.T2List[A,B]">tuple2</a><span title="sbt.AList.T2List[T,S]" class="delimiter">[</span><a href="#sbt;Init;Initialize;T" title="T">T</a>, <a href="#sbt;Init;Initialize.zipTupled;S" title="S">S</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="comment">/** A fold on the static attributes of this and nested Initializes. */</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;Initialize.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;Initialize.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Initialize.processAttributes.init">init</a>: <a href="#sbt;Init;Initialize.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;Initialize.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize.processAttributes;S" title="S">S</a>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="Init.this.Initialize.type" id="sbt;Init.Initialize">Initialize</a> <a href="#sbt;Init.Initialize" title="Init.this.Initialize.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](s: Seq[Init.this.Initialize[T]])sbt.Init.Initialize.JoinInitSeq[T]" id="sbt;Init.Initialize.joinInitialize">joinInitialize</a><span class="delimiter">[</span><a title="" id="sbt;Init.Initialize.joinInitialize;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Init.this.Initialize[T]]" id="sbt;Init.Initialize.joinInitialize.s">s</a>: <span title="Seq[Init.this.Initialize[T]]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init.Initialize;JoinInitSeq" title="sbt.Init.Initialize.JoinInitSeq[T]">JoinInitSeq</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="sbt.Init.Initialize.JoinInitSeq[T]" class="keyword">new</span> <a href="#sbt;Init.Initialize;JoinInitSeq" title="sbt.Init.Initialize.JoinInitSeq[T]">JoinInitSeq</a><span class="delimiter">(</span><a href="#sbt;Init.Initialize.joinInitialize.s" title="Seq[Init.this.Initialize[T]]">s</a><span class="delimiter">)</span>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class JoinInitSeq[T] extends AnyRef" id="sbt;Init.Initialize;JoinInitSeq">JoinInitSeq</a><span class="delimiter">[</span><a title="" id="sbt;Init.Initialize;JoinInitSeq;T">T</a><span class="delimiter">]</span><a href="#sbt;Init.Initialize;JoinInitSeq" title="sbt.Init.Initialize.JoinInitSeq[T]" class="delimiter">(</a><a title="Seq[Init.this.Initialize[T]]" id="sbt;Init.Initialize;JoinInitSeq.s">s</a>: <span title="Seq[Init.this.Initialize[T]]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[S](f: Seq[T] =&gt; S)Init.this.Initialize[S]" id="sbt;Init.Initialize;JoinInitSeq.joinWith">joinWith</a><span class="delimiter">[</span><a title="" id="sbt;Init.Initialize;JoinInitSeq.joinWith;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T] =&gt; S" id="sbt;Init.Initialize;JoinInitSeq.joinWith.f">f</a>: Seq<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <a href="#sbt;Init.uniform" title="(inputs: Seq[Init.this.Initialize[T]])(f: Seq[T] =&gt; S)Init.this.Initialize[S]">uniform</a><span class="delimiter">(</span><a href="#sbt;Init.Initialize;JoinInitSeq.s" title="Seq[Init.this.Initialize[T]]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.Initialize;JoinInitSeq.joinWith.f" title="Seq[T] =&gt; S">f</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="=&gt; Init.this.Initialize[Seq[T]]" id="sbt;Init.Initialize;JoinInitSeq.join">join</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Seq[T]]">Initialize</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.uniform" title="(inputs: Seq[Init.this.Initialize[T]])(f: Seq[T] =&gt; Seq[T])Init.this.Initialize[Seq[T]]">uniform</a><span class="delimiter">(</span><a href="#sbt;Init.Initialize;JoinInitSeq.s" title="Seq[Init.this.Initialize[T]]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="Seq[T] =&gt; Seq[T]">idFun</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[T](inits: Seq[Init.this.Initialize[T]])Init.this.Initialize[Seq[T]]" id="sbt;Init.Initialize.join">join</a><span class="delimiter">[</span><a title="" id="sbt;Init.Initialize.join;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Init.this.Initialize[T]]" id="sbt;Init.Initialize.join.inits">inits</a>: <span title="Seq[Init.this.Initialize[T]]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Seq[T]]">Initialize</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.uniform" title="(inputs: Seq[Init.this.Initialize[T]])(f: Seq[T] =&gt; Seq[T])Init.this.Initialize[Seq[T]]">uniform</a><span class="delimiter">(</span><a href="#sbt;Init.Initialize.join.inits" title="Seq[Init.this.Initialize[T]]">inits</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="Seq[T] =&gt; Seq[T]">idFun</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[M[_]](inits: Seq[Init.this.Initialize[M[T]] forSome { type T }])Init.this.Initialize[Seq[M[_]]]" id="sbt;Init.Initialize.joinAny">joinAny</a><span class="delimiter">[</span><a title="[_]" id="sbt;Init.Initialize.joinAny;M">M</a><span class="delimiter">[</span><a title="" id="sbt;Init.Initialize.joinAny;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Init.this.Initialize[M[T]] forSome { type T }]" id="sbt;Init.Initialize.joinAny.inits">inits</a>: <span title="Seq[Init.this.Initialize[M[T]] forSome { type T }]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">forSome</span> <span class="delimiter">{</span> <span class="keyword">type</span> T <span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Seq[M[_]]]">Initialize</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>M<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#sbt;Init.Initialize.join" title="(inits: Seq[Init.this.Initialize[M[Any]]])Init.this.Initialize[Seq[M[Any]]]">join</a><span class="delimiter">(</span><a href="#sbt;Init.Initialize.joinAny.inits" title="Seq[Init.this.Initialize[M[T]] forSome { type T }]">inits</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Seq[Init.this.Initialize[M[Any]]]" class="delimiter">[</span><span title="Seq[Init.this.Initialize[M[Any]]]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>M<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Init.this.Initialize[Seq[M[_]]]" class="delimiter">[</span><a href="#sbt;Init;Initialize" title="Init.this.Initialize[Seq[M[_]]]">Initialize</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="keyword">forSome</span> <span class="delimiter">{</span> <span class="keyword">type</span> T <span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="Init.this.SettingsDefinition.type" id="sbt;Init.SettingsDefinition">SettingsDefinition</a> <a href="#sbt;Init.SettingsDefinition" title="Init.this.SettingsDefinition.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.Init.SettingsDefinition.unwrapSettingsDefinition : (d: Init.this.SettingsDefinition)Seq[Init.this.Setting[_]]" id="sbt;Init.SettingsDefinition.unwrapSettingsDefinition">unwrapSettingsDefinition</a><span class="delimiter">(</span><a title="Init.this.SettingsDefinition" id="sbt;Init.SettingsDefinition.unwrapSettingsDefinition.d">d</a>: <a href="#sbt;Init;SettingsDefinition" title="Init.this.SettingsDefinition">SettingsDefinition</a><span class="delimiter">)</span>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.SettingsDefinition.unwrapSettingsDefinition.d" title="Init.this.SettingsDefinition">d</a>.<a href="#sbt;Init;SettingsDefinition.settings" title="=&gt; Seq[Init.this.Setting[_]]">settings</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.Init.SettingsDefinition.wrapSettingsDefinition : (ss: Seq[Init.this.Setting[_]])Init.this.SettingsDefinition" id="sbt;Init.SettingsDefinition.wrapSettingsDefinition">wrapSettingsDefinition</a><span class="delimiter">(</span><a title="Seq[Init.this.Setting[_]]" id="sbt;Init.SettingsDefinition.wrapSettingsDefinition.ss">ss</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;SettingsDefinition" title="Init.this.SettingsDefinition">SettingsDefinition</a> = <span title="Init.this.SettingList" class="keyword">new</span> <a href="#sbt;Init;SettingList" title="Init.this.SettingList">SettingList</a><span class="delimiter">(</span><a href="#sbt;Init.SettingsDefinition.wrapSettingsDefinition.ss" title="Seq[Init.this.Setting[_]]">ss</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait SettingsDefinition extends AnyRef" id="sbt;Init;SettingsDefinition">SettingsDefinition</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.Setting[_]]" id="sbt;Init;SettingsDefinition.settings">settings</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class SettingList extends AnyRef with Init.this.SettingsDefinition" id="sbt;Init;SettingList">SettingList</a><a href="#sbt;Init;SettingList" title="Init.this.SettingList" class="delimiter">(</a><span class="keyword">val</span> <a title="Seq[Init.this.Setting[_]]" id="sbt;Init;SettingList.settings">settings</a>: <span title="Seq[Init.this.Setting[_]]">Seq</span><span class="delimiter">[</span>Setting<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;SettingsDefinition" title="Init.this.SettingsDefinition">SettingsDefinition</a>
  <span class="keyword">sealed</span> <span class="keyword">class</span> <a title="class Setting[T] extends AnyRef with Init.this.SettingsDefinition" id="sbt;Init;Setting">Setting</a><span class="delimiter">[</span><a title="" id="sbt;Init;Setting;T">T</a><span class="delimiter">]</span> <a href="#sbt;Init;Setting" title="Init.this.Setting[T]" class="keyword">private</a><span class="delimiter">[</span>Init<span class="delimiter">]</span> <span class="delimiter">(</span><span class="keyword">val</span> <a title="Init.this.ScopedKey[T]" id="sbt;Init;Setting.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Init.this.Initialize[T]" id="sbt;Init;Setting.init">init</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="sbt.SourcePosition" id="sbt;Init;Setting.pos">pos</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;SettingsDefinition" title="Init.this.SettingsDefinition">SettingsDefinition</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; List[Init.this.Setting[T]]" id="sbt;Init;Setting.settings">settings</a> = <a href="#sbt;Init;Setting" title="Init.this.Setting[T]" class="keyword">this</a> <a href="#sbt;Init;Setting.settings.x$23" title="(x: Init.this.Setting[T])List[Init.this.Setting[T]]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Init;Setting.definitive">definitive</a>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>.<a href="#sbt;Init;Initialize.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.ScopedKey[_]]" id="sbt;Init;Setting.dependencies">dependencies</a>: <span title="Seq[Init.this.ScopedKey[_]]">Seq</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.remove" title="(s: Seq[Init.this.ScopedKey[_]], v: Init.this.ScopedKey[_])Seq[Init.this.ScopedKey[_]]">remove</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>.<a href="#sbt;Init;Initialize.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a>, <a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Will be made private.&quot;</span>, <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Setting[T]" id="sbt;Init;Setting.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Setting.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a> <a href="#sbt;Init;Initialize.mapReferenced" title="(g: Init.this.MapScoped)Init.this.Initialize[T]">mapReferenced</a> <a href="#sbt;Init;Setting.mapReferenced.g" title="Init.this.MapScoped">g</a>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Will be made private.&quot;</span>, <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateRef)Either[Seq[Init.this.Undefined],Init.this.Setting[T]]" id="sbt;Init;Setting.validateReferenced">validateReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateRef" id="sbt;Init;Setting.validateReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.ValidateRef">ValidateRef</a><span class="delimiter">)</span>: <span title="Either[Seq[Init.this.Undefined],Init.this.Setting[T]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Undefined<span class="delimiter">]</span>, Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a> <a href="#sbt;Init;Initialize.validateReferenced" title="(g: Init.this.ValidateRef)Init.this.ValidatedInit[T]">validateReferenced</a> <a href="#sbt;Init;Setting.validateReferenced.g" title="Init.this.ValidateRef">g</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[Init.this.Undefined],Init.this.Initialize[T]]">right</span>.<span title="(f: Init.this.Initialize[T] =&gt; Init.this.Setting[T])Product with Serializable with scala.util.Either[Seq[Init.this.Undefined],Init.this.Setting[T]]">map</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init;Setting.validateReferenced.$anonfun.newI">newI</a> =&gt; <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.validateReferenced.$anonfun.newI" title="Init.this.Initialize[T]">newI</a>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Either[Seq[Init.this.Undefined],Init.this.Setting[T]]" id="sbt;Init;Setting.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Setting.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span>: <span title="Either[Seq[Init.this.Undefined],Init.this.Setting[T]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>Undefined<span class="delimiter">]</span>, Setting<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">(</span><a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a> <a href="#sbt;Init;Initialize.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]">validateKeyReferenced</a> <a href="#sbt;Init;Setting.validateKeyReferenced.g" title="Init.this.ValidateKeyRef">g</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[Init.this.Undefined],Init.this.Initialize[T]]">right</span>.<span title="(f: Init.this.Initialize[T] =&gt; Init.this.Setting[T])Product with Serializable with scala.util.Either[Seq[Init.this.Undefined],Init.this.Setting[T]]">map</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init;Setting.validateKeyReferenced.$anonfun.newI">newI</a> =&gt; <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.validateKeyReferenced.$anonfun.newI" title="Init.this.Initialize[T]">newI</a>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Setting[T]" id="sbt;Init;Setting.mapKey">mapKey</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Setting.mapKey.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: Init.this.ScopedKey[T])Init.this.ScopedKey[T]">g</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span>, <a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(f: (Init.this.ScopedKey[T], T) =&gt; T)Init.this.Setting[T]" id="sbt;Init;Setting.mapInit">mapInit</a><span class="delimiter">(</span><a title="(Init.this.ScopedKey[T], T) =&gt; T" id="sbt;Init;Setting.mapInit.f">f</a>: <span class="delimiter">(</span>ScopedKey<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Initialize.apply" title="(g: T =&gt; T)Init.this.Initialize[T]">init</a><span class="delimiter">(</span><a title="T" id="sbt;Init;Setting.mapInit.$anonfun.t">t</a> =&gt; <a href="#sbt;Init;Setting.mapInit.f" title="(v1: Init.this.ScopedKey[T], v2: T)T">f</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.mapInit.$anonfun.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Will be made private.&quot;</span>, <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Setting[T]" id="sbt;Init;Setting.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Setting.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a> <a href="#sbt;Init;Initialize.mapConstant" title="(g: Init.this.MapConstant)Init.this.Initialize[T]">mapConstant</a> <a href="#sbt;Init;Setting.mapConstant.g" title="Init.this.MapConstant">g</a>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(pos: sbt.SourcePosition)Init.this.Setting[T]" id="sbt;Init;Setting.withPos">withPos</a><span class="delimiter">(</span><a title="sbt.SourcePosition" id="sbt;Init;Setting.withPos.pos">pos</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a><span class="delimiter">)</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>, <a href="#sbt;Init;Setting.withPos.pos" title="sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Option[String]" id="sbt;Init;Setting.positionString">positionString</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a> <span title="Option[String]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="sbt.FilePosition" id="sbt;Init;Setting.positionString.pos">pos</a>: <a href="Positions.scala.html#sbt;FilePosition" title="sbt.FilePosition">FilePosition</a> =&gt; <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#sbt;Init;Setting.positionString.pos" title="sbt.FilePosition">pos</a>.<a href="Positions.scala.html#sbt;FilePosition.path" title="=&gt; String">path</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;:&quot;)" class="string">&quot;:&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;Setting.positionString.pos" title="sbt.FilePosition">pos</a>.<a href="Positions.scala.html#sbt;FilePosition.startLine" title="=&gt; Int">startLine</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="Positions.scala.html#sbt.NoPosition" title="sbt.NoPosition.type">NoPosition</a>        =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(f: Init.this.Initialize[T] =&gt; Init.this.Initialize[T])Init.this.Setting[T]" id="sbt;Init;Setting.mapInitialize">mapInitialize</a><span class="delimiter">(</span><a title="Init.this.Initialize[T] =&gt; Init.this.Initialize[T]" id="sbt;Init;Setting.mapInitialize.f">f</a>: Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.mapInitialize.f" title="(v1: Init.this.Initialize[T])Init.this.Initialize[T]">f</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a><span class="delimiter">)</span>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;Init;Setting.toString">toString</a> = <span title="String(&quot;setting(&quot;)" class="string">&quot;setting(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;) at &quot;)" class="string">&quot;) at &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a>

    <span class="keyword">protected</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]" id="sbt;Init;Setting.make">make</a><span class="delimiter">[</span><a title="" id="sbt;Init;Setting.make;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init;Setting.make.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Init.this.Initialize[T]" id="sbt;Init;Setting.make.init">init</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.SourcePosition" id="sbt;Init;Setting.make.pos">pos</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Setting[T]" class="keyword">new</span> <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init;Setting.make.key" title="Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.make.init" title="Init.this.Initialize[T]">init</a>, <a href="#sbt;Init;Setting.make.pos" title="sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    <span class="keyword">protected</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Init;Setting.isDerived">isDerived</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(s: Scope)Init.this.Setting[T]" id="sbt;Init;Setting.setScope">setScope</a><span class="delimiter">(</span><a title="Scope" id="sbt;Init;Setting.setScope.s">s</a>: <a href="#sbt;Init;Scope" title="Scope">Scope</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>.<a href="#sbt;Init.ScopedKey.readResolve" title="(scope: Scope, key: sbt.AttributeKey[T])Init.this.ScopedKey[T]">copy</a><span class="delimiter">(</span>scope = <a href="#sbt;Init;Setting.setScope.s" title="Scope">s</a><span class="delimiter">)</span>, <a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>.<a href="#sbt;Init;Initialize.mapReferenced" title="(g: Init.this.MapScoped)Init.this.Initialize[T]">mapReferenced</a><span class="delimiter">(</span><a href="#sbt;Init.mapScope" title="(f: Scope =&gt; Scope)Init.this.MapScoped">mapScope</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: Scope)Scope =&gt; Scope">const</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.setScope.s" title="Scope">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a><span class="delimiter">)</span>
    <span class="comment">/** Turn this setting into a `DefaultSetting` if it's not already, otherwise returns `this` */</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(id: =&gt; Long)Init.this.DefaultSetting[T]" id="sbt;Init;Setting.default">default</a><span class="delimiter">(</span><a title="=&gt; Long" id="sbt;Init;Setting.default$default$1">id</a>: =&gt; <span title="Long">Long</span> = <a href="#sbt;Init.nextDefaultID" title="()Long">nextDefaultID</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]">DefaultSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.DefaultSetting.apply" title="(sk: Init.this.ScopedKey[T], i: Init.this.Initialize[T], p: sbt.SourcePosition, _id: Long)Init.this.Setting[T] with Init.this.DefaultSetting[T]">DefaultSetting</a><span class="delimiter">(</span><a href="#sbt;Init;Setting.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;Setting.init" title="=&gt; Init.this.Initialize[T]">init</a>, <a href="#sbt;Init;Setting.pos" title="=&gt; sbt.SourcePosition">pos</a>, <a href="#sbt;Init;Setting.default$default$1" title="=&gt; Long">id</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>Init<span class="delimiter">]</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <a title="class DerivedSetting[T] extends Init.this.Setting[T]" id="sbt;Init;DerivedSetting">DerivedSetting</a><span class="delimiter">[</span><a title="" id="sbt;Init;DerivedSetting;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[T]" class="delimiter">(</a><a title="Init.this.ScopedKey[T]" id="sbt;Init;DerivedSetting.sk">sk</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Init.this.Initialize[T]" id="sbt;Init;DerivedSetting.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.SourcePosition" id="sbt;Init;DerivedSetting.p">p</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a>, <span class="keyword">val</span> <a title="Scope =&gt; Boolean" id="sbt;Init;DerivedSetting.filter">filter</a>: Scope =&gt; Boolean, <span class="keyword">val</span> <a title="sbt.AttributeKey[_] =&gt; Boolean" id="sbt;Init;DerivedSetting.trigger">trigger</a>: AttributeKey<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init;DerivedSetting.sk" title="Init.this.ScopedKey[T]">sk</a>, <a href="#sbt;Init;DerivedSetting.i" title="Init.this.Initialize[T]">i</a>, <a href="#sbt;Init;DerivedSetting.p" title="sbt.SourcePosition">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]" id="sbt;Init;DerivedSetting.make">make</a><span class="delimiter">[</span><a title="" id="sbt;Init;DerivedSetting.make;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init;DerivedSetting.make.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Init.this.Initialize[T]" id="sbt;Init;DerivedSetting.make.init">init</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.SourcePosition" id="sbt;Init;DerivedSetting.make.pos">pos</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.DerivedSetting[T]" class="keyword">new</span> <a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[T]">DerivedSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init;DerivedSetting.make.key" title="Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;DerivedSetting.make.init" title="Init.this.Initialize[T]">init</a>, <a href="#sbt;Init;DerivedSetting.make.pos" title="sbt.SourcePosition">pos</a>, <a href="#sbt;Init;DerivedSetting.filter" title="=&gt; Scope =&gt; Boolean">filter</a>, <a href="#sbt;Init;DerivedSetting.trigger" title="=&gt; sbt.AttributeKey[_] =&gt; Boolean">trigger</a><span class="delimiter">)</span>
    <span class="keyword">protected</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Init;DerivedSetting.isDerived">isDerived</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(_id: =&gt; Long)Init.this.DefaultSetting[T]" id="sbt;Init;DerivedSetting.default">default</a><span class="delimiter">(</span><a title="=&gt; Long" id="sbt;Init;DerivedSetting.default._id">_id</a>: =&gt; Long<span class="delimiter">)</span>: <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]">DefaultSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;DerivedSetting.default;$anon" title="Init.this.DerivedSetting[T] with Init.this.DefaultSetting[T]{}" class="keyword">new</a> <a title="anonymous class $anon extends Init.this.DerivedSetting[T] with Init.this.DefaultSetting[T]" id="sbt;Init;DerivedSetting.default;$anon">DerivedSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init;DerivedSetting.sk" title="Init.this.ScopedKey[T]">sk</a>, <a href="#sbt;Init;DerivedSetting.i" title="Init.this.Initialize[T]">i</a>, <a href="#sbt;Init;DerivedSetting.p" title="sbt.SourcePosition">p</a>, <a href="#sbt;Init;DerivedSetting.filter" title="=&gt; Scope =&gt; Boolean">filter</a>, <a href="#sbt;Init;DerivedSetting.trigger" title="=&gt; sbt.AttributeKey[_] =&gt; Boolean">trigger</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]">DefaultSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">val</span> <a title="Long" id="sbt;Init;DerivedSetting.default;$anon.id">id</a> = <a href="#sbt;Init;DerivedSetting.default._id" title="=&gt; Long">_id</a> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;Init;DerivedSetting.toString">toString</a> = <span title="String(&quot;derived &quot;)" class="string">&quot;derived &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;DerivedSetting" title="Init.this.DerivedSetting[T]" class="keyword">super</a>.<a href="#sbt;Init;Setting.toString" title="()String">toString</a>
  <span class="delimiter">}</span>
  <span class="comment">// Only keep the first occurrence of this setting and move it to the front so that it has lower precedence than non-defaults.</span>
  <span class="comment">//  This is intended for internal sbt use only, where alternatives like Plugin.globalSettings are not available.</span>
  <span class="keyword">private</span><span class="delimiter">[</span>Init<span class="delimiter">]</span> <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait DefaultSetting[T] extends Init.this.Setting[T]" id="sbt;Init;DefaultSetting">DefaultSetting</a><span class="delimiter">[</span><a title="" id="sbt;Init;DefaultSetting;T">T</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="=&gt; Long" id="sbt;Init;DefaultSetting.id">id</a>: <span title="Long">Long</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[T](key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]" id="sbt;Init;DefaultSetting.make">make</a><span class="delimiter">[</span><a title="" id="sbt;Init;DefaultSetting.make;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init;DefaultSetting.make.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Init.this.Initialize[T]" id="sbt;Init;DefaultSetting.make.init">init</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.SourcePosition" id="sbt;Init;DefaultSetting.make.pos">pos</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a><span class="delimiter">)</span>: <a href="#sbt;Init;Setting" title="Init.this.Setting[T]">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]" class="keyword">super</a>.<a href="#sbt;Init;Setting.make" title="(key: Init.this.ScopedKey[T], init: Init.this.Initialize[T], pos: sbt.SourcePosition)Init.this.Setting[T]">make</a><span class="delimiter">(</span><a href="#sbt;Init;DefaultSetting.make.key" title="Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;DefaultSetting.make.init" title="Init.this.Initialize[T]">init</a>, <a href="#sbt;Init;DefaultSetting.make.pos" title="sbt.SourcePosition">pos</a><span class="delimiter">)</span> <a href="#sbt;Init;Setting.default" title="(id: =&gt; Long)Init.this.DefaultSetting[T]">default</a> <a href="#sbt;Init;DefaultSetting.id" title="=&gt; Long">id</a>
    <span class="keyword">override</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="()Int" id="sbt;Init;DefaultSetting.hashCode">hashCode</a> = <a href="#sbt;Init;DefaultSetting.id" title="=&gt; Long">id</a>.<span title="()Int">hashCode</span>
    <span class="keyword">override</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(o: Any)Boolean" id="sbt;Init;DefaultSetting.equals">equals</a><span class="delimiter">(</span><a title="Any" id="sbt;Init;DefaultSetting.equals.o">o</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#sbt;Init;DefaultSetting.equals.o" title="Any">o</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Init.this.DefaultSetting[_]" id="sbt;Init;DefaultSetting.equals.d">d</a>: <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[_]">DefaultSetting</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#sbt;Init;DefaultSetting.equals.d" title="Init.this.DefaultSetting[_]">d</a>.<a href="#sbt;Init;DefaultSetting.id" title="=&gt; Long">id</a> <span title="(x: Long)Boolean">==</span> <a href="#sbt;Init;DefaultSetting.id" title="=&gt; Long">id</a>; <span class="keyword">case</span> _ =&gt; <span title="Boolean(false)" class="keyword">false</span> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;Init;DefaultSetting.toString">toString</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;default(&quot;)">default($</span><a href="#sbt;Init;DefaultSetting.id" title="=&gt; Long">id</a><span title="String(&quot;) &quot;)" class="string">) &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]" class="keyword">super</a>.<a href="#sbt;Init;Setting.toString" title="()String">toString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(id: =&gt; Long)Init.this.DefaultSetting[T]" id="sbt;Init;DefaultSetting.default">default</a><span class="delimiter">(</span><a title="=&gt; Long" id="sbt;Init;DefaultSetting.default.id">id</a>: =&gt; Long<span class="delimiter">)</span> = <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]" class="keyword">this</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Init.this.DefaultSetting.type" id="sbt;Init.DefaultSetting">DefaultSetting</a> <a href="#sbt;Init.DefaultSetting" title="Init.this.DefaultSetting.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[T](sk: Init.this.ScopedKey[T], i: Init.this.Initialize[T], p: sbt.SourcePosition, _id: Long)Init.this.Setting[T] with Init.this.DefaultSetting[T]" id="sbt;Init.DefaultSetting.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.DefaultSetting.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init.DefaultSetting.apply.sk">sk</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Init.this.Initialize[T]" id="sbt;Init.DefaultSetting.apply.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.SourcePosition" id="sbt;Init.DefaultSetting.apply.p">p</a>: <a href="Positions.scala.html#sbt;SourcePosition" title="sbt.SourcePosition">SourcePosition</a>, <a title="Long" id="sbt;Init.DefaultSetting.apply._id">_id</a>: <span title="Long">Long</span><span class="delimiter">)</span> = <a href="#sbt;Init.DefaultSetting.apply;$anon" title="Init.this.Setting[T] with Init.this.DefaultSetting[T]{}" class="keyword">new</a> <a title="anonymous class $anon extends Init.this.Setting[T] with Init.this.DefaultSetting[T]" id="sbt;Init.DefaultSetting.apply;$anon">Setting</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.DefaultSetting.apply.sk" title="Init.this.ScopedKey[T]">sk</a>, <a href="#sbt;Init.DefaultSetting.apply.i" title="Init.this.Initialize[T]">i</a>, <a href="#sbt;Init.DefaultSetting.apply.p" title="sbt.SourcePosition">p</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#sbt;Init;DefaultSetting" title="Init.this.DefaultSetting[T]">DefaultSetting</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">val</span> <a title="Long" id="sbt;Init.DefaultSetting.apply;$anon.id">id</a> = <a href="#sbt;Init.DefaultSetting.apply._id" title="Long">_id</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](vr: Init.this.ValidatedInit[T])Init.this.Initialize[T]" id="sbt;Init.handleUndefined">handleUndefined</a><span class="delimiter">[</span><a title="" id="sbt;Init.handleUndefined;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ValidatedInit[T]" id="sbt;Init.handleUndefined.vr">vr</a>: <span title="Init.this.ValidatedInit[T]">ValidatedInit</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init.handleUndefined.vr" title="Init.this.ValidatedInit[T]">vr</a> <span title="Init.this.Initialize[T]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="Seq[Init.this.Undefined]" id="sbt;Init.handleUndefined.undefs">undefs</a><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="Init.this.RuntimeUndefined" class="keyword">new</span> <a href="#sbt;Init;RuntimeUndefined" title="Init.this.RuntimeUndefined">RuntimeUndefined</a><span class="delimiter">(</span><a href="#sbt;Init.handleUndefined.undefs" title="Seq[Init.this.Undefined]">undefs</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init.handleUndefined.x">x</a><span class="delimiter">)</span>     =&gt; <a href="#sbt;Init.handleUndefined.x" title="Init.this.Initialize[T]">x</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="getValidated extends AnyRef with sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]" id="sbt;Init.getValidated">getValidated</a> =
    <a href="#sbt;Init.getValidated;$anon" title="sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]" id="sbt;Init.getValidated;$anon" class="delimiter">(</a>ValidatedInit <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]">~&gt;</a> Initialize<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](v: Init.this.ValidatedInit[T])Init.this.Initialize[T]" id="sbt;Init.getValidated;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.getValidated;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ValidatedInit[T]" id="sbt;Init.getValidated;$anon.apply.v">v</a>: <span title="Init.this.ValidatedInit[T]">ValidatedInit</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.handleUndefined" title="[T](vr: Init.this.ValidatedInit[T])Init.this.Initialize[T]">handleUndefined</a><span title="(vr: Init.this.ValidatedInit[T])Init.this.Initialize[T]" class="delimiter">[</span><a href="#sbt;Init.getValidated;$anon.apply;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init.getValidated;$anon.apply.v" title="Init.this.ValidatedInit[T]">v</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">// mainly for reducing generated class count</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit]" id="sbt;Init.validateKeyReferencedT">validateKeyReferencedT</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init.validateKeyReferencedT.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> =
    <a href="#sbt;Init.validateKeyReferencedT;$anon" title="sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit]" id="sbt;Init.validateKeyReferencedT;$anon" class="delimiter">(</a>Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit]">~&gt;</a> ValidatedInit<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](i: Init.this.Initialize[T])Init.this.ValidatedInit[T]" id="sbt;Init.validateKeyReferencedT;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.validateKeyReferencedT;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init.validateKeyReferencedT;$anon.apply.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.validateKeyReferencedT;$anon.apply.i" title="Init.this.Initialize[T]">i</a> <a href="#sbt;Init;Initialize.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]">validateKeyReferenced</a> <a href="#sbt;Init.validateKeyReferencedT.g" title="Init.this.ValidateKeyRef">g</a> <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init.mapReferencedT">mapReferencedT</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init.mapReferencedT.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> =
    <a href="#sbt;Init.mapReferencedT;$anon" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init.mapReferencedT;$anon" class="delimiter">(</a>Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">~&gt;</a> Initialize<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](i: Init.this.Initialize[T])Init.this.Initialize[T]" id="sbt;Init.mapReferencedT;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.mapReferencedT;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init.mapReferencedT;$anon.apply.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.mapReferencedT;$anon.apply.i" title="Init.this.Initialize[T]">i</a> <a href="#sbt;Init;Initialize.mapReferenced" title="(g: Init.this.MapScoped)Init.this.Initialize[T]">mapReferenced</a> <a href="#sbt;Init.mapReferencedT.g" title="Init.this.MapScoped">g</a> <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init.mapConstantT">mapConstantT</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init.mapConstantT.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> =
    <a href="#sbt;Init.mapConstantT;$anon" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init.mapConstantT;$anon" class="delimiter">(</a>Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">~&gt;</a> Initialize<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](i: Init.this.Initialize[T])Init.this.Initialize[T]" id="sbt;Init.mapConstantT;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.mapConstantT;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init.mapConstantT;$anon.apply.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.mapConstantT;$anon.apply.i" title="Init.this.Initialize[T]">i</a> <a href="#sbt;Init;Initialize.mapConstant" title="(g: Init.this.MapConstant)Init.this.Initialize[T]">mapConstant</a> <a href="#sbt;Init.mapConstantT.g" title="Init.this.MapConstant">g</a> <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(g: sbt.Settings[Scope])sbt.~&gt;[Init.this.Initialize,sbt.Types.Id]" id="sbt;Init.evaluateT">evaluateT</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init.evaluateT.g">g</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#sbt;Init.evaluateT;$anon" title="sbt.~&gt;[Init.this.Initialize,sbt.Types.Id]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.Initialize,sbt.Types.Id]" id="sbt;Init.evaluateT;$anon" class="delimiter">(</a>Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,sbt.Types.Id]">~&gt;</a> Id<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](i: Init.this.Initialize[T])T" id="sbt;Init.evaluateT;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.evaluateT;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.Initialize[T]" id="sbt;Init.evaluateT;$anon.apply.i">i</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.evaluateT;$anon.apply.i" title="Init.this.Initialize[T]">i</a> <a href="#sbt;Init;Initialize.evaluate" title="(map: sbt.Settings[Scope])T">evaluate</a> <a href="#sbt;Init.evaluateT.g" title="sbt.Settings[Scope]">g</a> <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(ls: Seq[Init.this.Initialize[_]])Seq[Init.this.ScopedKey[_]]" id="sbt;Init.deps">deps</a><span class="delimiter">(</span><a title="Seq[Init.this.Initialize[_]]" id="sbt;Init.deps.ls">ls</a>: <span title="Seq[Init.this.Initialize[_]]">Seq</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Init.this.ScopedKey[_]]">Seq</span><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Init.deps.ls" title="Seq[Init.this.Initialize[_]]">ls</a>.<span title="(f: Init.this.Initialize[_] =&gt; scala.collection.GenTraversableOnce[Init.this.ScopedKey[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Init.this.Initialize[_]],Init.this.ScopedKey[_],Seq[Init.this.ScopedKey[_]]])Seq[Init.this.ScopedKey[_]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Init.this.ScopedKey[_],Seq[Init.this.ScopedKey[_]]]" class="delimiter">(</span><a href="#sbt;Init.deps.$anonfun.x$24" title="Init.this.Initialize[_]">_</a>.<a href="#sbt;Init;Initialize.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a><span class="delimiter">)</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Keyed[S, T] extends AnyRef with Init.this.Initialize[T]" id="sbt;Init;Keyed">Keyed</a><span class="delimiter">[</span><a title="" id="sbt;Init;Keyed;S">S</a>, <a title="" id="sbt;Init;Keyed;T">T</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Init.this.ScopedKey[S]" id="sbt;Init;Keyed.scopedKey">scopedKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[S]">ScopedKey</a><span class="delimiter">[</span>S<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="=&gt; S =&gt; T" id="sbt;Init;Keyed.transform">transform</a>: S =&gt; T
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; List[Init.this.ScopedKey[S]]" id="sbt;Init;Keyed.dependencies">dependencies</a> = <a href="#sbt;Init;Keyed.scopedKey" title="=&gt; Init.this.ScopedKey[S]">scopedKey</a> <a href="#sbt;Init;Keyed.dependencies.x$25" title="(x: Init.this.ScopedKey[S])List[Init.this.ScopedKey[S]]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="[Z](g: T =&gt; Z)Init.this.Initialize[Z]" id="sbt;Init;Keyed.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Keyed.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Z" id="sbt;Init;Keyed.apply.g">g</a>: T =&gt; Z<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Z]">Initialize</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <span title="Init.this.GetValue[S,Z]" class="keyword">new</span> <a href="#sbt;Init;GetValue" title="Init.this.GetValue[S,Z]">GetValue</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.scopedKey" title="=&gt; Init.this.ScopedKey[S]">scopedKey</a>, <a href="#sbt;Init;Keyed.apply.g" title="T =&gt; Z">g</a> <span title="(g: S =&gt; T)S =&gt; Z">compose</span> <a href="#sbt;Init;Keyed.transform" title="=&gt; S =&gt; T">transform</a><span class="delimiter">)</span>
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="(ss: sbt.Settings[Scope])T" id="sbt;Init;Keyed.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;Keyed.evaluate.ss">ss</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Keyed;T" title="T">T</a> = <a href="#sbt;Init;Keyed.transform" title="(v1: S)T">transform</a><span class="delimiter">(</span><a href="#sbt;Init.getValue" title="(s: sbt.Settings[Scope], k: Init.this.ScopedKey[S])S">getValue</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.evaluate.ss" title="sbt.Settings[Scope]">ss</a>, <a href="#sbt;Init;Keyed.scopedKey" title="=&gt; Init.this.ScopedKey[S]">scopedKey</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Initialize[T]" id="sbt;Init;Keyed.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Keyed.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.GetValue[S,T]" class="keyword">new</span> <a href="#sbt;Init;GetValue" title="Init.this.GetValue[S,T]">GetValue</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: Init.this.ScopedKey[S])Init.this.ScopedKey[S]">g</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.scopedKey" title="=&gt; Init.this.ScopedKey[S]">scopedKey</a><span class="delimiter">)</span>, <a href="#sbt;Init;Keyed.transform" title="=&gt; S =&gt; T">transform</a><span class="delimiter">)</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]" id="sbt;Init;Keyed.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Keyed.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span>: <span title="Init.this.ValidatedInit[T]">ValidatedInit</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Init;ValidateKeyRef.apply" title="(key: Init.this.ScopedKey[S], selfRefOk: Boolean)Init.this.ValidatedRef[S]">g</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.scopedKey" title="=&gt; Init.this.ScopedKey[S]">scopedKey</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span title="Init.this.ValidatedInit[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="Init.this.Undefined" id="sbt;Init;Keyed.validateKeyReferenced.un">un</a><span class="delimiter">)</span>  =&gt; <span title="(a: List[Init.this.Undefined])scala.util.Left[List[Init.this.Undefined],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;Init;Keyed.validateKeyReferenced.un" title="Init.this.Undefined">un</a> <a href="#sbt;Init;Keyed.validateKeyReferenced.x$26" title="(x: Init.this.Undefined)List[Init.this.Undefined]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
      <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="Init.this.ScopedKey[S]" id="sbt;Init;Keyed.validateKeyReferenced.nk">nk</a><span class="delimiter">)</span> =&gt; <span title="(b: Init.this.GetValue[S,T])scala.util.Right[Nothing,Init.this.GetValue[S,T]]">Right</span><span class="delimiter">(</span><span title="Init.this.GetValue[S,T]" class="keyword">new</span> <a href="#sbt;Init;GetValue" title="Init.this.GetValue[S,T]">GetValue</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.validateKeyReferenced.nk" title="Init.this.ScopedKey[S]">nk</a>, <a href="#sbt;Init;Keyed.transform" title="=&gt; S =&gt; T">transform</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Initialize[T]" id="sbt;Init;Keyed.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Keyed.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: Init.this.ScopedKey[S])Option[S]">g</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.scopedKey" title="=&gt; Init.this.ScopedKey[S]">scopedKey</a><span class="delimiter">)</span> <span title="Init.this.Initialize[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span>        =&gt; <a href="#sbt;Init;Keyed" title="Init.this.Keyed[S,T]" class="keyword">this</a>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="S" id="sbt;Init;Keyed.mapConstant.const">const</a><span class="delimiter">)</span> =&gt; <span title="Init.this.Value[T]" class="keyword">new</span> <a href="#sbt;Init;Value" title="Init.this.Value[T]">Value</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#sbt;Init;Keyed.transform" title="(v1: S)T">transform</a><span class="delimiter">(</span><a href="#sbt;Init;Keyed.mapConstant.const" title="S">const</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;Keyed.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;Keyed.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Keyed.processAttributes.init">init</a>: <a href="#sbt;Init;Keyed.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;Keyed.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Keyed.processAttributes;S" title="S">S</a> = <a href="#sbt;Init;Keyed.processAttributes.init" title="S">init</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class GetValue[S, T] extends AnyRef with Init.this.Keyed[S,T]" id="sbt;Init;GetValue">GetValue</a><span class="delimiter">[</span><a title="" id="sbt;Init;GetValue;S">S</a>, <a title="" id="sbt;Init;GetValue;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;GetValue" title="Init.this.GetValue[S,T]" class="delimiter">(</a><span class="keyword">val</span> <a title="Init.this.ScopedKey[S]" id="sbt;Init;GetValue.scopedKey">scopedKey</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[S]">ScopedKey</a><span class="delimiter">[</span>S<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="S =&gt; T" id="sbt;Init;GetValue.transform">transform</a>: S =&gt; T<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Keyed" title="Init.this.Keyed[S,T]">Keyed</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span>
  <span class="keyword">trait</span> <a title="trait KeyedInitialize[T] extends AnyRef with Init.this.Keyed[T,T]" id="sbt;Init;KeyedInitialize">KeyedInitialize</a><span class="delimiter">[</span><a title="" id="sbt;Init;KeyedInitialize;T">T</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#sbt;Init;Keyed" title="Init.this.Keyed[T,T]">Keyed</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> <span class="keyword">val</span> <a title="T =&gt; T" id="sbt;Init;KeyedInitialize.transform">transform</a> = <a href="TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="[T]=&gt; T =&gt; T">idFun</a><span title="T =&gt; T" class="delimiter">[</span><a href="#sbt;Init;KeyedInitialize;T" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TransformCapture extends AnyRef with Init.this.Initialize[sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]]" id="sbt;Init;TransformCapture">TransformCapture</a><a href="#sbt;Init;TransformCapture" title="Init.this.TransformCapture" class="delimiter">(</a><span class="keyword">val</span> <a title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init;TransformCapture.f">f</a>: Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">~&gt;</a> Initialize<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]]">Initialize</a><span class="delimiter">[</span>Initialize ~&gt; Initialize<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="sbt;Init;TransformCapture.dependencies">dependencies</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="[Z](g2: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize] =&gt; Z)Init.this.Initialize[Z]" id="sbt;Init;TransformCapture.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;TransformCapture.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize] =&gt; Z" id="sbt;Init;TransformCapture.apply.g2">g2</a>: <span class="delimiter">(</span>Initialize ~&gt; Initialize<span class="delimiter">)</span> =&gt; Z<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Z]">Initialize</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a href="#sbt;Init.map" title="(in: Init.this.Initialize[sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]])(f: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize] =&gt; Z)Init.this.Initialize[Z]">map</a><span class="delimiter">(</span><a href="#sbt;Init;TransformCapture" title="Init.this.TransformCapture" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;TransformCapture.apply.g2" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize] =&gt; Z">g2</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(ss: sbt.Settings[Scope])sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init;TransformCapture.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;TransformCapture.evaluate.ss">ss</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">~&gt;</a> Initialize = <a href="#sbt;Init;TransformCapture.f" title="=&gt; sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">f</a>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.TransformCapture" id="sbt;Init;TransformCapture.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;TransformCapture.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <span title="Init.this.TransformCapture" class="keyword">new</span> <a href="#sbt;Init;TransformCapture" title="Init.this.TransformCapture">TransformCapture</a><span class="delimiter">(</span><a href="#sbt;Init.mapReferencedT" title="(g: Init.this.MapScoped)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">mapReferencedT</a><span class="delimiter">(</span><a href="#sbt;Init;TransformCapture.mapReferenced.g" title="Init.this.MapScoped">g</a><span class="delimiter">)</span> <a href="TypeFunctions.scala.html#sbt;~>.∙(ddc0ac6381)" title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">∙</a> <a href="#sbt;Init;TransformCapture.f" title="=&gt; sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.TransformCapture" id="sbt;Init;TransformCapture.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;TransformCapture.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> = <span title="Init.this.TransformCapture" class="keyword">new</span> <a href="#sbt;Init;TransformCapture" title="Init.this.TransformCapture">TransformCapture</a><span class="delimiter">(</span><a href="#sbt;Init.mapConstantT" title="(g: Init.this.MapConstant)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">mapConstantT</a><span class="delimiter">(</span><a href="#sbt;Init;TransformCapture.mapConstant.g" title="Init.this.MapConstant">g</a><span class="delimiter">)</span> <a href="TypeFunctions.scala.html#sbt;~>.∙(ddc0ac6381)" title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">∙</a> <a href="#sbt;Init;TransformCapture.f" title="=&gt; sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)scala.util.Right[Nothing,Init.this.TransformCapture]" id="sbt;Init;TransformCapture.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;TransformCapture.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> = <span title="(b: Init.this.TransformCapture)scala.util.Right[Nothing,Init.this.TransformCapture]">Right</span><span class="delimiter">(</span><span title="Init.this.TransformCapture" class="keyword">new</span> <a href="#sbt;Init;TransformCapture" title="Init.this.TransformCapture">TransformCapture</a><span class="delimiter">(</span><a href="#sbt;Init.getValidated" title="=&gt; sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]">getValidated</a> <a href="TypeFunctions.scala.html#sbt;~>.∙(ddc0ac6381)" title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit])sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">∙</a> <a href="#sbt;Init.validateKeyReferencedT" title="(g: Init.this.ValidateKeyRef)sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit]">validateKeyReferencedT</a><span class="delimiter">(</span><a href="#sbt;Init;TransformCapture.validateKeyReferenced.g" title="Init.this.ValidateKeyRef">g</a><span class="delimiter">)</span> <a href="TypeFunctions.scala.html#sbt;~>.∙(ddc0ac6381)" title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">∙</a> <a href="#sbt;Init;TransformCapture.f" title="=&gt; sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;TransformCapture.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;TransformCapture.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;TransformCapture.processAttributes.init">init</a>: <a href="#sbt;Init;TransformCapture.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;TransformCapture.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;TransformCapture.processAttributes;S" title="S">S</a> = <a href="#sbt;Init;TransformCapture.processAttributes.init" title="S">init</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ValidationCapture[T] extends AnyRef with Init.this.Initialize[Init.this.ScopedKey[T]]" id="sbt;Init;ValidationCapture">ValidationCapture</a><span class="delimiter">[</span><a title="" id="sbt;Init;ValidationCapture;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="Init.this.ScopedKey[T]" id="sbt;Init;ValidationCapture.key">key</a>: <a href="#sbt;Init.ScopedKey.readResolve" title="Init.this.ScopedKey[T]">ScopedKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Boolean" id="sbt;Init;ValidationCapture.selfRefOk">selfRefOk</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Init.this.ScopedKey[T]]">Initialize</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="sbt;Init;ValidationCapture.dependencies">dependencies</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="[Z](g2: Init.this.ScopedKey[T] =&gt; Z)Init.this.Initialize[Z]" id="sbt;Init;ValidationCapture.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;ValidationCapture.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ScopedKey[T] =&gt; Z" id="sbt;Init;ValidationCapture.apply.g2">g2</a>: ScopedKey<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Z]">Initialize</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a href="#sbt;Init.map" title="(in: Init.this.Initialize[Init.this.ScopedKey[T]])(f: Init.this.ScopedKey[T] =&gt; Z)Init.this.Initialize[Z]">map</a><span class="delimiter">(</span><a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;ValidationCapture.apply.g2" title="Init.this.ScopedKey[T] =&gt; Z">g2</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(ss: sbt.Settings[Scope])Init.this.ScopedKey[T]" id="sbt;Init;ValidationCapture.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;ValidationCapture.evaluate.ss">ss</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init;ValidationCapture.key" title="=&gt; Init.this.ScopedKey[T]">key</a>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.ValidationCapture[T]" id="sbt;Init;ValidationCapture.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;ValidationCapture.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <span title="Init.this.ValidationCapture[T]" class="keyword">new</span> <a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]">ValidationCapture</a><span class="delimiter">(</span><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: Init.this.ScopedKey[T])Init.this.ScopedKey[T]">g</a><span class="delimiter">(</span><a href="#sbt;Init;ValidationCapture.key" title="=&gt; Init.this.ScopedKey[T]">key</a><span class="delimiter">)</span>, <a href="#sbt;Init;ValidationCapture.selfRefOk" title="=&gt; Boolean">selfRefOk</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.ValidationCapture[T]" id="sbt;Init;ValidationCapture.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;ValidationCapture.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> = <a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[Init.this.ScopedKey[T]]" id="sbt;Init;ValidationCapture.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;ValidationCapture.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> = <a href="#sbt;Init;ValidateKeyRef.apply" title="(key: Init.this.ScopedKey[T], selfRefOk: Boolean)Init.this.ValidatedRef[T]">g</a><span class="delimiter">(</span><a href="#sbt;Init;ValidationCapture.key" title="=&gt; Init.this.ScopedKey[T]">key</a>, <a href="#sbt;Init;ValidationCapture.selfRefOk" title="=&gt; Boolean">selfRefOk</a><span class="delimiter">)</span> <span title="Init.this.ValidatedInit[Init.this.ScopedKey[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="Init.this.Undefined" id="sbt;Init;ValidationCapture.validateKeyReferenced.un">un</a><span class="delimiter">)</span> =&gt; <span title="(a: List[Init.this.Undefined])scala.util.Left[List[Init.this.Undefined],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;Init;ValidationCapture.validateKeyReferenced.un" title="Init.this.Undefined">un</a> <a href="#sbt;Init;ValidationCapture.validateKeyReferenced.x$27" title="(x: Init.this.Undefined)List[Init.this.Undefined]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
      <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="Init.this.ScopedKey[T]" id="sbt;Init;ValidationCapture.validateKeyReferenced.k">k</a><span class="delimiter">)</span> =&gt; <span title="(b: Init.this.ValidationCapture[T])scala.util.Right[Nothing,Init.this.ValidationCapture[T]]">Right</span><span class="delimiter">(</span><span title="Init.this.ValidationCapture[T]" class="keyword">new</span> <a href="#sbt;Init;ValidationCapture" title="Init.this.ValidationCapture[T]">ValidationCapture</a><span class="delimiter">(</span><a href="#sbt;Init;ValidationCapture.validateKeyReferenced.k" title="Init.this.ScopedKey[T]">k</a>, <a href="#sbt;Init;ValidationCapture.selfRefOk" title="=&gt; Boolean">selfRefOk</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;ValidationCapture.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;ValidationCapture.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;ValidationCapture.processAttributes.init">init</a>: <a href="#sbt;Init;ValidationCapture.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;ValidationCapture.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;ValidationCapture.processAttributes;S" title="S">S</a> = <a href="#sbt;Init;ValidationCapture.processAttributes.init" title="S">init</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Bind[S, T] extends AnyRef with Init.this.Initialize[T]" id="sbt;Init;Bind">Bind</a><span class="delimiter">[</span><a title="" id="sbt;Init;Bind;S">S</a>, <a title="" id="sbt;Init;Bind;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;Bind" title="Init.this.Bind[S,T]" class="delimiter">(</a><span class="keyword">val</span> <a title="S =&gt; Init.this.Initialize[T]" id="sbt;Init;Bind.f">f</a>: S =&gt; Initialize<span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Init.this.Initialize[S]" id="sbt;Init;Bind.in">in</a>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[S]">Initialize</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.ScopedKey[_]]" id="sbt;Init;Bind.dependencies">dependencies</a> = <a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a>.<a href="#sbt;Init;Initialize.dependencies" title="=&gt; Seq[Init.this.ScopedKey[_]]">dependencies</a>
    <span class="keyword">def</span> <a title="[Z](g: T =&gt; Z)Init.this.Initialize[Z]" id="sbt;Init;Bind.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Bind.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Z" id="sbt;Init;Bind.apply.g">g</a>: T =&gt; Z<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Z]">Initialize</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <span title="Init.this.Bind[S,Z]" class="keyword">new</span> <a href="#sbt;Init;Bind" title="Init.this.Bind[S,Z]">Bind</a><span class="delimiter">[</span>S, Z<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Bind.apply.$anonfun.s">s</a> =&gt; <a href="#sbt;Init;Bind.f" title="(v1: S)Init.this.Initialize[T]">f</a><a href="#sbt;Init;Initialize.apply" title="(g: T =&gt; Z)Init.this.Initialize[Z]" class="delimiter">(</a><a href="#sbt;Init;Bind.apply.$anonfun.s" title="S">s</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;Bind.apply.g" title="T =&gt; Z">g</a><span class="delimiter">)</span>, <a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(ss: sbt.Settings[Scope])T" id="sbt;Init;Bind.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;Bind.evaluate.ss">ss</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Bind;T" title="T">T</a> = <a href="#sbt;Init;Bind.f" title="(v1: S)Init.this.Initialize[T]">f</a><span class="delimiter">(</span><a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a> <a href="#sbt;Init;Initialize.evaluate" title="(map: sbt.Settings[Scope])S">evaluate</a> <a href="#sbt;Init;Bind.evaluate.ss" title="sbt.Settings[Scope]">ss</a><span class="delimiter">)</span> <a href="#sbt;Init;Initialize.evaluate" title="(map: sbt.Settings[Scope])T">evaluate</a> <a href="#sbt;Init;Bind.evaluate.ss" title="sbt.Settings[Scope]">ss</a>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Bind[S,T]" id="sbt;Init;Bind.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Bind.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <span title="Init.this.Bind[S,T]" class="keyword">new</span> <a href="#sbt;Init;Bind" title="Init.this.Bind[S,T]">Bind</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Bind.mapReferenced.$anonfun.s">s</a> =&gt; <a href="#sbt;Init;Bind.f" title="(v1: S)Init.this.Initialize[T]">f</a><span class="delimiter">(</span><a href="#sbt;Init;Bind.mapReferenced.$anonfun.s" title="S">s</a><span class="delimiter">)</span> <a href="#sbt;Init;Initialize.mapReferenced" title="(g: Init.this.MapScoped)Init.this.Initialize[T]">mapReferenced</a> <a href="#sbt;Init;Bind.mapReferenced.g" title="Init.this.MapScoped">g</a>, <a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a> <a href="#sbt;Init;Initialize.mapReferenced" title="(g: Init.this.MapScoped)Init.this.Initialize[S]">mapReferenced</a> <a href="#sbt;Init;Bind.mapReferenced.g" title="Init.this.MapScoped">g</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Product with Serializable with scala.util.Either[Seq[Init.this.Undefined],Init.this.Bind[S,T]]" id="sbt;Init;Bind.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Bind.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a> <a href="#sbt;Init;Initialize.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[S]">validateKeyReferenced</a> <a href="#sbt;Init;Bind.validateKeyReferenced.g" title="Init.this.ValidateKeyRef">g</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[Init.this.Undefined],Init.this.Initialize[S]]">right</span>.<span title="(f: Init.this.Initialize[S] =&gt; Init.this.Bind[S,T])Product with Serializable with scala.util.Either[Seq[Init.this.Undefined],Init.this.Bind[S,T]]">map</span> <span class="delimiter">{</span> <a title="Init.this.Initialize[S]" id="sbt;Init;Bind.validateKeyReferenced.$anonfun.validIn">validIn</a> =&gt;
      <span title="Init.this.Bind[S,T]" class="keyword">new</span> <a href="#sbt;Init;Bind" title="Init.this.Bind[S,T]">Bind</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Bind.validateKeyReferenced.$anonfun.$anonfun.s">s</a> =&gt; <a href="#sbt;Init.handleUndefined" title="(vr: Init.this.ValidatedInit[T])Init.this.Initialize[T]">handleUndefined</a><span class="delimiter">(</span><a href="#sbt;Init;Bind.f" title="(v1: S)Init.this.Initialize[T]">f</a><span class="delimiter">(</span><a href="#sbt;Init;Bind.validateKeyReferenced.$anonfun.$anonfun.s" title="S">s</a><span class="delimiter">)</span> <a href="#sbt;Init;Initialize.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]">validateKeyReferenced</a> <a href="#sbt;Init;Bind.validateKeyReferenced.g" title="Init.this.ValidateKeyRef">g</a><span class="delimiter">)</span>, <a href="#sbt;Init;Bind.validateKeyReferenced.$anonfun.validIn" title="Init.this.Initialize[S]">validIn</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Bind[S,T]" id="sbt;Init;Bind.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Bind.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> = <span title="Init.this.Bind[S,T]" class="keyword">new</span> <a href="#sbt;Init;Bind" title="Init.this.Bind[S,T]">Bind</a><span class="delimiter">[</span>S, T<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Bind.mapConstant.$anonfun.s">s</a> =&gt; <a href="#sbt;Init;Bind.f" title="(v1: S)Init.this.Initialize[T]">f</a><span class="delimiter">(</span><a href="#sbt;Init;Bind.mapConstant.$anonfun.s" title="S">s</a><span class="delimiter">)</span> <a href="#sbt;Init;Initialize.mapConstant" title="(g: Init.this.MapConstant)Init.this.Initialize[T]">mapConstant</a> <a href="#sbt;Init;Bind.mapConstant.g" title="Init.this.MapConstant">g</a>, <a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a> <a href="#sbt;Init;Initialize.mapConstant" title="(g: Init.this.MapConstant)Init.this.Initialize[S]">mapConstant</a> <a href="#sbt;Init;Bind.mapConstant.g" title="Init.this.MapConstant">g</a><span class="delimiter">)</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;Bind.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;Bind.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Bind.processAttributes.init">init</a>: <a href="#sbt;Init;Bind.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;Bind.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Bind.processAttributes;S" title="S">S</a> = <a href="#sbt;Init;Bind.in" title="=&gt; Init.this.Initialize[S]">in</a>.<a href="#sbt;Init;Initialize.processAttributes" title="(init: S)(f: (S, sbt.AttributeMap) =&gt; S)S">processAttributes</a><span class="delimiter">(</span><a href="#sbt;Init;Bind.processAttributes.init" title="S">init</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;Bind.processAttributes.f" title="(S, sbt.AttributeMap) =&gt; S">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Optional[S, T] extends AnyRef with Init.this.Initialize[T]" id="sbt;Init;Optional">Optional</a><span class="delimiter">[</span><a title="" id="sbt;Init;Optional;S">S</a>, <a title="" id="sbt;Init;Optional;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;Optional" title="Init.this.Optional[S,T]" class="delimiter">(</a><span class="keyword">val</span> <a title="Option[Init.this.Initialize[S]]" id="sbt;Init;Optional.a">a</a>: <span title="Option[Init.this.Initialize[S]]">Option</span><span class="delimiter">[</span>Initialize<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Option[S] =&gt; T" id="sbt;Init;Optional.f">f</a>: Option<span class="delimiter">[</span>S<span class="delimiter">]</span> =&gt; T<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.ScopedKey[_]]" id="sbt;Init;Optional.dependencies">dependencies</a> = <a href="#sbt;Init.deps" title="(ls: Seq[Init.this.Initialize[_]])Seq[Init.this.ScopedKey[_]]">deps</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a>.<span title="=&gt; List[Init.this.Initialize[S]]">toList</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[Z](g: T =&gt; Z)Init.this.Initialize[Z]" id="sbt;Init;Optional.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Optional.apply;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Z" id="sbt;Init;Optional.apply.g">g</a>: T =&gt; Z<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Z]">Initialize</a><span class="delimiter">[</span>Z<span class="delimiter">]</span> = <span title="Init.this.Optional[S,Z]" class="keyword">new</span> <a href="#sbt;Init;Optional" title="Init.this.Optional[S,Z]">Optional</a><span class="delimiter">[</span>S, Z<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a>, <a href="#sbt;Init;Optional.apply.g" title="T =&gt; Z">g</a> <span title="(g: Option[S] =&gt; T)Option[S] =&gt; Z">compose</span> <a href="#sbt;Init;Optional.f" title="=&gt; Option[S] =&gt; T">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Optional[S,T]" id="sbt;Init;Optional.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Optional.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <span title="Init.this.Optional[S,T]" class="keyword">new</span> <a href="#sbt;Init;Optional" title="Init.this.Optional[S,T]">Optional</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a> <span title="(f: Init.this.Initialize[S] =&gt; Init.this.Initialize[S])Option[Init.this.Initialize[S]]">map</span> <a href="#sbt;Init.mapReferencedT" title="(g: Init.this.MapScoped)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">mapReferencedT</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.mapReferenced.g" title="Init.this.MapScoped">g</a><span class="delimiter">)</span>.<a href="TypeFunctions.scala.html#sbt;~>.fn" title="Init.this.Initialize[S] =&gt; Init.this.Initialize[S]">fn</a>, <a href="#sbt;Init;Optional.f" title="=&gt; Option[S] =&gt; T">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]" id="sbt;Init;Optional.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Optional.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> = <a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a> <span title="Init.this.ValidatedInit[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span>    =&gt; <span title="(b: Init.this.Optional[S,T])scala.util.Right[Nothing,Init.this.Optional[S,T]]">Right</span><span class="delimiter">(</span><a href="#sbt;Init;Optional" title="Init.this.Optional[S,T]" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init;Optional.validateKeyReferenced.i">i</a><span class="delimiter">)</span> =&gt; <span title="(b: Init.this.Optional[S,T])scala.util.Right[Nothing,Init.this.Optional[S,T]]">Right</span><span class="delimiter">(</span><span title="Init.this.Optional[S,T]" class="keyword">new</span> <a href="#sbt;Init;Optional" title="Init.this.Optional[S,T]">Optional</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.validateKeyReferenced.i" title="Init.this.Initialize[S]">i</a>.<a href="#sbt;Init;Initialize.validateKeyReferenced" title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[S]">validateKeyReferenced</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.validateKeyReferenced.g" title="Init.this.ValidateKeyRef">g</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[Init.this.Undefined],Init.this.Initialize[S]]">right</span>.<span title="=&gt; Option[Init.this.Initialize[S]]">toOption</span>, <a href="#sbt;Init;Optional.f" title="=&gt; Option[S] =&gt; T">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Initialize[T]" id="sbt;Init;Optional.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Optional.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Optional[S,T]" class="keyword">new</span> <a href="#sbt;Init;Optional" title="Init.this.Optional[S,T]">Optional</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a> <span title="(f: Init.this.Initialize[S] =&gt; Init.this.Initialize[S])Option[Init.this.Initialize[S]]">map</span> <a href="#sbt;Init.mapConstantT" title="(g: Init.this.MapConstant)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">mapConstantT</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.mapConstant.g" title="Init.this.MapConstant">g</a><span class="delimiter">)</span>.<a href="TypeFunctions.scala.html#sbt;~>.fn" title="Init.this.Initialize[S] =&gt; Init.this.Initialize[S]">fn</a>, <a href="#sbt;Init;Optional.f" title="=&gt; Option[S] =&gt; T">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(ss: sbt.Settings[Scope])T" id="sbt;Init;Optional.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;Optional.evaluate.ss">ss</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Optional;T" title="T">T</a> = <a href="#sbt;Init;Optional.f" title="(v1: Option[S])T">f</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a>.<span title="(f: Init.this.Initialize[S] =&gt; Option[sbt.Types.Id[S]])Option[sbt.Types.Id[S]]">flatMap</span><span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init;Optional.evaluate.$anonfun.i">i</a> =&gt; <a href="#sbt;Init;Optional.trapBadRef" title="(run: =&gt; sbt.Types.Id[S])Option[sbt.Types.Id[S]]">trapBadRef</a><span class="delimiter">(</span><a href="#sbt;Init.evaluateT" title="(g: sbt.Settings[Scope])sbt.~&gt;[Init.this.Initialize,sbt.Types.Id]">evaluateT</a><a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: Init.this.Initialize[S])sbt.Types.Id[S]" class="delimiter">(</a><a href="#sbt;Init;Optional.evaluate.ss" title="sbt.Settings[Scope]">ss</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;Optional.evaluate.$anonfun.i" title="Init.this.Initialize[S]">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// proper solution is for evaluate to be deprecated or for external use only and a new internal method returning Either be used</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[A](run: =&gt; A)Option[A]" id="sbt;Init;Optional.trapBadRef">trapBadRef</a><span class="delimiter">[</span><a title="" id="sbt;Init;Optional.trapBadRef;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="sbt;Init;Optional.trapBadRef.run">run</a>: =&gt; A<span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="keyword">try</span> <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#sbt;Init;Optional.trapBadRef.run" title="=&gt; A">run</a><span class="delimiter">)</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Init.this.InvalidReference" id="sbt;Init;Optional.trapBadRef.e">e</a>: <a href="#sbt;Init;InvalidReference" title="Init.this.InvalidReference">InvalidReference</a> =&gt; <span title="None.type">None</span> <span class="delimiter">}</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;Optional.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;Optional.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Optional.processAttributes.init">init</a>: <a href="#sbt;Init;Optional.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;Optional.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Optional.processAttributes;S" title="S">S</a> = <a href="#sbt;Init;Optional.a" title="=&gt; Option[Init.this.Initialize[S]]">a</a> <span title="S" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span>    =&gt; <a href="#sbt;Init;Optional.processAttributes.init" title="S">init</a>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="Init.this.Initialize[S]" id="sbt;Init;Optional.processAttributes.i">i</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Init;Optional.processAttributes.i" title="Init.this.Initialize[S]">i</a>.<a href="#sbt;Init;Initialize.processAttributes" title="(init: S)(f: (S, sbt.AttributeMap) =&gt; S)S">processAttributes</a><span class="delimiter">(</span><a href="#sbt;Init;Optional.processAttributes.init" title="S">init</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;Optional.processAttributes.f" title="(S, sbt.AttributeMap) =&gt; S">f</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Value[T] extends AnyRef with Init.this.Initialize[T]" id="sbt;Init;Value">Value</a><span class="delimiter">[</span><a title="" id="sbt;Init;Value;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;Value" title="Init.this.Value[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="() =&gt; T" id="sbt;Init;Value.value">value</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="sbt;Init;Value.dependencies">dependencies</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Value[T]" id="sbt;Init;Value.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Value.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <a href="#sbt;Init;Value" title="Init.this.Value[T]" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)scala.util.Right[Nothing,Init.this.Value[T]]" id="sbt;Init;Value.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Value.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> = <span title="(b: Init.this.Value[T])scala.util.Right[Nothing,Init.this.Value[T]]">Right</span><span class="delimiter">(</span><a href="#sbt;Init;Value" title="Init.this.Value[T]" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S](g: T =&gt; S)Init.this.Value[S]" id="sbt;Init;Value.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Value.apply;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; S" id="sbt;Init;Value.apply.g">g</a>: T =&gt; S<span class="delimiter">)</span> = <span title="Init.this.Value[S]" class="keyword">new</span> <a href="#sbt;Init;Value" title="Init.this.Value[S]">Value</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#sbt;Init;Value.apply.g" title="(v1: T)S">g</a><span class="delimiter">(</span><a href="#sbt;Init;Value.value" title="()T">value</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Value[T]" id="sbt;Init;Value.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Value.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> = <a href="#sbt;Init;Value" title="Init.this.Value[T]" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(map: sbt.Settings[Scope])T" id="sbt;Init;Value.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;Value.evaluate.map">map</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;Init;Value;T" title="T">T</a> = <a href="#sbt;Init;Value.value" title="()T">value</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;Value.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;Value.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Value.processAttributes.init">init</a>: <a href="#sbt;Init;Value.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;Value.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Value.processAttributes;S" title="S">S</a> = <a href="#sbt;Init;Value.processAttributes.init" title="S">init</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">object</span> <a title="Init.this.StaticScopes.type" id="sbt;Init.StaticScopes">StaticScopes</a> <a href="#sbt;Init.StaticScopes" title="Init.this.StaticScopes.type" class="keyword">extends</a> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[Set[Scope]]">Initialize</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="sbt;Init.StaticScopes.dependencies">dependencies</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.StaticScopes.type" id="sbt;Init.StaticScopes.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init.StaticScopes.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <span class="keyword">this</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)scala.util.Right[Nothing,Init.this.StaticScopes.type]" id="sbt;Init.StaticScopes.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init.StaticScopes.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> = <span title="(b: Init.this.StaticScopes.type)scala.util.Right[Nothing,Init.this.StaticScopes.type]">Right</span><span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S](g: Set[Scope] =&gt; S)Init.this.Initialize[S]" id="sbt;Init.StaticScopes.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init.StaticScopes.apply;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Set[Scope] =&gt; S" id="sbt;Init.StaticScopes.apply.g">g</a>: Set<span class="delimiter">[</span>Scope<span class="delimiter">]</span> =&gt; S<span class="delimiter">)</span> = <a href="#sbt;Init.map" title="(in: Init.this.Initialize[Set[Scope]])(f: Set[Scope] =&gt; S)Init.this.Initialize[S]">map</a><span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init.StaticScopes.apply.g" title="Set[Scope] =&gt; S">g</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.StaticScopes.type" id="sbt;Init.StaticScopes.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init.StaticScopes.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> = <span class="keyword">this</span>
    <span class="keyword">def</span> <a title="(map: sbt.Settings[Scope])Set[Scope]" id="sbt;Init.StaticScopes.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init.StaticScopes.evaluate.map">map</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init.StaticScopes.evaluate.map" title="sbt.Settings[Scope]">map</a>.<a href="#sbt;Settings.scopes" title="=&gt; Set[Scope]">scopes</a>
    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init.StaticScopes.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init.StaticScopes.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init.StaticScopes.processAttributes.init">init</a>: <a href="#sbt;Init.StaticScopes.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init.StaticScopes.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init.StaticScopes.processAttributes;S" title="S">S</a> = <a href="#sbt;Init.StaticScopes.processAttributes.init" title="S">init</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Apply[K[L[x]], T] extends AnyRef with Init.this.Initialize[T]" id="sbt;Init;Apply">Apply</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt;Init;Apply;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt;Init;Apply;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt;Init;Apply;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt;Init;Apply;T">T</a><span class="delimiter">]</span><a href="#sbt;Init;Apply" title="Init.this.Apply[K,T]" class="delimiter">(</a><span class="keyword">val</span> <a title="K[sbt.Types.Id] =&gt; T" id="sbt;Init;Apply.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; T, <span class="keyword">val</span> <a title="K[Init.this.Initialize]" id="sbt;Init;Apply.inputs">inputs</a>: <a href="#sbt;Init;Apply;K" title="K[Init.this.Initialize]">K</a><span class="delimiter">[</span>Initialize<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="sbt.AList[K]" id="sbt;Init;Apply.alist">alist</a>: <a href="AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Init.this.ScopedKey[_]]" id="sbt;Init;Apply.dependencies">dependencies</a> = <a href="#sbt;Init.deps" title="(ls: Seq[Init.this.Initialize[_]])Seq[Init.this.ScopedKey[_]]">deps</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.toList" title="(value: K[Init.this.Initialize])List[Init.this.Initialize[_]]">toList</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.inputs" title="=&gt; K[Init.this.Initialize]">inputs</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapScoped)Init.this.Initialize[T]" id="sbt;Init;Apply.mapReferenced">mapReferenced</a><span class="delimiter">(</span><a title="Init.this.MapScoped" id="sbt;Init;Apply.mapReferenced.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapScoped">MapScoped</a><span class="delimiter">)</span> = <a href="#sbt;Init;Apply.mapInputs" title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])Init.this.Initialize[T]">mapInputs</a><span class="delimiter">(</span><a href="#sbt;Init.mapReferencedT" title="(g: Init.this.MapScoped)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">mapReferencedT</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.mapReferenced.g" title="Init.this.MapScoped">g</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S](g: T =&gt; S)Init.this.Apply[K,S]" id="sbt;Init;Apply.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Apply.apply;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; S" id="sbt;Init;Apply.apply.g">g</a>: T =&gt; S<span class="delimiter">)</span> = <span title="Init.this.Apply[K,S]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[K,S]">Apply</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.apply.g" title="T =&gt; S">g</a> <span title="(g: K[sbt.Types.Id] =&gt; T)K[sbt.Types.Id] =&gt; S">compose</span> <a href="#sbt;Init;Apply.f" title="=&gt; K[sbt.Types.Id] =&gt; T">f</a>, <a href="#sbt;Init;Apply.inputs" title="=&gt; K[Init.this.Initialize]">inputs</a>, <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.MapConstant)Init.this.Initialize[T]" id="sbt;Init;Apply.mapConstant">mapConstant</a><span class="delimiter">(</span><a title="Init.this.MapConstant" id="sbt;Init;Apply.mapConstant.g">g</a>: <a href="TypeFunctions.scala.html#sbt;~>" title="Init.this.MapConstant">MapConstant</a><span class="delimiter">)</span> = <a href="#sbt;Init;Apply.mapInputs" title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])Init.this.Initialize[T]">mapInputs</a><span class="delimiter">(</span><a href="#sbt;Init.mapConstantT" title="(g: Init.this.MapConstant)sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">mapConstantT</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.mapConstant.g" title="Init.this.MapConstant">g</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])Init.this.Initialize[T]" id="sbt;Init;Apply.mapInputs">mapInputs</a><span class="delimiter">(</span><a title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]" id="sbt;Init;Apply.mapInputs.g">g</a>: Initialize <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">~&gt;</a> Initialize<span class="delimiter">)</span>: <a href="#sbt;Init;Initialize" title="Init.this.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Init.this.Apply[K,T]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[K,T]">Apply</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.f" title="=&gt; K[sbt.Types.Id] =&gt; T">f</a>, <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.transform" title="(value: K[Init.this.Initialize], f: sbt.~&gt;[Init.this.Initialize,Init.this.Initialize])K[Init.this.Initialize]">transform</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.inputs" title="=&gt; K[Init.this.Initialize]">inputs</a>, <a href="#sbt;Init;Apply.mapInputs.g" title="sbt.~&gt;[Init.this.Initialize,Init.this.Initialize]">g</a><span class="delimiter">)</span>, <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(ss: sbt.Settings[Scope])T" id="sbt;Init;Apply.evaluate">evaluate</a><span class="delimiter">(</span><a title="sbt.Settings[Scope]" id="sbt;Init;Apply.evaluate.ss">ss</a>: <a href="#sbt;Settings" title="sbt.Settings[Scope]">Settings</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init;Apply.f" title="(v1: K[sbt.Types.Id])T">f</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.transform" title="(value: K[Init.this.Initialize], f: sbt.~&gt;[Init.this.Initialize,sbt.Types.Id])K[sbt.Types.Id]">transform</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.inputs" title="=&gt; K[Init.this.Initialize]">inputs</a>, <a href="#sbt;Init.evaluateT" title="(g: sbt.Settings[Scope])sbt.~&gt;[Init.this.Initialize,sbt.Types.Id]">evaluateT</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.evaluate.ss" title="sbt.Settings[Scope]">ss</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(g: Init.this.ValidateKeyRef)Init.this.ValidatedInit[T]" id="sbt;Init;Apply.validateKeyReferenced">validateKeyReferenced</a><span class="delimiter">(</span><a title="Init.this.ValidateKeyRef" id="sbt;Init;Apply.validateKeyReferenced.g">g</a>: <a href="#sbt;Init;ValidateKeyRef" title="Init.this.ValidateKeyRef">ValidateKeyRef</a><span class="delimiter">)</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="K[Init.this.ValidatedInit]" id="sbt;Init;Apply.validateKeyReferenced.tx">tx</a> = <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.transform" title="(value: K[Init.this.Initialize], f: sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit])K[Init.this.ValidatedInit]">transform</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.inputs" title="=&gt; K[Init.this.Initialize]">inputs</a>, <a href="#sbt;Init.validateKeyReferencedT" title="(g: Init.this.ValidateKeyRef)sbt.~&gt;[Init.this.Initialize,Init.this.ValidatedInit]">validateKeyReferencedT</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.validateKeyReferenced.g" title="Init.this.ValidateKeyRef">g</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Init.this.Undefined]" id="sbt;Init;Apply.validateKeyReferenced.undefs">undefs</a> = <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.toList" title="(value: K[Init.this.ValidatedInit])List[Init.this.ValidatedInit[_]]">toList</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.validateKeyReferenced.tx" title="K[Init.this.ValidatedInit]">tx</a><span class="delimiter">)</span>.<span title="(f: Init.this.ValidatedInit[_] =&gt; scala.collection.GenTraversableOnce[Init.this.Undefined])(implicit bf: scala.collection.generic.CanBuildFrom[List[Init.this.ValidatedInit[_]],Init.this.Undefined,List[Init.this.Undefined]])List[Init.this.Undefined]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Init.this.Undefined,List[Init.this.Undefined]]" class="delimiter">(</span><a href="#sbt;Init;Apply.validateKeyReferenced.undefs.$anonfun.x$28" title="Init.this.ValidatedInit[_]">_</a>.<span title="=&gt; scala.util.Either.LeftProjection[Seq[Init.this.Undefined],Init.this.Initialize[_$2]]">left</span>.<span title="=&gt; Seq[Seq[Init.this.Undefined]]">toSeq</span>.<span title="(implicit asTraversable: Seq[Init.this.Undefined] =&gt; scala.collection.GenTraversableOnce[Init.this.Undefined])Seq[Init.this.Undefined]">flatten</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="get extends AnyRef with sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]" id="sbt;Init;Apply.validateKeyReferenced.get">get</a> = <a href="#sbt;Init;Apply.validateKeyReferenced.get;$anon" title="sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]" id="sbt;Init;Apply.validateKeyReferenced.get;$anon" class="delimiter">(</a>ValidatedInit <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]">~&gt;</a> Initialize<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](vr: Init.this.ValidatedInit[T])Init.this.Initialize[T]" id="sbt;Init;Apply.validateKeyReferenced.get;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Init;Apply.validateKeyReferenced.get;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Init.this.ValidatedInit[T]" id="sbt;Init;Apply.validateKeyReferenced.get;$anon.apply.vr">vr</a>: <span title="Init.this.ValidatedInit[T]">ValidatedInit</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Init;Apply.validateKeyReferenced.get;$anon.apply.vr" title="Init.this.ValidatedInit[T]">vr</a>.<span title="=&gt; scala.util.Either.RightProjection[Seq[Init.this.Undefined],Init.this.Initialize[T]]">right</span>.<span title="=&gt; Init.this.Initialize[T]">get</span> <span class="delimiter">}</span>
        <span title="Init.this.ValidatedInit[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Init;Apply.validateKeyReferenced.undefs" title="List[Init.this.Undefined]">undefs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(b: Init.this.Apply[K,T])scala.util.Right[Nothing,Init.this.Apply[K,T]]">Right</span><span class="delimiter">(</span><span title="Init.this.Apply[K,T]" class="keyword">new</span> <a href="#sbt;Init;Apply" title="Init.this.Apply[K,T]">Apply</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.f" title="=&gt; K[sbt.Types.Id] =&gt; T">f</a>, <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.transform" title="(value: K[Init.this.ValidatedInit], f: sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize])K[Init.this.Initialize]">transform</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.validateKeyReferenced.tx" title="K[Init.this.ValidatedInit]">tx</a>, <a href="#sbt;Init;Apply.validateKeyReferenced.get" title="get extends AnyRef with sbt.~&gt;[Init.this.ValidatedInit,Init.this.Initialize]">get</a><span class="delimiter">)</span>, <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="(a: List[Init.this.Undefined])scala.util.Left[List[Init.this.Undefined],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;Init;Apply.validateKeyReferenced.undefs" title="List[Init.this.Undefined]">undefs</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[S](init: S)(f: (S, sbt.AttributeMap) =&gt; S)S" id="sbt;Init;Apply.processAttributes">processAttributes</a><span class="delimiter">[</span><a title="" id="sbt;Init;Apply.processAttributes;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="sbt;Init;Apply.processAttributes.init">init</a>: <a href="#sbt;Init;Apply.processAttributes;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, sbt.AttributeMap) =&gt; S" id="sbt;Init;Apply.processAttributes.f">f</a>: <span class="delimiter">(</span>S, AttributeMap<span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt;Init;Apply.processAttributes;S" title="S">S</a> =
      <span class="delimiter">(</span><a href="#sbt;Init;Apply.processAttributes.init" title="S">init</a> <a href="#sbt;Init;Apply.processAttributes.x$29" title="(z: S)(op: (S, Init.this.Initialize[_]) =&gt; S)S">/:</a> <a href="#sbt;Init;Apply.alist" title="=&gt; sbt.AList[K]">alist</a>.<a href="AList.scala.html#sbt;AList.toList" title="(value: K[Init.this.Initialize])List[Init.this.Initialize[_]]">toList</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.inputs" title="=&gt; K[Init.this.Initialize]">inputs</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="S" id="sbt;Init;Apply.processAttributes.$anonfun.v">v</a>, <a title="Init.this.Initialize[_]" id="sbt;Init;Apply.processAttributes.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Init;Apply.processAttributes.$anonfun.i" title="Init.this.Initialize[_]">i</a>.<a href="#sbt;Init;Initialize.processAttributes" title="(init: S)(f: (S, sbt.AttributeMap) =&gt; S)S">processAttributes</a><span class="delimiter">(</span><a href="#sbt;Init;Apply.processAttributes.$anonfun.v" title="S">v</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Init;Apply.processAttributes.f" title="(S, sbt.AttributeMap) =&gt; S">f</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](s: Seq[T], v: T)Seq[T]" id="sbt;Init.remove">remove</a><span class="delimiter">[</span><a title="" id="sbt;Init.remove;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="sbt;Init.remove.s">s</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T" id="sbt;Init.remove.v">v</a>: <a href="#sbt;Init.remove;T" title="T">T</a><span class="delimiter">)</span> = <a href="#sbt;Init.remove.s" title="Seq[T]">s</a> <span title="(p: T =&gt; Boolean)Seq[T]">filterNot</span> <span class="delimiter">(</span><a href="#sbt;Init.remove.$anonfun.x$30" title="T">_</a> <span title="(x$1: Any)Boolean">==</span> <a href="#sbt;Init.remove.v" title="T">v</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
