<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>xsbt/Dependency.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2008, 2009 Mark Harrah
 */</span>
<span class="keyword">package</span> xsbt

<span class="keyword">import</span> scala.tools.nsc.<span class="delimiter">{</span> io, symtab, Phase <span class="delimiter">}</span>
<span class="keyword">import</span> io.<span class="delimiter">{</span> AbstractFile, PlainFile, ZipArchive <span class="delimiter">}</span>
<span class="keyword">import</span> symtab.Flags
<span class="keyword">import</span> xsbti.DependencyContext
<span class="keyword">import</span> xsbti.<a href="../xsbti/DependencyContext.java.html#xsbti.DependencyContext" title="xsbti.DependencyContext.type">DependencyContext</a>._

<span class="keyword">import</span> java.io.File

<span class="keyword">object</span> <a title="xsbt.Dependency.type" id="xsbt.Dependency">Dependency</a> <a href="#xsbt.Dependency" title="xsbt.Dependency.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="=&gt; String" id="xsbt.Dependency.name">name</a> = <span title="String(&quot;xsbt-dependency&quot;)" class="string">&quot;xsbt-dependency&quot;</span>
<span class="delimiter">}</span>
<span class="comment">/**
 * Extracts dependency information from each compilation unit.
 *
 * This phase uses CompilationUnit.depends and CallbackGlobal.inheritedDependencies
 * to collect all symbols that given compilation unit depends on. Those symbols are
 * guaranteed to represent Class-like structures.
 *
 * The CallbackGlobal.inheritedDependencies is populated by the API phase. See,
 * ExtractAPI class.
 *
 * When dependency symbol is processed, it is mapped back to either source file where
 * it's defined in (if it's available in current compilation run) or classpath entry
 * where it originates from. The Symbol-&gt;Classfile mapping is implemented by
 * LocateClassFile that we inherit from.
 */</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class Dependency extends xsbt.LocateClassFile" id="xsbt;Dependency">Dependency</a><a href="#xsbt;Dependency" title="xsbt.Dependency" class="delimiter">(</a><span class="keyword">val</span> <a title="xsbt.CallbackGlobal" id="xsbt;Dependency.global">global</a>: <a href="CompilerInterface.scala.html#xsbt;CallbackGlobal" title="xsbt.CallbackGlobal">CallbackGlobal</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="LocateClassFile.scala.html#xsbt;LocateClassFile" title="xsbt.LocateClassFile">LocateClassFile</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#xsbt;Dependency.global" title="=&gt; xsbt.CallbackGlobal">global</a>._

  <span class="keyword">def</span> <a title="(prev: tools.nsc.Phase)tools.nsc.Phase" id="xsbt;Dependency.newPhase">newPhase</a><span class="delimiter">(</span><a title="tools.nsc.Phase" id="xsbt;Dependency.newPhase.prev">prev</a>: <span title="tools.nsc.Phase">Phase</span><span class="delimiter">)</span>: <span title="tools.nsc.Phase">Phase</span> = <span title="Dependency.this.DependencyPhase" class="keyword">new</span> <a href="#xsbt;Dependency;DependencyPhase" title="Dependency.this.DependencyPhase">DependencyPhase</a><span class="delimiter">(</span><a href="#xsbt;Dependency.newPhase.prev" title="tools.nsc.Phase">prev</a><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">class</span> <a title="class DependencyPhase extends Dependency.this.global.GlobalPhase" id="xsbt;Dependency;DependencyPhase">DependencyPhase</a><a href="#xsbt;Dependency;DependencyPhase" title="Dependency.this.DependencyPhase" class="delimiter">(</a><a title="tools.nsc.Phase" id="xsbt;Dependency;DependencyPhase.prev">prev</a>: <span title="tools.nsc.Phase">Phase</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#xsbt;Dependency.global" title="Dependency.this.global.GlobalPhase">GlobalPhase</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.prev" title="tools.nsc.Phase">prev</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="xsbt;Dependency;DependencyPhase.description">description</a> = <span title="String(&quot;Extracts dependency information&quot;)" class="string">&quot;Extracts dependency information&quot;</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="xsbt;Dependency;DependencyPhase.name">name</a> = <a href="#xsbt.Dependency" title="xsbt.Dependency.type">Dependency</a>.<a href="#xsbt.Dependency.name" title="=&gt; String">name</a>
    <span class="keyword">def</span> <a title="(unit: Dependency.this.global.CompilationUnit)Unit" id="xsbt;Dependency;DependencyPhase.apply">apply</a><span class="delimiter">(</span><a title="Dependency.this.global.CompilationUnit" id="xsbt;Dependency;DependencyPhase.apply.unit">unit</a>: <span title="Dependency.this.global.CompilationUnit">CompilationUnit</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#xsbt;Dependency;DependencyPhase.apply.unit" title="Dependency.this.global.CompilationUnit">unit</a>.<span title="=&gt; Boolean">isJava</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// build dependencies structure</span>
        <span class="keyword">val</span> <a title="java.io.File" id="xsbt;Dependency;DependencyPhase.apply.sourceFile">sourceFile</a> = <a href="#xsbt;Dependency;DependencyPhase.apply.unit" title="Dependency.this.global.CompilationUnit">unit</a>.<span title="=&gt; scala.reflect.internal.util.SourceFile">source</span>.<span title="=&gt; scala.reflect.io.AbstractFile">file</span>.<span title="=&gt; java.io.File">file</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency.global" title="=&gt; xsbt.CallbackGlobal">global</a>.<a href="CompilerInterface.scala.html#xsbt;CallbackGlobal.callback" title="=&gt; xsbti.AnalysisCallback">callback</a>.<a href="../xsbti/AnalysisCallback.java.html#xsbti;AnalysisCallback.nameHashing" title="()Boolean">nameHashing</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Dependency.this.ExtractDependenciesTraverser" id="xsbt;Dependency;DependencyPhase.apply.dependencyExtractor">dependencyExtractor</a> = <span title="Dependency.this.ExtractDependenciesTraverser" class="keyword">new</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser" title="Dependency.this.ExtractDependenciesTraverser">ExtractDependenciesTraverser</a>
          <a href="#xsbt;Dependency;DependencyPhase.apply.dependencyExtractor" title="Dependency.this.ExtractDependenciesTraverser">dependencyExtractor</a>.<a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse" title="(tree: Dependency.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.unit" title="Dependency.this.global.CompilationUnit">unit</a>.<span title="=&gt; Dependency.this.global.Tree">body</span><span class="delimiter">)</span>

          <a href="#xsbt;Dependency;DependencyPhase.apply.dependencyExtractor" title="Dependency.this.ExtractDependenciesTraverser">dependencyExtractor</a>.<a href="#xsbt;Dependency;ExtractDependenciesTraverser.topLevelDependencies" title="=&gt; Iterator[Dependency.this.global.Symbol]">topLevelDependencies</a> <span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span> <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency" title="(context: xsbti.DependencyContext)(on: Dependency.this.global.Symbol)Unit">processDependency</a><a href="#xsbt;Dependency;DependencyPhase.apply.$anonfun.on" title="Dependency.this.global.Symbol" class="delimiter">(</a>context = <span title="xsbti.DependencyContext(DependencyByMemberRef)">DependencyByMemberRef</span><span class="delimiter">)</span>
          <a href="#xsbt;Dependency;DependencyPhase.apply.dependencyExtractor" title="Dependency.this.ExtractDependenciesTraverser">dependencyExtractor</a>.<a href="#xsbt;Dependency;ExtractDependenciesTraverser.topLevelInheritanceDependencies" title="=&gt; Iterator[Dependency.this.global.Symbol]">topLevelInheritanceDependencies</a> <span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span> <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency" title="(context: xsbti.DependencyContext)(on: Dependency.this.global.Symbol)Unit">processDependency</a><a href="#xsbt;Dependency;DependencyPhase.apply.$anonfun.on" title="Dependency.this.global.Symbol" class="delimiter">(</a>context = <span title="xsbti.DependencyContext(DependencyByInheritance)">DependencyByInheritance</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#xsbt;Dependency;DependencyPhase.apply.unit" title="Dependency.this.global.CompilationUnit">unit</a>.<span title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">depends</span> <span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span> <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency" title="(context: xsbti.DependencyContext)(on: Dependency.this.global.Symbol)Unit">processDependency</a><a href="#xsbt;Dependency;DependencyPhase.apply.$anonfun.on" title="Dependency.this.global.Symbol" class="delimiter">(</a>context = <span title="xsbti.DependencyContext(DependencyByMemberRef)">DependencyByMemberRef</span><span class="delimiter">)</span>
          <a href="CompilerInterface.scala.html#xsbt;CallbackGlobal.inheritedDependencies" title="=&gt; scala.collection.mutable.HashMap[java.io.File,scala.collection.mutable.Set[Dependency.this.global.Symbol]]">inheritedDependencies</a>.<span title="(key: java.io.File, default: =&gt; Iterable[Dependency.this.global.Symbol])Iterable[Dependency.this.global.Symbol]">getOrElse</span><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.sourceFile" title="java.io.File">sourceFile</a>, <span title="scala.collection.immutable.Nil.type">Nil</span>: <span title="Iterable[Dependency.this.global.Symbol]">Iterable</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span> <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency" title="(context: xsbti.DependencyContext)(on: Dependency.this.global.Symbol)Unit">processDependency</a><a href="#xsbt;Dependency;DependencyPhase.apply.$anonfun.on" title="Dependency.this.global.Symbol" class="delimiter">(</a>context = <span title="xsbti.DependencyContext(DependencyByInheritance)">DependencyByInheritance</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="comment">/**
         * Handles dependency on given symbol by trying to figure out if represents a term
         * that is coming from either source code (not necessarily compiled in this compilation
         * run) or from class file and calls respective callback method.
         */</span>
        <span class="keyword">def</span> <a title="(context: xsbti.DependencyContext)(on: Dependency.this.global.Symbol)Unit" id="xsbt;Dependency;DependencyPhase.apply.processDependency">processDependency</a><span class="delimiter">(</span><a title="xsbti.DependencyContext" id="xsbt;Dependency;DependencyPhase.apply.processDependency.context">context</a>: <a href="../xsbti/DependencyContext.java.html#xsbti;DependencyContext" title="xsbti.DependencyContext">DependencyContext</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Dependency.this.global.Symbol" id="xsbt;Dependency;DependencyPhase.apply.processDependency.on">on</a>: <span title="Dependency.this.global.Symbol">Symbol</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(file: java.io.File, className: String)Unit" id="xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency">binaryDependency</a><span class="delimiter">(</span><a title="java.io.File" id="xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency.file">file</a>: <span title="java.io.File">File</span>, <a title="String" id="xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency.className">className</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="CompilerInterface.scala.html#xsbt;CallbackGlobal.callback" title="=&gt; xsbti.AnalysisCallback">callback</a>.<a href="../xsbti/AnalysisCallback.java.html#xsbti;AnalysisCallback.binaryDependency(c2fd1b07af)" title="(binary: java.io.File, name: String, source: java.io.File, context: xsbti.DependencyContext)Unit">binaryDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency.file" title="java.io.File">file</a>, <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency.className" title="String">className</a>, <a href="#xsbt;Dependency;DependencyPhase.apply.sourceFile" title="java.io.File">sourceFile</a>, <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.context" title="xsbti.DependencyContext">context</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="scala.reflect.io.AbstractFile" id="xsbt;Dependency;DependencyPhase.apply.processDependency.onSource">onSource</a> = <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.on" title="Dependency.this.global.Symbol">on</a>.<span title="=&gt; scala.reflect.io.AbstractFile">sourceFile</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.onSource" title="scala.reflect.io.AbstractFile">onSource</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="LocateClassFile.scala.html#xsbt;LocateClassFile.classFile" title="(sym: Dependency.this.global.Symbol)Option[(tools.nsc.io.AbstractFile, String, Boolean)]">classFile</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.on" title="Dependency.this.global.Symbol">on</a><span class="delimiter">)</span> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<span class="delimiter">(</span><span class="delimiter">(</span><a title="tools.nsc.io.AbstractFile" id="xsbt;Dependency;DependencyPhase.apply.processDependency.f">f</a>, <a title="String" id="xsbt;Dependency;DependencyPhase.apply.processDependency.className">className</a>, <a title="Boolean" id="xsbt;Dependency;DependencyPhase.apply.processDependency.inOutDir">inOutDir</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.inOutDir" title="Boolean">inOutDir</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.on" title="Dependency.this.global.Symbol">on</a>.<span title="=&gt; Boolean">isJavaDefined</span><span class="delimiter">)</span> <a href="#xsbt;Dependency.global" title="(sym: Dependency.this.global.Symbol)Unit">registerTopLevelSym</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.on" title="Dependency.this.global.Symbol">on</a><span class="delimiter">)</span>
                <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.f" title="tools.nsc.io.AbstractFile">f</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <a title="scala.reflect.io.ZipArchive#Entry" id="xsbt;Dependency;DependencyPhase.apply.processDependency.ze">ze</a>: ZipArchive#<span title="scala.reflect.io.ZipArchive#Entry">Entry</span> =&gt; <span class="keyword">for</span> <span class="delimiter">(</span><a title="scala.reflect.io.ZipArchive" id="xsbt;Dependency;DependencyPhase.apply.processDependency.$anonfun.zip">zip</a> &lt;- <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.ze" title="scala.reflect.io.ZipArchive#Entry">ze</a>.<span title="(f: scala.reflect.io.ZipArchive =&gt; Unit)Unit">underlyingSource</span>; <a title="java.io.File" id="xsbt;Dependency;DependencyPhase.apply.processDependency.$anonfun.$anonfun.zipFile">zipFile</a> &lt;- <span title="(x: java.io.File)Option[java.io.File]">Option</span><span title="(f: java.io.File =&gt; Unit)Unit" class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.$anonfun.zip" title="scala.reflect.io.ZipArchive">zip</a>.<span title="=&gt; java.io.File">file</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency" title="(file: java.io.File, className: String)Unit">binaryDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.$anonfun.$anonfun.zipFile" title="java.io.File">zipFile</a>, <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.className" title="String">className</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> <a title="scala.tools.nsc.io.PlainFile" id="xsbt;Dependency;DependencyPhase.apply.processDependency.pf">pf</a>: <span title="scala.tools.nsc.io.PlainFile">PlainFile</span>        =&gt; <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.binaryDependency" title="(file: java.io.File, className: String)Unit">binaryDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.pf" title="scala.tools.nsc.io.PlainFile">pf</a>.<span title="=&gt; java.io.File">file</span>, <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.className" title="String">className</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> _                    =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>
              <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.onSource" title="scala.reflect.io.AbstractFile">onSource</a>.<span title="=&gt; java.io.File">file</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#xsbt;Dependency;DependencyPhase.apply.sourceFile" title="java.io.File">sourceFile</a><span class="delimiter">)</span>
            <a href="CompilerInterface.scala.html#xsbt;CallbackGlobal.callback" title="=&gt; xsbti.AnalysisCallback">callback</a>.<a href="../xsbti/AnalysisCallback.java.html#xsbti;AnalysisCallback.sourceDependency(4e0f82fd39)" title="(dependsOn: java.io.File, source: java.io.File, context: xsbti.DependencyContext)Unit">sourceDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.onSource" title="scala.reflect.io.AbstractFile">onSource</a>.<span title="=&gt; java.io.File">file</span>, <a href="#xsbt;Dependency;DependencyPhase.apply.sourceFile" title="java.io.File">sourceFile</a>, <a href="#xsbt;Dependency;DependencyPhase.apply.processDependency.context" title="xsbti.DependencyContext">context</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span title="Unit" class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">class</span> <a title="class ExtractDependenciesTraverser extends Dependency.this.global.Traverser" id="xsbt;Dependency;ExtractDependenciesTraverser">ExtractDependenciesTraverser</a> <a href="#xsbt;Dependency;ExtractDependenciesTraverser" title="Dependency.this.ExtractDependenciesTraverser" class="keyword">extends</a> <a href="#xsbt;Dependency.global" title="Dependency.this.global.Traverser">Traverser</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser._dependencies">_dependencies</a> = collection.mutable.<span title="scala.collection.mutable.HashSet.type">HashSet</span>.<span title="[A]=&gt; scala.collection.mutable.HashSet[A]">empty</span><span title="scala.collection.mutable.HashSet[Dependency.this.global.Symbol]" class="delimiter">[</span><span title="Dependency.this.global.Symbol">Symbol</span><span class="delimiter">]</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(dep: Dependency.this.global.Symbol)Unit" id="xsbt;Dependency;ExtractDependenciesTraverser.addDependency">addDependency</a><span class="delimiter">(</span><a title="Dependency.this.global.Symbol" id="xsbt;Dependency;ExtractDependenciesTraverser.addDependency.dep">dep</a>: <span title="Dependency.this.global.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency.dep" title="Dependency.this.global.Symbol">dep</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#xsbt;Dependency.global" title="=&gt; Dependency.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser._dependencies" title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">_dependencies</a> <span title="(elem: Dependency.this.global.Symbol)ExtractDependenciesTraverser.this._dependencies.type">+=</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency.dep" title="Dependency.this.global.Symbol">dep</a>
    <span class="keyword">def</span> <a title="=&gt; Iterator[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.dependencies">dependencies</a>: <span title="Iterator[Dependency.this.global.Symbol]">Iterator</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser._dependencies" title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">_dependencies</a>.<span title="=&gt; Iterator[Dependency.this.global.Symbol]">iterator</span>
    <span class="keyword">def</span> <a title="=&gt; Iterator[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.topLevelDependencies">topLevelDependencies</a>: <span title="Iterator[Dependency.this.global.Symbol]">Iterator</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser._dependencies" title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">_dependencies</a>.<span title="(f: Dependency.this.global.Symbol =&gt; Dependency.this.global.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.HashSet[Dependency.this.global.Symbol],Dependency.this.global.Symbol,scala.collection.mutable.HashSet[Dependency.this.global.Symbol]])scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.HashSet.Coll,Dependency.this.global.Symbol,scala.collection.mutable.HashSet[Dependency.this.global.Symbol]]" class="delimiter">(</span><a href="#xsbt;Dependency.enclosingTopLevelClass" title="(sym: Dependency.this.global.Symbol)Dependency.this.global.Symbol">enclosingTopLevelClass</a><span class="delimiter">)</span>.<span title="=&gt; Iterator[Dependency.this.global.Symbol]">iterator</span>

    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser._inheritanceDependencies">_inheritanceDependencies</a> = collection.mutable.<span title="scala.collection.mutable.HashSet.type">HashSet</span>.<span title="[A]=&gt; scala.collection.mutable.HashSet[A]">empty</span><span title="scala.collection.mutable.HashSet[Dependency.this.global.Symbol]" class="delimiter">[</span><span title="Dependency.this.global.Symbol">Symbol</span><span class="delimiter">]</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(dep: Dependency.this.global.Symbol)Unit" id="xsbt;Dependency;ExtractDependenciesTraverser.addInheritanceDependency">addInheritanceDependency</a><span class="delimiter">(</span><a title="Dependency.this.global.Symbol" id="xsbt;Dependency;ExtractDependenciesTraverser.addInheritanceDependency.dep">dep</a>: <span title="Dependency.this.global.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.addInheritanceDependency.dep" title="Dependency.this.global.Symbol">dep</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#xsbt;Dependency.global" title="=&gt; Dependency.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser._inheritanceDependencies" title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">_inheritanceDependencies</a> <span title="(elem: Dependency.this.global.Symbol)ExtractDependenciesTraverser.this._inheritanceDependencies.type">+=</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addInheritanceDependency.dep" title="Dependency.this.global.Symbol">dep</a>
    <span class="keyword">def</span> <a title="=&gt; Iterator[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.inheritanceDependencies">inheritanceDependencies</a>: <span title="Iterator[Dependency.this.global.Symbol]">Iterator</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser._inheritanceDependencies" title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">_inheritanceDependencies</a>.<span title="=&gt; Iterator[Dependency.this.global.Symbol]">iterator</span>
    <span class="keyword">def</span> <a title="=&gt; Iterator[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.topLevelInheritanceDependencies">topLevelInheritanceDependencies</a>: <span title="Iterator[Dependency.this.global.Symbol]">Iterator</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser._inheritanceDependencies" title="=&gt; scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">_inheritanceDependencies</a>.<span title="(f: Dependency.this.global.Symbol =&gt; Dependency.this.global.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.HashSet[Dependency.this.global.Symbol],Dependency.this.global.Symbol,scala.collection.mutable.HashSet[Dependency.this.global.Symbol]])scala.collection.mutable.HashSet[Dependency.this.global.Symbol]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.HashSet.Coll,Dependency.this.global.Symbol,scala.collection.mutable.HashSet[Dependency.this.global.Symbol]]" class="delimiter">(</span><a href="#xsbt;Dependency.enclosingTopLevelClass" title="(sym: Dependency.this.global.Symbol)Dependency.this.global.Symbol">enclosingTopLevelClass</a><span class="delimiter">)</span>.<span title="=&gt; Iterator[Dependency.this.global.Symbol]">iterator</span>

    <span class="comment">/*
     * Some macros appear to contain themselves as original tree.
     * We must check that we don't inspect the same tree over and over.
     * See https://issues.scala-lang.org/browse/SI-8486
     *     https://github.com/sbt/sbt/issues/1237
     *     https://github.com/sbt/sbt/issues/1544
     */</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Set[Dependency.this.global.Tree]" id="xsbt;Dependency;ExtractDependenciesTraverser.inspectedOriginalTrees">inspectedOriginalTrees</a> = collection.mutable.<span title="scala.collection.mutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.mutable.Set[A]">empty</span><span title="scala.collection.mutable.Set[Dependency.this.global.Tree]" class="delimiter">[</span><span title="Dependency.this.global.Tree">Tree</span><span class="delimiter">]</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Dependency.this.global.Tree)Unit" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse">traverse</a><span class="delimiter">(</span><a title="Dependency.this.global.Tree" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.tree">tree</a>: <span title="Dependency.this.global.Tree">Tree</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.tree" title="Dependency.this.global.Tree">tree</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Import<span class="delimiter">(</span><a title="Dependency.this.global.Tree" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.expr">expr</a>, <a title="List[Dependency.this.global.ImportSelector]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.selectors">selectors</a><span class="delimiter">)</span> =&gt;
        <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse" title="(tree: Dependency.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.expr" title="Dependency.this.global.Tree">expr</a><span class="delimiter">)</span>
        <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.selectors" title="List[Dependency.this.global.ImportSelector]">selectors</a>.<span title="(f: Dependency.this.global.ImportSelector =&gt; Unit)Unit">foreach</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
          <span class="keyword">case</span> ImportSelector<span class="delimiter">(</span><a href="#xsbt;Dependency.global" title="Dependency.this.global.nme.type">nme</a>.<span title="=&gt; Dependency.this.global.nme.NameType">WILDCARD</span>, _, <span title="Null(null)" class="keyword">null</span>, _<span class="delimiter">)</span> =&gt;
          <span class="comment">// in case of wildcard import we do not rely on any particular name being defined</span>
          <span class="comment">// on `expr`; all symbols that are being used will get caught through selections</span>
          <span class="keyword">case</span> ImportSelector<span class="delimiter">(</span><a title="Dependency.this.global.Name" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.name">name</a>: <span title="Dependency.this.global.Name">Name</span>, _, _, _<span class="delimiter">)</span> =&gt;
            <span class="keyword">def</span> <a title="(name: Dependency.this.global.Name)Dependency.this.global.Symbol" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.lookupImported">lookupImported</a><span class="delimiter">(</span><a title="Dependency.this.global.Name" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.lookupImported.name">name</a>: <span title="Dependency.this.global.Name">Name</span><span class="delimiter">)</span> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.expr" title="Dependency.this.global.Tree">expr</a>.<span title="=&gt; Dependency.this.global.Symbol">symbol</span>.<span title="=&gt; Dependency.this.global.Type">info</span>.<span title="(name: Dependency.this.global.Name)Dependency.this.global.Symbol">member</span><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.lookupImported.name" title="Dependency.this.global.Name">name</a><span class="delimiter">)</span>
            <span class="comment">// importing a name means importing both a term and a type (if they exist)</span>
            <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.lookupImported" title="(name: Dependency.this.global.Name)Dependency.this.global.Symbol">lookupImported</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.name" title="Dependency.this.global.Name">name</a>.<span title="=&gt; Dependency.this.global.TermName">toTermName</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.lookupImported" title="(name: Dependency.this.global.Name)Dependency.this.global.Symbol">lookupImported</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.name" title="Dependency.this.global.Name">name</a>.<span title="=&gt; Dependency.this.global.TypeName">toTypeName</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="comment">/*
       * Idents are used in number of situations:
       *  - to refer to local variable
       *  - to refer to a top-level package (other packages are nested selections)
       *  - to refer to a term defined in the same package as an enclosing class;
       *    this looks fishy, see this thread:
       *    https://groups.google.com/d/topic/scala-internals/Ms9WUAtokLo/discussion
       */</span>
      <span class="keyword">case</span> <a title="Dependency.this.global.Ident" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.id">id</a>: <span title="Dependency.this.global.Ident">Ident</span> =&gt; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.id" title="Dependency.this.global.Ident">id</a>.<span title="=&gt; Dependency.this.global.Symbol">symbol</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Dependency.this.global.Select">sel</span> @ Select<span class="delimiter">(</span><span title="Dependency.this.global.Tree">qual</span>, _<span class="delimiter">)</span> =&gt;
        <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse" title="(tree: Dependency.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><span title="Dependency.this.global.Tree">qual</span><span class="delimiter">)</span>; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a><span class="delimiter">(</span><span title="Dependency.this.global.Select">sel</span>.<span title="=&gt; Dependency.this.global.Symbol">symbol</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Dependency.this.global.SelectFromTypeTree">sel</span> @ SelectFromTypeTree<span class="delimiter">(</span><span title="Dependency.this.global.Tree">qual</span>, _<span class="delimiter">)</span> =&gt;
        <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse" title="(tree: Dependency.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><span title="Dependency.this.global.Tree">qual</span><span class="delimiter">)</span>; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a><span class="delimiter">(</span><span title="Dependency.this.global.SelectFromTypeTree">sel</span>.<span title="=&gt; Dependency.this.global.Symbol">symbol</span><span class="delimiter">)</span>

      <span class="keyword">case</span> Template<span class="delimiter">(</span><a title="List[Dependency.this.global.Tree]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.parents">parents</a>, <a title="Dependency.this.global.ValDef" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.self">self</a>, <a title="List[Dependency.this.global.Tree]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.body">body</a><span class="delimiter">)</span> =&gt;
        <span class="comment">// use typeSymbol to dealias type aliases -- we want to track the dependency on the real class in the alias's RHS</span>
        <span class="keyword">def</span> <a title="(tp: Dependency.this.global.Type)List[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols">flattenTypeToSymbols</a><span class="delimiter">(</span><a title="Dependency.this.global.Type" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols.tp">tp</a>: <span title="Dependency.this.global.Type">Type</span><span class="delimiter">)</span>: <span title="List[Dependency.this.global.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="List[Dependency.this.global.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols.tp" title="Dependency.this.global.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span> <span class="keyword">else</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols.tp" title="Dependency.this.global.Type">tp</a> <span title="List[Dependency.this.global.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="comment">// rt.typeSymbol is redundant if we list out all parents, TODO: what about rt.decls?</span>
          <span class="keyword">case</span> <a title="Dependency.this.global.RefinedType" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols.rt">rt</a>: <span title="Dependency.this.global.RefinedType">RefinedType</span> =&gt; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols.rt" title="Dependency.this.global.RefinedType">rt</a>.<span title="=&gt; List[Dependency.this.global.Type]">parents</span>.<span title="(f: Dependency.this.global.Type =&gt; scala.collection.GenTraversableOnce[Dependency.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Dependency.this.global.Type],Dependency.this.global.Symbol,List[Dependency.this.global.Symbol]])List[Dependency.this.global.Symbol]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Dependency.this.global.Symbol,List[Dependency.this.global.Symbol]]" class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols" title="(tp: Dependency.this.global.Type)List[Dependency.this.global.Symbol]">flattenTypeToSymbols</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _               =&gt; <span title="(xs: Dependency.this.global.Symbol*)List[Dependency.this.global.Symbol]">List</span><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols.tp" title="Dependency.this.global.Type">tp</a>.<span title="=&gt; Dependency.this.global.Symbol">typeSymbol</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Dependency.this.global.Type]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceTypes">inheritanceTypes</a> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.parents" title="List[Dependency.this.global.Tree]">parents</a>.<span title="(f: Dependency.this.global.Tree =&gt; Dependency.this.global.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Dependency.this.global.Tree],Dependency.this.global.Type,List[Dependency.this.global.Type]])List[Dependency.this.global.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Dependency.this.global.Type,List[Dependency.this.global.Type]]" class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceTypes.$anonfun.x$1" title="Dependency.this.global.Tree">_</a>.<span title="=&gt; Dependency.this.global.Type">tpe</span><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[Dependency.this.global.Type]">toSet</span>
        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceSymbols">inheritanceSymbols</a> = <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceTypes" title="scala.collection.immutable.Set[Dependency.this.global.Type]">inheritanceTypes</a>.<span title="(f: Dependency.this.global.Type =&gt; scala.collection.GenTraversableOnce[Dependency.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Dependency.this.global.Type],Dependency.this.global.Symbol,scala.collection.immutable.Set[Dependency.this.global.Symbol]])scala.collection.immutable.Set[Dependency.this.global.Symbol]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Dependency.this.global.Symbol,scala.collection.immutable.Set[Dependency.this.global.Symbol]]" class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.flattenTypeToSymbols" title="(tp: Dependency.this.global.Type)List[Dependency.this.global.Symbol]">flattenTypeToSymbols</a><span class="delimiter">)</span>

        <a href="#xsbt;Dependency.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;Parent types for &quot;)" class="string">&quot;Parent types for &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.tree" title="Dependency.this.global.Tree">tree</a>.<span title="=&gt; Dependency.this.global.Symbol">symbol</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; (self: &quot;)" class="string">&quot; (self: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.self" title="Dependency.this.global.ValDef">self</a>.<span title="=&gt; Dependency.this.global.Tree">tpt</span>.<span title="=&gt; Dependency.this.global.Type">tpe</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;): &quot;)" class="string">&quot;): &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceTypes" title="scala.collection.immutable.Set[Dependency.this.global.Type]">inheritanceTypes</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; with symbols &quot;)" class="string">&quot; with symbols &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceSymbols" title="scala.collection.immutable.Set[Dependency.this.global.Symbol]">inheritanceSymbols</a>.<span title="(f: Dependency.this.global.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Dependency.this.global.Symbol],String,Any])Any">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,String,scala.collection.immutable.Set[String]]" class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.$anonfun.x$2" title="Dependency.this.global.Symbol">_</a>.<span title="=&gt; String">fullName</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceSymbols" title="scala.collection.immutable.Set[Dependency.this.global.Symbol]">inheritanceSymbols</a>.<span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.addInheritanceDependency" title="(dep: Dependency.this.global.Symbol)Unit">addInheritanceDependency</a><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.allSymbols">allSymbols</a> = <span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceTypes" title="scala.collection.immutable.Set[Dependency.this.global.Type]">inheritanceTypes</a> <span title="(elem: Dependency.this.global.Type)scala.collection.immutable.Set[Dependency.this.global.Type]">+</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.self" title="Dependency.this.global.ValDef">self</a>.<span title="=&gt; Dependency.this.global.Tree">tpt</span>.<span title="=&gt; Dependency.this.global.Type">tpe</span><span class="delimiter">)</span>.<span title="(f: Dependency.this.global.Type =&gt; scala.collection.GenTraversableOnce[Dependency.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Dependency.this.global.Type],Dependency.this.global.Symbol,scala.collection.immutable.Set[Dependency.this.global.Symbol]])scala.collection.immutable.Set[Dependency.this.global.Symbol]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,Dependency.this.global.Symbol,scala.collection.immutable.Set[Dependency.this.global.Symbol]]" class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType" title="(tp: Dependency.this.global.Type)Set[Dependency.this.global.Symbol]">symbolsInType</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.allSymbols" title="scala.collection.immutable.Set[Dependency.this.global.Symbol]">allSymbols</a> <span title="(elems: scala.collection.GenTraversableOnce[Dependency.this.global.Symbol])scala.collection.immutable.Set[Dependency.this.global.Symbol]">++</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.inheritanceSymbols" title="scala.collection.immutable.Set[Dependency.this.global.Symbol]">inheritanceSymbols</a><span class="delimiter">)</span>.<span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a><span class="delimiter">)</span>
        <a href="#xsbt;Dependency;ExtractDependenciesTraverser" title="(trees: List[Dependency.this.global.Tree])Unit">traverseTrees</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.body" title="List[Dependency.this.global.Tree]">body</a><span class="delimiter">)</span>

      <span class="comment">// In some cases (eg. macro annotations), `typeTree.tpe` may be null. See sbt/sbt#1593 and sbt/sbt#1655.</span>
      <span class="keyword">case</span> <a title="Dependency.this.global.TypeTree" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.typeTree">typeTree</a>: <span title="Dependency.this.global.TypeTree">TypeTree</span> <span class="keyword">if</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.typeTree" title="Dependency.this.global.TypeTree">typeTree</a>.<span title="=&gt; Dependency.this.global.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> =&gt; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType" title="(tp: Dependency.this.global.Type)Set[Dependency.this.global.Symbol]">symbolsInType</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.typeTree" title="Dependency.this.global.TypeTree">typeTree</a>.<span title="=&gt; Dependency.this.global.Type">tpe</span><span class="delimiter">)</span> <span title="(f: Dependency.this.global.Symbol =&gt; Unit)Unit">foreach</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.addDependency" title="(dep: Dependency.this.global.Symbol)Unit">addDependency</a>

      <span class="keyword">case</span> <a href="Compat.scala.html#xsbt;Compat.MacroExpansionOf.unapply" title="(tree: Dependency.this.global.Tree)Option[Dependency.this.global.Tree]">MacroExpansionOf</a><span class="delimiter">(</span><a title="Dependency.this.global.Tree" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.original">original</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#xsbt;Dependency;ExtractDependenciesTraverser.inspectedOriginalTrees" title="=&gt; scala.collection.mutable.Set[Dependency.this.global.Tree]">inspectedOriginalTrees</a>.<span title="(elem: Dependency.this.global.Tree)Boolean">add</span><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.original" title="Dependency.this.global.Tree">original</a><span class="delimiter">)</span> =&gt; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse" title="(tree: Dependency.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.original" title="Dependency.this.global.Tree">original</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Dependency.this.global.Tree" id="xsbt;Dependency;ExtractDependenciesTraverser.traverse.other">other</a> =&gt; <a href="#xsbt;Dependency;ExtractDependenciesTraverser" title="Dependency.this.ExtractDependenciesTraverser" class="keyword">super</a>.<span title="(tree: Dependency.this.global.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.traverse.other" title="Dependency.this.global.Tree">other</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Dependency.this.global.Type)Set[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType">symbolsInType</a><span class="delimiter">(</span><a title="Dependency.this.global.Type" id="xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.tp">tp</a>: <span title="Dependency.this.global.Type">Type</span><span class="delimiter">)</span>: <span title="Set[Dependency.this.global.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Dependency.this.CollectTypeTraverser[Dependency.this.global.Symbol]" id="xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector">typeSymbolCollector</a> =
        <span title="Dependency.this.CollectTypeTraverser[Dependency.this.global.Symbol]" class="keyword">new</span> <a href="#xsbt;Dependency;CollectTypeTraverser" title="Dependency.this.CollectTypeTraverser[Dependency.this.global.Symbol]">CollectTypeTraverser</a><span class="delimiter">(</span><a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Dependency.this.global.Type,Dependency.this.global.Symbol] with Serializable" id="xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
          <span class="keyword">case</span> <a title="Dependency.this.global.Type" id="xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector;$anonfun.isDefinedAt.tpe">tpe</a> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector;$anonfun.isDefinedAt.tpe" title="Dependency.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector;$anonfun.isDefinedAt.tpe" title="Dependency.this.global.Type">tpe</a>.<span title="=&gt; Dependency.this.global.Symbol">typeSymbolDirect</span>.<span title="=&gt; Boolean">isPackage</span> =&gt; <a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector;$anonfun.isDefinedAt.tpe" title="Dependency.this.global.Type">tpe</a>.<span title="=&gt; Dependency.this.global.Symbol">typeSymbolDirect</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>

      <a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector" title="Dependency.this.CollectTypeTraverser[Dependency.this.global.Symbol]">typeSymbolCollector</a>.<a href="#xsbt;Dependency;CollectTypeTraverser.traverse" title="(tpe: Dependency.this.global.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.tp" title="Dependency.this.global.Type">tp</a><span class="delimiter">)</span>
      <a href="#xsbt;Dependency;ExtractDependenciesTraverser.symbolsInType.typeSymbolCollector" title="Dependency.this.CollectTypeTraverser[Dependency.this.global.Symbol]">typeSymbolCollector</a>.<a href="#xsbt;Dependency;CollectTypeTraverser.collected_=" title="=&gt; List[Dependency.this.global.Symbol]">collected</a>.<span title="scala.collection.immutable.Set[Dependency.this.global.Symbol]">toSet</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Traverses given type and collects result of applying a partial function `pf`.
   *
   * NOTE: This class exists in Scala 2.10 as CollectTypeCollector but does not in earlier
   * versions (like 2.9) of Scala compiler that incremental cmpiler supports so we had to
   * reimplement that class here.
   */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class CollectTypeTraverser[T] extends Dependency.this.global.TypeTraverser" id="xsbt;Dependency;CollectTypeTraverser">CollectTypeTraverser</a><span class="delimiter">[</span><a title="" id="xsbt;Dependency;CollectTypeTraverser;T">T</a><span class="delimiter">]</span><a href="#xsbt;Dependency;CollectTypeTraverser" title="Dependency.this.CollectTypeTraverser[T]" class="delimiter">(</a><a title="PartialFunction[Dependency.this.global.Type,T]" id="xsbt;Dependency;CollectTypeTraverser.pf">pf</a>: <span title="PartialFunction[Dependency.this.global.Type,T]">PartialFunction</span><span class="delimiter">[</span>Type, T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#xsbt;Dependency.global" title="Dependency.this.global.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[T]" id="xsbt;Dependency;CollectTypeTraverser.collected_=">collected</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="(tpe: Dependency.this.global.Type)Unit" id="xsbt;Dependency;CollectTypeTraverser.traverse">traverse</a><span class="delimiter">(</span><a title="Dependency.this.global.Type" id="xsbt;Dependency;CollectTypeTraverser.traverse.tpe">tpe</a>: <span title="Dependency.this.global.Type">Type</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency;CollectTypeTraverser.pf" title="PartialFunction[Dependency.this.global.Type,T]">pf</a>.<span title="(x: Dependency.this.global.Type)Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#xsbt;Dependency;CollectTypeTraverser.traverse.tpe" title="Dependency.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#xsbt;Dependency;CollectTypeTraverser.collected_=" title="(x$1: List[T])Unit">collected</a> = <a href="#xsbt;Dependency;CollectTypeTraverser.pf" title="(v1: Dependency.this.global.Type)T">pf</a><span class="delimiter">(</span><a href="#xsbt;Dependency;CollectTypeTraverser.traverse.tpe" title="Dependency.this.global.Type">tpe</a><span class="delimiter">)</span> <a href="#xsbt;Dependency;CollectTypeTraverser.traverse.x$3" title="(x: T)List[T]">::</a> <a href="#xsbt;Dependency;CollectTypeTraverser.collected_=" title="=&gt; List[T]">collected</a>
      <a href="#xsbt;Dependency;CollectTypeTraverser" title="(tp: Dependency.this.global.Type)Dependency.this.global.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#xsbt;Dependency;CollectTypeTraverser.traverse.tpe" title="Dependency.this.global.Type">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Copied straight from Scala 2.10 as it does not exist in Scala 2.9 compiler */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(msg: =&gt; String)Unit" id="xsbt;Dependency.debuglog">debuglog</a><span class="delimiter">(</span><a title="=&gt; String" id="xsbt;Dependency.debuglog.msg">msg</a>: =&gt; String<span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#xsbt;Dependency.global" title="=&gt; scala.tools.nsc.Settings">settings</a>.<span title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</span>.<span title="=&gt; Boolean">value</span><span class="delimiter">)</span> <a href="#xsbt;Dependency.global" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><a href="#xsbt;Dependency.debuglog.msg" title="=&gt; String">msg</a><span class="delimiter">)</span>

  <span class="comment">/**
   * We capture enclosing classes only because that's what CompilationUnit.depends does and we don't want
   * to deviate from old behaviour too much for now.
   *
   * NOTE: for Scala 2.8 and 2.9 this method is provided through SymbolCompat
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Dependency.this.global.Symbol)Dependency.this.global.Symbol" id="xsbt;Dependency.enclosingTopLevelClass">enclosingTopLevelClass</a><span class="delimiter">(</span><a title="Dependency.this.global.Symbol" id="xsbt;Dependency.enclosingTopLevelClass.sym">sym</a>: <span title="Dependency.this.global.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Dependency.this.global.Symbol">Symbol</span> = <a href="#xsbt;Dependency.enclosingTopLevelClass.sym" title="Dependency.this.global.Symbol">sym</a>.<span title="=&gt; Dependency.this.global.Symbol">enclosingTopLevelClass</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
