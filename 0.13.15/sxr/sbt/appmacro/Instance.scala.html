<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/appmacro/Instance.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> appmacro

<span class="keyword">import</span> <a href="../Classes.scala.html#sbt.Classes" title="sbt.Classes.type">Classes</a>.Applicative
<span class="keyword">import</span> <a href="../Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>.Id

<span class="comment">/**
 * The separate hierarchy from Applicative/Monad is for two reasons.
 *
 * 1. The type constructor is represented as an abstract type because a TypeTag cannot represent a type constructor directly.
 * 2. The applicative interface is uncurried.
 */</span>
<span class="keyword">trait</span> <a title="trait Instance extends AnyRef" id="sbt.appmacro;Instance">Instance</a> <span class="delimiter">{</span>
  <span class="keyword">type</span> <a title="[x]" id="sbt.appmacro;Instance;M">M</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;Instance;M;x">x</a><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[K[L[x]], Z](in: K[Instance.this.M], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])Instance.this.M[Z]" id="sbt.appmacro;Instance.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.appmacro;Instance.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.appmacro;Instance.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;Instance.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt.appmacro;Instance.app;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[Instance.this.M]" id="sbt.appmacro;Instance.app.in">in</a>: <a href="#sbt.appmacro;Instance.app;K" title="K[Instance.this.M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; Z" id="sbt.appmacro;Instance.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt.appmacro;Instance.app.a">a</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.appmacro;Instance;M" title="Instance.this.M[Z]">M</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[S, T](in: Instance.this.M[S], f: S =&gt; T)Instance.this.M[T]" id="sbt.appmacro;Instance.map">map</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;Instance.map;S">S</a>, <a title="" id="sbt.appmacro;Instance.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Instance.this.M[S]" id="sbt.appmacro;Instance.map.in">in</a>: <a href="#sbt.appmacro;Instance;M" title="Instance.this.M[S]">M</a><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="S =&gt; T" id="sbt.appmacro;Instance.map.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="#sbt.appmacro;Instance;M" title="Instance.this.M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](t: () =&gt; T)Instance.this.M[T]" id="sbt.appmacro;Instance.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;Instance.pure;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; T" id="sbt.appmacro;Instance.pure.t">t</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="#sbt.appmacro;Instance;M" title="Instance.this.M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait MonadInstance extends AnyRef with sbt.appmacro.Instance" id="sbt.appmacro;MonadInstance">MonadInstance</a> <span class="keyword">extends</span> <a href="#sbt.appmacro;Instance" title="sbt.appmacro.Instance">Instance</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](in: MonadInstance.this.M[MonadInstance.this.M[T]])MonadInstance.this.M[T]" id="sbt.appmacro;MonadInstance.flatten">flatten</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;MonadInstance.flatten;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="MonadInstance.this.M[MonadInstance.this.M[T]]" id="sbt.appmacro;MonadInstance.flatten.in">in</a>: <a href="#sbt.appmacro;Instance;M" title="MonadInstance.this.M[MonadInstance.this.M[T]]">M</a><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.appmacro;Instance;M" title="MonadInstance.this.M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="keyword">import</span> scala.reflect._
<span class="keyword">import</span> macros._
<span class="keyword">import</span> reflect.internal.annotations.compileTimeOnly

<span class="keyword">object</span> <a title="sbt.appmacro.Instance.type" id="sbt.appmacro.Instance">Instance</a> <a href="#sbt.appmacro.Instance" title="sbt.appmacro.Instance.type" class="delimiter">{</a>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;app&quot;)" id="sbt.appmacro.Instance.ApplyName">ApplyName</a> = <span title="String(&quot;app&quot;)" class="string">&quot;app&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;flatten&quot;)" id="sbt.appmacro.Instance.FlattenName">FlattenName</a> = <span title="String(&quot;flatten&quot;)" class="string">&quot;flatten&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;pure&quot;)" id="sbt.appmacro.Instance.PureName">PureName</a> = <span title="String(&quot;pure&quot;)" class="string">&quot;pure&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;map&quot;)" id="sbt.appmacro.Instance.MapName">MapName</a> = <span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;M&quot;)" id="sbt.appmacro.Instance.InstanceTCName">InstanceTCName</a> = <span title="String(&quot;M&quot;)" class="string">&quot;M&quot;</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Input[U &lt;: scala.reflect.macros.Universe with Singleton] extends AnyRef" id="sbt.appmacro.Instance;Input">Input</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Universe with Singleton" id="sbt.appmacro.Instance;Input;U">U</a> &lt;: Universe <span class="keyword">with</span> Singleton<span class="delimiter">]</span><a href="#sbt.appmacro.Instance;Input" title="sbt.appmacro.Instance.Input[U]" class="delimiter">(</a><span class="keyword">val</span> <a title="U#Type" id="sbt.appmacro.Instance;Input.tpe">tpe</a>: U#<span title="U#Type">Type</span>, <span class="keyword">val</span> <a title="U#Tree" id="sbt.appmacro.Instance;Input.expr">expr</a>: U#<span title="U#Tree">Tree</span>, <span class="keyword">val</span> <a title="U#ValDef" id="sbt.appmacro.Instance;Input.local">local</a>: U#<span title="U#ValDef">ValDef</span><span class="delimiter">)</span>
  <span class="keyword">trait</span> <a title="trait Transform[C &lt;: scala.reflect.macros.Context with Singleton, N[_]] extends AnyRef" id="sbt.appmacro.Instance;Transform">Transform</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context with Singleton" id="sbt.appmacro.Instance;Transform;C">C</a> &lt;: Context <span class="keyword">with</span> Singleton, <a title="[_]" id="sbt.appmacro.Instance;Transform;N">N</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Transform;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(in: C#Tree)C#Tree" id="sbt.appmacro.Instance;Transform.apply">apply</a><span class="delimiter">(</span><a title="C#Tree" id="sbt.appmacro.Instance;Transform.apply.in">in</a>: C#<span title="C#Tree">Tree</span><span class="delimiter">)</span>: C#<span title="C#Tree">Tree</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[C &lt;: scala.reflect.macros.Context with Singleton]=&gt; sbt.appmacro.Instance.Transform[C,sbt.Types.Id]" id="sbt.appmacro.Instance.idTransform">idTransform</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context with Singleton" id="sbt.appmacro.Instance.idTransform;C">C</a> &lt;: Context <span class="keyword">with</span> Singleton<span class="delimiter">]</span>: <a href="#sbt.appmacro.Instance;Transform" title="sbt.appmacro.Instance.Transform[C,sbt.Types.Id]">Transform</a><span class="delimiter">[</span>C, Id<span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance.idTransform;$anon" title="sbt.appmacro.Instance.Transform[C,sbt.Types.Id]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.appmacro.Instance.Transform[C,sbt.Types.Id]" id="sbt.appmacro.Instance.idTransform;$anon">Transform</a><span class="delimiter">[</span>C, Id<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(in: C#Tree)C#Tree" id="sbt.appmacro.Instance.idTransform;$anon.apply">apply</a><span class="delimiter">(</span><a title="C#Tree" id="sbt.appmacro.Instance.idTransform;$anon.apply.in">in</a>: C#<span title="C#Tree">Tree</span><span class="delimiter">)</span>: C#<span title="C#Tree">Tree</span> = <a href="#sbt.appmacro.Instance.idTransform;$anon.apply.in" title="C#Tree">in</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Implementation of a macro that provides a direct syntax for applicative functors and monads.
   * It is intended to be used in conjunction with another macro that conditions the inputs.
   *
   * This method processes the Tree `t` to find inputs of the form `wrap[T]( input )`
   * This form is typically constructed by another macro that pretends to be able to get a value of type `T`
   * from a value convertible to `M[T]`.  This `wrap(input)` form has two main purposes.
   * First, it identifies the inputs that should be transformed.
   * Second, it allows the input trees to be wrapped for later conversion into the appropriate `M[T]` type by `convert`.
   * This wrapping is necessary because applying the first macro must preserve the original type,
   * but it is useful to delay conversion until the outer, second macro is called.  The `wrap` method accomplishes this by
   * allowing the original `Tree` and `Type` to be hidden behind the raw `T` type.  This method will remove the call to `wrap`
   * so that it is not actually called at runtime.
   *
   * Each `input` in each expression of the form `wrap[T]( input )` is transformed by `convert`.
   * This transformation converts the input Tree to a Tree of type `M[T]`.
   * The original wrapped expression `wrap(input)` is replaced by a reference to a new local `val $x: T`, where `$x` is a fresh name.
   * These converted inputs are passed to `builder` as well as the list of these synthetic `ValDef`s.
   * The `TupleBuilder` instance constructs a tuple (Tree) from the inputs and defines the right hand side of the vals
   * that unpacks the tuple containing the results of the inputs.
   *
   * The constructed tuple of inputs and the code that unpacks the results of the inputs are then passed to the `i`,
   * which is an implementation of `Instance` that is statically accessible.
   * An Instance defines a applicative functor associated with a specific type constructor and, if it implements MonadInstance as well, a monad.
   * Typically, it will be either a top-level module or a stable member of a top-level module (such as a val or a nested module).
   * The `with Singleton` part of the type verifies some cases at macro compilation time,
   *  while the full check for static accessibility is done at macro expansion time.
   * Note: Ideally, the types would verify that `i: MonadInstance` when `t.isRight`.
   * With the various dependent types involved, this is not worth it.
   *
   * The `t` argument is the argument of the macro that will be transformed as described above.
   * If the macro that calls this method is for a multi-input map (app followed by map),
   * `t` should be the argument wrapped in Left.
   * If this is for multi-input flatMap (app followed by flatMap),
   *  this should be the argument wrapped in Right.
   */</span>
  <span class="keyword">def</span> <a title="[T, N[_]](c: scala.reflect.macros.Context, i: sbt.appmacro.Instance with Singleton, convert: sbt.appmacro.Convert, builder: sbt.appmacro.TupleBuilder)(t: Either[c.Expr[T],c.Expr[i.M[T]]], inner: sbt.appmacro.Instance.Transform[c.type,N])(implicit tt: c.WeakTypeTag[T], implicit nt: c.WeakTypeTag[N[T]], implicit it: c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])c.Expr[i.M[N[T]]]" id="sbt.appmacro.Instance.contImpl">contImpl</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.contImpl;T">T</a>, <a title="[_]" id="sbt.appmacro.Instance.contImpl;N">N</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.contImpl;N;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.appmacro.Instance.contImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span>, <a title="Instance extends sbt.appmacro.Instance with Singleton" id="sbt.appmacro.Instance.contImpl.i">i</a>: <a href="#sbt.appmacro.Instance;<refinement>" title="Instance extends sbt.appmacro.Instance with Singleton">Instance</a> <span class="keyword">with</span> Singleton, <a title="sbt.appmacro.Convert" id="sbt.appmacro.Instance.contImpl.convert">convert</a>: <a href="Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a>, <a title="sbt.appmacro.TupleBuilder" id="sbt.appmacro.Instance.contImpl.builder">builder</a>: <a href="TupleBuilder.scala.html#sbt.appmacro;TupleBuilder" title="sbt.appmacro.TupleBuilder">TupleBuilder</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Either[c.Expr[T],c.Expr[i.M[T]]]" id="sbt.appmacro.Instance.contImpl.t">t</a>: <span title="Either[c.Expr[T],c.Expr[i.M[T]]]">Either</span><span class="delimiter">[</span>c.Expr<span class="delimiter">[</span>T<span class="delimiter">]</span>, c.Expr<span class="delimiter">[</span>i.M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="sbt.appmacro.Instance.Transform[c.type,N]" id="sbt.appmacro.Instance.contImpl.inner">inner</a>: <a href="#sbt.appmacro.Instance;Transform" title="sbt.appmacro.Instance.Transform[c.type,N]">Transform</a><span class="delimiter">[</span>c.<span class="keyword">type</span>, N<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
    <span class="keyword">implicit</span> <a title="c.WeakTypeTag[T]" id="sbt.appmacro.Instance.contImpl.tt">tt</a>: c.<span title="c.WeakTypeTag[T]">WeakTypeTag</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="c.WeakTypeTag[N[T]]" id="sbt.appmacro.Instance.contImpl.nt">nt</a>: c.<span title="c.WeakTypeTag[N[T]]">WeakTypeTag</span><span class="delimiter">[</span>N<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type]" id="sbt.appmacro.Instance.contImpl.it">it</a>: c.<span title="c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type]">TypeTag</span><span class="delimiter">[</span>i.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[i.M[N[T]]]">Expr</span><span class="delimiter">[</span>i.M<span class="delimiter">[</span>N<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span class="delimiter">{</span> Apply =&gt; ApplyTree, _ <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="sbt.appmacro.ContextUtil[c.type]" id="sbt.appmacro.Instance.contImpl.util">util</a> = <a href="ContextUtil.scala.html#sbt.appmacro.ContextUtil.apply" title="[C &lt;: scala.reflect.macros.Context with Singleton](c: C)sbt.appmacro.ContextUtil[C]">ContextUtil</a><span title="(c: c.type)sbt.appmacro.ContextUtil[c.type]" class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="c.universe.Type" id="sbt.appmacro.Instance.contImpl.mTC">mTC</a>: <span title="c.universe.Type">Type</span> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.extractTC" title="(tcp: Singleton, name: String)(implicit it: util.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type])util.ctx.Type">extractTC</a><a href="#sbt.appmacro.Instance.contImpl.it" title="c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type]" class="delimiter">(</a><a href="#sbt.appmacro.Instance.contImpl.i" title="Instance extends sbt.appmacro.Instance with Singleton">i</a>, <span title="String(&quot;M&quot;)">InstanceTCName</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="c.universe.Type" id="sbt.appmacro.Instance.contImpl.mttpe">mttpe</a>: <span title="c.universe.Type">Type</span> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(tycon: c.universe.Type, args: List[c.universe.Type])c.universe.Type">appliedType</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.mTC" title="c.universe.Type">mTC</a>, <a href="#sbt.appmacro.Instance.contImpl.nt" title="c.WeakTypeTag[N[T]]">nt</a>.<span title="=&gt; c.universe.Type">tpe</span> <a href="#sbt.appmacro.Instance.contImpl.mttpe.x$1" title="(x: c.universe.Type)List[c.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Type">normalize</span>

      <span class="comment">// the tree for the macro argument</span>
      <span class="keyword">val</span> <a href="#sbt.appmacro.Instance.contImpl.tree" title="(c.universe.Tree, c.universe.Type)" class="delimiter">(</a><a href="#sbt.appmacro.Instance.contImpl.x$2" title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.tree">tree</a>, <a href="#sbt.appmacro.Instance.contImpl.x$2" title="c.universe.Type" id="sbt.appmacro.Instance.contImpl.treeType">treeType</a><span class="delimiter">)</span> = <a href="#sbt.appmacro.Instance.contImpl.t" title="Either[c.Expr[T],c.Expr[i.M[T]]]">t</a> <span title="(c.universe.Tree, c.universe.Type)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="c.Expr[T]" id="sbt.appmacro.Instance.contImpl.x$2.l">l</a><span class="delimiter">)</span>  =&gt; <span title="(_1: c.universe.Tree, _2: c.universe.Type)(c.universe.Tree, c.universe.Type)" class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.x$2.l" title="c.Expr[T]">l</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.appmacro.Instance.contImpl.nt" title="c.WeakTypeTag[N[T]]">nt</a>.<span title="=&gt; c.universe.Type">tpe</span>.<span title="=&gt; c.universe.Type">normalize</span><span class="delimiter">)</span>
        <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="c.Expr[i.M[T]]" id="sbt.appmacro.Instance.contImpl.x$2.r">r</a><span class="delimiter">)</span> =&gt; <span title="(_1: c.universe.Tree, _2: c.universe.Type)(c.universe.Tree, c.universe.Type)" class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.x$2.r" title="c.Expr[i.M[T]]">r</a>.<span title="=&gt; c.universe.Tree">tree</span>, <a href="#sbt.appmacro.Instance.contImpl.mttpe" title="c.universe.Type">mttpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="comment">// the Symbol for the anonymous function passed to the appropriate Instance.map/flatMap/pure method</span>
      <span class="comment">// this Symbol needs to be known up front so that it can be used as the owner of synthetic vals</span>
      <span class="keyword">val</span> <a title="util.ctx.universe.Symbol" id="sbt.appmacro.Instance.contImpl.functionSym">functionSym</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.functionSymbol" title="(pos: util.ctx.universe.Position)util.ctx.universe.Symbol">functionSymbol</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="util.ctx.universe.Symbol" id="sbt.appmacro.Instance.contImpl.instanceSym">instanceSym</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.singleton" title="(i: sbt.appmacro.Instance with Singleton)(implicit it: util.ctx.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type])util.ctx.universe.Symbol">singleton</a><a href="#sbt.appmacro.Instance.contImpl.it" title="c.TypeTag[sbt.appmacro.Instance.&lt;refinement&gt;.type]" class="delimiter">(</a><a href="#sbt.appmacro.Instance.contImpl.i" title="Instance extends sbt.appmacro.Instance with Singleton">i</a><span class="delimiter">)</span>
      <span class="comment">// A Tree that references the statically accessible Instance that provides the actual implementations of map, flatMap, ...</span>
      <span class="keyword">val</span> <a title="c.universe.Ident" id="sbt.appmacro.Instance.contImpl.instance">instance</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.instanceSym" title="util.ctx.universe.Symbol">instanceSym</a><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="(String, c.universe.Type, c.universe.Tree) =&gt; Boolean" id="sbt.appmacro.Instance.contImpl.isWrapper">isWrapper</a>: <span class="delimiter">(</span>String, Type, Tree<span class="delimiter">)</span> =&gt; Boolean = <a href="#sbt.appmacro.Instance.contImpl.convert" title="sbt.appmacro.Convert">convert</a>.<a href="Convert.scala.html#sbt.appmacro;Convert.asPredicate" title="(c: scala.reflect.macros.Context)(String, c.Type, c.Tree) =&gt; Boolean">asPredicate</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span>

      <span class="comment">// Local definitions `defs` in the macro.  This is used to ensure references are to M instances defined outside of the macro call.</span>
      <span class="comment">// Also `refCount` is the number of references, which is used to create the private, synthetic method containing the body</span>
      <span class="keyword">val</span> <a title="scala.collection.Set[util.ctx.universe.Symbol]" id="sbt.appmacro.Instance.contImpl.defs">defs</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.collectDefs" title="(tree: util.ctx.universe.Tree, isWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree) =&gt; Boolean)scala.collection.Set[util.ctx.universe.Symbol]">collectDefs</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.tree" title="c.universe.Tree">tree</a>, <a href="#sbt.appmacro.Instance.contImpl.isWrapper" title="(String, c.universe.Type, c.universe.Tree) =&gt; Boolean">isWrapper</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="c.universe.Tree =&gt; Unit" id="sbt.appmacro.Instance.contImpl.checkQual">checkQual</a>: Tree =&gt; Unit = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.checkReferences" title="(defs: scala.collection.Set[util.ctx.universe.Symbol], isWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree) =&gt; Boolean)util.ctx.universe.Tree =&gt; Unit">checkReferences</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.defs" title="scala.collection.Set[util.ctx.universe.Symbol]">defs</a>, <a href="#sbt.appmacro.Instance.contImpl.isWrapper" title="(String, c.universe.Type, c.universe.Tree) =&gt; Boolean">isWrapper</a><span class="delimiter">)</span>

      <span class="keyword">type</span> <a title="sbt.appmacro.Instance.Input[c.universe.type]" id="sbt.appmacro.Instance.contImpl;In">In</a> = <a href="#sbt.appmacro.Instance;Input" title="sbt.appmacro.Instance.Input[c.universe.type]">Input</a><span class="delimiter">[</span>c.universe.<span class="keyword">type</span><span class="delimiter">]</span>
      <span class="keyword">var</span> <a title="List[In]" id="sbt.appmacro.Instance.contImpl.inputs">inputs</a> = List<span class="delimiter">[</span>In<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>

      <span class="comment">// transforms the original tree into calls to the Instance functions pure, map, ...,</span>
      <span class="comment">//  resulting in a value of type M[T]</span>
      <span class="keyword">def</span> <a title="(body: c.universe.Tree)c.universe.Tree" id="sbt.appmacro.Instance.contImpl.makeApp">makeApp</a><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.makeApp.body">body</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
        <a href="#sbt.appmacro.Instance.contImpl.inputs" title="List[In]">inputs</a> <span title="c.universe.Tree" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span>      =&gt; <a href="#sbt.appmacro.Instance.contImpl.pure" title="(body: c.universe.Tree)c.universe.Tree">pure</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.makeApp.body" title="c.universe.Tree">body</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="In" id="sbt.appmacro.Instance.contImpl.makeApp.x">x</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt; <a href="#sbt.appmacro.Instance.contImpl.single" title="(body: c.universe.Tree, input: In)c.universe.Tree">single</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.makeApp.body" title="c.universe.Tree">body</a>, <a href="#sbt.appmacro.Instance.contImpl.makeApp.x" title="In">x</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="List[In]" id="sbt.appmacro.Instance.contImpl.makeApp.xs">xs</a>       =&gt; <a href="#sbt.appmacro.Instance.contImpl.arbArity" title="(body: c.universe.Tree, inputs: List[In])c.universe.Tree">arbArity</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.makeApp.body" title="c.universe.Tree">body</a>, <a href="#sbt.appmacro.Instance.contImpl.makeApp.xs" title="List[In]">xs</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="comment">// no inputs, so construct M[T] via Instance.pure or pure+flatten</span>
      <span class="keyword">def</span> <a title="(body: c.universe.Tree)c.universe.Tree" id="sbt.appmacro.Instance.contImpl.pure">pure</a><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.pure.body">body</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="c.universe.TypeApply" id="sbt.appmacro.Instance.contImpl.pure.typeApplied">typeApplied</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.select" title="(t: util.ctx.universe.Tree, name: String)util.ctx.universe.Tree">select</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.instance" title="c.universe.Ident">instance</a>, <span title="String(&quot;pure&quot;)">PureName</span><span class="delimiter">)</span>, <a href="#sbt.appmacro.Instance.contImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.treeType" title="c.universe.Type">treeType</a><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.pure.typeApplied.x$3" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="util.ctx.universe.Tree" id="sbt.appmacro.Instance.contImpl.pure.f">f</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.createFunction" title="(params: List[util.ctx.universe.ValDef], body: util.ctx.universe.Tree, functionSym: util.ctx.universe.Symbol)util.ctx.universe.Tree">createFunction</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro.Instance.contImpl.pure.body" title="c.universe.Tree">body</a>, <a href="#sbt.appmacro.Instance.contImpl.functionSym" title="util.ctx.universe.Symbol">functionSym</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="c.universe.Apply" id="sbt.appmacro.Instance.contImpl.pure.p">p</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.pure.typeApplied" title="c.universe.TypeApply">typeApplied</a>, <a href="#sbt.appmacro.Instance.contImpl.pure.f" title="util.ctx.universe.Tree">f</a> <a href="#sbt.appmacro.Instance.contImpl.pure.p.x$4" title="(x: util.ctx.universe.Tree)List[util.ctx.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span title="c.universe.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.t" title="Either[c.Expr[T],c.Expr[i.M[T]]]">t</a>.<span title="=&gt; Boolean">isLeft</span><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.pure.p" title="c.universe.Apply">p</a> <span class="keyword">else</span> <a href="#sbt.appmacro.Instance.contImpl.flatten" title="(m: c.universe.Tree)c.universe.Tree">flatten</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.pure.p" title="c.universe.Apply">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="comment">// m should have type M[M[T]]</span>
      <span class="comment">// the returned Tree will have type M[T]</span>
      <span class="keyword">def</span> <a title="(m: c.universe.Tree)c.universe.Tree" id="sbt.appmacro.Instance.contImpl.flatten">flatten</a><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.flatten.m">m</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="c.universe.TypeApply" id="sbt.appmacro.Instance.contImpl.flatten.typedFlatten">typedFlatten</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.select" title="(t: util.ctx.universe.Tree, name: String)util.ctx.universe.Tree">select</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.instance" title="c.universe.Ident">instance</a>, <span title="String(&quot;flatten&quot;)">FlattenName</span><span class="delimiter">)</span>, <a href="#sbt.appmacro.Instance.contImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.tt" title="c.WeakTypeTag[T]">tt</a>.<span title="=&gt; c.universe.Type">tpe</span><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.flatten.typedFlatten.x$5" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.flatten.typedFlatten" title="c.universe.TypeApply">typedFlatten</a>, <a href="#sbt.appmacro.Instance.contImpl.flatten.m" title="c.universe.Tree">m</a> <a href="#sbt.appmacro.Instance.contImpl.flatten.x$6" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="comment">// calls Instance.map or flatmap directly, skipping the intermediate Instance.app that is unnecessary for a single input</span>
      <span class="keyword">def</span> <a title="(body: c.universe.Tree, input: In)c.universe.Tree" id="sbt.appmacro.Instance.contImpl.single">single</a><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.single.body">body</a>: <span title="c.universe.Tree">Tree</span>, <a title="In" id="sbt.appmacro.Instance.contImpl.single.input">input</a>: <a href="#sbt.appmacro.Instance;Input" title="In">In</a><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="c.universe.ValDef" id="sbt.appmacro.Instance.contImpl.single.variable">variable</a> = <a href="#sbt.appmacro.Instance.contImpl.single.input" title="In">input</a>.<a href="#sbt.appmacro.Instance;Input.local" title="=&gt; c.universe.ValDef">local</a>
          <span class="keyword">val</span> <a title="c.universe.ValDef" id="sbt.appmacro.Instance.contImpl.single.param">param</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="=&gt; c.universe.TreeCopier">treeCopy</a>.<span title="(tree: c.universe.Tree, mods: c.universe.Modifiers, name: c.universe.Name, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.single.variable" title="c.universe.ValDef">variable</a>, <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.parameterModifiers" title="=&gt; util.ctx.universe.Modifiers">parameterModifiers</a>, <a href="#sbt.appmacro.Instance.contImpl.single.variable" title="c.universe.ValDef">variable</a>.<span title="=&gt; c.universe.TermName">name</span>, <a href="#sbt.appmacro.Instance.contImpl.single.variable" title="c.universe.ValDef">variable</a>.<span title="=&gt; c.universe.Tree">tpt</span>, <a href="#sbt.appmacro.Instance.contImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="c.universe.TypeApply" id="sbt.appmacro.Instance.contImpl.single.typeApplied">typeApplied</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.select" title="(t: util.ctx.universe.Tree, name: String)util.ctx.universe.Tree">select</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.instance" title="c.universe.Ident">instance</a>, <span title="String(&quot;map&quot;)">MapName</span><span class="delimiter">)</span>, <a href="#sbt.appmacro.Instance.contImpl.single.variable" title="c.universe.ValDef">variable</a>.<span title="=&gt; c.universe.Tree">tpt</span> <a href="#sbt.appmacro.Instance.contImpl.single.typeApplied.x$8" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <a href="#sbt.appmacro.Instance.contImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.treeType" title="c.universe.Type">treeType</a><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.single.typeApplied.x$7" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="util.ctx.universe.Tree" id="sbt.appmacro.Instance.contImpl.single.f">f</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.createFunction" title="(params: List[util.ctx.universe.ValDef], body: util.ctx.universe.Tree, functionSym: util.ctx.universe.Symbol)util.ctx.universe.Tree">createFunction</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.single.param" title="c.universe.ValDef">param</a> <a href="#sbt.appmacro.Instance.contImpl.single.f.x$9" title="(x: c.universe.ValDef)List[c.universe.ValDef]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro.Instance.contImpl.single.body" title="c.universe.Tree">body</a>, <a href="#sbt.appmacro.Instance.contImpl.functionSym" title="util.ctx.universe.Symbol">functionSym</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="c.universe.Apply" id="sbt.appmacro.Instance.contImpl.single.mapped">mapped</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.single.typeApplied" title="c.universe.TypeApply">typeApplied</a>, <a href="#sbt.appmacro.Instance.contImpl.single.input" title="In">input</a>.<a href="#sbt.appmacro.Instance;Input.expr" title="=&gt; c.universe.Tree">expr</a> <a href="#sbt.appmacro.Instance.contImpl.single.mapped.x$11" title="(x: util.ctx.universe.Tree)List[util.ctx.universe.Tree]">::</a> <a href="#sbt.appmacro.Instance.contImpl.single.f" title="util.ctx.universe.Tree">f</a> <a href="#sbt.appmacro.Instance.contImpl.single.mapped.x$10" title="(x: util.ctx.universe.Tree)List[util.ctx.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span title="c.universe.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.t" title="Either[c.Expr[T],c.Expr[i.M[T]]]">t</a>.<span title="=&gt; Boolean">isLeft</span><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.single.mapped" title="c.universe.Apply">mapped</a> <span class="keyword">else</span> <a href="#sbt.appmacro.Instance.contImpl.flatten" title="(m: c.universe.Tree)c.universe.Tree">flatten</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.single.mapped" title="c.universe.Apply">mapped</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="comment">// calls Instance.app to get the values for all inputs and then calls Instance.map or flatMap to evaluate the body</span>
      <span class="keyword">def</span> <a title="(body: c.universe.Tree, inputs: List[In])c.universe.Tree" id="sbt.appmacro.Instance.contImpl.arbArity">arbArity</a><span class="delimiter">(</span><a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.arbArity.body">body</a>: <span title="c.universe.Tree">Tree</span>, <a title="List[In]" id="sbt.appmacro.Instance.contImpl.arbArity.inputs">inputs</a>: <span title="List[In]">List</span><span class="delimiter">[</span>In<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="sbt.appmacro.BuilderResult[c.type]" id="sbt.appmacro.Instance.contImpl.arbArity.result">result</a> = <a href="#sbt.appmacro.Instance.contImpl.builder" title="sbt.appmacro.TupleBuilder">builder</a>.<a href="TupleBuilder.scala.html#sbt.appmacro;TupleBuilder.make" title="(c: scala.reflect.macros.Context)(tcType: c.Type, inputs: builder.Inputs[c.universe.type])sbt.appmacro.BuilderResult[c.type]">make</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.mTC" title="c.universe.Type">mTC</a>, <a href="#sbt.appmacro.Instance.contImpl.arbArity.inputs" title="List[In]">inputs</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="util.ctx.universe.ValDef" id="sbt.appmacro.Instance.contImpl.arbArity.param">param</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.freshMethodParameter" title="(tpe: util.ctx.universe.Type)util.ctx.universe.ValDef">freshMethodParameter</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.c" title="(tycon: c.universe.Type, args: List[c.universe.Type])c.universe.Type">appliedType</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.result" title="sbt.appmacro.BuilderResult[c.type]">result</a>.<a href="TupleBuilder.scala.html#sbt.appmacro;BuilderResult.representationC" title="=&gt; result.ctx.universe.PolyType">representationC</a>, <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.idTC" title="=&gt; util.ctx.universe.Type">idTC</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.param.x$12" title="(x: util.ctx.universe.Type)List[util.ctx.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[result.ctx.universe.ValDef]" id="sbt.appmacro.Instance.contImpl.arbArity.bindings">bindings</a> = <a href="#sbt.appmacro.Instance.contImpl.arbArity.result" title="sbt.appmacro.BuilderResult[c.type]">result</a>.<a href="TupleBuilder.scala.html#sbt.appmacro;BuilderResult.extract" title="(param: result.ctx.universe.ValDef)List[result.ctx.universe.ValDef]">extract</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.param" title="util.ctx.universe.ValDef">param</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="util.ctx.universe.Tree" id="sbt.appmacro.Instance.contImpl.arbArity.f">f</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.createFunction" title="(params: List[util.ctx.universe.ValDef], body: util.ctx.universe.Tree, functionSym: util.ctx.universe.Symbol)util.ctx.universe.Tree">createFunction</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.param" title="util.ctx.universe.ValDef">param</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.f.x$13" title="(x: util.ctx.universe.ValDef)List[util.ctx.universe.ValDef]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro.Instance.contImpl.c" title="(stats: List[c.universe.Tree], expr: c.universe.Tree)c.universe.Block">Block</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.bindings" title="List[result.ctx.universe.ValDef]">bindings</a>, <a href="#sbt.appmacro.Instance.contImpl.arbArity.body" title="c.universe.Tree">body</a><span class="delimiter">)</span>, <a href="#sbt.appmacro.Instance.contImpl.functionSym" title="util.ctx.universe.Symbol">functionSym</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="c.universe.TypeTree" id="sbt.appmacro.Instance.contImpl.arbArity.ttt">ttt</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.treeType" title="c.universe.Type">treeType</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="c.universe.TypeApply" id="sbt.appmacro.Instance.contImpl.arbArity.typedApp">typedApp</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.select" title="(t: util.ctx.universe.Tree, name: String)util.ctx.universe.Tree">select</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.instance" title="c.universe.Ident">instance</a>, <span title="String(&quot;app&quot;)">ApplyName</span><span class="delimiter">)</span>, <a href="#sbt.appmacro.Instance.contImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.result" title="sbt.appmacro.BuilderResult[c.type]">result</a>.<a href="TupleBuilder.scala.html#sbt.appmacro;BuilderResult.representationC" title="=&gt; result.ctx.universe.PolyType">representationC</a><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.arbArity.typedApp.x$15" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.ttt" title="c.universe.TypeTree">ttt</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.typedApp.x$14" title="(x: c.universe.TypeTree)List[c.universe.TypeTree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="c.universe.Apply" id="sbt.appmacro.Instance.contImpl.arbArity.app">app</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">ApplyTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.typedApp" title="c.universe.TypeApply">typedApp</a>, <a href="#sbt.appmacro.Instance.contImpl.arbArity.result" title="sbt.appmacro.BuilderResult[c.type]">result</a>.<a href="TupleBuilder.scala.html#sbt.appmacro;BuilderResult.input" title="=&gt; result.ctx.universe.Tree">input</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.app.x$17" title="(x: util.ctx.universe.Tree)List[util.ctx.universe.Tree]">::</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.f" title="util.ctx.universe.Tree">f</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.app.x$16" title="(x: util.ctx.universe.Tree)List[util.ctx.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a href="#sbt.appmacro.Instance.contImpl.arbArity.result" title="sbt.appmacro.BuilderResult[c.type]">result</a>.<a href="TupleBuilder.scala.html#sbt.appmacro;BuilderResult.alistInstance" title="=&gt; result.ctx.universe.Tree">alistInstance</a> <a href="#sbt.appmacro.Instance.contImpl.arbArity.app.x$18" title="(x: result.ctx.universe.Tree)List[result.ctx.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
          <span title="c.universe.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.t" title="Either[c.Expr[T],c.Expr[i.M[T]]]">t</a>.<span title="=&gt; Boolean">isLeft</span><span class="delimiter">)</span> <a href="#sbt.appmacro.Instance.contImpl.arbArity.app" title="c.universe.Apply">app</a> <span class="keyword">else</span> <a href="#sbt.appmacro.Instance.contImpl.flatten" title="(m: c.universe.Tree)c.universe.Tree">flatten</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.arbArity.app" title="c.universe.Apply">app</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="comment">// Called when transforming the tree to add an input.</span>
      <span class="comment">//  For `qual` of type M[A], and a `selection` qual.value,</span>
      <span class="comment">//  the call is addType(Type A, Tree qual)</span>
      <span class="comment">// The result is a Tree representing a reference to</span>
      <span class="comment">//  the bound value of the input.</span>
      <span class="keyword">def</span> <a title="(tpe: c.universe.Type, qual: c.universe.Tree, selection: c.universe.Tree)c.universe.Tree" id="sbt.appmacro.Instance.contImpl.addType">addType</a><span class="delimiter">(</span><a title="c.universe.Type" id="sbt.appmacro.Instance.contImpl.addType.tpe">tpe</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.addType.qual">qual</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.addType.selection">selection</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
        <span class="delimiter">{</span>
          <a href="#sbt.appmacro.Instance.contImpl.addType.qual" title="c.universe.Tree">qual</a>.<span title="(f: c.universe.Tree =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.checkQual" title="c.universe.Tree =&gt; Unit">checkQual</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="util.ctx.universe.ValDef" id="sbt.appmacro.Instance.contImpl.addType.vd">vd</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.freshValDef" title="(tpe: util.ctx.universe.Type, pos: util.ctx.universe.Position, owner: util.ctx.universe.Symbol)util.ctx.universe.ValDef">freshValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.addType.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.appmacro.Instance.contImpl.addType.qual" title="c.universe.Tree">qual</a>.<span title="=&gt; c.universe.Position">pos</span>, <a href="#sbt.appmacro.Instance.contImpl.functionSym" title="util.ctx.universe.Symbol">functionSym</a><span class="delimiter">)</span>
          <a href="#sbt.appmacro.Instance.contImpl.inputs" title="List[In]">inputs</a> <span title="(x: In)List[In]">::=</span> <span title="sbt.appmacro.Instance.Input[util.ctx.universe.type]" class="keyword">new</span> <a href="#sbt.appmacro.Instance;Input" title="sbt.appmacro.Instance.Input[util.ctx.universe.type]">Input</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.addType.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.appmacro.Instance.contImpl.addType.qual" title="c.universe.Tree">qual</a>, <a href="#sbt.appmacro.Instance.contImpl.addType.vd" title="util.ctx.universe.ValDef">vd</a><span class="delimiter">)</span>
          <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.refVal" title="(replaced: util.ctx.universe.Tree, vd: util.ctx.universe.ValDef)util.ctx.universe.Tree">refVal</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.addType.selection" title="c.universe.Tree">selection</a>, <a href="#sbt.appmacro.Instance.contImpl.addType.vd" title="util.ctx.universe.ValDef">vd</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(name: String, tpe: c.universe.Type, qual: c.universe.Tree, replace: c.universe.Tree)sbt.appmacro.Converted[c.type]" id="sbt.appmacro.Instance.contImpl.sub">sub</a><span class="delimiter">(</span><a title="String" id="sbt.appmacro.Instance.contImpl.sub.name">name</a>: <span title="String">String</span>, <a title="c.universe.Type" id="sbt.appmacro.Instance.contImpl.sub.tpe">tpe</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.sub.qual">qual</a>: <span title="c.universe.Tree">Tree</span>, <a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.sub.replace">replace</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <a href="Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
        <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="c.WeakTypeTag[T]" id="sbt.appmacro.Instance.contImpl.sub.tag">tag</a> = <a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tpe: c.Type)c.WeakTypeTag[T]">WeakTypeTag</span><span title="(tpe: c.Type)c.WeakTypeTag[T]" class="delimiter">[</span><a href="#sbt.appmacro.Instance.contImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.sub.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
          <a href="Convert.scala.html#sbt.appmacro;Convert.apply" title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]">convert</a><span title="(c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" class="delimiter">[</span><a href="#sbt.appmacro.Instance.contImpl;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.sub.name" title="String">name</a>, <a href="#sbt.appmacro.Instance.contImpl.sub.qual" title="c.universe.Tree">qual</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.sub.tag" title="c.WeakTypeTag[T]">tag</a><span class="delimiter">)</span> <a href="Convert.scala.html#sbt.appmacro;Converted.transform" title="(f: c.Tree =&gt; c.Tree)sbt.appmacro.Converted[c.type]">transform</a> <span class="delimiter">{</span> <a title="c.Tree" id="sbt.appmacro.Instance.contImpl.sub.$anonfun.tree">tree</a> =&gt;
            <a href="#sbt.appmacro.Instance.contImpl.addType" title="(tpe: c.universe.Type, qual: c.universe.Tree, selection: c.universe.Tree)c.universe.Tree">addType</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.sub.tpe" title="c.universe.Type">tpe</a>, <a href="#sbt.appmacro.Instance.contImpl.sub.$anonfun.tree" title="c.Tree">tree</a>, <a href="#sbt.appmacro.Instance.contImpl.sub.replace" title="c.universe.Tree">replace</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <span class="comment">// applies the transformation</span>
      <span class="keyword">val</span> <a title="util.ctx.universe.Tree" id="sbt.appmacro.Instance.contImpl.tx">tx</a> = <a href="#sbt.appmacro.Instance.contImpl.util" title="sbt.appmacro.ContextUtil[c.type]">util</a>.<a href="ContextUtil.scala.html#sbt.appmacro;ContextUtil.transformWrappers" title="(t: util.ctx.universe.Tree, subWrapper: (String, util.ctx.universe.Type, util.ctx.universe.Tree, util.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[util.ctx.type])util.ctx.universe.Tree">transformWrappers</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.tree" title="c.universe.Tree">tree</a>, <span class="delimiter">(</span><a title="String" id="sbt.appmacro.Instance.contImpl.tx.$anonfun.n">n</a>, <a title="util.ctx.universe.Type" id="sbt.appmacro.Instance.contImpl.tx.$anonfun.tpe">tpe</a>, <a title="util.ctx.universe.Tree" id="sbt.appmacro.Instance.contImpl.tx.$anonfun.t">t</a>, <a title="util.ctx.universe.Tree" id="sbt.appmacro.Instance.contImpl.tx.$anonfun.replace">replace</a><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro.Instance.contImpl.sub" title="(name: String, tpe: c.universe.Type, qual: c.universe.Tree, replace: c.universe.Tree)sbt.appmacro.Converted[c.type]">sub</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.tx.$anonfun.n" title="String">n</a>, <a href="#sbt.appmacro.Instance.contImpl.tx.$anonfun.tpe" title="util.ctx.universe.Type">tpe</a>, <a href="#sbt.appmacro.Instance.contImpl.tx.$anonfun.t" title="util.ctx.universe.Tree">t</a>, <a href="#sbt.appmacro.Instance.contImpl.tx.$anonfun.replace" title="util.ctx.universe.Tree">replace</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">// resetting attributes must be: a) local b) done here and not wider or else there are obscure errors</span>
      <span class="keyword">val</span> <a title="c.universe.Tree" id="sbt.appmacro.Instance.contImpl.tr">tr</a> = <a href="#sbt.appmacro.Instance.contImpl.makeApp" title="(body: c.universe.Tree)c.universe.Tree">makeApp</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance;Transform.apply" title="(in: c.Tree)c.Tree">inner</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.contImpl.tx" title="util.ctx.universe.Tree">tx</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.appmacro.Instance.contImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[i.M[N[T]]])c.Expr[i.M[N[T]]]" class="delimiter">[</span>i.<a href="#sbt.appmacro;Instance;M" title="i.M[N[T]]">M</a><span class="delimiter">[</span>N<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.appmacro.Instance.contImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[i.M[N[T]]]" class="delimiter">(</a><a href="#sbt.appmacro.Instance.contImpl.tr" title="c.universe.Tree">tr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="../Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A[_]](implicit ap: sbt.Classes.Applicative[A])sbt.appmacro.Instance{type M[x] = A[x]}" id="sbt.appmacro.Instance.applicativeInstance">applicativeInstance</a><span class="delimiter">[</span><a title="[_]" id="sbt.appmacro.Instance.applicativeInstance;A">A</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.applicativeInstance;A;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.Classes.Applicative[A]" id="sbt.appmacro.Instance.applicativeInstance.ap">ap</a>: <a href="../Classes.scala.html#sbt.Classes;Applicative" title="sbt.Classes.Applicative[A]">Applicative</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.appmacro.Instance;<refinement>" title="Instance extends sbt.appmacro.Instance">Instance</a> <span class="delimiter">{</span> <span class="keyword">type</span> M<span class="delimiter">[</span>x<span class="delimiter">]</span> = A<span class="delimiter">[</span>x<span class="delimiter">]</span> <span class="delimiter">}</span> = <a href="#sbt.appmacro.Instance.applicativeInstance;$anon" title="sbt.appmacro.Instance" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.appmacro.Instance" id="sbt.appmacro.Instance.applicativeInstance;$anon">Instance</a> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[x]A[x]" id="sbt.appmacro.Instance.applicativeInstance;$anon;M">M</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.applicativeInstance;$anon;M;x">x</a><span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance.applicativeInstance;A" title="A[x]">A</a><span class="delimiter">[</span>x<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[K[L[x]], Z](in: K[A], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])A[Z]" id="sbt.appmacro.Instance.applicativeInstance;$anon.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.appmacro.Instance.applicativeInstance;$anon.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.appmacro.Instance.applicativeInstance;$anon.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.applicativeInstance;$anon.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt.appmacro.Instance.applicativeInstance;$anon.app;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[A]" id="sbt.appmacro.Instance.applicativeInstance;$anon.app.in">in</a>: <a href="#sbt.appmacro.Instance.applicativeInstance;$anon.app;K" title="K[A]">K</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; Z" id="sbt.appmacro.Instance.applicativeInstance;$anon.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt.appmacro.Instance.applicativeInstance;$anon.app.a">a</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.appmacro.Instance.applicativeInstance;$anon.app.a" title="sbt.AList[K]">a</a>.<a href="../AList.scala.html#sbt;AList.apply" title="[M[_], C](value: K[M], f: K[sbt.Types.Id] =&gt; C)(implicit a: sbt.Classes.Applicative[M])M[C]">apply</a><span title="(value: K[A], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.Classes.Applicative[A])A[Z]" class="delimiter">[</span><a href="#sbt.appmacro.Instance.applicativeInstance;A" title="A">A</a>, <a href="#sbt.appmacro.Instance.applicativeInstance;$anon.app;Z" title="Z">Z</a><span class="delimiter">]</span><a href="#sbt.appmacro.Instance.applicativeInstance.ap" title="sbt.Classes.Applicative[A]" class="delimiter">(</a><a href="#sbt.appmacro.Instance.applicativeInstance;$anon.app.in" title="K[A]">in</a>, <a href="#sbt.appmacro.Instance.applicativeInstance;$anon.app.f" title="K[sbt.Types.Id] =&gt; Z">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S, T](in: A[S], f: S =&gt; T)A[T]" id="sbt.appmacro.Instance.applicativeInstance;$anon.map">map</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.applicativeInstance;$anon.map;S">S</a>, <a title="" id="sbt.appmacro.Instance.applicativeInstance;$anon.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[S]" id="sbt.appmacro.Instance.applicativeInstance;$anon.map.in">in</a>: <a href="#sbt.appmacro.Instance.applicativeInstance;A" title="A[S]">A</a><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="S =&gt; T" id="sbt.appmacro.Instance.applicativeInstance;$anon.map.f">f</a>: S =&gt; T<span class="delimiter">)</span> = <a href="#sbt.appmacro.Instance.applicativeInstance.ap" title="sbt.Classes.Applicative[A]">ap</a>.<a href="../Classes.scala.html#sbt.Classes;Applicative.map" title="(f: S =&gt; T, v: A[S])A[T]">map</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.applicativeInstance;$anon.map.f" title="S =&gt; T">f</a>, <a href="#sbt.appmacro.Instance.applicativeInstance;$anon.map.in" title="A[S]">in</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S](s: () =&gt; S)this.M[S]" id="sbt.appmacro.Instance.applicativeInstance;$anon.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.applicativeInstance;$anon.pure;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; S" id="sbt.appmacro.Instance.applicativeInstance;$anon.pure.s">s</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt.appmacro.Instance.applicativeInstance;A" title="this.M[S]">M</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance.applicativeInstance.ap" title="sbt.Classes.Applicative[A]">ap</a>.<a href="../Classes.scala.html#sbt.Classes;Applicative.pure" title="(s: =&gt; S)A[S]">pure</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.applicativeInstance;$anon.pure.s" title="()S">s</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="Instance[A[_]] extends sbt.appmacro.Instance" id="sbt.appmacro.Instance;AI">AI</a><span class="delimiter">[</span><a title="[_]" id="sbt.appmacro.Instance;AI;A">A</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;AI;A;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance;<refinement>" title="Instance extends sbt.appmacro.Instance">Instance</a> <span class="delimiter">{</span> <span class="keyword">type</span> M<span class="delimiter">[</span>x<span class="delimiter">]</span> = A<span class="delimiter">[</span>x<span class="delimiter">]</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[A[_], B[_]](implicit a: sbt.appmacro.Instance.AI[A], implicit b: sbt.appmacro.Instance.AI[B])sbt.appmacro.Instance{type M[x] = A[B[x]]}" id="sbt.appmacro.Instance.compose">compose</a><span class="delimiter">[</span><a title="[_]" id="sbt.appmacro.Instance.compose;A">A</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.compose;A;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.appmacro.Instance.compose;B">B</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance.compose;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.appmacro.Instance.AI[A]" id="sbt.appmacro.Instance.compose.a">a</a>: <a href="#sbt.appmacro.Instance;<refinement>" title="sbt.appmacro.Instance.AI[A]">AI</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.appmacro.Instance.AI[B]" id="sbt.appmacro.Instance.compose.b">b</a>: <a href="#sbt.appmacro.Instance;<refinement>" title="sbt.appmacro.Instance.AI[B]">AI</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.appmacro.Instance;<refinement>" title="Instance extends sbt.appmacro.Instance">Instance</a> <span class="delimiter">{</span> <span class="keyword">type</span> M<span class="delimiter">[</span>x<span class="delimiter">]</span> = A<span class="delimiter">[</span>B<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span> = <span title="sbt.appmacro.Instance.Composed[A,B]" class="keyword">new</span> <a href="#sbt.appmacro.Instance;Composed" title="sbt.appmacro.Instance.Composed[A,B]">Composed</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance.compose.a" title="sbt.appmacro.Instance.AI[A]">a</a>, <a href="#sbt.appmacro.Instance.compose.b" title="sbt.appmacro.Instance.AI[B]">b</a><span class="delimiter">)</span>
  <span class="comment">// made a public, named, unsealed class because of trouble with macros and inference when the Instance is not an object</span>
  <span class="keyword">class</span> <a title="class Composed[A[_], B[_]] extends AnyRef with sbt.appmacro.Instance" id="sbt.appmacro.Instance;Composed">Composed</a><span class="delimiter">[</span><a title="[_]" id="sbt.appmacro.Instance;Composed;A">A</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed;A;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.appmacro.Instance;Composed;B">B</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.appmacro.Instance;Composed" title="sbt.appmacro.Instance.Composed[A,B]" class="delimiter">(</a><a title="sbt.appmacro.Instance.AI[A]" id="sbt.appmacro.Instance;Composed.a">a</a>: <a href="#sbt.appmacro.Instance;<refinement>" title="sbt.appmacro.Instance.AI[A]">AI</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.appmacro.Instance.AI[B]" id="sbt.appmacro.Instance;Composed.b">b</a>: <a href="#sbt.appmacro.Instance;<refinement>" title="sbt.appmacro.Instance.AI[B]">AI</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.appmacro;Instance" title="sbt.appmacro.Instance">Instance</a> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[x]A[B[x]]" id="sbt.appmacro.Instance;Composed;M">M</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed;M;x">x</a><span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance;Composed;A" title="A[B[x]]">A</a><span class="delimiter">[</span>B<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[S](s: () =&gt; S)A[B[S]]" id="sbt.appmacro.Instance;Composed.pure">pure</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed.pure;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; S" id="sbt.appmacro.Instance;Composed.pure.s">s</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; S<span class="delimiter">)</span>: <a href="#sbt.appmacro.Instance;Composed;A" title="A[B[S]]">A</a><span class="delimiter">[</span>B<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance;Composed.a" title="sbt.appmacro.Instance.AI[A]">a</a>.<a href="#sbt.appmacro;Instance.pure" title="(t: () =&gt; Composed.this.b.M[S])Composed.this.a.M[Composed.this.b.M[S]]">pure</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro.Instance;Composed.b" title="sbt.appmacro.Instance.AI[B]">b</a>.<a href="#sbt.appmacro;Instance.pure" title="(t: () =&gt; S)Composed.this.b.M[S]">pure</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance;Composed.pure.s" title="() =&gt; S">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[S, T](in: Composed.this.M[S], f: S =&gt; T)Composed.this.M[T]" id="sbt.appmacro.Instance;Composed.map">map</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed.map;S">S</a>, <a title="" id="sbt.appmacro.Instance;Composed.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Composed.this.M[S]" id="sbt.appmacro.Instance;Composed.map.in">in</a>: <a href="#sbt.appmacro.Instance;Composed;A" title="Composed.this.M[S]">M</a><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="S =&gt; T" id="sbt.appmacro.Instance;Composed.map.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="#sbt.appmacro.Instance;Composed;A" title="Composed.this.M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance;Composed.a" title="sbt.appmacro.Instance.AI[A]">a</a>.<a href="#sbt.appmacro;Instance.map" title="(in: Composed.this.a.M[B[S]], f: B[S] =&gt; Composed.this.b.M[T])Composed.this.a.M[Composed.this.b.M[T]]">map</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance;Composed.map.in" title="Composed.this.M[S]">in</a>, <span class="delimiter">(</span>bv: <a href="#sbt.appmacro.Instance;Composed;B" title="B[S]">B</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro.Instance;Composed.b" title="sbt.appmacro.Instance.AI[B]">b</a>.<a href="#sbt.appmacro;Instance.map" title="(in: Composed.this.b.M[S], f: S =&gt; T)Composed.this.b.M[T]">map</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance;Composed.map.$anonfun.bv" title="B[S]">bv</a>, <a href="#sbt.appmacro.Instance;Composed.map.f" title="S =&gt; T">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[K[L[x]], Z](in: K[Composed.this.M], f: K[sbt.Types.Id] =&gt; Z)(implicit alist: sbt.AList[K])A[B[Z]]" id="sbt.appmacro.Instance;Composed.app">app</a><span class="delimiter">[</span><a title="[L[x]]" id="sbt.appmacro.Instance;Composed.app;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.appmacro.Instance;Composed.app;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed.app;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="sbt.appmacro.Instance;Composed.app;Z">Z</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[Composed.this.M]" id="sbt.appmacro.Instance;Composed.app.in">in</a>: <a href="#sbt.appmacro.Instance;Composed.app;K" title="K[Composed.this.M]">K</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="K[sbt.Types.Id] =&gt; Z" id="sbt.appmacro.Instance;Composed.app.f">f</a>: K<span class="delimiter">[</span>Id<span class="delimiter">]</span> =&gt; Z<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[K]" id="sbt.appmacro.Instance;Composed.app.alist">alist</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[K]">AList</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.appmacro.Instance;Composed;A" title="A[B[Z]]">A</a><span class="delimiter">[</span>B<span class="delimiter">[</span>Z<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="K[B] =&gt; B[Z]" id="sbt.appmacro.Instance;Composed.app.g">g</a>: K<span class="delimiter">[</span>B<span class="delimiter">]</span> =&gt; B<span class="delimiter">[</span>Z<span class="delimiter">]</span> = <a title="K[B]" id="sbt.appmacro.Instance;Composed.app.g.$anonfun.in">in</a> =&gt; <a href="#sbt.appmacro.Instance;Composed.b" title="sbt.appmacro.Instance.AI[B]">b</a>.<a href="#sbt.appmacro;Instance.app" title="[K[L[x]], Z](in: K[Composed.this.b.M], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])Composed.this.b.M[Z]">app</a><span title="(in: K[Composed.this.b.M], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])Composed.this.b.M[Z]" class="delimiter">[</span><a href="#sbt.appmacro.Instance;Composed.app;K" title="K">K</a>, <a href="#sbt.appmacro.Instance;Composed.app;Z" title="Z">Z</a><span class="delimiter">]</span><a href="#sbt.appmacro.Instance;Composed.app.alist" title="sbt.AList[K]" class="delimiter">(</a><a href="#sbt.appmacro.Instance;Composed.app.g.$anonfun.in" title="K[B]">in</a>, <a href="#sbt.appmacro.Instance;Composed.app.f" title="K[sbt.Types.Id] =&gt; Z">f</a><span class="delimiter">)</span>
        <span class="keyword">type</span> <a title="[L[x]]K[[T]L[B[T]]]" id="sbt.appmacro.Instance;Composed.app;Split">Split</a><span class="delimiter">[</span><a title="[x]" id="sbt.appmacro.Instance;Composed.app;Split;L">L</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.Instance;Composed.app;Split;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.appmacro.Instance;Composed.app;K" title="K[[T]L[B[T]]]">K</a><span class="delimiter">[</span><span class="delimiter">(</span>L ∙ B<span class="delimiter">)</span>#l<span class="delimiter">]</span>
        <a href="#sbt.appmacro.Instance;Composed.a" title="sbt.appmacro.Instance.AI[A]">a</a>.<a href="#sbt.appmacro;Instance.app" title="[K[L[x]], Z](in: K[Composed.this.a.M], f: K[sbt.Types.Id] =&gt; Z)(implicit a: sbt.AList[K])Composed.this.a.M[Z]">app</a><span title="(in: Split[Composed.this.a.M], f: Split[sbt.Types.Id] =&gt; B[Z])(implicit a: sbt.AList[Split])Composed.this.a.M[B[Z]]" class="delimiter">[</span><a href="#sbt.appmacro.Instance;Composed.app;K" title="Split">Split</a>, <a href="#sbt.appmacro.Instance;Composed;B" title="B[Z]">B</a><span class="delimiter">[</span>Z<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.appmacro.Instance;Composed.app.in" title="K[Composed.this.M]">in</a>, <a href="#sbt.appmacro.Instance;Composed.app.g" title="K[B] =&gt; B[Z]">g</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../AList.scala.html#sbt.AList" title="sbt.AList.type">AList</a>.<a href="../AList.scala.html#sbt.AList.asplit" title="(base: sbt.AList[K])sbt.AList.ASplit[K,B]">asplit</a><span class="delimiter">(</span><a href="#sbt.appmacro.Instance;Composed.app.alist" title="sbt.AList[K]">alist</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
