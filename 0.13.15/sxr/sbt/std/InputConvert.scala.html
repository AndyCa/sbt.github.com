<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/std/InputConvert.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> std

<span class="keyword">import</span> <span title="language.type">language</span>.<span title="language.experimental.type">experimental</span>.macros
<span class="keyword">import</span> scala.reflect._
<span class="keyword">import</span> reflect.macros._

<span class="keyword">import</span> <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.Initialize
<span class="keyword">import</span> complete.Parser
<span class="keyword">import</span> appmacro.<span class="delimiter">{</span> Convert, Converted <span class="delimiter">}</span>

<span class="keyword">object</span> <a title="sbt.std.InputInitConvert.type" id="sbt.std.InputInitConvert">InputInitConvert</a> <a href="#sbt.std.InputInitConvert" title="sbt.std.InputInitConvert.type" class="keyword">extends</a> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" id="sbt.std.InputInitConvert.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.InputInitConvert.apply;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.InputInitConvert.apply.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.InputInitConvert.apply.nme">nme</a>: <span title="String">String</span>, <a title="c.Tree" id="sbt.std.InputInitConvert.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
    <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InputInitConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapInit_☃☃&quot;)">WrapInitName</span><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.InputInitConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InputInitConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapInitTask_☃☃&quot;)">WrapInitTaskName</span><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted;Failure" title="(position: c.Position, message: String)sbt.appmacro.Converted.Failure[c.type]">Failure</a><span class="delimiter">(</span><a href="#sbt.std.InputInitConvert.apply.in" title="c.Tree">in</a>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;Internal sbt error: initialize+task wrapper not split&quot;)" class="string">&quot;Internal sbt error: initialize+task wrapper not split&quot;</span><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
<span class="delimiter">}</span>

<span class="comment">/** Converts an input `Tree` of type `Parser[T]` or `State =&gt; Parser[T]` into a `Tree` of type `State =&gt; Parser[T]`.*/</span>
<span class="keyword">object</span> <a title="sbt.std.ParserConvert.type" id="sbt.std.ParserConvert">ParserConvert</a> <a href="#sbt.std.ParserConvert" title="sbt.std.ParserConvert.type" class="keyword">extends</a> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$2: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" id="sbt.std.ParserConvert.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.ParserConvert.apply;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.ParserConvert.apply.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.ParserConvert.apply.nme">nme</a>: <span title="String">String</span>, <a title="c.Tree" id="sbt.std.ParserConvert.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.ParserConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.WrapName" title="=&gt; String">WrapName</a><span class="delimiter">)</span>
        <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.ParserConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.ParserConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.WrapInitName" title="=&gt; String">WrapInitName</a><span class="delimiter">)</span>
        <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted;Failure" title="(position: c.Position, message: String)sbt.appmacro.Converted.Failure[c.type]">Failure</a><span class="delimiter">(</span><a href="#sbt.std.ParserConvert.apply.in" title="c.Tree">in</a>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;Internal sbt error: initialize+parser wrapper not split&quot;)" class="string">&quot;Internal sbt error: initialize+parser wrapper not split&quot;</span><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/** Convert instance for plain `Task`s not within the settings system. */</span>
<span class="keyword">object</span> <a title="sbt.std.TaskConvert.type" id="sbt.std.TaskConvert">TaskConvert</a> <a href="#sbt.std.TaskConvert" title="sbt.std.TaskConvert.type" class="keyword">extends</a> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$3: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" id="sbt.std.TaskConvert.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.TaskConvert.apply;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.TaskConvert.apply.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.TaskConvert.apply.nme">nme</a>: <span title="String">String</span>, <a title="c.Tree" id="sbt.std.TaskConvert.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
    <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.TaskConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> InputWrapper.<span title="String(&quot;wrapTask_☃☃&quot;)">WrapTaskName</span><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.TaskConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
<span class="delimiter">}</span>

<span class="comment">/** Converts an input `Tree` of type `Initialize[T]`, `Initialize[Task[T]]`, or `Task[T]` into a `Tree` of type `Initialize[Task[T]]`.*/</span>
<span class="keyword">object</span> <a title="sbt.std.FullConvert.type" id="sbt.std.FullConvert">FullConvert</a> <a href="#sbt.std.FullConvert" title="sbt.std.FullConvert.type" class="keyword">extends</a> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="InputWrapper.scala.html#sbt.std.InputWrapper" title="sbt.std.InputWrapper.type">InputWrapper</a>._
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$4: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" id="sbt.std.FullConvert.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.FullConvert.apply;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.FullConvert.apply.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.FullConvert.apply.nme">nme</a>: <span title="String">String</span>, <a title="c.Tree" id="sbt.std.FullConvert.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
    <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.FullConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;wrapInitTask_☃☃&quot;)">WrapInitTaskName</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.std.FullConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;wrapPrevious_☃☃&quot;)">WrapPreviousName</span><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.FullConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.FullConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;wrapInit_☃☃&quot;)">WrapInitName</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <span title="c.Expr[sbt.Def.Initialize[T]]">i</span> = <a href="#sbt.std.FullConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Def.Initialize[T]])c.Expr[sbt.Def.Initialize[T]]" class="delimiter">[</span><a href="../Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[T]">Initialize</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.FullConvert.apply.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Def.Initialize[T]]" class="delimiter">(</a><a href="#sbt.std.FullConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <span title="c.universe.Tree">t</span> = <a href="#sbt.std.FullConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Def.Initialize[sbt.Task[T]])c.universe.Expr[sbt.Def.Initialize[sbt.Task[T]]]">reify</span><span class="delimiter">(</span><a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Def.scala.html#sbt.Def.toITask" title="(i: sbt.Def.Initialize[T])sbt.Def.Initialize[sbt.Task[T]]">toITask</a><span class="delimiter">(</span><span title="c.Expr[sbt.Def.Initialize[T]]">i</span>.<span title="=&gt; sbt.Def.Initialize[T]">splice</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><span title="c.universe.Tree">t</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.FullConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;wrapTask_☃☃&quot;)">WrapTaskName</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <span title="c.Expr[sbt.Task[T]]">i</span> = <a href="#sbt.std.FullConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.Task[T]])c.Expr[sbt.Task[T]]" class="delimiter">[</span><a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.FullConvert.apply.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.Task[T]]" class="delimiter">(</a><a href="#sbt.std.FullConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <span title="c.universe.Tree">t</span> = <a href="#sbt.std.FullConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Def.Initialize[sbt.Task[T]])c.universe.Expr[sbt.Def.Initialize[sbt.Task[T]]]">reify</span><span class="delimiter">(</span><a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.valueStrict" title="[T](value: T)sbt.Def.Initialize[T]">valueStrict</a><span title="(value: sbt.Task[T])sbt.Def.Initialize[sbt.Task[T]]" class="delimiter">[</span><a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="c.Expr[sbt.Task[T]]">i</span>.<span title="=&gt; sbt.Task[T]">splice</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; c.universe.Tree">tree</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><span title="c.universe.Tree">t</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * Converts an input `Tree` of type `State =&gt; Parser[T]` or `Initialize[State =&gt; Parser[T]]`
 * into a `Tree` of type `Initialize[State =&gt; Parser[T]]`.
 */</span>
<span class="keyword">object</span> <a title="sbt.std.InitParserConvert.type" id="sbt.std.InitParserConvert">InitParserConvert</a> <a href="#sbt.std.InitParserConvert" title="sbt.std.InitParserConvert.type" class="keyword">extends</a> <a href="../appmacro/Convert.scala.html#sbt.appmacro;Convert" title="sbt.appmacro.Convert">Convert</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(nme: String, in: c.Tree)(implicit evidence$5: c.WeakTypeTag[T])sbt.appmacro.Converted[c.type]" id="sbt.std.InitParserConvert.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.InitParserConvert.apply;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.std.InitParserConvert.apply.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.std.InitParserConvert.apply.nme">nme</a>: <span title="String">String</span>, <a title="c.Tree" id="sbt.std.InitParserConvert.apply.in">in</a>: c.<span title="c.Tree">Tree</span><span class="delimiter">)</span>: <a href="../appmacro/Convert.scala.html#sbt.appmacro;Converted" title="sbt.appmacro.Converted[c.type]">Converted</a><span class="delimiter">[</span>c.<span class="keyword">type</span><span class="delimiter">]</span> =
    <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InitParserConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.WrapName" title="=&gt; String">WrapName</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="c.Expr[sbt.State =&gt; sbt.complete.Parser[T]]" id="sbt.std.InitParserConvert.apply.e">e</a> = <a href="#sbt.std.InitParserConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[sbt.State =&gt; sbt.complete.Parser[T]])c.Expr[sbt.State =&gt; sbt.complete.Parser[T]]" class="delimiter">[</span>State =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.std.InitParserConvert.apply.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[sbt.State =&gt; sbt.complete.Parser[T]]" class="delimiter">(</a><a href="#sbt.std.InitParserConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="c.universe.Expr[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]" id="sbt.std.InitParserConvert.apply.t">t</a> = <a href="#sbt.std.InitParserConvert.apply.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="(expr: sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]])c.universe.Expr[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]">reify</span> <span class="delimiter">{</span> <a href="../Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="../Settings.scala.html#sbt;Init.valueStrict" title="[T](value: T)sbt.Def.Initialize[T]">valueStrict</a><span title="(value: sbt.State =&gt; sbt.complete.Parser[T])sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]" class="delimiter">[</span>State =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.InitParserConvert.apply.e" title="c.Expr[sbt.State =&gt; sbt.complete.Parser[T]]">e</a>.<span title="=&gt; sbt.State =&gt; sbt.complete.Parser[T]">splice</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.InitParserConvert.apply.t" title="c.universe.Expr[sbt.Def.Initialize[sbt.State =&gt; sbt.complete.Parser[T]]]">t</a>.<span title="=&gt; c.universe.Tree">tree</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="sbt.appmacro.Converted[c.type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.std.InitParserConvert.apply.nme" title="String">nme</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="InputWrapper.scala.html#sbt.std.ParserInput" title="sbt.std.ParserInput.type">ParserInput</a>.<a href="InputWrapper.scala.html#sbt.std.ParserInput.WrapInitName" title="=&gt; String">WrapInitName</a><span class="delimiter">)</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.Success.apply(7e3102fbab)" title="(tree: c.Tree)sbt.appmacro.Converted.Success[c.type]">Success</a><span class="delimiter">(</span><a href="#sbt.std.InitParserConvert.apply.in" title="c.Tree">in</a><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted" title="sbt.appmacro.Converted.type">Converted</a>.<a href="../appmacro/Convert.scala.html#sbt.appmacro.Converted.NotApplicable" title="sbt.appmacro.Converted.NotApplicable[c.type]">NotApplicable</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
