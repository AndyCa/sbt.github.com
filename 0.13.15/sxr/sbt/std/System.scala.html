<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/std/System.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2010 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> std

<span class="keyword">import</span> <a href="../Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._
<span class="keyword">import</span> <a href="../Action.scala.html#sbt.Task" title="sbt.Task.type">Task</a>._
<span class="keyword">import</span> <a href="TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>.<span class="delimiter">{</span> all, existToAny <span class="delimiter">}</span>
<span class="keyword">import</span> <a href="../Execute.scala.html#sbt.Execute" title="sbt.Execute.type">Execute</a>._

<span class="keyword">object</span> <a title="sbt.std.Transform.type" id="sbt.std.Transform">Transform</a> <a href="#sbt.std.Transform" title="sbt.std.Transform.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[T](original: sbt.Task[T])(action: =&gt; T)sbt.Task[T]" id="sbt.std.Transform.fromDummy">fromDummy</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.fromDummy;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[T]" id="sbt.std.Transform.fromDummy.original">original</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; T" id="sbt.std.Transform.fromDummy.action">action</a>: =&gt; T<span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../Action.scala.html#sbt;Task" title="(info: sbt.Info[T], work: sbt.Action[T])sbt.Task[T]">Task</a><span class="delimiter">(</span><a href="#sbt.std.Transform.fromDummy.original" title="sbt.Task[T]">original</a>.<a href="../Action.scala.html#sbt;Task.info" title="=&gt; sbt.Info[T]">info</a>, <a href="../Action.scala.html#sbt;Pure" title="(f: () =&gt; T, inline: Boolean)sbt.Pure[T]">Pure</a><span class="delimiter">(</span><a href="#sbt.std.Transform.fromDummy.action" title="=&gt; T">action</a> _, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](original: sbt.Task[T], value: T)sbt.Task[T]" id="sbt.std.Transform.fromDummyStrict">fromDummyStrict</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.fromDummyStrict;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[T]" id="sbt.std.Transform.fromDummyStrict.original">original</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T" id="sbt.std.Transform.fromDummyStrict.value">value</a>: <a href="#sbt.std.Transform.fromDummyStrict;T" title="T">T</a><span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.std.Transform.fromDummy" title="(original: sbt.Task[T])(action: =&gt; T)sbt.Task[T]">fromDummy</a><span class="delimiter">(</span><a href="#sbt.std.Transform.fromDummyStrict.original" title="sbt.Task[T]">original</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.Transform.fromDummyStrict.value" title="T">value</a><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K[_], V[_]](map: sbt.RMap[K,V])sbt.Types.~&gt;|[K,V]" id="sbt.std.Transform.to_~>|">to_~&gt;|</a><span class="delimiter">[</span><a title="[_]" id="sbt.std.Transform.to_~>|;K">K</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.to_~>|;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.std.Transform.to_~>|;V">V</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.to_~>|;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.RMap[K,V]" id="sbt.std.Transform.to_~>|.map">map</a>: <a href="../PMap.scala.html#sbt;RMap" title="sbt.RMap[K,V]">RMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: K <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.Types.~&gt;|[K,V]">~&gt;|</a> V = <a href="#sbt.std.Transform.to_~>|;$anon" title="sbt.Types.~&gt;|[K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.Types.~&gt;|[K,V]" id="sbt.std.Transform.to_~>|;$anon" class="delimiter">(</a>K <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.Types.~&gt;|[K,V]">~&gt;|</a> V<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](k: K[T])Option[V[T]]" id="sbt.std.Transform.to_~>|;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.to_~>|;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt.std.Transform.to_~>|;$anon.apply.k">k</a>: <a href="#sbt.std.Transform.to_~>|;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.std.Transform.to_~>|.map" title="sbt.RMap[K,V]">map</a>.<a href="../PMap.scala.html#sbt;RMap.get" title="(k: K[T])Option[V[T]]">get</a><span class="delimiter">(</span><a href="#sbt.std.Transform.to_~>|;$anon.apply.k" title="K[T]">k</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class DummyTaskMap extends AnyRef with Product with Serializable" id="sbt.std.Transform.DummyTaskMap.readResolve">DummyTaskMap</a><a href="#sbt.std.Transform.DummyTaskMap.readResolve" title="Product" class="delimiter">(</a><a title="List[sbt.std.Transform.TaskAndValue[_]]" id="sbt.std.Transform;DummyTaskMap.mappings">mappings</a>: <span title="List[sbt.std.Transform.TaskAndValue[_]]">List</span><span class="delimiter">[</span>TaskAndValue<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](tav: (sbt.Task[T], T))sbt.std.Transform.DummyTaskMap" id="sbt.std.Transform;DummyTaskMap.::">::</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform;DummyTaskMap.::;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(sbt.Task[T], T)" id="sbt.std.Transform;DummyTaskMap.::.tav">tav</a>: <span title="(sbt.Task[T], T)" class="delimiter">(</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#sbt.std.Transform.DummyTaskMap.readResolve" title="sbt.std.Transform.DummyTaskMap">DummyTaskMap</a> = <a href="#sbt.std.Transform.DummyTaskMap.readResolve" title="(mappings: List[sbt.std.Transform.TaskAndValue[_]])sbt.std.Transform.DummyTaskMap">DummyTaskMap</a><span class="delimiter">(</span><span title="sbt.std.Transform.TaskAndValue[T]" class="keyword">new</span> <a href="#sbt.std.Transform;TaskAndValue" title="sbt.std.Transform.TaskAndValue[T]">TaskAndValue</a><span class="delimiter">(</span><a href="#sbt.std.Transform;DummyTaskMap.::.tav" title="(sbt.Task[T], T)">tav</a>.<span title="=&gt; sbt.Task[T]">_1</span>, <a href="#sbt.std.Transform;DummyTaskMap.::.tav" title="(sbt.Task[T], T)">tav</a>.<span title="=&gt; T">_2</span><span class="delimiter">)</span> <a href="#sbt.std.Transform;DummyTaskMap.::.x$1" title="(x: sbt.std.Transform.TaskAndValue[_])List[sbt.std.Transform.TaskAndValue[_]]">::</a> <a href="#sbt.std.Transform;DummyTaskMap.mappings" title="=&gt; List[sbt.std.Transform.TaskAndValue[_]]">mappings</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TaskAndValue[T] extends AnyRef" id="sbt.std.Transform;TaskAndValue">TaskAndValue</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform;TaskAndValue;T">T</a><span class="delimiter">]</span><a href="#sbt.std.Transform;TaskAndValue" title="sbt.std.Transform.TaskAndValue[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="sbt.Task[T]" id="sbt.std.Transform;TaskAndValue.task">task</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="T" id="sbt.std.Transform;TaskAndValue.value">value</a>: <a href="#sbt.std.Transform;TaskAndValue;T" title="T">T</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(dummyMap: sbt.std.Transform.DummyTaskMap)sbt.Types.~&gt;|[sbt.Task,sbt.Task]" id="sbt.std.Transform.dummyMap">dummyMap</a><span class="delimiter">(</span><a title="sbt.std.Transform.DummyTaskMap" id="sbt.std.Transform.dummyMap.dummyMap">dummyMap</a>: <a href="#sbt.std.Transform.DummyTaskMap.readResolve" title="sbt.std.Transform.DummyTaskMap">DummyTaskMap</a><span class="delimiter">)</span>: Task <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.Types.~&gt;|[sbt.Task,sbt.Task]">~&gt;|</a> Task =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.DelegatingPMap[sbt.Task,sbt.Task]" id="sbt.std.Transform.dummyMap.pmap">pmap</a> = <span title="sbt.DelegatingPMap[sbt.Task,sbt.Task]" class="keyword">new</span> <a href="../PMap.scala.html#sbt;DelegatingPMap" title="sbt.DelegatingPMap[sbt.Task,sbt.Task]">DelegatingPMap</a><span class="delimiter">[</span>Task, Task<span class="delimiter">]</span><span class="delimiter">(</span><span title="scala.collection.mutable.ListMap[sbt.Task[_],sbt.Task[_]]" class="keyword">new</span> collection.mutable.<span title="scala.collection.mutable.ListMap[sbt.Task[_],sbt.Task[_]]">ListMap</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[T](dummy: sbt.std.Transform.TaskAndValue[T])Unit" id="sbt.std.Transform.dummyMap.add">add</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.dummyMap.add;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.std.Transform.TaskAndValue[T]" id="sbt.std.Transform.dummyMap.add.dummy">dummy</a>: <a href="#sbt.std.Transform;TaskAndValue" title="sbt.std.Transform.TaskAndValue[T]">TaskAndValue</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span> <a href="../PMap.scala.html#sbt;DelegatingPMap.update" title="(k: sbt.Task[T], v: sbt.Task[T])Unit">pmap</a><span class="delimiter">(</span><a href="#sbt.std.Transform.dummyMap.add.dummy" title="sbt.std.Transform.TaskAndValue[T]">dummy</a>.<a href="#sbt.std.Transform;TaskAndValue.task" title="=&gt; sbt.Task[T]">task</a><span class="delimiter">)</span> = <a href="#sbt.std.Transform.fromDummyStrict" title="(original: sbt.Task[T], value: T)sbt.Task[T]">fromDummyStrict</a><span class="delimiter">(</span><a href="#sbt.std.Transform.dummyMap.add.dummy" title="sbt.std.Transform.TaskAndValue[T]">dummy</a>.<a href="#sbt.std.Transform;TaskAndValue.task" title="=&gt; sbt.Task[T]">task</a>, <a href="#sbt.std.Transform.dummyMap.add.dummy" title="sbt.std.Transform.TaskAndValue[T]">dummy</a>.<a href="#sbt.std.Transform;TaskAndValue.value" title="=&gt; T">value</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="#sbt.std.Transform.dummyMap.dummyMap" title="sbt.std.Transform.DummyTaskMap">dummyMap</a>.<a href="#sbt.std.Transform;DummyTaskMap.mappings" title="=&gt; List[sbt.std.Transform.TaskAndValue[_]]">mappings</a>.<span title="(f: sbt.std.Transform.TaskAndValue[_] =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a title="sbt.std.Transform.TaskAndValue[_]" id="sbt.std.Transform.dummyMap.$anonfun.x">x</a> =&gt; <a href="#sbt.std.Transform.dummyMap.add" title="(dummy: sbt.std.Transform.TaskAndValue[_$1])Unit">add</a><span class="delimiter">(</span><a href="#sbt.std.Transform.dummyMap.$anonfun.x" title="sbt.std.Transform.TaskAndValue[_]">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.std.Transform.to_~>|" title="(map: sbt.RMap[sbt.Task,sbt.Task])sbt.Types.~&gt;|[sbt.Task,sbt.Task]">pmap</a>
    <span class="delimiter">}</span>

  <span class="comment">/** Applies `map`, returning the result if defined or returning the input unchanged otherwise.*/</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.std.Transform.getOrId : (map: sbt.Types.~&gt;|[sbt.Task,sbt.Task])sbt.~&gt;[sbt.Task,sbt.Task]" id="sbt.std.Transform.getOrId">getOrId</a><span class="delimiter">(</span><a title="sbt.Types.~&gt;|[sbt.Task,sbt.Task]" id="sbt.std.Transform.getOrId.map">map</a>: Task <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.Types.~&gt;|[sbt.Task,sbt.Task]">~&gt;|</a> Task<span class="delimiter">)</span>: Task <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[sbt.Task,sbt.Task]">~&gt;</a> Task =
    <a href="#sbt.std.Transform.getOrId;$anon" title="sbt.~&gt;[sbt.Task,sbt.Task]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[sbt.Task,sbt.Task]" id="sbt.std.Transform.getOrId;$anon" class="delimiter">(</a>Task <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[sbt.Task,sbt.Task]">~&gt;</a> Task<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[T](in: sbt.Task[T])sbt.Task[T]" id="sbt.std.Transform.getOrId;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.getOrId;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[T]" id="sbt.std.Transform.getOrId;$anon.apply.in">in</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../TypeFunctions.scala.html#sbt;~>.apply" title="(a: sbt.Task[T])Option[sbt.Task[T]]">map</a><span class="delimiter">(</span><a href="#sbt.std.Transform.getOrId;$anon.apply.in" title="sbt.Task[T]">in</a><span class="delimiter">)</span>.<span title="(default: =&gt; sbt.Task[T])sbt.Task[T]">getOrElse</span><span class="delimiter">(</span><a href="#sbt.std.Transform.getOrId;$anon.apply.in" title="sbt.Task[T]">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(dummies: sbt.std.Transform.DummyTaskMap)sbt.NodeView[sbt.Task]" id="sbt.std.Transform.apply">apply</a><span class="delimiter">(</span><a title="sbt.std.Transform.DummyTaskMap" id="sbt.std.Transform.apply.dummies">dummies</a>: <a href="#sbt.std.Transform.DummyTaskMap.readResolve" title="sbt.std.Transform.DummyTaskMap">DummyTaskMap</a><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">import</span> <span title="System.type">System</span>._
      <a href="#sbt.std.Transform.taskToNode" title="(pre: sbt.~&gt;[sbt.Task,sbt.Task])sbt.NodeView[sbt.Task]">taskToNode</a><span class="delimiter">(</span><a href="#sbt.std.Transform.getOrId" title="implicit sbt.std.Transform.getOrId : (map: sbt.Types.~&gt;|[sbt.Task,sbt.Task])sbt.~&gt;[sbt.Task,sbt.Task]">getOrId</a><span class="delimiter">(</span><a href="#sbt.std.Transform.dummyMap" title="(dummyMap: sbt.std.Transform.DummyTaskMap)sbt.Types.~&gt;|[sbt.Task,sbt.Task]">dummyMap</a><span class="delimiter">(</span><a href="#sbt.std.Transform.apply.dummies" title="sbt.std.Transform.DummyTaskMap">dummies</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(pre: sbt.~&gt;[sbt.Task,sbt.Task])sbt.NodeView[sbt.Task]" id="sbt.std.Transform.taskToNode">taskToNode</a><span class="delimiter">(</span><a title="sbt.~&gt;[sbt.Task,sbt.Task]" id="sbt.std.Transform.taskToNode.pre">pre</a>: Task <a href="../TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[sbt.Task,sbt.Task]">~&gt;</a> Task<span class="delimiter">)</span>: <a href="../Execute.scala.html#sbt;NodeView" title="sbt.NodeView[sbt.Task]">NodeView</a><span class="delimiter">[</span>Task<span class="delimiter">]</span> = <a href="#sbt.std.Transform.taskToNode;$anon" title="sbt.NodeView[sbt.Task]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.NodeView[sbt.Task]" id="sbt.std.Transform.taskToNode;$anon">NodeView</a><span class="delimiter">[</span>Task<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](t: sbt.Task[T])sbt.Node[sbt.Task,T]" id="sbt.std.Transform.taskToNode;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.taskToNode;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[T]" id="sbt.std.Transform.taskToNode;$anon.apply.t">t</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Node.scala.html#sbt;Node" title="sbt.Node[sbt.Task,T]">Node</a><span class="delimiter">[</span>Task, T<span class="delimiter">]</span> = <a href="../TypeFunctions.scala.html#sbt;~>.apply" title="(a: sbt.Task[T])sbt.Task[T]">pre</a><span class="delimiter">(</span><a href="#sbt.std.Transform.taskToNode;$anon.apply.t" title="sbt.Task[T]">t</a><span class="delimiter">)</span>.<a href="../Action.scala.html#sbt;Task.work" title="=&gt; sbt.Action[T]">work</a> <span title="sbt.Node[sbt.Task,T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Pure<span class="delimiter">(</span><a title="() =&gt; T" id="sbt.std.Transform.taskToNode;$anon.apply.eval">eval</a>, _<span class="delimiter">)</span>       =&gt; <a href="#sbt.std.Transform.uniform" title="(tasks: Seq[sbt.Task[Nothing]])(f: Seq[sbt.Result[Nothing]] =&gt; Either[sbt.Task[T],T])sbt.Node[sbt.Task,T]">uniform</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Seq[sbt.Result[Nothing]]" id="sbt.std.Transform.taskToNode;$anon.apply.$anonfun.x$2">_</a> =&gt; <span title="(b: T)scala.util.Right[Nothing,T]">Right</span><span class="delimiter">(</span><a href="#sbt.std.Transform.taskToNode;$anon.apply.eval" title="()T">eval</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="sbt.Mapped[t,k[L]]">m</span>: <a href="../Action.scala.html#sbt;Mapped" title="sbt.Mapped[t,k[L]]">Mapped</a><span class="delimiter">[</span>t, k<span class="delimiter">]</span>     =&gt; <a href="#sbt.std.Transform.toNode" title="[T, k[L[x]]](inputs: k[sbt.Task])(f: k[sbt.Result] =&gt; Either[sbt.Task[T],T])(implicit a: sbt.AList[k])sbt.Node[sbt.Task,T]">toNode</a><span title="(inputs: k[sbt.Task])(f: k[sbt.Result] =&gt; Either[sbt.Task[t],t])(implicit a: sbt.AList[k])sbt.Node[sbt.Task,t]" class="delimiter">[</span><a href="#sbt.std.Transform.taskToNode;$anon.apply;t" title="t">t</a>, <span title="k">k</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="sbt.Mapped[t,k[L]]">m</span>.<a href="../Action.scala.html#sbt;Mapped.in" title="=&gt; k[sbt.Task]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.right" title="=&gt; sbt.~&gt;[sbt.Types.Id,[B]scala.util.Right[Nothing,B]]">right</a> <a href="../TypeFunctions.scala.html#sbt;~>.∙(3ac26a5aef)" title="(g: Any =&gt; t)(implicit ev: &lt;:&lt;[t,sbt.Types.Id[t]])Any =&gt; scala.util.Right[Nothing,t]">∙</a> <span title="sbt.Mapped[t,k[L]]">m</span>.<a href="../Action.scala.html#sbt;Mapped.f" title="=&gt; k[sbt.Result] =&gt; t">f</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="sbt.Mapped[t,k[L]]">m</span>.<a href="../Action.scala.html#sbt;Mapped.alist" title="=&gt; sbt.AList[k[L]]">alist</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="sbt.FlatMapped[t,k[L]]">m</span>: <a href="../Action.scala.html#sbt;FlatMapped" title="sbt.FlatMapped[t,k[L]]">FlatMapped</a><span class="delimiter">[</span>t, k<span class="delimiter">]</span> =&gt; <a href="#sbt.std.Transform.toNode" title="[T, k[L[x]]](inputs: k[sbt.Task])(f: k[sbt.Result] =&gt; Either[sbt.Task[T],T])(implicit a: sbt.AList[k])sbt.Node[sbt.Task,T]">toNode</a><span title="(inputs: k[sbt.Task])(f: k[sbt.Result] =&gt; Either[sbt.Task[t],t])(implicit a: sbt.AList[k])sbt.Node[sbt.Task,t]" class="delimiter">[</span><a href="#sbt.std.Transform.taskToNode;$anon.apply;t" title="t">t</a>, <span title="k">k</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="sbt.FlatMapped[t,k[L]]">m</span>.<a href="../Action.scala.html#sbt;FlatMapped.in" title="=&gt; k[sbt.Task]">in</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.left" title="=&gt; sbt.~&gt;[sbt.Types.Id,[B]scala.util.Left[B,Nothing]]">left</a> <a href="../TypeFunctions.scala.html#sbt;~>.∙(3ac26a5aef)" title="(g: Any =&gt; sbt.Task[t])(implicit ev: &lt;:&lt;[sbt.Task[t],sbt.Types.Id[sbt.Task[t]]])Any =&gt; scala.util.Left[sbt.Task[t],Nothing]">∙</a> <span title="sbt.FlatMapped[t,k[L]]">m</span>.<a href="../Action.scala.html#sbt;FlatMapped.f" title="=&gt; k[sbt.Result] =&gt; sbt.Task[t]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="sbt.FlatMapped[t,k[L]]">m</span>.<a href="../Action.scala.html#sbt;FlatMapped.alist" title="=&gt; sbt.AList[k[L]]">alist</a><span class="delimiter">)</span>
      <span class="keyword">case</span> DependsOn<span class="delimiter">(</span><span title="sbt.Task[T]">in</span>, <a title="Seq[sbt.Task[_]]" id="sbt.std.Transform.taskToNode;$anon.apply.deps">deps</a><span class="delimiter">)</span> =&gt; <a href="#sbt.std.Transform.uniform" title="(tasks: Seq[sbt.Task[Any]])(f: Seq[sbt.Result[Any]] =&gt; Either[sbt.Task[T],T])sbt.Node[sbt.Task,T]">uniform</a><span class="delimiter">(</span><a href="TaskExtra.scala.html#sbt.std.TaskExtra.existToAny" title="(in: Seq[sbt.Task[_]])Seq[sbt.Task[Any]]">existToAny</a><span class="delimiter">(</span><a href="#sbt.std.Transform.taskToNode;$anon.apply.deps" title="Seq[sbt.Task[_]]">deps</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: scala.util.Left[sbt.Task[T],Nothing])Any =&gt; scala.util.Left[sbt.Task[T],Nothing]">const</a><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.toFn1" title="(f: Any =&gt; scala.util.Left[sbt.Task[T],Nothing])sbt.Fn1[Any,scala.util.Left[sbt.Task[T],Nothing]]" class="delimiter">(</a><span title="(a: sbt.Task[T])scala.util.Left[sbt.Task[T],Nothing]">Left</span><span class="delimiter">(</span><span title="sbt.Task[T]">in</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../TypeFunctions.scala.html#sbt;Fn1.∙" title="(g: Seq[sbt.Result[Any]] =&gt; Any)Seq[sbt.Result[Any]] =&gt; scala.util.Left[sbt.Task[T],Nothing]">∙</a> <a href="TaskExtra.scala.html#sbt.std.TaskExtra.all" title="(in: Seq[sbt.Result[Any]])Seq[Any]">all</a><span class="delimiter">)</span>
      <span class="keyword">case</span> Join<span class="delimiter">(</span><span title="Seq[sbt.Task[Any]]">in</span>, <a title="Seq[sbt.Result[Any]] =&gt; Either[sbt.Task[T],T]" id="sbt.std.Transform.taskToNode;$anon.apply.f">f</a><span class="delimiter">)</span>         =&gt; <a href="#sbt.std.Transform.uniform" title="(tasks: Seq[sbt.Task[Any]])(f: Seq[sbt.Result[Any]] =&gt; Either[sbt.Task[T],T])sbt.Node[sbt.Task,T]">uniform</a><span class="delimiter">(</span><span title="Seq[sbt.Task[Any]]">in</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.Transform.taskToNode;$anon.apply.f" title="Seq[sbt.Result[Any]] =&gt; Either[sbt.Task[T],T]">f</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[T](t: sbt.Task[T])Option[() =&gt; T]" id="sbt.std.Transform.taskToNode;$anon.inline">inline</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.taskToNode;$anon.inline;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Task[T]" id="sbt.std.Transform.taskToNode;$anon.inline.t">t</a>: <a href="../Action.scala.html#sbt;Task" title="sbt.Task[T]">Task</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.std.Transform.taskToNode;$anon.inline.t" title="sbt.Task[T]">t</a>.<a href="../Action.scala.html#sbt;Task.work" title="=&gt; sbt.Action[T]">work</a> <span title="Option[() =&gt; T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Pure<span class="delimiter">(</span><a title="() =&gt; T" id="sbt.std.Transform.taskToNode;$anon.inline.eval">eval</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> =&gt; <span title="(x: () =&gt; T)Some[() =&gt; T]">Some</span><span class="delimiter">(</span><a href="#sbt.std.Transform.taskToNode;$anon.inline.eval" title="() =&gt; T">eval</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _                =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T, D](tasks: Seq[sbt.Task[D]])(f: Seq[sbt.Result[D]] =&gt; Either[sbt.Task[T],T])sbt.Node[sbt.Task,T]" id="sbt.std.Transform.uniform">uniform</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.uniform;T">T</a>, <a title="" id="sbt.std.Transform.uniform;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[sbt.Task[D]]" id="sbt.std.Transform.uniform.tasks">tasks</a>: <span title="Seq[sbt.Task[D]]">Seq</span><span class="delimiter">[</span>Task<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Seq[sbt.Result[D]] =&gt; Either[sbt.Task[T],T]" id="sbt.std.Transform.uniform.f">f</a>: Seq<span class="delimiter">[</span>Result<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Either<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Node.scala.html#sbt;Node" title="sbt.Node[sbt.Task,T]">Node</a><span class="delimiter">[</span>Task, T<span class="delimiter">]</span> =
    <a href="#sbt.std.Transform.toNode" title="[T, k[L[x]]](inputs: k[sbt.Task])(f: k[sbt.Result] =&gt; Either[sbt.Task[T],T])(implicit a: sbt.AList[k])sbt.Node[sbt.Task,T]">toNode</a><span title="(inputs: List[sbt.Task[D]])(f: List[sbt.Result[D]] =&gt; Either[sbt.Task[T],T])(implicit a: sbt.AList[[L[x]]List[L[D]]])sbt.Node[sbt.Task,T]" class="delimiter">[</span><a href="#sbt.std.Transform.uniform;T" title="T">T</a>, <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>L<span class="delimiter">[</span>x<span class="delimiter">]</span><span class="delimiter">]</span> = List<span class="delimiter">[</span>L<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[L[x]]List[L[D]]">l</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.std.Transform.uniform.tasks" title="Seq[sbt.Task[D]]">tasks</a>.<span title="=&gt; List[sbt.Task[D]]">toList</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.std.Transform.uniform.f" title="Seq[sbt.Result[D]] =&gt; Either[sbt.Task[T],T]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../AList.scala.html#sbt.AList" title="sbt.AList.type">AList</a>.<a href="../AList.scala.html#sbt.AList.seq" title="[T]=&gt; sbt.AList.SeqList[T]">seq</a><span title="sbt.AList.SeqList[D]" class="delimiter">[</span><a href="#sbt.std.Transform.uniform;D" title="D">D</a><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T, k[L[x]]](inputs: k[sbt.Task])(f: k[sbt.Result] =&gt; Either[sbt.Task[T],T])(implicit a: sbt.AList[k])sbt.Node[sbt.Task,T]" id="sbt.std.Transform.toNode">toNode</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.toNode;T">T</a>, <a title="[L[x]]" id="sbt.std.Transform.toNode;k">k</a><span class="delimiter">[</span><a title="[x]" id="sbt.std.Transform.toNode;k;L">L</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.toNode;k;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="k[sbt.Task]" id="sbt.std.Transform.toNode.inputs">inputs</a>: <a href="#sbt.std.Transform.toNode;k" title="k[sbt.Task]">k</a><span class="delimiter">[</span>Task<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="k[sbt.Result] =&gt; Either[sbt.Task[T],T]" id="sbt.std.Transform.toNode.f">f</a>: k<span class="delimiter">[</span>Result<span class="delimiter">]</span> =&gt; Either<span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.AList[k]" id="sbt.std.Transform.toNode.a">a</a>: <a href="../AList.scala.html#sbt;AList" title="sbt.AList[k]">AList</a><span class="delimiter">[</span>k<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Node.scala.html#sbt;Node" title="sbt.Node[sbt.Task,T]">Node</a><span class="delimiter">[</span>Task, T<span class="delimiter">]</span> = <a href="#sbt.std.Transform.toNode;$anon" title="sbt.Node[sbt.Task,T]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.Node[sbt.Task,T]" id="sbt.std.Transform.toNode;$anon">Node</a><span class="delimiter">[</span>Task, T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[L[x]]k[L]" id="sbt.std.Transform.toNode;$anon;K">K</a><span class="delimiter">[</span><a title="[x]" id="sbt.std.Transform.toNode;$anon;K;L">L</a><span class="delimiter">[</span><a title="" id="sbt.std.Transform.toNode;$anon;K;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.std.Transform.toNode;k" title="k[L]">k</a><span class="delimiter">[</span>L<span class="delimiter">]</span>
    <span class="keyword">val</span> <a title="k[sbt.Task]" id="sbt.std.Transform.toNode;$anon.in">in</a> = <a href="#sbt.std.Transform.toNode.inputs" title="k[sbt.Task]">inputs</a>
    <span class="keyword">val</span> <a title="sbt.AList[k]" id="sbt.std.Transform.toNode;$anon.alist">alist</a> = <a href="#sbt.std.Transform.toNode.a" title="sbt.AList[k]">a</a>
    <span class="keyword">def</span> <a title="(results: this.K[sbt.Result])Either[sbt.Task[T],T]" id="sbt.std.Transform.toNode;$anon.work">work</a><span class="delimiter">(</span><a title="this.K[sbt.Result]" id="sbt.std.Transform.toNode;$anon.work.results">results</a>: <a href="#sbt.std.Transform.toNode;k" title="this.K[sbt.Result]">K</a><span class="delimiter">[</span>Result<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.std.Transform.toNode.f" title="(v1: k[sbt.Result])Either[sbt.Task[T],T]">f</a><span class="delimiter">(</span><a href="#sbt.std.Transform.toNode;$anon.work.results" title="this.K[sbt.Result]">results</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
