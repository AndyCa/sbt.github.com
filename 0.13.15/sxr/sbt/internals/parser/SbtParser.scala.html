<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/internals/parser/SbtParser.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> internals
<span class="keyword">package</span> parser

<span class="keyword">import</span> java.io.File

<span class="keyword">import</span> sbt.internals.parser.<a href="#sbt.internals.parser.SbtParser.readResolve" title="sbt.internals.parser.SbtParser.type">SbtParser</a>._

<span class="keyword">import</span> scala.reflect.runtime.<span title="=&gt; scala.reflect.api.JavaUniverse">universe</span>._

<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.internals.parser.SbtParser.type" id="sbt.internals.parser.SbtParser.readResolve">SbtParser</a> <a href="#sbt.internals.parser.SbtParser.readResolve" title="sbt.internals.parser.SbtParser.type" class="delimiter">{</a>
  <span class="keyword">val</span> <a title="Char" id="sbt.internals.parser.SbtParser.END_OF_LINE_CHAR">END_OF_LINE_CHAR</a> = <span title="Char('\n')" class="char">'\n'</span>
  <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtParser.END_OF_LINE">END_OF_LINE</a> = <span title="String.type">String</span>.<span title="(x$1: Char)String">valueOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.END_OF_LINE_CHAR" title="=&gt; Char">END_OF_LINE_CHAR</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>parser<span class="delimiter">]</span> <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.SbtParser.NOT_FOUND_INDEX">NOT_FOUND_INDEX</a> = -<span title="Int(-1)" class="int">1</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">val</span> <a title="java.io.File" id="sbt.internals.parser.SbtParser.FAKE_FILE">FAKE_FILE</a> = <span title="java.io.File" class="keyword">new</span> <span title="java.io.File">File</span><span class="delimiter">(</span><span title="String(&quot;fake&quot;)" class="string">&quot;fake&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>parser<span class="delimiter">]</span> <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtParser.XML_ERROR">XML_ERROR</a> = <span title="String(&quot;\';\' expected but \'val\' found.&quot;)" class="string">&quot;';' expected but 'val' found.&quot;</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * This method soley exists to add scaladoc to members in SbtParser which
 * are defined using pattern matching.
 */</span>
<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ParsedSbtFileExpressions extends AnyRef" id="sbt.internals.parser;ParsedSbtFileExpressions">ParsedSbtFileExpressions</a> <span class="delimiter">{</span>
  <span class="comment">/** The set of parsed import expressions. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(String, Int)]" id="sbt.internals.parser;ParsedSbtFileExpressions.imports">imports</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>

  <span class="comment">/** The set of parsed defintions and/or sbt build settings. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(String, sbt.LineRange)]" id="sbt.internals.parser;ParsedSbtFileExpressions.settings">settings</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>

  <span class="comment">/** The set of scala tree's for parsed definitions/settings and the underlying string representation.. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(String, reflect.runtime.universe.Tree)]" id="sbt.internals.parser;ParsedSbtFileExpressions.settingsTrees">settingsTrees</a>: <span title="Seq[(String, reflect.runtime.universe.Tree)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Tree<span class="delimiter">)</span><span class="delimiter">]</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * An initial parser/splitter of .sbt files.
 *
 * This class is responsible for chunking a `.sbt` file into expression ranges
 * which we can then compile using the Scala compiler.
 *
 * Example:
 *
 * {{{
 *   val parser = SbtParser(myFile, IO.readLines(myFile))
 *   // All import statements
 *   val imports = parser.imports
 *   // All other statements (val x =, or raw settings)
 *   val settings = parser.settings
 * }}}
 *
 * @param file  The file we're parsing (may be a dummy file)
 * @param lines The parsed &quot;lines&quot; of the file, where each string is a line.
 */</span>
<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">case class</span> <a title="(file: java.io.File, lines: Seq[String])sbt.internals.parser.SbtParser" id="sbt.internals.parser;SbtParser.equals">SbtParser</a><a href="#sbt.internals.parser;SbtParser.equals" title="Product" class="delimiter">(</a><a title="java.io.File" id="sbt.internals.parser;SbtParser.copy$default$1">file</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.internals.parser;SbtParser.copy$default$2">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.internals.parser;ParsedSbtFileExpressions" title="sbt.internals.parser.ParsedSbtFileExpressions">ParsedSbtFileExpressions</a> <span class="delimiter">{</span>
  <span class="comment">//settingsTrees,modifiedContent needed for &quot;session save&quot;</span>
  <span class="comment">// TODO - We should look into splitting out &quot;defintiions&quot; vs. &quot;settings&quot; here instead of further string lookups, since we have the</span>
  <span class="comment">// parsed trees.</span>
  <span class="keyword">val</span> <a href="#sbt.internals.parser;SbtParser.imports" title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)])" class="delimiter">(</a><a href="#sbt.internals.parser;SbtParser.x$1" title="Seq[(String, Int)]" id="sbt.internals.parser;SbtParser.imports">imports</a>, <a href="#sbt.internals.parser;SbtParser.x$1" title="Seq[(String, sbt.LineRange)]" id="sbt.internals.parser;SbtParser.settings">settings</a>, <a href="#sbt.internals.parser;SbtParser.x$1" title="Seq[(String, reflect.runtime.universe.Tree)]" id="sbt.internals.parser;SbtParser.settingsTrees">settingsTrees</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.splitExpressions" title="(file: java.io.File, lines: Seq[String])(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)])">splitExpressions</a><span title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)]) @unchecked" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.copy$default$1" title="=&gt; java.io.File">file</a>, <a href="#sbt.internals.parser;SbtParser.copy$default$2" title="=&gt; Seq[String]">lines</a><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(file: java.io.File, lines: Seq[String])(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)])" id="sbt.internals.parser;SbtParser.splitExpressions">splitExpressions</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.internals.parser;SbtParser.splitExpressions.file">file</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.internals.parser;SbtParser.splitExpressions.lines">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)])" class="delimiter">(</span>Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, Tree<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> sbt.internals.parser.<a href="#sbt.internals.parser.MissingBracketHandler" title="sbt.internals.parser.MissingBracketHandler.type">MissingBracketHandler</a>._

    <span class="keyword">import</span> scala.compat.<span title="scala.compat.Platform.type">Platform</span>.EOL
    <span class="keyword">import</span> scala.reflect.runtime._
    <span class="keyword">import</span> scala.tools.reflect.<span class="delimiter">{</span> ToolBox, ToolBoxError <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="reflect.runtime.universe.Mirror" id="sbt.internals.parser;SbtParser.splitExpressions.mirror">mirror</a> = <span title="=&gt; scala.reflect.api.JavaUniverse">universe</span>.<span title="(cl: ClassLoader)reflect.runtime.universe.Mirror">runtimeMirror</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.equals" title="SbtParser.this.type" class="keyword">this</a>.<span title="()Class[_]">getClass</span>.<span title="()ClassLoader">getClassLoader</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox">toolbox</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.mirror" title="scala.tools.reflect.ToolBoxFactory[reflect.runtime.universe.type] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox.qual$1">mirror</a>.<a title="scala.tools.reflect.FrontEnd" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox.x$6">mkToolBox</a><span class="delimiter">(</span>options = <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox.x$5" class="string">&quot;-Yrangepos&quot;</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[String]" id="sbt.internals.parser;SbtParser.splitExpressions.indexedLines">indexedLines</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.lines" title="Seq[String]">lines</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[String]">toIndexedSeq</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.content">content</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.indexedLines" title="scala.collection.immutable.IndexedSeq[String]">indexedLines</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.END_OF_LINE" title="=&gt; String">END_OF_LINE</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.fileName">fileName</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.file" title="java.io.File">file</a>.<span title="()String">getAbsolutePath</span>

    <span class="keyword">val</span> <a title="toolbox.u.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parsed">parsed</a> =
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="(code: String)toolbox.u.Tree">parse</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.content" title="String">content</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="scala.tools.reflect.ToolBoxError" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.e">e</a>: <span title="scala.tools.reflect.ToolBoxError">ToolBoxError</span> =&gt;
          <span class="keyword">val</span> <a title="scala.collection.mutable.LinkedHashSet[String]" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.seq">seq</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="=&gt; scala.tools.reflect.FrontEnd">frontEnd</span>.<span title="(=&gt; scala.collection.mutable.LinkedHashSet[_1361.Info]) forSome { val _1361: scala.tools.reflect.FrontEnd }">infos</span>.<span title="(f: _1158.Info =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.LinkedHashSet[_1158.Info],String,scala.collection.mutable.LinkedHashSet[String]])scala.collection.mutable.LinkedHashSet[String]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.LinkedHashSet.Coll,String,scala.collection.mutable.LinkedHashSet[String]]" class="delimiter">{</span> <a title="_1158.Info" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.seq.$anonfun.i">i</a> =&gt;
            <span title="(args: Any*)String">s</span>&quot;&quot;&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.fileName" title="String">fileName</a><span title="String(&quot;]:&quot;)">]:$</span><span class="delimiter">{</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.seq.$anonfun.i" title="_1158.Info">i</a>.<span title="=&gt; scala.reflect.internal.util.Position">pos</span>.<span title="=&gt; Int">line</span><span class="delimiter">}</span><span title="String(&quot;: &quot;)">: $</span><span class="delimiter">{</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.seq.$anonfun.i" title="_1158.Info">i</a>.<span title="=&gt; String">msg</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.errorMessage">errorMessage</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.seq" title="scala.collection.mutable.LinkedHashSet[String]">seq</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="=&gt; String">EOL</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.error">error</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.errorMessage" title="String">errorMessage</a>.<span title="(x$1: CharSequence)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.XML_ERROR" title="=&gt; String">XML_ERROR</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>&quot;&quot;&quot;<span title="String(&quot;\n               |&quot;)">
               |$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.errorMessage" title="String">errorMessage</a><span title="String(&quot;\n               |Probably problem with parsing xml group, please add parens or semicolons:\n               |Replace:\n               |val xmlGroup = &lt;a/&gt;&lt;b/&gt;\n               |with:\n               |val xmlGroup = (&lt;a/&gt;&lt;b/&gt;)\n               |or\n               |val xmlGroup = &lt;a/&gt;&lt;b/&gt;;\n               |\n             &quot;)" class="string">
               |Probably problem with parsing xml group, please add parens or semicolons:
               |Replace:
               |val xmlGroup = &lt;a/&gt;&lt;b/&gt;
               |with:
               |val xmlGroup = (&lt;a/&gt;&lt;b/&gt;)
               |or
               |val xmlGroup = &lt;a/&gt;&lt;b/&gt;;
               |
             &quot;&quot;&quot;</span>.<span title="=&gt; String">stripMargin</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.errorMessage" title="String">errorMessage</a>
          <span class="delimiter">}</span>
          <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="../../MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.error" title="String">error</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees">parsedTrees</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed" title="toolbox.u.Tree">parsed</a> <span title="Seq[reflect.runtime.universe.Tree]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.<unapply-selector>" title="(block: reflect.runtime.universe.Block)Option[(List[reflect.runtime.universe.Tree], reflect.runtime.universe.Tree)]">Block</a><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.Block]" class="delimiter">(</a><a title="List[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.stmt">stmt</a>, <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.expr">expr</a><span class="delimiter">)</span> =&gt;
        <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.stmt" title="List[reflect.runtime.universe.Tree]">stmt</a> <span title="(elem: reflect.runtime.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[reflect.runtime.universe.Tree],reflect.runtime.universe.Tree,List[reflect.runtime.universe.Tree]])List[reflect.runtime.universe.Tree]">:+</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.expr" title="reflect.runtime.universe.Tree">expr</a>
      <span class="keyword">case</span> <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.t">t</a>: <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.Tree]">Tree</a> =&gt;
        <span title="(elems: reflect.runtime.universe.Tree*)Seq[reflect.runtime.universe.Tree]">Seq</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.t" title="reflect.runtime.universe.Tree">t</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// Check No val (a,b) = foo *or* val a,b = foo as these are problematic to range positions and the WHOLE architecture.</span>
    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree)Boolean" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef">isBadValDef</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.t" title="reflect.runtime.universe.Tree">t</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="toolbox.u.ValDef" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.x">x</a> @ <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="=&gt; reflect.runtime.universe.type">u</span>.<a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.<unapply-selector>" title="(valDef: toolbox.u.ValDef)Option[(toolbox.u.Modifiers, toolbox.u.TermName, toolbox.u.Tree, toolbox.u.Tree)]">ValDef</a><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.ValDef]" class="delimiter">(</a>_, _, _, <a title="toolbox.u.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.rhs">rhs</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.rhs" title="toolbox.u.Tree">rhs</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="=&gt; reflect.runtime.universe.type">u</span>.<span title="=&gt; toolbox.u.Tree">EmptyTree</span> =&gt;
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.c">c</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.x" title="toolbox.u.ValDef">x</a>.<span title="=&gt; toolbox.u.Position">pos</span>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.x" title="toolbox.u.ValDef">x</a>.<span title="=&gt; toolbox.u.Position">pos</span>.<span title="=&gt; Int">end</span><span class="delimiter">)</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.c" title="String">c</a> <span title="(x$1: CharSequence)Boolean">contains</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span>
    <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees" title="Seq[reflect.runtime.universe.Tree]">parsedTrees</a>.<span title="(p: reflect.runtime.universe.Tree =&gt; Boolean)Seq[reflect.runtime.universe.Tree]">filter</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef" title="(t: reflect.runtime.universe.Tree)Boolean">isBadValDef</a><span class="delimiter">)</span>.<span title="(f: reflect.runtime.universe.Tree =&gt; Nothing)Unit">foreach</span> <span class="delimiter">{</span> <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.badTree">badTree</a> =&gt;
      <span class="comment">// Issue errors</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.positionLine">positionLine</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.badTree" title="reflect.runtime.universe.Tree">badTree</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">line</span>
      <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="../../MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>&quot;&quot;&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.fileName" title="String">fileName</a><span title="String(&quot;]:&quot;)">]:$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.positionLine" title="Int">positionLine</a><span title="String(&quot;: Pattern matching in val statements is not supported&quot;)" class="string">: Pattern matching in val statements is not supported&quot;&quot;&quot;</span>.<span title="=&gt; String">stripMargin</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.imports" title="(Seq[reflect.runtime.universe.Tree], Seq[reflect.runtime.universe.Tree])" class="delimiter">(</a><a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2" title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.imports">imports</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2" title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.statements">statements</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees" title="Seq[reflect.runtime.universe.Tree]">parsedTrees</a> <span title="(p: reflect.runtime.universe.Tree =&gt; Boolean)(Seq[reflect.runtime.universe.Tree], Seq[reflect.runtime.universe.Tree])">partition</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2.$anonfun.x0$1" title="Boolean" class="delimiter">{</a>
      <span class="keyword">case</span> _: <a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2.$anonfun.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.Import]">Import</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> _         =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * See BugInParser
     * @param t - tree
     * @param originalStatement - original
     * @return originalStatement or originalStatement with missing bracket
     */</span>
    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree, originalStatement: String)String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain">parseStatementAgain</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span>, <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement">originalStatement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement">statement</a> = util.<span title="(r: =&gt; toolbox.u.Tree)scala.util.Try[toolbox.u.Tree]">Try</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="(code: String)toolbox.u.Tree">parse</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement" title="String">originalStatement</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> util.Failure<span class="delimiter">(</span><a title="Throwable" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.th">th</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.missingText">missingText</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText" title="(content: String, positionEnd: Int, positionLine: Int, fileName: String, originalException: Throwable)String">findMissingText</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.content" title="String">content</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">end</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">line</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.fileName" title="String">fileName</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.th" title="Throwable">th</a><span class="delimiter">)</span>
          <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement" title="String">originalStatement</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.missingText" title="String">missingText</a>
        <span class="keyword">case</span> _ =&gt;
          <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement" title="String">originalStatement</a>
      <span class="delimiter">}</span>
      <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement" title="String">statement</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree)Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)]" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement">convertStatement</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Tree, LineRange<span class="delimiter">)</span><span class="delimiter">]</span> =
      <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span> <span title="Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="=&gt; reflect.runtime.universe.Position">NoPosition</span> =&gt;
          <span title="None.type">None</span>
        <span class="keyword">case</span> <a title="reflect.runtime.universe.Position" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position">position</a> =&gt;
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.originalStatement">originalStatement</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">end</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.statement">statement</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain" title="(t: reflect.runtime.universe.Tree, originalStatement: String)String">parseStatementAgain</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t" title="reflect.runtime.universe.Tree">t</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.originalStatement" title="String">originalStatement</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.numberLines">numberLines</a> = <a href="#sbt.internals.parser;SbtParser.countLines" title="(statement: String)Int">countLines</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.statement" title="String">statement</a><span class="delimiter">)</span>
          <span title="(x: (String, reflect.runtime.universe.Tree, sbt.LineRange))Some[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">Some</span><span class="delimiter">(</span><span title="(_1: String, _2: reflect.runtime.universe.Tree, _3: sbt.LineRange)(String, reflect.runtime.universe.Tree, sbt.LineRange)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.statement" title="String">statement</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t" title="reflect.runtime.universe.Tree">t</a>, <a href="../../Positions.scala.html#sbt;LineRange" title="(start: Int, end: Int)sbt.LineRange">LineRange</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">line</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">line</span> <span title="(x: Int)Int">+</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.numberLines" title="Int">numberLines</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]" id="sbt.internals.parser;SbtParser.splitExpressions.stmtTreeLineRange">stmtTreeLineRange</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.statements" title="Seq[reflect.runtime.universe.Tree]">statements</a> <span title="(f: reflect.runtime.universe.Tree =&gt; scala.collection.GenTraversableOnce[(String, reflect.runtime.universe.Tree, sbt.LineRange)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[reflect.runtime.universe.Tree],(String, reflect.runtime.universe.Tree, sbt.LineRange),Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]])Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">flatMap</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement" title="(xo: Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)])Iterable[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">convertStatement</a>
    <span class="keyword">val</span> <a title="Seq[(String, Int)]" id="sbt.internals.parser;SbtParser.splitExpressions.importsLineRange">importsLineRange</a> = <a href="#sbt.internals.parser;SbtParser.importsToLineRanges" title="(modifiedContent: String, imports: Seq[reflect.runtime.universe.Tree])Seq[(String, Int)]">importsToLineRanges</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.content" title="String">content</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.imports" title="Seq[reflect.runtime.universe.Tree]">imports</a><span class="delimiter">)</span>
    <span title="(_1: Seq[(String, Int)], _2: Seq[(String, sbt.LineRange)], _3: Seq[(String, reflect.runtime.universe.Tree)])(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)])" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.importsLineRange" title="Seq[(String, Int)]">importsLineRange</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.stmtTreeLineRange" title="Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">stmtTreeLineRange</a>.<span title="(f: ((String, reflect.runtime.universe.Tree, sbt.LineRange)) =&gt; (String, sbt.LineRange))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)],(String, sbt.LineRange),Seq[(String, sbt.LineRange)]])Seq[(String, sbt.LineRange)]">map</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.x0$2" title="(String, sbt.LineRange)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">stmt</span>, _, <a title="sbt.LineRange" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.lr">lr</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: sbt.LineRange)(String, sbt.LineRange)" class="delimiter">(</span><span title="String">stmt</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.lr" title="sbt.LineRange">lr</a><span class="delimiter">)</span> <span class="delimiter">}</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.stmtTreeLineRange" title="Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">stmtTreeLineRange</a>.<span title="(f: ((String, reflect.runtime.universe.Tree, sbt.LineRange)) =&gt; (String, reflect.runtime.universe.Tree))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)],(String, reflect.runtime.universe.Tree),Seq[(String, reflect.runtime.universe.Tree)]])Seq[(String, reflect.runtime.universe.Tree)]">map</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.x0$3" title="(String, reflect.runtime.universe.Tree)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">stmt</span>, <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.tree">tree</a>, _<span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: reflect.runtime.universe.Tree)(String, reflect.runtime.universe.Tree)" class="delimiter">(</span><span title="String">stmt</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.tree" title="reflect.runtime.universe.Tree">tree</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * import sbt._, Keys._,java.util._ should return (&quot;import sbt._, Keys._,java.util._&quot;,0)
   * @param modifiedContent - modifiedContent
   * @param imports - trees
   * @return imports per line
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(modifiedContent: String, imports: Seq[reflect.runtime.universe.Tree])Seq[(String, Int)]" id="sbt.internals.parser;SbtParser.importsToLineRanges">importsToLineRanges</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser;SbtParser.importsToLineRanges.modifiedContent">modifiedContent</a>: <span title="String">String</span>, <a title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.importsToLineRanges.imports">imports</a>: <span title="Seq[reflect.runtime.universe.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[((Int, Int), Int)]" id="sbt.internals.parser;SbtParser.importsToLineRanges.toLineRange">toLineRange</a> = <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.imports" title="Seq[reflect.runtime.universe.Tree]">imports</a> <span title="(f: reflect.runtime.universe.Tree =&gt; ((Int, Int), Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[reflect.runtime.universe.Tree],((Int, Int), Int),Seq[((Int, Int), Int)]])Seq[((Int, Int), Int)]">map</span> <a href="#sbt.internals.parser;SbtParser.convertImport" title="(modifiedContent: String)(t: reflect.runtime.universe.Tree)((Int, Int), Int)">convertImport</a><a href="#sbt.internals.parser;SbtParser.importsToLineRanges.toLineRange.$anonfun.t" title="reflect.runtime.universe.Tree" class="delimiter">(</a><a href="#sbt.internals.parser;SbtParser.importsToLineRanges.modifiedContent" title="String">modifiedContent</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Int,Seq[((Int, Int), Int)]]" id="sbt.internals.parser;SbtParser.importsToLineRanges.groupedByLineNumber">groupedByLineNumber</a> = <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.toLineRange" title="Seq[((Int, Int), Int)]">toLineRange</a>.<span title="(f: (((Int, Int), Int)) =&gt; Int)scala.collection.immutable.Map[Int,Seq[((Int, Int), Int)]]">groupBy</span> <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.groupedByLineNumber.$anonfun.x0$4" title="Int" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span>_, <a title="Int" id="sbt.internals.parser;SbtParser.importsToLineRanges.groupedByLineNumber.$anonfun.lineNumber">lineNumber</a><span class="delimiter">)</span> =&gt; <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.groupedByLineNumber.$anonfun.lineNumber" title="Int">lineNumber</a> <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Int,String]" id="sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports">mergedImports</a> = <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.groupedByLineNumber" title="scala.collection.immutable.Map[Int,Seq[((Int, Int), Int)]]">groupedByLineNumber</a>.<span title="(f: ((Int, Seq[((Int, Int), Int)])) =&gt; (Int, String))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Int,Seq[((Int, Int), Int)]],(Int, String),scala.collection.immutable.Map[Int,String]])scala.collection.immutable.Map[Int,String]">map</span> <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports.$anonfun.x0$5" title="(Int, String)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="Int" id="sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports.$anonfun.l">l</a>, <a title="Seq[((Int, Int), Int)]" id="sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports.$anonfun.seq">seq</a><span class="delimiter">)</span> =&gt; <span title="(_1: Int, _2: String)(Int, String)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports.$anonfun.l" title="Int">l</a>, <a href="#sbt.internals.parser;SbtParser.extractLine" title="(modifiedContent: String, importsInOneLine: Seq[((Int, Int), Int)])String">extractLine</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.importsToLineRanges.modifiedContent" title="String">modifiedContent</a>, <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports.$anonfun.seq" title="Seq[((Int, Int), Int)]">seq</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.mergedImports" title="scala.collection.immutable.Map[Int,String]">mergedImports</a>.<span title="=&gt; Seq[(Int, String)]">toSeq</span>.<span title="(f: ((Int, String)) =&gt; Int)(implicit ord: scala.math.Ordering[Int])Seq[(Int, String)]">sortBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.importsToLineRanges.$anonfun.x$3" title="(Int, String)">_</a>.<span title="=&gt; Int">_1</span><span class="delimiter">)</span>.<span title="(f: ((Int, String)) =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(Int, String)],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">map</span> <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.$anonfun.x0$6" title="(String, Int)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="Int" id="sbt.internals.parser;SbtParser.importsToLineRanges.$anonfun.k">k</a>, <a title="String" id="sbt.internals.parser;SbtParser.importsToLineRanges.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.importsToLineRanges.$anonfun.v" title="String">v</a>, <a href="#sbt.internals.parser;SbtParser.importsToLineRanges.$anonfun.k" title="Int">k</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *
   * @param modifiedContent - modifiedContent
   * @param t - tree
   * @return ((start,end),lineNumber)
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(modifiedContent: String)(t: reflect.runtime.universe.Tree)((Int, Int), Int)" id="sbt.internals.parser;SbtParser.convertImport">convertImport</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser;SbtParser.convertImport.modifiedContent">modifiedContent</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.convertImport.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="((Int, Int), Int)" class="delimiter">(</span><span class="delimiter">(</span>Int, Int<span class="delimiter">)</span>, Int<span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser;SbtParser.convertImport.lineNumber">lineNumber</a> = <a href="#sbt.internals.parser;SbtParser.convertImport.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">line</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
    <span title="(_1: (Int, Int), _2: Int)((Int, Int), Int)" class="delimiter">(</span><span title="(_1: Int, _2: Int)(Int, Int)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.convertImport.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser;SbtParser.convertImport.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">end</span><span class="delimiter">)</span>, <a href="#sbt.internals.parser;SbtParser.convertImport.lineNumber" title="Int">lineNumber</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Search for min begin index and max end index
   * @param modifiedContent - modifiedContent
   * @param importsInOneLine - imports in line
   * @return - text
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(modifiedContent: String, importsInOneLine: Seq[((Int, Int), Int)])String" id="sbt.internals.parser;SbtParser.extractLine">extractLine</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser;SbtParser.extractLine.modifiedContent">modifiedContent</a>: <span title="String">String</span>, <a title="Seq[((Int, Int), Int)]" id="sbt.internals.parser;SbtParser.extractLine.importsInOneLine">importsInOneLine</a>: <span title="Seq[((Int, Int), Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">(</span>Int, Int<span class="delimiter">)</span>, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a href="#sbt.internals.parser;SbtParser.extractLine.begin" title="(Int, Int)" class="delimiter">(</a><a href="#sbt.internals.parser;SbtParser.extractLine.x$4" title="Int" id="sbt.internals.parser;SbtParser.extractLine.begin">begin</a>, <a href="#sbt.internals.parser;SbtParser.extractLine.x$4" title="Int" id="sbt.internals.parser;SbtParser.extractLine.end">end</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.extractLine.importsInOneLine" title="Seq[((Int, Int), Int)]">importsInOneLine</a>.<span title="(z: (Int, Int))(op: ((Int, Int), ((Int, Int), Int)) =&gt; (Int, Int))(Int, Int)">foldLeft</span><span class="delimiter">(</span><span title="(_1: Int, _2: Int)(Int, Int)" class="delimiter">(</span>Int.<span title="Int(2147483647)">MaxValue</span>, Int.<span title="Int(-2147483648)">MinValue</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.x0$7" title="(Int, Int)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.min">min</a>, <a title="Int" id="sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.max">max</a><span class="delimiter">)</span>, <span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.start">start</a>, <a title="Int" id="sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.end">end</a><span class="delimiter">)</span>, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span title="(_1: Int, _2: Int)(Int, Int)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.min" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">min</a>.<span title="(that: Int)Int">min</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.start" title="Int">start</a><span class="delimiter">)</span>, <a href="#sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.max" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">max</a>.<span title="(that: Int)Int">max</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.extractLine.x$4.$anonfun.end" title="Int">end</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#sbt.internals.parser;SbtParser.extractLine.modifiedContent" title="String">modifiedContent</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.extractLine.begin" title="Int">begin</a>, <a href="#sbt.internals.parser;SbtParser.extractLine.end" title="Int">end</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(statement: String)Int" id="sbt.internals.parser;SbtParser.countLines">countLines</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser;SbtParser.countLines.statement">statement</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.countLines.statement" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">statement</a>.<span title="(p: Char =&gt; Boolean)Int">count</span><span class="delimiter">(</span><a title="Char" id="sbt.internals.parser;SbtParser.countLines.$anonfun.c">c</a> =&gt; <a href="#sbt.internals.parser;SbtParser.countLines.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.END_OF_LINE_CHAR" title="=&gt; Char">END_OF_LINE_CHAR</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Scala parser cuts last bracket -
 * @see https://github.com/scala/scala/pull/3991
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.internals.parser.MissingBracketHandler.type" id="sbt.internals.parser.MissingBracketHandler">MissingBracketHandler</a> <a href="#sbt.internals.parser.MissingBracketHandler" title="sbt.internals.parser.MissingBracketHandler.type" class="delimiter">{</a>
  <span class="comment">/**
   *
   * @param content - parsed file
   * @param positionEnd - from index
   * @param positionLine - number of start position line
   * @param fileName - file name
   * @param originalException - original exception
   * @return missing text
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(content: String, positionEnd: Int, positionLine: Int, fileName: String, originalException: Throwable)String" id="sbt.internals.parser.MissingBracketHandler.findMissingText">findMissingText</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findMissingText.positionEnd">positionEnd</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findMissingText.positionLine">positionLine</a>: <span title="Int">Int</span>, <a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.fileName">fileName</a>: <span title="String">String</span>, <a title="Throwable" id="sbt.internals.parser.MissingBracketHandler.findMissingText.originalException">originalException</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex" title="(content: String, from: Int)Option[Int]">findClosingBracketIndex</a><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.content" title="String">content</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionEnd" title="Int">positionEnd</a><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="Int" id="sbt.internals.parser.MissingBracketHandler.findMissingText.index">index</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.text">text</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionEnd" title="Int">positionEnd</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.index" title="Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.textWithoutBracket">textWithoutBracket</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.text" title="String">text</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.text" title="String">text</a>.<span title="()Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        util.<span title="(r: =&gt; sbt.internals.parser.SbtParser)scala.util.Try[sbt.internals.parser.SbtParser]">Try</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.equals" title="(file: java.io.File, lines: Seq[String])sbt.internals.parser.SbtParser">SbtParser</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.FAKE_FILE" title="=&gt; java.io.File">FAKE_FILE</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.textWithoutBracket" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">textWithoutBracket</a>.<span title="=&gt; Iterator[String]">lines</span>.<span title="=&gt; Seq[String]">toSeq</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> util.Success<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.text" title="String">text</a>
          <span class="keyword">case</span> util.Failure<span class="delimiter">(</span><a title="Throwable" id="sbt.internals.parser.MissingBracketHandler.findMissingText.th">th</a><span class="delimiter">)</span> =&gt;
            <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText" title="(content: String, positionEnd: Int, positionLine: Int, fileName: String, originalException: Throwable)String">findMissingText</a><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.content" title="String">content</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.index" title="Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionLine" title="Int">positionLine</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.fileName" title="String">fileName</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.originalException" title="Throwable">originalException</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="../../MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>&quot;&quot;&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.fileName" title="String">fileName</a><span title="String(&quot;]:&quot;)">]:$</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionLine" title="Int">positionLine</a><span title="String(&quot;: &quot;)">: $</span><span class="delimiter">{</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.originalException" title="Throwable">originalException</a>.<span title="()String">getMessage</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span>.<span title="=&gt; String">stripMargin</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *
   * @param content - parsed file
   * @param from - start index
   * @return first not commented index or None
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(content: String, from: Int)Option[Int]" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex">findClosingBracketIndex</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.from">from</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index">index</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.content" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">content</a>.<span title="(p: Char =&gt; Boolean, from: Int)Int">indexWhere</span><span class="delimiter">(</span><a title="Char" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index.$anonfun.c">c</a> =&gt; <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char('}')" class="char">'}'</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char(')')" class="char">')'</span>, <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.from" title="Int">from</a><span class="delimiter">)</span>
    <span title="Option[Int]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index" title="Int">index</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="None.type">None</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index" title="Int">index</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
