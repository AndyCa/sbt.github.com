<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/internals/parser/SbtRefactorings.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> internals
<span class="keyword">package</span> parser

<span class="keyword">import</span> scala.reflect.runtime.<span title="=&gt; scala.reflect.api.JavaUniverse">universe</span>._

<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.internals.parser.SbtRefactorings.type" id="sbt.internals.parser.SbtRefactorings">SbtRefactorings</a> <a href="#sbt.internals.parser.SbtRefactorings" title="sbt.internals.parser.SbtRefactorings.type" class="delimiter">{</a>

  <span class="keyword">import</span> sbt.internals.parser.<a href="SbtParser.scala.html#sbt.internals.parser.SbtParser" title="sbt.internals.parser.SbtParser.type">SbtParser</a>.<span class="delimiter">{</span> END_OF_LINE, FAKE_FILE <span class="delimiter">}</span>
  <span class="keyword">import</span> sbt.<a href="../../SessionSettings.scala.html#sbt.SessionSettings" title="sbt.SessionSettings.type">SessionSettings</a>.<span class="delimiter">{</span> SessionSetting, SbtConfigFile <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.EMPTY_STRING">EMPTY_STRING</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
  <span class="keyword">val</span> <a title="scala.math.Ordering[Int]" id="sbt.internals.parser.SbtRefactorings.REVERSE_ORDERING_INT">REVERSE_ORDERING_INT</a> = <span title="[T](implicit ord: scala.math.Ordering[T])scala.math.Ordering[T]">Ordering</span><span title="(implicit ord: scala.math.Ordering[Int])scala.math.Ordering[Int]" class="delimiter">[</span><span title="Int">Int</span><span class="delimiter">]</span>.<span title="=&gt; scala.math.Ordering[Int]">reverse</span>

  <span class="comment">/**
   * Refactoring a `.sbt` file so that the new settings are used instead of any existing settings.
   * @param configFile SbtConfigFile with the lines of an sbt file as a List[String] where each string is one line
   * @param commands A List of settings (space separate) that should be inserted into the current file.
   *                 If the settings replaces a value, it will replace the original line in the .sbt file.
   *                 If in the `.sbt` file we have multiply value for one settings -
   *                 the first will be replaced and the other will be removed.
   * @return a SbtConfigFile with new lines which represent the contents of the refactored .sbt file.
   */</span>
  <span class="keyword">def</span> <a title="(configFile: (java.io.File, Seq[String]), commands: Seq[(sbt.Def.Setting[_], Seq[String])])(java.io.File, Seq[String])" id="sbt.internals.parser.SbtRefactorings.applySessionSettings">applySessionSettings</a><span class="delimiter">(</span><a title="(java.io.File, Seq[String])" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.configFile">configFile</a>: <span title="(java.io.File, Seq[String])">SbtConfigFile</span>, <a title="Seq[(sbt.Def.Setting[_], Seq[String])]" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.commands">commands</a>: <span title="Seq[(sbt.Def.Setting[_], Seq[String])]">Seq</span><span class="delimiter">[</span>SessionSetting<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(java.io.File, Seq[String])">SbtConfigFile</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.file" title="(java.io.File, Seq[String])" class="delimiter">(</a><a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.x$1" title="java.io.File" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.file">file</a>, <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.x$1" title="Seq[String]" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.lines">lines</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.configFile" title="(java.io.File, Seq[String])">configFile</a>
    <span class="keyword">val</span> <a title="sbt.internals.parser.SbtParser" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.split">split</a> = <a href="SbtParser.scala.html#sbt.internals.parser;SbtParser" title="(file: java.io.File, lines: Seq[String])sbt.internals.parser.SbtParser">SbtParser</a><span class="delimiter">(</span><a href="SbtParser.scala.html#sbt.internals.parser.SbtParser.FAKE_FILE" title="=&gt; java.io.File">FAKE_FILE</a>, <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.lines" title="Seq[String]">lines</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Seq[(Int, String, String)]" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.recordedCommands">recordedCommands</a> = <a href="#sbt.internals.parser.SbtRefactorings.recordCommands" title="(commands: Seq[(sbt.Def.Setting[_], Seq[String])], split: sbt.internals.parser.SbtParser)Seq[(Int, String, String)]">recordCommands</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.commands" title="Seq[(sbt.Def.Setting[_], Seq[String])]">commands</a>, <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.split" title="sbt.internals.parser.SbtParser">split</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Seq[(Int, String, String)]" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.sortedRecordedCommands">sortedRecordedCommands</a> = <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.recordedCommands" title="Seq[(Int, String, String)]">recordedCommands</a>.<span title="(f: ((Int, String, String)) =&gt; Int)(implicit ord: scala.math.Ordering[Int])Seq[(Int, String, String)]">sortBy</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.sortedRecordedCommands.$anonfun.x$2" title="(Int, String, String)">_</a>.<span title="=&gt; Int">_1</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.REVERSE_ORDERING_INT" title="=&gt; scala.math.Ordering[Int]">REVERSE_ORDERING_INT</a><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.applySessionSettings.newContent">newContent</a> = <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop" title="(modifiedContent: String, sortedRecordedCommands: Seq[(Int, String, String)])String">replaceFromBottomToTop</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.lines" title="Seq[String]">lines</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><a href="SbtParser.scala.html#sbt.internals.parser.SbtParser.END_OF_LINE" title="=&gt; String">END_OF_LINE</a><span class="delimiter">)</span>, <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.sortedRecordedCommands" title="Seq[(Int, String, String)]">sortedRecordedCommands</a><span class="delimiter">)</span>
    <span title="(_1: java.io.File, _2: List[String])(java.io.File, List[String])" class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.file" title="java.io.File">file</a>, <a href="#sbt.internals.parser.SbtRefactorings.applySessionSettings.newContent" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">newContent</a>.<span title="=&gt; Iterator[String]">lines</span>.<span title="=&gt; List[String]">toList</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(modifiedContent: String, sortedRecordedCommands: Seq[(Int, String, String)])String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop">replaceFromBottomToTop</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.modifiedContent">modifiedContent</a>: <span title="String">String</span>, <a title="Seq[(Int, String, String)]" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.sortedRecordedCommands">sortedRecordedCommands</a>: <span title="Seq[(Int, String, String)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.sortedRecordedCommands" title="Seq[(Int, String, String)]">sortedRecordedCommands</a>.<span title="(z: String)(op: (String, (Int, String, String)) =&gt; String)String">foldLeft</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.modifiedContent" title="String">modifiedContent</a><span class="delimiter">)</span> <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.x0$5" title="String" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.acc">acc</a>, <span class="delimiter">(</span><a title="Int" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.from">from</a>, <a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.old">old</a>, <a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.replacement">replacement</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.before">before</a> = <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.acc" title="String">acc</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.from" title="Int">from</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.after">after</a> = <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.acc" title="String">acc</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.from" title="Int">from</a> <span title="(x: Int)Int">+</span> <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.old" title="String">old</a>.<span title="()Int">length</span>, <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.acc" title="String">acc</a>.<span title="()Int">length</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.afterLast">afterLast</a> = <a href="#sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString" title="(text: String)String">emptyStringForEmptyString</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.after" title="String">after</a><span class="delimiter">)</span>
        <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.before" title="String">before</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.replacement" title="String">replacement</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.internals.parser.SbtRefactorings.replaceFromBottomToTop.$anonfun.afterLast" title="String">afterLast</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(text: String)String" id="sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString">emptyStringForEmptyString</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString.text">text</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString.trimmed">trimmed</a> = <a href="#sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString.text" title="String">text</a>.<span title="()String">trim</span>
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString.trimmed" title="String">trimmed</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString.trimmed" title="String">trimmed</a> <span class="keyword">else</span> <a href="#sbt.internals.parser.SbtRefactorings.emptyStringForEmptyString.text" title="String">text</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(commands: Seq[(sbt.Def.Setting[_], Seq[String])], split: sbt.internals.parser.SbtParser)Seq[(Int, String, String)]" id="sbt.internals.parser.SbtRefactorings.recordCommands">recordCommands</a><span class="delimiter">(</span><a title="Seq[(sbt.Def.Setting[_], Seq[String])]" id="sbt.internals.parser.SbtRefactorings.recordCommands.commands">commands</a>: <span title="Seq[(sbt.Def.Setting[_], Seq[String])]">Seq</span><span class="delimiter">[</span>SessionSetting<span class="delimiter">]</span>, <a title="sbt.internals.parser.SbtParser" id="sbt.internals.parser.SbtRefactorings.recordCommands.split">split</a>: <a href="SbtParser.scala.html#sbt.internals.parser;SbtParser" title="sbt.internals.parser.SbtParser">SbtParser</a><span class="delimiter">)</span> =
    <a href="#sbt.internals.parser.SbtRefactorings.recordCommands.commands" title="Seq[(sbt.Def.Setting[_], Seq[String])]">commands</a>.<span title="(f: ((sbt.Def.Setting[_], Seq[String])) =&gt; scala.collection.GenTraversableOnce[(Int, String, String)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(sbt.Def.Setting[_], Seq[String])],(Int, String, String),Seq[(Int, String, String)]])Seq[(Int, String, String)]">flatMap</span> <a href="#sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.x0$1" title="scala.collection.immutable.Iterable[(Int, String, String)]" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span>_, <a title="Seq[String]" id="sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.command">command</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="scala.collection.immutable.Map[String,String]" id="sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.map">map</a> = <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap" title="(command: Seq[String])scala.collection.immutable.Map[String,String]">toTreeStringMap</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.command" title="Seq[String]">command</a><span class="delimiter">)</span>
        <a href="#sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.map" title="scala.collection.immutable.Map[String,String]">map</a>.<span title="(f: ((String, String)) =&gt; scala.collection.GenTraversableOnce[(Int, String, String)])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,String],(Int, String, String),scala.collection.immutable.Iterable[(Int, String, String)]])scala.collection.immutable.Iterable[(Int, String, String)]">flatMap</span> <a href="#sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.$anonfun.x0$3" title="Seq[(Int, String, String)]" class="delimiter">{</a>
          <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.$anonfun.name">name</a>, <a title="String" id="sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.$anonfun.statement">statement</a><span class="delimiter">)</span> =&gt;
            <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements" title="(split: sbt.internals.parser.SbtParser, name: String, command: Seq[String])Seq[(Int, String, String)]">treesToReplacements</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.recordCommands.split" title="sbt.internals.parser.SbtParser">split</a>, <a href="#sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.$anonfun.name" title="String">name</a>, <a href="#sbt.internals.parser.SbtRefactorings.recordCommands.$anonfun.command" title="Seq[String]">command</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(split: sbt.internals.parser.SbtParser, name: String, command: Seq[String])Seq[(Int, String, String)]" id="sbt.internals.parser.SbtRefactorings.treesToReplacements">treesToReplacements</a><span class="delimiter">(</span><a title="sbt.internals.parser.SbtParser" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.split">split</a>: <a href="SbtParser.scala.html#sbt.internals.parser;SbtParser" title="sbt.internals.parser.SbtParser">SbtParser</a>, <a title="String" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.name">name</a>: <span title="String">String</span>, <a title="Seq[String]" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.command">command</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.split" title="sbt.internals.parser.SbtParser">split</a>.<a href="SbtParser.scala.html#sbt.internals.parser;SbtParser.settingsTrees" title="=&gt; Seq[(String, reflect.runtime.universe.Tree)]">settingsTrees</a>.<span title="(z: Seq[(Int, String, String)])(op: (Seq[(Int, String, String)], (String, reflect.runtime.universe.Tree)) =&gt; Seq[(Int, String, String)])Seq[(Int, String, String)]">foldLeft</span><span class="delimiter">(</span><span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[(Int, String, String)]" class="delimiter">[</span><span title="(Int, String, String)" class="delimiter">(</span>Int, String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.x0$4" title="Seq[(Int, String, String)]" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a title="Seq[(Int, String, String)]" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.acc">acc</a>, <span class="delimiter">(</span><a title="String" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.st">st</a>, <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.treeName">treeName</a> = <a href="#sbt.internals.parser.SbtRefactorings.extractSettingName" title="(tree: reflect.runtime.universe.Tree)String">extractSettingName</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.tree" title="reflect.runtime.universe.Tree">tree</a><span class="delimiter">)</span>
        <span title="Seq[(Int, String, String)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.name" title="String">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.treeName" title="String">treeName</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.replacement">replacement</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.acc" title="Seq[(Int, String, String)]">acc</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.command" title="Seq[String]">command</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><a href="SbtParser.scala.html#sbt.internals.parser.SbtParser.END_OF_LINE" title="=&gt; String">END_OF_LINE</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#sbt.internals.parser.SbtRefactorings.EMPTY_STRING" title="=&gt; String">EMPTY_STRING</a>
          <span class="delimiter">}</span>
          <span title="(_1: Int, _2: String, _3: String)(Int, String, String)" class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.tree" title="reflect.runtime.universe.Tree">tree</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.st" title="String">st</a>, <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.replacement" title="String">replacement</a><span class="delimiter">)</span> <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.x$3" title="(elem: (Int, String, String))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(Int, String, String)],(Int, String, String),Seq[(Int, String, String)]])Seq[(Int, String, String)]">+:</a> <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.acc" title="Seq[(Int, String, String)]">acc</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#sbt.internals.parser.SbtRefactorings.treesToReplacements.$anonfun.acc" title="Seq[(Int, String, String)]">acc</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(command: Seq[String])scala.collection.immutable.Map[String,String]" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap">toTreeStringMap</a><span class="delimiter">(</span><a title="Seq[String]" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap.command">command</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="sbt.internals.parser.SbtParser" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap.split">split</a> = <a href="SbtParser.scala.html#sbt.internals.parser;SbtParser" title="(file: java.io.File, lines: Seq[String])sbt.internals.parser.SbtParser">SbtParser</a><span class="delimiter">(</span><a href="SbtParser.scala.html#sbt.internals.parser.SbtParser.FAKE_FILE" title="=&gt; java.io.File">FAKE_FILE</a>, <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.command" title="Seq[String]">command</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Seq[(String, reflect.runtime.universe.Tree)]" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap.trees">trees</a> = <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.split" title="sbt.internals.parser.SbtParser">split</a>.<a href="SbtParser.scala.html#sbt.internals.parser;SbtParser.settingsTrees" title="=&gt; Seq[(String, reflect.runtime.universe.Tree)]">settingsTrees</a>
    <span class="keyword">val</span> <a title="Seq[(String, String)]" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq">seq</a> = <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.trees" title="Seq[(String, reflect.runtime.universe.Tree)]">trees</a>.<span title="(f: ((String, reflect.runtime.universe.Tree)) =&gt; (String, String))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, reflect.runtime.universe.Tree)],(String, String),Seq[(String, String)]])Seq[(String, String)]">map</span> <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq.$anonfun.x0$2" title="(String, String)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq.$anonfun.statement">statement</a>, <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq.$anonfun.tree">tree</a><span class="delimiter">)</span> =&gt;
        <span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.extractSettingName" title="(tree: reflect.runtime.universe.Tree)String">extractSettingName</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq.$anonfun.tree" title="reflect.runtime.universe.Tree">tree</a><span class="delimiter">)</span>, <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq.$anonfun.statement" title="String">statement</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#sbt.internals.parser.SbtRefactorings.toTreeStringMap.seq" title="Seq[(String, String)]">seq</a>.<span title="(implicit ev: &lt;:&lt;[(String, String),(String, String)])scala.collection.immutable.Map[String,String]">toMap</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tree: reflect.runtime.universe.Tree)String" id="sbt.internals.parser.SbtRefactorings.extractSettingName">extractSettingName</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser.SbtRefactorings.extractSettingName.tree">tree</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <a href="#sbt.internals.parser.SbtRefactorings.extractSettingName.tree" title="reflect.runtime.universe.Tree">tree</a>.<span title="=&gt; List[reflect.runtime.universe.Tree]">children</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser.SbtRefactorings.extractSettingName.h">h</a> :: _ =&gt;
        <a href="#sbt.internals.parser.SbtRefactorings.extractSettingName" title="(tree: reflect.runtime.universe.Tree)String">extractSettingName</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtRefactorings.extractSettingName.h" title="reflect.runtime.universe.Tree">h</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#sbt.internals.parser.SbtRefactorings.extractSettingName.tree" title="reflect.runtime.universe.Tree">tree</a>.<span title="()String">toString</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
