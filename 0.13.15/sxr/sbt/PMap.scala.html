<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/PMap.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2010 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> collection.mutable

<span class="keyword">trait</span> <a title="trait RMap[K[_], V[_]] extends AnyRef" id="sbt;RMap">RMap</a><span class="delimiter">[</span><a title="[_]" id="sbt;RMap;K">K</a><span class="delimiter">[</span><a title="" id="sbt;RMap;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;RMap;V">V</a><span class="delimiter">[</span><a title="" id="sbt;RMap;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])V[T]" id="sbt;RMap.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;RMap.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;RMap.apply.k">k</a>: <a href="#sbt;RMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;RMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])Option[V[T]]" id="sbt;RMap.get">get</a><span class="delimiter">[</span><a title="" id="sbt;RMap.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;RMap.get.k">k</a>: <a href="#sbt;RMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])Boolean" id="sbt;RMap.contains">contains</a><span class="delimiter">[</span><a title="" id="sbt;RMap.contains;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;RMap.contains.k">k</a>: <a href="#sbt;RMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(K[_], V[_])]" id="sbt;RMap.toSeq">toSeq</a>: <span title="Seq[(K[_], V[_])]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>K<span class="delimiter">[</span>_<span class="delimiter">]</span>, V<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[RMap.this.TPair[_]]" id="sbt;RMap.toTypedSeq">toTypedSeq</a>: <span title="Seq[RMap.this.TPair[_]]">Seq</span><span class="delimiter">[</span>TPair<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;RMap.toSeq" title="=&gt; Seq[(K[_], V[_])]">toSeq</a>.<span title="(f: ((K[_], V[_])) =&gt; RMap.this.TPair[_])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(K[_], V[_])],RMap.this.TPair[_],Seq[RMap.this.TPair[_]]])Seq[RMap.this.TPair[_]]">map</span> <a href="#sbt;RMap.toTypedSeq.$anonfun.x0$1" title="RMap.this.TPair[t]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="K[t]" id="sbt;RMap.toTypedSeq.$anonfun.k">k</a>: <a href="#sbt;RMap;K" title="K[t]">K</a><span class="delimiter">[</span>t<span class="delimiter">]</span>, <a title="V[_]" id="sbt;RMap.toTypedSeq.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; <a href="#sbt;RMap.TPair.readResolve" title="[T](key: K[T], value: V[T])RMap.this.TPair[T]">TPair</a><span title="(key: K[t], value: V[t])RMap.this.TPair[t]" class="delimiter">[</span><a href="#sbt;RMap.toTypedSeq.$anonfun;t" title="t">t</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;RMap.toTypedSeq.$anonfun.k" title="K[t]">k</a>, <a href="#sbt;RMap.toTypedSeq.$anonfun.v" title="V[_]">v</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="V[t]" class="delimiter">[</span><a href="#sbt;RMap;V" title="V[t]">V</a><span class="delimiter">[</span>t<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; Iterable[K[_]]" id="sbt;RMap.keys">keys</a>: <span title="Iterable[K[_]]">Iterable</span><span class="delimiter">[</span>K<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Iterable[V[_]]" id="sbt;RMap.values">values</a>: <span title="Iterable[V[_]]">Iterable</span><span class="delimiter">[</span>V<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;RMap.isEmpty">isEmpty</a>: <span title="Boolean">Boolean</span>

  <span class="keyword">final</span> <span class="keyword">case class</span> <a href="#sbt;RMap;TPair.productElement.x$1" title="class TPair[T] extends AnyRef with Product with Serializable" id="sbt;RMap.TPair.readResolve">TPair</a><span class="delimiter">[</span><a title="" id="sbt;RMap;TPair;T">T</a><span class="delimiter">]</span><a href="#sbt;RMap.TPair.readResolve" title="Product" class="delimiter">(</a><a title="K[T]" id="sbt;RMap;TPair.key">key</a>: <a href="#sbt;RMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;RMap;TPair.value">value</a>: <a href="#sbt;RMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait IMap[K[_], V[_]] extends AnyRef with sbt.~&gt;[K,V] with sbt.RMap[K,V]" id="sbt;IMap">IMap</a><span class="delimiter">[</span><a title="[_]" id="sbt;IMap;K">K</a><span class="delimiter">[</span><a title="" id="sbt;IMap;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;IMap;V">V</a><span class="delimiter">[</span><a title="" id="sbt;IMap;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">extends</span> <span class="delimiter">(</span>K <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[K,V]">~&gt;</a> V<span class="delimiter">)</span> <span class="keyword">with</span> <a href="#sbt;RMap" title="sbt.RMap[K,V]">RMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], v: V[T])sbt.IMap[K,V]" id="sbt;IMap.put">put</a><span class="delimiter">[</span><a title="" id="sbt;IMap.put;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;IMap.put.k">k</a>: <a href="#sbt;IMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;IMap.put.v">v</a>: <a href="#sbt;IMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;IMap" title="sbt.IMap[K,V]">IMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])sbt.IMap[K,V]" id="sbt;IMap.remove">remove</a><span class="delimiter">[</span><a title="" id="sbt;IMap.remove;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;IMap.remove.k">k</a>: <a href="#sbt;IMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;IMap" title="sbt.IMap[K,V]">IMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], init: V[T], f: V[T] =&gt; V[T])sbt.IMap[K,V]" id="sbt;IMap.mapValue">mapValue</a><span class="delimiter">[</span><a title="" id="sbt;IMap.mapValue;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;IMap.mapValue.k">k</a>: <a href="#sbt;IMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;IMap.mapValue.init">init</a>: <a href="#sbt;IMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T] =&gt; V[T]" id="sbt;IMap.mapValue.f">f</a>: V<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;IMap" title="sbt.IMap[K,V]">IMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[V2[_]](f: sbt.~&gt;[V,V2])sbt.IMap[K,V2]" id="sbt;IMap.mapValues">mapValues</a><span class="delimiter">[</span><a title="[_]" id="sbt;IMap.mapValues;V2">V2</a><span class="delimiter">[</span><a title="" id="sbt;IMap.mapValues;V2;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[V,V2]" id="sbt;IMap.mapValues.f">f</a>: V <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[V,V2]">~&gt;</a> V2<span class="delimiter">)</span>: <a href="#sbt;IMap" title="sbt.IMap[K,V2]">IMap</a><span class="delimiter">[</span>K, V2<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[VL[_], VR[_]](f: sbt.~&gt;[V,[T]scala.util.Either[VL[T],VR[T]]])(sbt.IMap[K,VL], sbt.IMap[K,VR])" id="sbt;IMap.mapSeparate">mapSeparate</a><span class="delimiter">[</span><a title="[_]" id="sbt;IMap.mapSeparate;VL">VL</a><span class="delimiter">[</span><a title="" id="sbt;IMap.mapSeparate;VL;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;IMap.mapSeparate;VR">VR</a><span class="delimiter">[</span><a title="" id="sbt;IMap.mapSeparate;VR;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[V,[T]scala.util.Either[VL[T],VR[T]]]" id="sbt;IMap.mapSeparate.f">f</a>: V <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[V,[T]scala.util.Either[VL[T],VR[T]]]">~&gt;</a> <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>T<span class="delimiter">]</span> = Either<span class="delimiter">[</span>VL<span class="delimiter">[</span>T<span class="delimiter">]</span>, VR<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l<span class="delimiter">)</span>: <span title="(sbt.IMap[K,VL], sbt.IMap[K,VR])" class="delimiter">(</span>IMap<span class="delimiter">[</span>K, VL<span class="delimiter">]</span>, IMap<span class="delimiter">[</span>K, VR<span class="delimiter">]</span><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="keyword">trait</span> <a title="trait PMap[K[_], V[_]] extends AnyRef with sbt.~&gt;[K,V] with sbt.RMap[K,V]" id="sbt;PMap">PMap</a><span class="delimiter">[</span><a title="[_]" id="sbt;PMap;K">K</a><span class="delimiter">[</span><a title="" id="sbt;PMap;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;PMap;V">V</a><span class="delimiter">[</span><a title="" id="sbt;PMap;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">extends</span> <span class="delimiter">(</span>K <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[K,V]">~&gt;</a> V<span class="delimiter">)</span> <span class="keyword">with</span> <a href="#sbt;RMap" title="sbt.RMap[K,V]">RMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], v: V[T])Unit" id="sbt;PMap.update">update</a><span class="delimiter">[</span><a title="" id="sbt;PMap.update;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;PMap.update.k">k</a>: <a href="#sbt;PMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;PMap.update.v">v</a>: <a href="#sbt;PMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])Option[V[T]]" id="sbt;PMap.remove">remove</a><span class="delimiter">[</span><a title="" id="sbt;PMap.remove;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;PMap.remove.k">k</a>: <a href="#sbt;PMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], make: =&gt; V[T])V[T]" id="sbt;PMap.getOrUpdate">getOrUpdate</a><span class="delimiter">[</span><a title="" id="sbt;PMap.getOrUpdate;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;PMap.getOrUpdate.k">k</a>: <a href="#sbt;PMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; V[T]" id="sbt;PMap.getOrUpdate.make">make</a>: =&gt; V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;PMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], init: V[T], f: V[T] =&gt; V[T])V[T]" id="sbt;PMap.mapValue">mapValue</a><span class="delimiter">[</span><a title="" id="sbt;PMap.mapValue;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;PMap.mapValue.k">k</a>: <a href="#sbt;PMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;PMap.mapValue.init">init</a>: <a href="#sbt;PMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T] =&gt; V[T]" id="sbt;PMap.mapValue.f">f</a>: V<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;PMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="delimiter">}</span>
<span class="keyword">object</span> <a title="sbt.PMap.type" id="sbt.PMap">PMap</a> <a href="#sbt.PMap" title="sbt.PMap.type" class="delimiter">{</a>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K[_], V[_]](map: sbt.PMap[K,V])K[_] =&gt; V[_]" id="sbt.PMap.toFunction">toFunction</a><span class="delimiter">[</span><a title="[_]" id="sbt.PMap.toFunction;K">K</a><span class="delimiter">[</span><a title="" id="sbt.PMap.toFunction;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.PMap.toFunction;V">V</a><span class="delimiter">[</span><a title="" id="sbt.PMap.toFunction;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.PMap[K,V]" id="sbt.PMap.toFunction.map">map</a>: <a href="#sbt;PMap" title="sbt.PMap[K,V]">PMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: K<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; V<span class="delimiter">[</span>_<span class="delimiter">]</span> = <a title="K[_]" id="sbt.PMap.toFunction.$anonfun.k">k</a> =&gt; <a href="#sbt;RMap.apply" title="(k: K[_$6])V[_$6]">map</a><span class="delimiter">(</span><a href="#sbt.PMap.toFunction.$anonfun.k" title="K[_]">k</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[K[_], V[_]]=&gt; sbt.PMap[K,V]" id="sbt.PMap.empty">empty</a><span class="delimiter">[</span><a title="[_]" id="sbt.PMap.empty;K">K</a><span class="delimiter">[</span><a title="" id="sbt.PMap.empty;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.PMap.empty;V">V</a><span class="delimiter">[</span><a title="" id="sbt.PMap.empty;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span>: <a href="#sbt;PMap" title="sbt.PMap[K,V]">PMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span title="sbt.DelegatingPMap[K,V]" class="keyword">new</span> <a href="#sbt;DelegatingPMap" title="sbt.DelegatingPMap[K,V]">DelegatingPMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><span title="()scala.collection.mutable.HashMap[K[_],V[_]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[K[_],V[_]]">HashMap</span><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.IMap.type" id="sbt.IMap">IMap</a> <a href="#sbt.IMap" title="sbt.IMap.type" class="delimiter">{</a>
  <span class="comment">/**
   * Only suitable for K that is invariant in its type parameter.
   * Option and List keys are not suitable, for example,
   *  because None &amp;lt;:&amp;lt; Option[String] and None &amp;lt;: Option[Int].
   */</span>
  <span class="keyword">def</span> <a title="[K[_], V[_]]=&gt; sbt.IMap[K,V]" id="sbt.IMap.empty">empty</a><span class="delimiter">[</span><a title="[_]" id="sbt.IMap.empty;K">K</a><span class="delimiter">[</span><a title="" id="sbt.IMap.empty;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.IMap.empty;V">V</a><span class="delimiter">[</span><a title="" id="sbt.IMap.empty;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span>: <a href="#sbt;IMap" title="sbt.IMap[K,V]">IMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span title="sbt.IMap.IMap0[K,V]" class="keyword">new</span> <a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,V]">IMap0</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[K[_],Nothing]">empty</span><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class IMap0[K[_], V[_]] extends sbt.AbstractRMap[K,V] with sbt.IMap[K,V]" id="sbt.IMap;IMap0">IMap0</a><span class="delimiter">[</span><a title="[_]" id="sbt.IMap;IMap0;K">K</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.IMap;IMap0;V">V</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,V]" class="delimiter">(</a><a title="Map[K[_],V[_]]" id="sbt.IMap;IMap0.backing">backing</a>: <span title="Map[K[_],V[_]]">Map</span><span class="delimiter">[</span>K<span class="delimiter">[</span>_<span class="delimiter">]</span>, V<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;AbstractRMap" title="sbt.AbstractRMap[K,V]">AbstractRMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#sbt;IMap" title="sbt.IMap[K,V]">IMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](k: K[T])Option[V[T]]" id="sbt.IMap;IMap0.get">get</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt.IMap;IMap0.get.k">k</a>: <a href="#sbt.IMap;IMap0;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a> <span title="(key: K[_])Option[V[_]]">get</span> <a href="#sbt.IMap;IMap0.get.k" title="K[T]">k</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Option[V[T]]" class="delimiter">[</span><span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[T](k: K[T], v: V[T])sbt.IMap.IMap0[K,V]" id="sbt.IMap;IMap0.put">put</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.put;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt.IMap;IMap0.put.k">k</a>: <a href="#sbt.IMap;IMap0;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt.IMap;IMap0.put.v">v</a>: <a href="#sbt.IMap;IMap0;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="sbt.IMap.IMap0[K,V]" class="keyword">new</span> <a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,V]">IMap0</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="(key: K[_], value: V[_])scala.collection.immutable.Map[K[_],V[_]]">updated</span><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.put.k" title="K[T]">k</a>, <a href="#sbt.IMap;IMap0.put.v" title="V[T]">v</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[T](k: K[T])sbt.IMap.IMap0[K,V]" id="sbt.IMap;IMap0.remove">remove</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.remove;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt.IMap;IMap0.remove.k">k</a>: <a href="#sbt.IMap;IMap0;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="sbt.IMap.IMap0[K,V]" class="keyword">new</span> <a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,V]">IMap0</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a> <span title="(key: K[_])scala.collection.immutable.Map[K[_],V[_]]">-</span> <a href="#sbt.IMap;IMap0.remove.k" title="K[T]">k</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[T](k: K[T], init: V[T], f: V[T] =&gt; V[T])sbt.IMap.IMap0[K,V]" id="sbt.IMap;IMap0.mapValue">mapValue</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.mapValue;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt.IMap;IMap0.mapValue.k">k</a>: <a href="#sbt.IMap;IMap0;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt.IMap;IMap0.mapValue.init">init</a>: <a href="#sbt.IMap;IMap0;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T] =&gt; V[T]" id="sbt.IMap;IMap0.mapValue.f">f</a>: V<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#sbt.IMap;IMap0.put" title="(k: K[T], v: V[T])sbt.IMap.IMap0[K,V]">put</a><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapValue.k" title="K[T]">k</a>, <a href="#sbt.IMap;IMap0.mapValue.f" title="(v1: V[T])V[T]">f</a><span class="delimiter">(</span><a href="#sbt.IMap;IMap0" title="IMap0.this.type" class="keyword">this</a> <a href="#sbt.IMap;IMap0.get" title="(k: K[T])Option[V[T]]">get</a> <a href="#sbt.IMap;IMap0.mapValue.k" title="K[T]">k</a> <span title="(default: =&gt; V[T])V[T]">getOrElse</span> <a href="#sbt.IMap;IMap0.mapValue.init" title="V[T]">init</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[V2[_]](f: sbt.~&gt;[V,V2])sbt.IMap.IMap0[K,V2]" id="sbt.IMap;IMap0.mapValues">mapValues</a><span class="delimiter">[</span><a title="[_]" id="sbt.IMap;IMap0.mapValues;V2">V2</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.mapValues;V2;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[V,V2]" id="sbt.IMap;IMap0.mapValues.f">f</a>: V <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[V,V2]">~&gt;</a> V2<span class="delimiter">)</span> =
      <span title="sbt.IMap.IMap0[K,V2]" class="keyword">new</span> <a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,V2]">IMap0</a><span class="delimiter">[</span>K, V2<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="(f: V[_] =&gt; V2[_])scala.collection.immutable.Map[K[_],V2[_]]">mapValues</span><span class="delimiter">(</span><a title="V[_]" id="sbt.IMap;IMap0.mapValues.$anonfun.x">x</a> =&gt; <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: V[_$9])V2[_$9]">f</a><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapValues.$anonfun.x" title="V[_]">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[VL[_], VR[_]](f: sbt.~&gt;[V,[T]scala.util.Either[VL[T],VR[T]]])(sbt.IMap.IMap0[K,VL], sbt.IMap.IMap0[K,VR])" id="sbt.IMap;IMap0.mapSeparate">mapSeparate</a><span class="delimiter">[</span><a title="[_]" id="sbt.IMap;IMap0.mapSeparate;VL">VL</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.mapSeparate;VL;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.IMap;IMap0.mapSeparate;VR">VR</a><span class="delimiter">[</span><a title="" id="sbt.IMap;IMap0.mapSeparate;VR;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[V,[T]scala.util.Either[VL[T],VR[T]]]" id="sbt.IMap;IMap0.mapSeparate.f">f</a>: V <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[V,[T]scala.util.Either[VL[T],VR[T]]]">~&gt;</a> <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>T<span class="delimiter">]</span> = Either<span class="delimiter">[</span>VL<span class="delimiter">[</span>T<span class="delimiter">]</span>, VR<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#l<span class="delimiter">)</span> =
      <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Iterator[Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])] forSome { type _0; type _0; type _0; type _0 }]" id="sbt.IMap;IMap0.mapSeparate.mapped">mapped</a> = <a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="=&gt; Iterator[(K[_], V[_])]">iterator</span>.<span title="(f: ((K[_], V[_])) =&gt; Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])] forSome { type _0; type _0; type _0; type _0 })Iterator[Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])] forSome { type _0; type _0; type _0; type _0 }]">map</span> <a href="#sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.x0$2" title="&lt;root&gt; extends Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])]" class="delimiter">{</a>
          <span class="keyword">case</span> <span class="delimiter">(</span><a title="K[_]" id="sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.k">k</a>, <a title="V[_]" id="sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; <a href="TypeFunctions.scala.html#sbt;~>.apply" title="(a: V[_0])scala.util.Either[VL[_0],VR[_0]]">f</a><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.v" title="V[_]">v</a><span class="delimiter">)</span> <span title="&lt;root&gt; extends Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="VL[_0]" id="sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.l">l</a><span class="delimiter">)</span>  =&gt; <span title="(a: (K[_0], VL[_0]))scala.util.Left[(K[_0], VL[_0]),Nothing]">Left</span><span class="delimiter">(</span><span title="(_1: K[_0], _2: VL[_0])(K[_0], VL[_0])" class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.k" title="K[_]">k</a>, <a href="#sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.l" title="VL[_0]">l</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="VR[_0]" id="sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.r">r</a><span class="delimiter">)</span> =&gt; <span title="(b: (K[_0], VR[_0]))scala.util.Right[Nothing,(K[_0], VR[_0])]">Right</span><span class="delimiter">(</span><span title="(_1: K[_0], _2: VR[_0])(K[_0], VR[_0])" class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.k" title="K[_]">k</a>, <a href="#sbt.IMap;IMap0.mapSeparate.mapped.$anonfun.r" title="VR[_0]">r</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a href="#sbt.IMap;IMap0.mapSeparate.l" title="(Seq[(K[_], VL[_])], Seq[(K[_], VR[_])])" class="delimiter">(</a><a href="#sbt.IMap;IMap0.mapSeparate.x$1" title="Seq[(K[_], VL[_])]" id="sbt.IMap;IMap0.mapSeparate.l">l</a>, <a href="#sbt.IMap;IMap0.mapSeparate.x$1" title="Seq[(K[_], VR[_])]" id="sbt.IMap;IMap0.mapSeparate.r">r</a><span class="delimiter">)</span> = <a href="Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<a href="Util.scala.html#sbt.Util.separateE" title="[A, B](ps: Seq[Either[A,B]])(Seq[A], Seq[B])">separateE</a><span title="(ps: Seq[Either[(K[_], VL[_]),(K[_], VR[_])]])(Seq[(K[_], VL[_])], Seq[(K[_], VR[_])])" class="delimiter">[</span><span title="(K[_], VL[_])" class="delimiter">(</span>K<span class="delimiter">[</span>_<span class="delimiter">]</span>, VL<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>, <span title="(K[_], VR[_])" class="delimiter">(</span>K<span class="delimiter">[</span>_<span class="delimiter">]</span>, VR<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span title="(Seq[(K[_], VL[_])], Seq[(K[_], VR[_])]) @unchecked" class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapSeparate.mapped" title="Iterator[Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])] forSome { type _0; type _0; type _0; type _0 }]">mapped</a>.<span title="=&gt; List[Product with Serializable with scala.util.Either[(K[_0], VL[_0]),(K[_0], VR[_0])] forSome { type _0; type _0; type _0; type _0 }]">toList</span><span class="delimiter">)</span>
        <span title="(_1: sbt.IMap.IMap0[K,VL], _2: sbt.IMap.IMap0[K,VR])(sbt.IMap.IMap0[K,VL], sbt.IMap.IMap0[K,VR])" class="delimiter">(</span><span title="sbt.IMap.IMap0[K,VL]" class="keyword">new</span> <a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,VL]">IMap0</a><span class="delimiter">[</span>K, VL<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapSeparate.l" title="Seq[(K[_], VL[_])]">l</a>.<span title="(implicit ev: &lt;:&lt;[(K[_], VL[_]),(K[_], VL[_])])scala.collection.immutable.Map[K[_],VL[_]]">toMap</span><span class="delimiter">)</span>, <span title="sbt.IMap.IMap0[K,VR]" class="keyword">new</span> <a href="#sbt.IMap;IMap0" title="sbt.IMap.IMap0[K,VR]">IMap0</a><span class="delimiter">[</span>K, VR<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.IMap;IMap0.mapSeparate.r" title="Seq[(K[_], VR[_])]">r</a>.<span title="(implicit ev: &lt;:&lt;[(K[_], VR[_]),(K[_], VR[_])])scala.collection.immutable.Map[K[_],VR[_]]">toMap</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Seq[(K[_], V[_])]" id="sbt.IMap;IMap0.toSeq">toSeq</a> = <a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="=&gt; Seq[(K[_], V[_])]">toSeq</span>
    <span class="keyword">def</span> <a title="=&gt; Iterable[K[_]]" id="sbt.IMap;IMap0.keys">keys</a> = <a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="=&gt; Iterable[K[_]]">keys</span>
    <span class="keyword">def</span> <a title="=&gt; Iterable[V[_]]" id="sbt.IMap;IMap0.values">values</a> = <a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="=&gt; Iterable[V[_]]">values</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.IMap;IMap0.isEmpty">isEmpty</a> = <a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.IMap;IMap0.toString">toString</a> = <a href="#sbt.IMap;IMap0.backing" title="Map[K[_],V[_]]">backing</a>.<span title="()String">toString</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbstractRMap[K[_], V[_]] extends AnyRef with sbt.RMap[K,V]" id="sbt;AbstractRMap">AbstractRMap</a><span class="delimiter">[</span><a title="[_]" id="sbt;AbstractRMap;K">K</a><span class="delimiter">[</span><a title="" id="sbt;AbstractRMap;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;AbstractRMap;V">V</a><span class="delimiter">[</span><a title="" id="sbt;AbstractRMap;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <a href="#sbt;AbstractRMap" title="sbt.AbstractRMap[K,V]" class="keyword">extends</a> <a href="#sbt;RMap" title="sbt.RMap[K,V]">RMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])V[T]" id="sbt;AbstractRMap.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;AbstractRMap.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;AbstractRMap.apply.k">k</a>: <a href="#sbt;AbstractRMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;AbstractRMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;RMap.get" title="(k: K[T])Option[V[T]]">get</a><span class="delimiter">(</span><a href="#sbt;AbstractRMap.apply.k" title="K[T]">k</a><span class="delimiter">)</span>.<span title="=&gt; V[T]">get</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])Boolean" id="sbt;AbstractRMap.contains">contains</a><span class="delimiter">[</span><a title="" id="sbt;AbstractRMap.contains;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;AbstractRMap.contains.k">k</a>: <a href="#sbt;AbstractRMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#sbt;RMap.get" title="(k: K[T])Option[V[T]]">get</a><span class="delimiter">(</span><a href="#sbt;AbstractRMap.contains.k" title="K[T]">k</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isDefined</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Only suitable for K that is invariant in its type parameter.
 * Option and List keys are not suitable, for example,
 *  because None &amp;lt;:&amp;lt; Option[String] and None &amp;lt;: Option[Int].
 */</span>
<span class="keyword">class</span> <a title="class DelegatingPMap[K[_], V[_]] extends sbt.AbstractRMap[K,V] with sbt.PMap[K,V]" id="sbt;DelegatingPMap">DelegatingPMap</a><span class="delimiter">[</span><a title="[_]" id="sbt;DelegatingPMap;K">K</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap;K;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;DelegatingPMap;V">V</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap;V;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt;DelegatingPMap" title="sbt.DelegatingPMap[K,V]" class="delimiter">(</a><a title="scala.collection.mutable.Map[K[_],V[_]]" id="sbt;DelegatingPMap.backing">backing</a>: mutable.<span title="scala.collection.mutable.Map[K[_],V[_]]">Map</span><span class="delimiter">[</span>K<span class="delimiter">[</span>_<span class="delimiter">]</span>, V<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt;AbstractRMap" title="sbt.AbstractRMap[K,V]">AbstractRMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#sbt;PMap" title="sbt.PMap[K,V]">PMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])Option[V[T]]" id="sbt;DelegatingPMap.get">get</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;DelegatingPMap.get.k">k</a>: <a href="#sbt;DelegatingPMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;DelegatingPMap.cast(870a06bbf9)" title="[T](o: Option[V[_]])Option[V[T]]">cast</a><span title="(o: Option[V[_]])Option[V[T]]" class="delimiter">[</span><a href="#sbt;DelegatingPMap.get;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="(key: K[_])Option[V[_]]">get</span><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.get.k" title="K[T]">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], v: V[T])Unit" id="sbt;DelegatingPMap.update">update</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.update;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;DelegatingPMap.update.k">k</a>: <a href="#sbt;DelegatingPMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;DelegatingPMap.update.v">v</a>: <a href="#sbt;DelegatingPMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt;DelegatingPMap.backing" title="(key: K[_], value: V[_])Unit">backing</a><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.update.k" title="K[T]">k</a><span class="delimiter">)</span> = <a href="#sbt;DelegatingPMap.update.v" title="V[T]">v</a> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[T](k: K[T])Option[V[T]]" id="sbt;DelegatingPMap.remove">remove</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.remove;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;DelegatingPMap.remove.k">k</a>: <a href="#sbt;DelegatingPMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;DelegatingPMap.cast(870a06bbf9)" title="(o: Option[V[_]])Option[V[T]]">cast</a><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="(key: K[_])Option[V[_]]">remove</span><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.remove.k" title="K[T]">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], make: =&gt; V[T])V[T]" id="sbt;DelegatingPMap.getOrUpdate">getOrUpdate</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.getOrUpdate;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;DelegatingPMap.getOrUpdate.k">k</a>: <a href="#sbt;DelegatingPMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; V[T]" id="sbt;DelegatingPMap.getOrUpdate.make">make</a>: =&gt; V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;DelegatingPMap.cast(e0e351852d)" title="[T](v: V[_])V[T]">cast</a><span title="(v: V[_])V[T]" class="delimiter">[</span><a href="#sbt;DelegatingPMap.getOrUpdate;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="(key: K[_], op: =&gt; V[_])V[_]">getOrElseUpdate</span><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.getOrUpdate.k" title="K[T]">k</a>, <a href="#sbt;DelegatingPMap.getOrUpdate.make" title="=&gt; V[T]">make</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](k: K[T], init: V[T], f: V[T] =&gt; V[T])V[T]" id="sbt;DelegatingPMap.mapValue">mapValue</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.mapValue;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="K[T]" id="sbt;DelegatingPMap.mapValue.k">k</a>: <a href="#sbt;DelegatingPMap;K" title="K[T]">K</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T]" id="sbt;DelegatingPMap.mapValue.init">init</a>: <a href="#sbt;DelegatingPMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="V[T] =&gt; V[T]" id="sbt;DelegatingPMap.mapValue.f">f</a>: V<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;DelegatingPMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="V[T]" id="sbt;DelegatingPMap.mapValue.v">v</a> = <a href="#sbt;DelegatingPMap.mapValue.f" title="(v1: V[T])V[T]">f</a><span class="delimiter">(</span><a href="#sbt;DelegatingPMap" title="DelegatingPMap.this.type" class="keyword">this</a> <a href="#sbt;DelegatingPMap.get" title="(k: K[T])Option[V[T]]">get</a> <a href="#sbt;DelegatingPMap.mapValue.k" title="K[T]">k</a> <span title="(default: =&gt; V[T])V[T]">getOrElse</span> <a href="#sbt;DelegatingPMap.mapValue.init" title="V[T]">init</a><span class="delimiter">)</span>
      <a href="#sbt;DelegatingPMap.update" title="(k: K[T], v: V[T])Unit">update</a><span class="delimiter">(</span><a href="#sbt;DelegatingPMap.mapValue.k" title="K[T]">k</a>, <a href="#sbt;DelegatingPMap.mapValue.v" title="V[T]">v</a><span class="delimiter">)</span>
      <a href="#sbt;DelegatingPMap.mapValue.v" title="V[T]">v</a>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(K[_], V[_])]" id="sbt;DelegatingPMap.toSeq">toSeq</a> = <a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="=&gt; Seq[(K[_], V[_])]">toSeq</span>
  <span class="keyword">def</span> <a title="=&gt; Iterable[K[_]]" id="sbt;DelegatingPMap.keys">keys</a> = <a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="=&gt; Iterable[K[_]]">keys</span>
  <span class="keyword">def</span> <a title="=&gt; Iterable[V[_]]" id="sbt;DelegatingPMap.values">values</a> = <a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="=&gt; Iterable[V[_]]">values</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;DelegatingPMap.isEmpty">isEmpty</a> = <a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](v: V[_])V[T]" id="sbt;DelegatingPMap.cast(e0e351852d)">cast</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.cast(e0e351852d);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="V[_]" id="sbt;DelegatingPMap.cast(e0e351852d).v">v</a>: <a href="#sbt;DelegatingPMap;V" title="V[_]">V</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;DelegatingPMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;DelegatingPMap.cast(e0e351852d).v" title="V[_]">v</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="V[T]" class="delimiter">[</span><a href="#sbt;DelegatingPMap;V" title="V[T]">V</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](o: Option[V[_]])Option[V[T]]" id="sbt;DelegatingPMap.cast(870a06bbf9)">cast</a><span class="delimiter">[</span><a title="" id="sbt;DelegatingPMap.cast(870a06bbf9);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Option[V[_]]" id="sbt;DelegatingPMap.cast(870a06bbf9).o">o</a>: <span title="Option[V[_]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[V[T]]">Option</span><span class="delimiter">[</span>V<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;DelegatingPMap.cast(870a06bbf9).o" title="Option[V[_]]">o</a> <span title="(f: V[_] =&gt; V[T])Option[V[T]]">map</span> <a href="#sbt;DelegatingPMap.cast(e0e351852d)" title="[T](v: V[_])V[T]">cast</a><a href="#sbt;DelegatingPMap.cast(870a06bbf9).$anonfun.v" title="(v: V[_])V[T]" class="delimiter">[</a><a href="#sbt;DelegatingPMap.cast(870a06bbf9);T" title="T">T</a><span class="delimiter">]</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt;DelegatingPMap.toString">toString</a> = <a href="#sbt;DelegatingPMap.backing" title="scala.collection.mutable.Map[K[_],V[_]]">backing</a>.<span title="()String">toString</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
