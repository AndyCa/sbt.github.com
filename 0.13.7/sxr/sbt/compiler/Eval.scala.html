<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/compiler/Eval.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> compiler

<span class="keyword">import</span> scala.reflect.Manifest
<span class="keyword">import</span> scala.tools.nsc.<span class="delimiter">{</span> ast, interpreter, io, reporters, util, CompilerCommand, Global, Phase, Settings <span class="delimiter">}</span>
<span class="keyword">import</span> interpreter.AbstractFileClassLoader
<span class="keyword">import</span> io.<span class="delimiter">{</span> AbstractFile, PlainFile, VirtualDirectory <span class="delimiter">}</span>
<span class="keyword">import</span> ast.parser.Tokens
<span class="keyword">import</span> reporters.<span class="delimiter">{</span> ConsoleReporter, Reporter <span class="delimiter">}</span>
<span class="keyword">import</span> scala.reflect.internal.util.BatchSourceFile
<span class="keyword">import</span> <span title="scala.tools.nsc.ast.parser.Tokens.type">Tokens</span>.<span class="delimiter">{</span> EOF, NEWLINE, NEWLINES, SEMI <span class="delimiter">}</span>
<span class="keyword">import</span> java.io.File
<span class="keyword">import</span> java.nio.ByteBuffer
<span class="keyword">import</span> java.net.URLClassLoader
<span class="keyword">import</span> <a href="#sbt.compiler.Eval" title="sbt.compiler.Eval.type">Eval</a>.<span class="delimiter">{</span> getModule, getValue, WrapValName <span class="delimiter">}</span>

<span class="comment">// TODO: provide a way to cleanup backing directory</span>

<span class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalImports extends AnyRef" id="sbt.compiler;EvalImports">EvalImports</a><a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports" class="delimiter">(</a><span class="keyword">val</span> <a title="Seq[(String, Int)]" id="sbt.compiler;EvalImports.strings">strings</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;EvalImports.srcName">srcName</a>: <span title="String">String</span><span class="delimiter">)</span>

<span class="comment">/**
 * The result of evaluating a Scala expression.  The inferred type of the expression is given by `tpe`.
 * The value may be obtained from `getValue` by providing a parent class loader that provides the classes from the classpath
 * this expression was compiled against.  Each call to `getValue` constructs a new class loader and loads
 * the module from that class loader.  `generated` contains the compiled classes and cache files related
 * to the expression.  The name of the auto-generated module wrapping the expression is `enclosingModule`.
 */</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalResult extends AnyRef" id="sbt.compiler;EvalResult">EvalResult</a><a href="#sbt.compiler;EvalResult" title="sbt.compiler.EvalResult" class="delimiter">(</a><span class="keyword">val</span> <a title="String" id="sbt.compiler;EvalResult.tpe">tpe</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="ClassLoader =&gt; Any" id="sbt.compiler;EvalResult.getValue">getValue</a>: ClassLoader =&gt; Any, <span class="keyword">val</span> <a title="Seq[java.io.File]" id="sbt.compiler;EvalResult.generated">generated</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;EvalResult.enclosingModule">enclosingModule</a>: <span title="String">String</span><span class="delimiter">)</span>

<span class="comment">/**
 * The result of evaluating a group of Scala definitions.  The definitions are wrapped in an auto-generated,
 * top-level module named `enclosingModule`.  `generated` contains the compiled classes and cache files related to the definitions.
 * A new class loader containing the module may be obtained from `loader` by passing the parent class loader providing the classes
 * from the classpath that the definitions were compiled against.  The list of vals with the requested types is `valNames`.
 * The values for these may be obtained by providing the parent class loader to `values` as is done with `loader`.
 */</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalDefinitions extends AnyRef" id="sbt.compiler;EvalDefinitions">EvalDefinitions</a><a href="#sbt.compiler;EvalDefinitions" title="sbt.compiler.EvalDefinitions" class="delimiter">(</a><span class="keyword">val</span> <a title="ClassLoader =&gt; ClassLoader" id="sbt.compiler;EvalDefinitions.loader">loader</a>: ClassLoader =&gt; ClassLoader, <span class="keyword">val</span> <a title="Seq[java.io.File]" id="sbt.compiler;EvalDefinitions.generated">generated</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;EvalDefinitions.enclosingModule">enclosingModule</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="Seq[String]" id="sbt.compiler;EvalDefinitions.valNames">valNames</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(parent: ClassLoader)Seq[Any]" id="sbt.compiler;EvalDefinitions.values">values</a><span class="delimiter">(</span><a title="ClassLoader" id="sbt.compiler;EvalDefinitions.values.parent">parent</a>: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span>: <span title="Seq[Any]">Seq</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Any" id="sbt.compiler;EvalDefinitions.values.module">module</a> = <a href="#sbt.compiler.Eval.getModule" title="(moduleName: String, loader: ClassLoader)Any">getModule</a><span class="delimiter">(</span><a href="#sbt.compiler;EvalDefinitions.enclosingModule" title="=&gt; String">enclosingModule</a>, <a href="#sbt.compiler;EvalDefinitions.loader" title="(v1: ClassLoader)ClassLoader">loader</a><span class="delimiter">(</span><a href="#sbt.compiler;EvalDefinitions.values.parent" title="ClassLoader">parent</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="String" id="sbt.compiler;EvalDefinitions.values.$anonfun.n">n</a> &lt;- <a href="#sbt.compiler;EvalDefinitions.valNames" title="(f: String =&gt; Object)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],Object,Seq[Any]])Seq[Any]">valNames</a><span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#sbt.compiler;EvalDefinitions.values.module" title="Any">module</a>.<span title="()Class[_]">getClass</span>.<span title="(x$1: String, x$2: &lt;repeated...&gt;[Class[_]])java.lang.reflect.Method">getMethod</span><span class="delimiter">(</span><a href="#sbt.compiler;EvalDefinitions.values.$anonfun.n" title="String">n</a><span class="delimiter">)</span>.<span title="(x$1: Any, x$2: &lt;repeated...&gt;[Object])Object">invoke</span><span class="delimiter">(</span><a href="#sbt.compiler;EvalDefinitions.values.module" title="Any">module</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalException extends RuntimeException" id="sbt.compiler;EvalException">EvalException</a><a href="#sbt.compiler;EvalException" title="sbt.compiler.EvalException" class="delimiter">(</a><a title="String" id="sbt.compiler;EvalException.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="RuntimeException">RuntimeException</span><span class="delimiter">(</span><a href="#sbt.compiler;EvalException.msg" title="String">msg</a><span class="delimiter">)</span>
<span class="comment">// not thread safe, since it reuses a Global instance</span>
<span class="keyword">final</span> <span class="keyword">class</span> <a title="class Eval extends AnyRef" id="sbt.compiler;Eval">Eval</a><a href="#sbt.compiler;Eval" title="sbt.compiler.Eval" class="delimiter">(</a><a title="Seq[String]" id="sbt.compiler;Eval.optionsNoncp">optionsNoncp</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Seq[java.io.File]" id="sbt.compiler;Eval.classpath">classpath</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="scala.tools.nsc.Settings =&gt; scala.tools.nsc.reporters.Reporter" id="sbt.compiler;Eval.mkReporter">mkReporter</a>: Settings =&gt; Reporter, <a title="Option[java.io.File]" id="sbt.compiler;Eval.backing">backing</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(mkReporter: scala.tools.nsc.Settings =&gt; scala.tools.nsc.reporters.Reporter, backing: Option[java.io.File])sbt.compiler.Eval" id="sbt.compiler;Eval.<init>(6691dfe9d6)" class="keyword">this</a><span class="delimiter">(</span><a title="scala.tools.nsc.Settings =&gt; scala.tools.nsc.reporters.Reporter" id="sbt.compiler;Eval.<init>(6691dfe9d6).mkReporter">mkReporter</a>: Settings =&gt; Reporter, <a title="Option[java.io.File]" id="sbt.compiler;Eval.<init>(6691dfe9d6).backing">backing</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval" title="Eval.this.type" class="keyword">this</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="../IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="../IO.scala.html#sbt.IO.classLocationFile(4f0d1e2f63)" title="[T](implicit mf: scala.reflect.Manifest[T])java.io.File">classLocationFile</a><span title="(implicit mf: scala.reflect.Manifest[Product])java.io.File" class="delimiter">[</span><span title="Product">Product</span><span class="delimiter">]</span> <a href="#sbt.compiler;Eval.<init>(6691dfe9d6).x$1" title="(x: java.io.File)List[java.io.File]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.compiler;Eval.<init>(6691dfe9d6).mkReporter" title="scala.tools.nsc.Settings =&gt; scala.tools.nsc.reporters.Reporter">mkReporter</a>, <a href="#sbt.compiler;Eval.<init>(6691dfe9d6).backing" title="Option[java.io.File]">backing</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="()sbt.compiler.Eval" id="sbt.compiler;Eval.<init>(e8eb7a32f2)" class="keyword">this</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.<init>(6691dfe9d6)" title="(mkReporter: scala.tools.nsc.Settings =&gt; scala.tools.nsc.reporters.Reporter, backing: Option[java.io.File])sbt.compiler.Eval" class="keyword">this</a><span class="delimiter">(</span><a title="scala.tools.nsc.Settings" id="sbt.compiler;Eval.<init>(e8eb7a32f2).$anonfun.s">s</a> =&gt; <span title="(settings: scala.tools.nsc.Settings)scala.tools.nsc.reporters.ConsoleReporter" class="keyword">new</span> <span title="scala.tools.nsc.reporters.ConsoleReporter">ConsoleReporter</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.<init>(e8eb7a32f2).$anonfun.s" title="scala.tools.nsc.Settings">s</a><span class="delimiter">)</span>, <span title="None.type">None</span><span class="delimiter">)</span>

  <a href="#sbt.compiler;Eval.backing" title="Option[java.io.File]">backing</a>.<span title="(f: java.io.File =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="../IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="../IO.scala.html#sbt.IO.createDirectory" title="(dir: java.io.File)Unit">createDirectory</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval.classpathString">classpathString</a> = <a href="../Path.scala.html#sbt.Path" title="sbt.Path.type">Path</a>.<a href="../Path.scala.html#sbt.Path.makeString(d8b5db7ba2)" title="(paths: Seq[java.io.File])String">makeString</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.classpath" title="Seq[java.io.File]">classpath</a> <span title="(that: scala.collection.GenTraversableOnce[java.io.File])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[java.io.File],java.io.File,Seq[java.io.File]])Seq[java.io.File]">++</span> <a href="#sbt.compiler;Eval.backing" title="Option[java.io.File]">backing</a>.<span title="=&gt; List[java.io.File]">toList</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="Seq[String]" id="sbt.compiler;Eval.options">options</a> = <span title="String(&quot;-cp&quot;)" class="string">&quot;-cp&quot;</span> <a href="#sbt.compiler;Eval.options.x$3" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.compiler;Eval.classpathString" title="=&gt; String">classpathString</a> <a href="#sbt.compiler;Eval.options.x$2" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.compiler;Eval.optionsNoncp" title="Seq[String]">optionsNoncp</a>

  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="scala.tools.nsc.Settings" id="sbt.compiler;Eval.settings">settings</a> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.Settings" id="sbt.compiler;Eval.settings.s">s</a> = <span title="scala.tools.nsc.Settings" class="keyword">new</span> <span title="scala.tools.nsc.Settings">Settings</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.settings.s.$anonfun.x" title="(x: Any)Unit">println</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.CompilerCommand" id="sbt.compiler;Eval.settings.command">command</a> = <span title="scala.tools.nsc.CompilerCommand" class="keyword">new</span> <span title="scala.tools.nsc.CompilerCommand">CompilerCommand</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.options" title="=&gt; Seq[String]">options</a>.<span title="=&gt; List[String]">toList</span>, <a href="#sbt.compiler;Eval.settings.s" title="scala.tools.nsc.Settings">s</a><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.settings.s" title="scala.tools.nsc.Settings">s</a>
    <span class="delimiter">}</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="scala.tools.nsc.reporters.Reporter" id="sbt.compiler;Eval.reporter">reporter</a> = <a href="#sbt.compiler;Eval.mkReporter" title="(v1: scala.tools.nsc.Settings)scala.tools.nsc.reporters.Reporter">mkReporter</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.settings" title="=&gt; scala.tools.nsc.Settings">settings</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Subclass of Global which allows us to mutate currentRun from outside.
   * See for rationale https://issues.scala-lang.org/browse/SI-8794
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalGlobal extends scala.tools.nsc.Global" id="sbt.compiler;Eval;EvalGlobal">EvalGlobal</a><a href="#sbt.compiler;Eval;EvalGlobal" title="Eval.this.EvalGlobal" class="delimiter">(</a><a title="scala.tools.nsc.Settings" id="sbt.compiler;Eval;EvalGlobal.settings">settings</a>: <span title="scala.tools.nsc.Settings">Settings</span>, <a title="scala.tools.nsc.reporters.Reporter" id="sbt.compiler;Eval;EvalGlobal.reporter">reporter</a>: <span title="scala.tools.nsc.reporters.Reporter">Reporter</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="scala.tools.nsc.Global">Global</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;EvalGlobal.settings" title="scala.tools.nsc.Settings">settings</a>, <a href="#sbt.compiler;Eval;EvalGlobal.reporter" title="scala.tools.nsc.reporters.Reporter">reporter</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; EvalGlobal.this.Run" id="sbt.compiler;Eval;EvalGlobal.currentRun">currentRun</a>: <span title="EvalGlobal.this.Run">Run</span> = <a href="#sbt.compiler;Eval;EvalGlobal.curRun_=(5aa6db0198)" title="=&gt; EvalGlobal.this.Run">curRun</a>
    <span class="keyword">var</span> <a title="EvalGlobal.this.Run" id="sbt.compiler;Eval;EvalGlobal.curRun_=(5aa6db0198)">curRun</a>: <span title="EvalGlobal.this.Run">Run</span> = <span title="Null(null)" class="keyword">null</span>
  <span class="delimiter">}</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Eval.this.EvalGlobal" id="sbt.compiler;Eval.global">global</a>: <a href="#sbt.compiler;Eval;EvalGlobal" title="Eval.this.EvalGlobal">EvalGlobal</a> = <span title="Eval.this.EvalGlobal" class="keyword">new</span> <a href="#sbt.compiler;Eval;EvalGlobal" title="Eval.this.EvalGlobal">EvalGlobal</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.settings" title="=&gt; scala.tools.nsc.Settings">settings</a>, <a href="#sbt.compiler;Eval.reporter" title="=&gt; scala.tools.nsc.reporters.Reporter">reporter</a><span class="delimiter">)</span>
  <span class="keyword">import</span> <a href="#sbt.compiler;Eval.global" title="=&gt; Eval.this.EvalGlobal">global</a>._
  <span class="keyword">import</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.definitions.type">definitions</a>._

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="()Unit" id="sbt.compiler;Eval.unlinkDeferred">unlinkDeferred</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#sbt.compiler;Eval.toUnlinkLater" title="List[Eval.this.global.Symbol]">toUnlinkLater</a> <span title="(f: Eval.this.global.Symbol =&gt; Unit)Unit">foreach</span> <a href="#sbt.compiler;Eval.unlink" title="(sym: Eval.this.global.Symbol)Unit">unlink</a>
    <a href="#sbt.compiler;Eval.toUnlinkLater" title="List[Eval.this.global.Symbol]">toUnlinkLater</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[Eval.this.global.Symbol]" id="sbt.compiler;Eval.toUnlinkLater">toUnlinkLater</a> = List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(sym: Eval.this.global.Symbol)Unit" id="sbt.compiler;Eval.unlink">unlink</a><span class="delimiter">(</span><a title="Eval.this.global.Symbol" id="sbt.compiler;Eval.unlink.sym">sym</a>: <span title="Eval.this.global.Symbol">Symbol</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.unlink.sym" title="Eval.this.global.Symbol">sym</a>.<span title="=&gt; Eval.this.global.Symbol">owner</span>.<span title="=&gt; Eval.this.global.Type">info</span>.<span title="=&gt; Eval.this.global.Scope">decls</span>.<span title="(sym: Eval.this.global.Symbol)Unit">unlink</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.unlink.sym" title="Eval.this.global.Symbol">sym</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(expression: String, imports: sbt.compiler.EvalImports, tpeName: Option[String], srcName: String, line: Int)sbt.compiler.EvalResult" id="sbt.compiler;Eval.eval">eval</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.eval.expression">expression</a>: <span title="String">String</span>, <a title="sbt.compiler.EvalImports" id="sbt.compiler;Eval.eval$default$2">imports</a>: <a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a> = <a href="#sbt.compiler;Eval.noImports" title="=&gt; sbt.compiler.EvalImports">noImports</a>, <a title="Option[String]" id="sbt.compiler;Eval.eval$default$3">tpeName</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="None.type">None</span>, <a title="String" id="sbt.compiler;Eval.eval$default$4">srcName</a>: <span title="String">String</span> = <span title="String(&quot;&lt;setting&gt;&quot;)" class="string">&quot;&lt;setting&gt;&quot;</span>, <a title="Int" id="sbt.compiler;Eval.eval$default$5">line</a>: <span title="Int">Int</span> = <a href="#sbt.compiler;Eval.DefaultStartLine" title="=&gt; Int">DefaultStartLine</a><span class="delimiter">)</span>: <a href="#sbt.compiler;EvalResult" title="sbt.compiler.EvalResult">EvalResult</a> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ev extends AnyRef with Eval.this.EvalType[String]" id="sbt.compiler;Eval.eval.ev">ev</a> = <a href="#sbt.compiler;Eval.eval.ev;$anon" title="Eval.this.EvalType[String]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Eval.this.EvalType[String]" id="sbt.compiler;Eval.eval.ev;$anon">EvalType</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="=&gt; Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.eval.ev;$anon.makeUnit">makeUnit</a> = <a href="#sbt.compiler;Eval.mkUnit" title="(srcName: String, firstLine: Int, s: String)Eval.this.global.CompilationUnit">mkUnit</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval$default$4" title="String">srcName</a>, <a href="#sbt.compiler;Eval.eval$default$5" title="Int">line</a>, <a href="#sbt.compiler;Eval.eval.expression" title="String">expression</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.compiler;Eval.eval.ev;$anon.unlink">unlink</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">def</span> <a title="(unit: Eval.this.global.CompilationUnit, importTrees: Seq[Eval.this.global.Tree], moduleName: String)Eval.this.global.Tree" id="sbt.compiler;Eval.eval.ev;$anon.unitBody">unitBody</a><span class="delimiter">(</span><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.eval.ev;$anon.unitBody.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span>, <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.eval.ev;$anon.unitBody.importTrees">importTrees</a>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval.eval.ev;$anon.unitBody.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.parser" title="(Eval.this.global.syntaxAnalyzer.UnitParser, Eval.this.global.syntaxAnalyzer.global.Tree)" class="delimiter">(</a><a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.x$5" title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.eval.ev;$anon.unitBody.parser">parser</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.x$5" title="Eval.this.global.syntaxAnalyzer.global.Tree" id="sbt.compiler;Eval.eval.ev;$anon.unitBody.tree">tree</a><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.parse" title="(unit: Eval.this.global.CompilationUnit, errors: Eval.this.ParseErrorStrings, f: Eval.this.global.syntaxAnalyzer.UnitParser =&gt; Eval.this.global.syntaxAnalyzer.global.Tree)(Eval.this.global.syntaxAnalyzer.UnitParser, Eval.this.global.syntaxAnalyzer.global.Tree)">parse</a><span title="(Eval.this.global.syntaxAnalyzer.UnitParser, Eval.this.global.syntaxAnalyzer.global.Tree) @unchecked" class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.unit" title="Eval.this.global.CompilationUnit">unit</a>, <a href="#sbt.compiler;Eval.settingErrorStrings" title="=&gt; Eval.this.ParseErrorStrings">settingErrorStrings</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.x$5.$anonfun.x$4" title="Eval.this.global.syntaxAnalyzer.UnitParser">_</a>.<span title="()Eval.this.global.syntaxAnalyzer.global.Tree">expr</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Eval.this.global.Tree" id="sbt.compiler;Eval.eval.ev;$anon.unitBody.tpt">tpt</a>: <span title="Eval.this.global.Tree">Tree</span> = <a href="#sbt.compiler;Eval.expectedType" title="(tpeName: Option[String])Eval.this.global.Tree">expectedType</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval$default$3" title="Option[String]">tpeName</a><span class="delimiter">)</span>
          <a href="#sbt.compiler;Eval.augment" title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser, imports: Seq[Eval.this.global.Tree], tree: Eval.this.global.Tree, tpt: Eval.this.global.Tree, objectName: String)Eval.this.global.Tree">augment</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.importTrees" title="Seq[Eval.this.global.Tree]">importTrees</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.tree" title="Eval.this.global.syntaxAnalyzer.global.Tree">tree</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.tpt" title="Eval.this.global.Tree">tpt</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.unitBody.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(run: Eval.this.global.Run, unit: Eval.this.global.CompilationUnit)String" id="sbt.compiler;Eval.eval.ev;$anon.extra">extra</a><span class="delimiter">(</span><a title="Eval.this.global.Run" id="sbt.compiler;Eval.eval.ev;$anon.extra.run">run</a>: <span title="Eval.this.global.Run">Run</span>, <a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.eval.ev;$anon.extra.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.global" title="(ph: scala.reflect.internal.Phase)(op: =&gt; String)String">atPhase</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.ev;$anon.extra.run" title="Eval.this.global.Run">run</a>.<span title="=&gt; scala.tools.nsc.Phase">typerPhase</span>.<span title="=&gt; scala.reflect.internal.Phase">next</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><span title="Eval.this.TypeExtractor" class="keyword">new</span> <a href="#sbt.compiler;Eval;TypeExtractor" title="Eval.this.TypeExtractor">TypeExtractor</a><span class="delimiter">)</span>.<a href="#sbt.compiler;Eval;TypeExtractor.getType" title="(t: Eval.this.global.Tree)String">getType</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.ev;$anon.extra.unit" title="Eval.this.global.CompilationUnit">unit</a>.<span title="=&gt; Eval.this.global.Tree">body</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(file: java.io.File)String" id="sbt.compiler;Eval.eval.ev;$anon.read">read</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.eval.ev;$anon.read.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span> = <a href="../IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="../IO.scala.html#sbt.IO.read" title="(file: java.io.File, charset: java.nio.charset.Charset)String">read</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.ev;$anon.read.file" title="java.io.File">file</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(value: String, f: java.io.File)Unit" id="sbt.compiler;Eval.eval.ev;$anon.write">write</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.eval.ev;$anon.write.value">value</a>: <span title="String">String</span>, <a title="java.io.File" id="sbt.compiler;Eval.eval.ev;$anon.write.f">f</a>: <span title="java.io.File">File</span><span class="delimiter">)</span> = <a href="../IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="../IO.scala.html#sbt.IO.write(1cd4fc02a6)" title="(file: java.io.File, content: String, charset: java.nio.charset.Charset, append: Boolean)Unit">write</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.ev;$anon.write.f" title="java.io.File">f</a>, <a href="#sbt.compiler;Eval.eval.ev;$anon.write.value" title="String">value</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="=&gt; String" id="sbt.compiler;Eval.eval.ev;$anon.extraHash">extraHash</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Eval.this.EvalIntermediate[String]" id="sbt.compiler;Eval.eval.i">i</a> = <a href="#sbt.compiler;Eval.evalCommon" title="(content: Seq[String], imports: sbt.compiler.EvalImports, tpeName: Option[String], ev: Eval.this.EvalType[String])Eval.this.EvalIntermediate[String]">evalCommon</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.expression" title="String">expression</a> <a href="#sbt.compiler;Eval.eval.i.x$6" title="(x: String)List[String]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.compiler;Eval.eval$default$2" title="sbt.compiler.EvalImports">imports</a>, <a href="#sbt.compiler;Eval.eval$default$3" title="Option[String]">tpeName</a>, <a href="#sbt.compiler;Eval.eval.ev" title="ev extends AnyRef with Eval.this.EvalType[String]">ev</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ClassLoader =&gt; Any" id="sbt.compiler;Eval.eval.value">value</a> = <span class="delimiter">(</span>cl: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span> =&gt; <a href="#sbt.compiler.Eval.getValue" title="[T](objectName: String, loader: ClassLoader)T">getValue</a><span title="(objectName: String, loader: ClassLoader)Any" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.i" title="Eval.this.EvalIntermediate[String]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.enclosingModule" title="=&gt; String">enclosingModule</a>, <a href="#sbt.compiler;Eval.eval.i" title="Eval.this.EvalIntermediate[String]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.loader" title="(v1: ClassLoader)ClassLoader">loader</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.value.$anonfun.cl" title="ClassLoader">cl</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="sbt.compiler.EvalResult" class="keyword">new</span> <a href="#sbt.compiler;EvalResult" title="sbt.compiler.EvalResult">EvalResult</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.eval.i" title="Eval.this.EvalIntermediate[String]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.extra" title="=&gt; String">extra</a>, <a href="#sbt.compiler;Eval.eval.value" title="ClassLoader =&gt; Any">value</a>, <a href="#sbt.compiler;Eval.eval.i" title="Eval.this.EvalIntermediate[String]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.generated" title="=&gt; Seq[java.io.File]">generated</a>, <a href="#sbt.compiler;Eval.eval.i" title="Eval.this.EvalIntermediate[String]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.enclosingModule" title="=&gt; String">enclosingModule</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(definitions: Seq[(String, Range)], imports: sbt.compiler.EvalImports, srcName: String, file: Option[java.io.File], valTypes: Seq[String])sbt.compiler.EvalDefinitions" id="sbt.compiler;Eval.evalDefinitions">evalDefinitions</a><span class="delimiter">(</span><a title="Seq[(String, Range)]" id="sbt.compiler;Eval.evalDefinitions.definitions">definitions</a>: <span title="Seq[(String, Range)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, scala.Range<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="sbt.compiler.EvalImports" id="sbt.compiler;Eval.evalDefinitions.imports">imports</a>: <a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a>, <a title="String" id="sbt.compiler;Eval.evalDefinitions.srcName">srcName</a>: <span title="String">String</span>, <a title="Option[java.io.File]" id="sbt.compiler;Eval.evalDefinitions.file">file</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="Seq[String]" id="sbt.compiler;Eval.evalDefinitions.valTypes">valTypes</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.compiler;EvalDefinitions" title="sbt.compiler.EvalDefinitions">EvalDefinitions</a> =
    <span class="delimiter">{</span>
      <a href="#sbt.compiler;Eval.global" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.definitions" title="Seq[(String, Range)]">definitions</a>.<span title="=&gt; Boolean">nonEmpty</span>, <span title="String(&quot;Definitions to evaluate cannot be empty.&quot;)" class="string">&quot;Definitions to evaluate cannot be empty.&quot;</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ev extends AnyRef with Eval.this.EvalType[Seq[String]]" id="sbt.compiler;Eval.evalDefinitions.ev">ev</a> = <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon" title="Eval.this.EvalType[Seq[String]]{lazy val fullUnit: Eval.this.global.CompilationUnit; lazy val defUnits: Seq[Eval.this.global.CompilationUnit]}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Eval.this.EvalType[Seq[String]]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon">EvalType</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="(Eval.this.global.CompilationUnit, Seq[Eval.this.global.CompilationUnit])" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.x$7" class="delimiter">(</a><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.fullUnit">fullUnit</a>, <a title="Seq[Eval.this.global.CompilationUnit]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.defUnits">defUnits</a><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.mkDefsUnit" title="(srcName: String, definitions: Seq[(String, Range)])(Eval.this.global.CompilationUnit, Seq[Eval.this.global.CompilationUnit])">mkDefsUnit</a><span title="(Eval.this.global.CompilationUnit, Seq[Eval.this.global.CompilationUnit]) @unchecked" class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.srcName" title="String">srcName</a>, <a href="#sbt.compiler;Eval.evalDefinitions.definitions" title="Seq[(String, Range)]">definitions</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="=&gt; Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.makeUnit">makeUnit</a> = <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.fullUnit" title="=&gt; Eval.this.global.CompilationUnit">fullUnit</a>
        <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unlink">unlink</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">def</span> <a title="(unit: Eval.this.global.CompilationUnit, importTrees: Seq[Eval.this.global.Tree], moduleName: String)Eval.this.global.Tree" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody">unitBody</a><span class="delimiter">(</span><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span>, <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.importTrees">importTrees</a>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.fullParser">fullParser</a> = <span title="(unit: Eval.this.global.syntaxAnalyzer.global.CompilationUnit)Eval.this.global.syntaxAnalyzer.UnitParser" class="keyword">new</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.syntaxAnalyzer.type">syntaxAnalyzer</a>.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.unit" title="Eval.this.global.CompilationUnit">unit</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.trees">trees</a> = <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.defUnits" title="=&gt; Seq[Eval.this.global.CompilationUnit]">defUnits</a> <span title="(f: Eval.this.global.CompilationUnit =&gt; scala.collection.GenTraversableOnce[Eval.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Eval.this.global.CompilationUnit],Eval.this.global.Tree,Seq[Eval.this.global.Tree]])Seq[Eval.this.global.Tree]">flatMap</span> <a href="#sbt.compiler;Eval.parseDefinitions(051565c453)" title="(du: Eval.this.global.CompilationUnit)Seq[Eval.this.global.Tree]">parseDefinitions</a>
          <a href="#sbt.compiler;Eval.syntheticModule" title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser, imports: Seq[Eval.this.global.Tree], definitions: List[Eval.this.global.Tree], objectName: String)Eval.this.global.Tree">syntheticModule</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.fullParser" title="Eval.this.global.syntaxAnalyzer.UnitParser">fullParser</a>, <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.importTrees" title="Seq[Eval.this.global.Tree]">importTrees</a>, <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.trees" title="Seq[Eval.this.global.Tree]">trees</a>.<span title="=&gt; List[Eval.this.global.Tree]">toList</span>, <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.unitBody.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(run: Eval.this.global.Run, unit: Eval.this.global.CompilationUnit)List[String]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.extra">extra</a><span class="delimiter">(</span><a title="Eval.this.global.Run" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.extra.run">run</a>: <span title="Eval.this.global.Run">Run</span>, <a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.extra.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
          <a href="#sbt.compiler;Eval.global" title="(ph: scala.reflect.internal.Phase)(op: =&gt; List[String])List[String]">atPhase</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.extra.run" title="Eval.this.global.Run">run</a>.<span title="=&gt; scala.tools.nsc.Phase">typerPhase</span>.<span title="=&gt; scala.reflect.internal.Phase">next</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><span title="Eval.this.ValExtractor" class="keyword">new</span> <a href="#sbt.compiler;Eval;ValExtractor" title="Eval.this.ValExtractor">ValExtractor</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.valTypes" title="Seq[String]">valTypes</a>.<span title="scala.collection.immutable.Set[String]">toSet</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#sbt.compiler;Eval;ValExtractor.getVals" title="(t: Eval.this.global.Tree)List[String]">getVals</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.extra.unit" title="Eval.this.global.CompilationUnit">unit</a>.<span title="=&gt; Eval.this.global.Tree">body</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(file: java.io.File)List[String]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.read">read</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.read.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span> = <a href="../IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="../IO.scala.html#sbt.IO.readLines(50ee8d6d9c)" title="(file: java.io.File, charset: java.nio.charset.Charset)List[String]">readLines</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.read.file" title="java.io.File">file</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(value: Seq[String], file: java.io.File)Unit" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.write">write</a><span class="delimiter">(</span><a title="Seq[String]" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.write.value">value</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="java.io.File" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.write.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span> = <a href="../IO.scala.html#sbt.IO" title="sbt.IO.type">IO</a>.<a href="../IO.scala.html#sbt.IO.writeLines(b1ce86847a)" title="(file: java.io.File, lines: Seq[String], charset: java.nio.charset.Charset, append: Boolean)Unit">writeLines</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.write.file" title="java.io.File">file</a>, <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.write.value" title="Seq[String]">value</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="=&gt; String" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.extraHash">extraHash</a> = <a href="#sbt.compiler;Eval.evalDefinitions.file" title="Option[java.io.File]">file</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.evalDefinitions.ev;$anon.extraHash.f">f</a><span class="delimiter">)</span> =&gt; <a href="#sbt.compiler;Eval.evalDefinitions.ev;$anon.extraHash.f" title="java.io.File">f</a>.<span title="()String">getAbsolutePath</span>
          <span class="keyword">case</span> <span title="None.type">None</span>    =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Eval.this.EvalIntermediate[Seq[String]]" id="sbt.compiler;Eval.evalDefinitions.i">i</a> = <a href="#sbt.compiler;Eval.evalCommon" title="(content: Seq[String], imports: sbt.compiler.EvalImports, tpeName: Option[String], ev: Eval.this.EvalType[Seq[String]])Eval.this.EvalIntermediate[Seq[String]]">evalCommon</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.definitions" title="Seq[(String, Range)]">definitions</a>.<span title="(f: ((String, Range)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Range)],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.i.$anonfun.x$8" title="(String, Range)">_</a>.<span title="=&gt; String">_1</span><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.evalDefinitions.imports" title="sbt.compiler.EvalImports">imports</a>, <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.evalDefinitions.ev" title="ev extends AnyRef with Eval.this.EvalType[Seq[String]]">ev</a><span class="delimiter">)</span>
      <span title="sbt.compiler.EvalDefinitions" class="keyword">new</span> <a href="#sbt.compiler;EvalDefinitions" title="sbt.compiler.EvalDefinitions">EvalDefinitions</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalDefinitions.i" title="Eval.this.EvalIntermediate[Seq[String]]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.loader" title="=&gt; ClassLoader =&gt; ClassLoader">loader</a>, <a href="#sbt.compiler;Eval.evalDefinitions.i" title="Eval.this.EvalIntermediate[Seq[String]]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.generated" title="=&gt; Seq[java.io.File]">generated</a>, <a href="#sbt.compiler;Eval.evalDefinitions.i" title="Eval.this.EvalIntermediate[Seq[String]]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.enclosingModule" title="=&gt; String">enclosingModule</a>, <a href="#sbt.compiler;Eval.evalDefinitions.i" title="Eval.this.EvalIntermediate[Seq[String]]">i</a>.<a href="#sbt.compiler;Eval;EvalIntermediate.extra" title="=&gt; Seq[String]">extra</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](content: Seq[String], imports: sbt.compiler.EvalImports, tpeName: Option[String], ev: Eval.this.EvalType[T])Eval.this.EvalIntermediate[T]" id="sbt.compiler;Eval.evalCommon">evalCommon</a><span class="delimiter">[</span><a title="" id="sbt.compiler;Eval.evalCommon;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[String]" id="sbt.compiler;Eval.evalCommon.content">content</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="sbt.compiler.EvalImports" id="sbt.compiler;Eval.evalCommon.imports">imports</a>: <a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a>, <a title="Option[String]" id="sbt.compiler;Eval.evalCommon.tpeName">tpeName</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Eval.this.EvalType[T]" id="sbt.compiler;Eval.evalCommon.ev">ev</a>: <a href="#sbt.compiler;Eval;EvalType" title="Eval.this.EvalType[T]">EvalType</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.compiler;Eval;EvalIntermediate" title="Eval.this.EvalIntermediate[T]">EvalIntermediate</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#sbt.compiler.Eval" title="sbt.compiler.Eval.type">Eval</a>._
      <span class="comment">// TODO - We also encode the source of the setting into the hash to avoid conflicts where the exact SAME setting</span>
      <span class="comment">// is defined in multiple evaluated instances with a backing.  This leads to issues with finding a previous</span>
      <span class="comment">// value on the classpath when compiling.</span>
      <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval.evalCommon.hash">hash</a> = <a href="../Hash.scala.html#sbt.Hash" title="sbt.Hash.type">Hash</a>.<a href="../Hash.scala.html#sbt.Hash.toHex(f717a17611)" title="(bytes: Array[Byte])String">toHex</a><span class="delimiter">(</span><a href="../Hash.scala.html#sbt.Hash.apply(31cdad99de)" title="(as: Array[Byte])Array[Byte]">Hash</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(70a716c2b0)" title="(b: Seq[Array[Byte]])Array[Byte]">bytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.stringSeqBytes" title="(s: Seq[String])Array[Byte]">stringSeqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.content" title="Seq[String]">content</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$16" title="(x: Array[Byte])List[Array[Byte]]">::</a> <a href="#sbt.compiler.Eval.optBytes" title="(o: Option[java.io.File])(f: java.io.File =&gt; Array[Byte])Array[Byte]">optBytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.backing" title="Option[java.io.File]">backing</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.fileExistsBytes" title="(f: java.io.File)Array[Byte]">fileExistsBytes</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$15" title="(x: Array[Byte])List[Array[Byte]]">::</a> <a href="#sbt.compiler.Eval.stringSeqBytes" title="(s: Seq[String])Array[Byte]">stringSeqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.options" title="=&gt; Seq[String]">options</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$14" title="(x: Array[Byte])List[Array[Byte]]">::</a>
        <a href="#sbt.compiler.Eval.seqBytes" title="(s: Seq[java.io.File])(f: java.io.File =&gt; Array[Byte])Array[Byte]">seqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.classpath" title="Seq[java.io.File]">classpath</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.fileModifiedBytes" title="(f: java.io.File)Array[Byte]">fileModifiedBytes</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$13" title="(x: Array[Byte])List[Array[Byte]]">::</a> <a href="#sbt.compiler.Eval.stringSeqBytes" title="(s: Seq[String])Array[Byte]">stringSeqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.imports" title="sbt.compiler.EvalImports">imports</a>.<a href="#sbt.compiler;EvalImports.strings" title="=&gt; Seq[(String, Int)]">strings</a>.<span title="(f: ((String, Int)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.hash.x$12.$anonfun.x$9" title="(String, Int)">_</a>.<span title="=&gt; String">_1</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$12" title="(x: Array[Byte])List[Array[Byte]]">::</a> <a href="#sbt.compiler.Eval.optBytes" title="(o: Option[String])(f: String =&gt; Array[Byte])Array[Byte]">optBytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.tpeName" title="Option[String]">tpeName</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(36b13669ca)" title="(s: String)Array[Byte]">bytes</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$11" title="(x: Array[Byte])List[Array[Byte]]">::</a>
        <a href="#sbt.compiler.Eval.bytes(36b13669ca)" title="(s: String)Array[Byte]">bytes</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.extraHash" title="=&gt; String">extraHash</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.evalCommon.hash.x$10" title="(x: Array[Byte])List[Array[Byte]]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval.evalCommon.moduleName">moduleName</a> = <a href="#sbt.compiler;Eval.makeModuleName" title="(hash: String)String">makeModuleName</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.hash" title="String">hash</a><span class="delimiter">)</span>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.evalCommon.unit">unit</a> = <span class="delimiter">{</span>
        <a href="#sbt.compiler;Eval.reporter" title="=&gt; scala.tools.nsc.reporters.Reporter">reporter</a>.<span title="()Unit">reset</span>
        <a href="#sbt.compiler;Eval.evalCommon.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.makeUnit" title="=&gt; Eval.this.global.CompilationUnit">makeUnit</a>
      <span class="delimiter">}</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Eval.this.global.Run" id="sbt.compiler;Eval.evalCommon.run">run</a> = <a href="#sbt.compiler;Eval.evalCommon.run;$anon" title="Eval.this.global.Run" class="keyword">new</a> <a href="#sbt.compiler;Eval.global" title="anonymous class $anon extends Eval.this.global.Run" id="sbt.compiler;Eval.evalCommon.run;$anon">Run</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Iterator[Eval.this.global.CompilationUnit]" id="sbt.compiler;Eval.evalCommon.run;$anon.units">units</a> = <span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.unit" title="=&gt; Eval.this.global.CompilationUnit">unit</a> <a href="#sbt.compiler;Eval.evalCommon.run;$anon.units.x$17" title="(x: Eval.this.global.CompilationUnit)List[Eval.this.global.CompilationUnit]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>.<span title="=&gt; Iterator[Eval.this.global.CompilationUnit]">iterator</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="()Unit" id="sbt.compiler;Eval.evalCommon.unlinkAll">unlinkAll</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Eval.this.global.Symbol" id="sbt.compiler;Eval.evalCommon.unlinkAll.$anonfun.sym">sym</a>, _<span class="delimiter">)</span> &lt;- <a href="#sbt.compiler;Eval.evalCommon.run" title="=&gt; Eval.this.global.Run">run</a>.<a href="#sbt.compiler;Eval.evalCommon.unlinkAll.$anonfun.check$ifrefutable$1" title="(f: ((Eval.this.global.Symbol, scala.tools.nsc.io.AbstractFile)) =&gt; Unit)Unit">symSource</a><span class="delimiter">)</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.unlink" title="=&gt; Boolean">unlink</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.unlink" title="(sym: Eval.this.global.Symbol)Unit">unlink</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.unlinkAll.$anonfun.sym" title="Eval.this.global.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.compiler;Eval.toUnlinkLater" title="List[Eval.this.global.Symbol]">toUnlinkLater</a> <span title="(x: Eval.this.global.Symbol)List[Eval.this.global.Symbol]">::=</span> <a href="#sbt.compiler;Eval.evalCommon.unlinkAll.$anonfun.sym" title="Eval.this.global.Symbol">sym</a>

      <span class="keyword">val</span> <span title="(T, ClassLoader =&gt; ClassLoader)" class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.x$19" title="T" id="sbt.compiler;Eval.evalCommon.extra">extra</a>, <a href="#sbt.compiler;Eval.evalCommon.x$19" title="ClassLoader =&gt; ClassLoader" id="sbt.compiler;Eval.evalCommon.loader">loader</a><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.backing" title="Option[java.io.File]">backing</a> <span title="(T, ClassLoader =&gt; ClassLoader)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.evalCommon.x$19.back">back</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.compiler;Eval.classExists" title="(dir: java.io.File, name: String)Boolean">classExists</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.x$19.back" title="java.io.File">back</a>, <a href="#sbt.compiler;Eval.evalCommon.moduleName" title="String">moduleName</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <span title="ClassLoader =&gt; java.net.URLClassLoader">loader</span> = <span class="delimiter">(</span>parent: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span> =&gt; <span title="java.net.URLClassLoader" class="keyword">new</span> <span title="java.net.URLClassLoader">URLClassLoader</span><span class="delimiter">(</span><span title="(xs: java.net.URL*)(implicit evidence$2: scala.reflect.ClassTag[java.net.URL])Array[java.net.URL]">Array</span><span title="()scala.reflect.ClassTag[java.net.URL]" class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.x$19.back" title="java.io.File">back</a>.<span title="()java.net.URI">toURI</span>.<span title="()java.net.URL">toURL</span><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.evalCommon.x$19.loader.$anonfun.parent" title="ClassLoader">parent</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <span title="T">extra</span> = <a href="#sbt.compiler;Eval.evalCommon.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.read" title="(file: java.io.File)T">read</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.cacheFile" title="(base: java.io.File, moduleName: String)java.io.File">cacheFile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.x$19.back" title="java.io.File">back</a>, <a href="#sbt.compiler;Eval.evalCommon.moduleName" title="String">moduleName</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="(_1: T, _2: ClassLoader =&gt; java.net.URLClassLoader)(T, ClassLoader =&gt; java.net.URLClassLoader)" class="delimiter">(</span><span title="T">extra</span>, <span title="ClassLoader =&gt; java.net.URLClassLoader">loader</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt.compiler;Eval.compileAndLoad" title="(run: Eval.this.global.Run, unit: Eval.this.global.CompilationUnit, imports: sbt.compiler.EvalImports, backing: Option[java.io.File], moduleName: String, ev: Eval.this.EvalType[T])(T, ClassLoader =&gt; ClassLoader)">compileAndLoad</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.run" title="=&gt; Eval.this.global.Run">run</a>, <a href="#sbt.compiler;Eval.evalCommon.unit" title="=&gt; Eval.this.global.CompilationUnit">unit</a>, <a href="#sbt.compiler;Eval.evalCommon.imports" title="sbt.compiler.EvalImports">imports</a>, <a href="#sbt.compiler;Eval.backing" title="Option[java.io.File]">backing</a>, <a href="#sbt.compiler;Eval.evalCommon.moduleName" title="String">moduleName</a>, <a href="#sbt.compiler;Eval.evalCommon.ev" title="Eval.this.EvalType[T]">ev</a><span class="delimiter">)</span> <span class="delimiter">}</span>
          <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#sbt.compiler;Eval.evalCommon.unlinkAll" title="()Unit">unlinkAll</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="Seq[java.io.File]" id="sbt.compiler;Eval.evalCommon.generatedFiles">generatedFiles</a> = <a href="#sbt.compiler;Eval.getGeneratedFiles" title="(backing: Option[java.io.File], moduleName: String)Seq[java.io.File]">getGeneratedFiles</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.backing" title="Option[java.io.File]">backing</a>, <a href="#sbt.compiler;Eval.evalCommon.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
      <span title="Eval.this.EvalIntermediate[T]" class="keyword">new</span> <a href="#sbt.compiler;Eval;EvalIntermediate" title="Eval.this.EvalIntermediate[T]">EvalIntermediate</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.evalCommon.extra" title="T">extra</a>, <a href="#sbt.compiler;Eval.evalCommon.loader" title="ClassLoader =&gt; ClassLoader">loader</a>, <a href="#sbt.compiler;Eval.evalCommon.generatedFiles" title="Seq[java.io.File]">generatedFiles</a>, <a href="#sbt.compiler;Eval.evalCommon.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="comment">// location of the cached type or definition information</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(base: java.io.File, moduleName: String)java.io.File" id="sbt.compiler;Eval.cacheFile">cacheFile</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.cacheFile.base">base</a>: <span title="java.io.File">File</span>, <a title="String" id="sbt.compiler;Eval.cacheFile.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="java.io.File">File</span> = <span title="(x$1: java.io.File, x$2: String)java.io.File" class="keyword">new</span> <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.cacheFile.base" title="java.io.File">base</a>, <a href="#sbt.compiler;Eval.cacheFile.moduleName" title="String">moduleName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.cache&quot;)" class="string">&quot;.cache&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](run: Eval.this.global.Run, unit: Eval.this.global.CompilationUnit, imports: sbt.compiler.EvalImports, backing: Option[java.io.File], moduleName: String, ev: Eval.this.EvalType[T])(T, ClassLoader =&gt; ClassLoader)" id="sbt.compiler;Eval.compileAndLoad">compileAndLoad</a><span class="delimiter">[</span><a title="" id="sbt.compiler;Eval.compileAndLoad;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Eval.this.global.Run" id="sbt.compiler;Eval.compileAndLoad.run">run</a>: <span title="Eval.this.global.Run">Run</span>, <a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.compileAndLoad.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span>, <a title="sbt.compiler.EvalImports" id="sbt.compiler;Eval.compileAndLoad.imports">imports</a>: <a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a>, <a title="Option[java.io.File]" id="sbt.compiler;Eval.compileAndLoad.backing">backing</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval.compileAndLoad.moduleName">moduleName</a>: <span title="String">String</span>, <a title="Eval.this.EvalType[T]" id="sbt.compiler;Eval.compileAndLoad.ev">ev</a>: <a href="#sbt.compiler;Eval;EvalType" title="Eval.this.EvalType[T]">EvalType</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(T, ClassLoader =&gt; ClassLoader)" class="delimiter">(</span>T, ClassLoader =&gt; ClassLoader<span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <a href="#sbt.compiler;Eval.global" title="=&gt; Eval.this.EvalGlobal">global</a>.<a href="#sbt.compiler;Eval;EvalGlobal.curRun_=(5aa6db0198)" title="(x$1: Eval.this.global.Run)Unit">curRun</a> = <a href="#sbt.compiler;Eval.compileAndLoad.run" title="Eval.this.global.Run">run</a>
      <a href="#sbt.compiler;Eval.compileAndLoad.run" title="Eval.this.global.Run">run</a>.<span title="(x$1: Eval.this.global.CompilationUnit)Unit">currentUnit</span> = <a href="#sbt.compiler;Eval.compileAndLoad.unit" title="Eval.this.global.CompilationUnit">unit</a>
      <span class="keyword">val</span> <a title="scala.tools.nsc.io.AbstractFile" id="sbt.compiler;Eval.compileAndLoad.dir">dir</a> = <a href="#sbt.compiler;Eval.outputDirectory" title="(backing: Option[java.io.File])scala.tools.nsc.io.AbstractFile">outputDirectory</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.backing" title="Option[java.io.File]">backing</a><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.settings" title="=&gt; scala.tools.nsc.Settings">settings</a>.<span title="=&gt; Eval.this.settings.OutputDirs">outputDirs</span> <span title="(dir: scala.tools.nsc.io.AbstractFile)Unit">setSingleOutput</span> <a href="#sbt.compiler;Eval.compileAndLoad.dir" title="scala.tools.nsc.io.AbstractFile">dir</a>

      <span class="keyword">val</span> <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.compileAndLoad.importTrees">importTrees</a> = <a href="#sbt.compiler;Eval.parseImports" title="(imports: sbt.compiler.EvalImports)Seq[Eval.this.global.Tree]">parseImports</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.imports" title="sbt.compiler.EvalImports">imports</a><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.compileAndLoad.unit" title="Eval.this.global.CompilationUnit">unit</a>.<span title="(x$1: Eval.this.global.Tree)Unit">body</span> = <a href="#sbt.compiler;Eval.compileAndLoad.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.unitBody" title="(unit: Eval.this.global.CompilationUnit, importTrees: Seq[Eval.this.global.Tree], moduleName: String)Eval.this.global.Tree">unitBody</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.unit" title="Eval.this.global.CompilationUnit">unit</a>, <a href="#sbt.compiler;Eval.compileAndLoad.importTrees" title="Seq[Eval.this.global.Tree]">importTrees</a>, <a href="#sbt.compiler;Eval.compileAndLoad.moduleName" title="String">moduleName</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(phase: tools.nsc.Phase)Unit" id="sbt.compiler;Eval.compileAndLoad.compile">compile</a><span class="delimiter">(</span><a title="tools.nsc.Phase" id="sbt.compiler;Eval.compileAndLoad.compile.phase">phase</a>: <span title="tools.nsc.Phase">Phase</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
        <span class="delimiter">{</span>
          <a href="#sbt.compiler;Eval.global" title="(x$1: scala.tools.nsc.Phase)Unit">globalPhase</a> = <a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a>.<span title="=&gt; scala.reflect.internal.Phase">next</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.compiler;Eval.reporter" title="=&gt; scala.tools.nsc.reporters.Reporter">reporter</a>.<span title="=&gt; Boolean">hasErrors</span><span class="delimiter">)</span>
            <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#sbt.compiler;Eval.global" title="(ph: scala.reflect.internal.Phase)(op: =&gt; Unit)Unit">atPhase</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a>.<span title="()Unit">run</span> <span class="delimiter">}</span>
            <a href="#sbt.compiler;Eval.compileAndLoad.compile" title="(phase: tools.nsc.Phase)Unit">compile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.compile.phase" title="tools.nsc.Phase">phase</a>.<span title="=&gt; scala.reflect.internal.Phase">next</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <a href="#sbt.compiler;Eval.compileAndLoad.compile" title="(phase: tools.nsc.Phase)Unit">compile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.run" title="Eval.this.global.Run">run</a>.<span title="=&gt; scala.tools.nsc.Phase">namerPhase</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.checkError" title="(label: String)Unit">checkError</a><span class="delimiter">(</span><span title="String(&quot;Type error in expression&quot;)" class="string">&quot;Type error in expression&quot;</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="T" id="sbt.compiler;Eval.compileAndLoad.extra">extra</a> = <a href="#sbt.compiler;Eval.compileAndLoad.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.extra" title="(run: Eval.this.global.Run, unit: Eval.this.global.CompilationUnit)T">extra</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.run" title="Eval.this.global.Run">run</a>, <a href="#sbt.compiler;Eval.compileAndLoad.unit" title="Eval.this.global.CompilationUnit">unit</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.compileAndLoad.$anonfun.f">f</a> &lt;- <a href="#sbt.compiler;Eval.compileAndLoad.backing" title="(f: java.io.File =&gt; Unit)Unit">backing</a><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.compileAndLoad.ev" title="Eval.this.EvalType[T]">ev</a>.<a href="#sbt.compiler;Eval;EvalType.write" title="(value: T, file: java.io.File)Unit">write</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.extra" title="T">extra</a>, <a href="#sbt.compiler;Eval.cacheFile" title="(base: java.io.File, moduleName: String)java.io.File">cacheFile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.$anonfun.f" title="java.io.File">f</a>, <a href="#sbt.compiler;Eval.compileAndLoad.moduleName" title="String">moduleName</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ClassLoader =&gt; scala.tools.nsc.interpreter.AbstractFileClassLoader" id="sbt.compiler;Eval.compileAndLoad.loader">loader</a> = <span class="delimiter">(</span>parent: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span> =&gt; <span title="scala.tools.nsc.interpreter.AbstractFileClassLoader" class="keyword">new</span> <span title="scala.tools.nsc.interpreter.AbstractFileClassLoader">AbstractFileClassLoader</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.dir" title="scala.tools.nsc.io.AbstractFile">dir</a>, <a href="#sbt.compiler;Eval.compileAndLoad.loader.$anonfun.parent" title="ClassLoader">parent</a><span class="delimiter">)</span>
      <span title="(_1: T, _2: ClassLoader =&gt; scala.tools.nsc.interpreter.AbstractFileClassLoader)(T, ClassLoader =&gt; scala.tools.nsc.interpreter.AbstractFileClassLoader)" class="delimiter">(</span><a href="#sbt.compiler;Eval.compileAndLoad.extra" title="T">extra</a>, <a href="#sbt.compiler;Eval.compileAndLoad.loader" title="ClassLoader =&gt; scala.tools.nsc.interpreter.AbstractFileClassLoader">loader</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tpeName: Option[String])Eval.this.global.Tree" id="sbt.compiler;Eval.expectedType">expectedType</a><span class="delimiter">(</span><a title="Option[String]" id="sbt.compiler;Eval.expectedType.tpeName">tpeName</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span> =
    <a href="#sbt.compiler;Eval.expectedType.tpeName" title="Option[String]">tpeName</a> <span title="Eval.this.global.Tree" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.expectedType.tpe">tpe</a><span class="delimiter">)</span> =&gt; <a href="#sbt.compiler;Eval.parseType" title="(tpe: String)Eval.this.global.Tree">parseType</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.expectedType.tpe" title="String">tpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">None</span>      =&gt; <a href="#sbt.compiler;Eval.global" title="(tp: Eval.this.global.Type)Eval.this.global.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="Eval.this.global.NoType.type">NoType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(backing: Option[java.io.File])scala.tools.nsc.io.AbstractFile" id="sbt.compiler;Eval.outputDirectory">outputDirectory</a><span class="delimiter">(</span><a title="Option[java.io.File]" id="sbt.compiler;Eval.outputDirectory.backing">backing</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.tools.nsc.io.AbstractFile">AbstractFile</span> =
    <a href="#sbt.compiler;Eval.outputDirectory.backing" title="Option[java.io.File]">backing</a> <span title="scala.tools.nsc.io.AbstractFile" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <span title="scala.reflect.io.VirtualDirectory" class="keyword">new</span> <span title="scala.reflect.io.VirtualDirectory">VirtualDirectory</span><span class="delimiter">(</span><span title="String(&quot;&lt;virtual&gt;&quot;)" class="string">&quot;&lt;virtual&gt;&quot;</span>, <span title="None.type">None</span><span class="delimiter">)</span>; <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.outputDirectory.dir">dir</a><span class="delimiter">)</span> =&gt; <span title="scala.reflect.io.PlainFile" class="keyword">new</span> <span title="scala.reflect.io.PlainFile">PlainFile</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.outputDirectory.dir" title="implicit scala.reflect.io.Path.jfile2path : (jfile: java.io.File)scala.reflect.io.Path">dir</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(dir: scala.tools.nsc.io.AbstractFile, moduleName: String)ClassLoader =&gt; Any" id="sbt.compiler;Eval.load">load</a><span class="delimiter">(</span><a title="scala.tools.nsc.io.AbstractFile" id="sbt.compiler;Eval.load.dir">dir</a>: <span title="scala.tools.nsc.io.AbstractFile">AbstractFile</span>, <a title="String" id="sbt.compiler;Eval.load.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: ClassLoader =&gt; Any = <a title="ClassLoader" id="sbt.compiler;Eval.load.$anonfun.parent">parent</a> =&gt; <a href="#sbt.compiler.Eval.getValue" title="[T](objectName: String, loader: ClassLoader)T">getValue</a><span title="(objectName: String, loader: ClassLoader)Any" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.load.moduleName" title="String">moduleName</a>, <span title="scala.tools.nsc.interpreter.AbstractFileClassLoader" class="keyword">new</span> <span title="scala.tools.nsc.interpreter.AbstractFileClassLoader">AbstractFileClassLoader</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.load.dir" title="scala.tools.nsc.io.AbstractFile">dir</a>, <a href="#sbt.compiler;Eval.load.$anonfun.parent" title="ClassLoader">parent</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(dir: java.io.File, moduleName: String)ClassLoader =&gt; Any" id="sbt.compiler;Eval.loadPlain">loadPlain</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.loadPlain.dir">dir</a>: <span title="java.io.File">File</span>, <a title="String" id="sbt.compiler;Eval.loadPlain.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: ClassLoader =&gt; Any = <a title="ClassLoader" id="sbt.compiler;Eval.loadPlain.$anonfun.parent">parent</a> =&gt; <a href="#sbt.compiler.Eval.getValue" title="[T](objectName: String, loader: ClassLoader)T">getValue</a><span title="(objectName: String, loader: ClassLoader)Any" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.loadPlain.moduleName" title="String">moduleName</a>, <span title="java.net.URLClassLoader" class="keyword">new</span> <span title="java.net.URLClassLoader">URLClassLoader</span><span class="delimiter">(</span><span title="(xs: java.net.URL*)(implicit evidence$2: scala.reflect.ClassTag[java.net.URL])Array[java.net.URL]">Array</span><span title="()scala.reflect.ClassTag[java.net.URL]" class="delimiter">(</span><a href="#sbt.compiler;Eval.loadPlain.dir" title="java.io.File">dir</a>.<span title="()java.net.URI">toURI</span>.<span title="()java.net.URL">toURL</span><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.loadPlain.$anonfun.parent" title="ClassLoader">parent</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">//wrap tree in object objectName { def WrapValName = &lt;tree&gt; }</span>
  <span class="keyword">def</span> <a title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser, imports: Seq[Eval.this.global.Tree], tree: Eval.this.global.Tree, tpt: Eval.this.global.Tree, objectName: String)Eval.this.global.Tree" id="sbt.compiler;Eval.augment">augment</a><span class="delimiter">(</span><a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.augment.parser">parser</a>: global.syntaxAnalyzer.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span>, <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.augment.imports">imports</a>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Eval.this.global.Tree" id="sbt.compiler;Eval.augment.tree">tree</a>: <span title="Eval.this.global.Tree">Tree</span>, <a title="Eval.this.global.Tree" id="sbt.compiler;Eval.augment.tpt">tpt</a>: <span title="Eval.this.global.Tree">Tree</span>, <a title="String" id="sbt.compiler;Eval.augment.objectName">objectName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Eval.this.global.DefDef" id="sbt.compiler;Eval.augment.method">method</a> = <a href="#sbt.compiler;Eval.global" title="(mods: Eval.this.global.Modifiers, name: Eval.this.global.Name, tparams: List[Eval.this.global.TypeDef], vparamss: List[List[Eval.this.global.ValDef]], tpt: Eval.this.global.Tree, rhs: Eval.this.global.Tree)Eval.this.global.DefDef">DefDef</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="=&gt; Eval.this.global.Modifiers">NoMods</a>, <a href="#sbt.compiler;Eval.global" title="(s: String)Eval.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;$sbtdef&quot;)">WrapValName</span><span class="delimiter">)</span>, <span title="scala.collection.immutable.Nil.type">Nil</span>, <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.compiler;Eval.augment.tpt" title="Eval.this.global.Tree">tpt</a>, <a href="#sbt.compiler;Eval.augment.tree" title="Eval.this.global.Tree">tree</a><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.syntheticModule" title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser, imports: Seq[Eval.this.global.Tree], definitions: List[Eval.this.global.Tree], objectName: String)Eval.this.global.Tree">syntheticModule</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.augment.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>, <a href="#sbt.compiler;Eval.augment.imports" title="Seq[Eval.this.global.Tree]">imports</a>, <a href="#sbt.compiler;Eval.augment.method" title="Eval.this.global.DefDef">method</a> <a href="#sbt.compiler;Eval.augment.x$20" title="(x: Eval.this.global.DefDef)List[Eval.this.global.DefDef]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.compiler;Eval.augment.objectName" title="String">objectName</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser, imports: Seq[Eval.this.global.Tree], definitions: List[Eval.this.global.Tree], objectName: String)Eval.this.global.Tree" id="sbt.compiler;Eval.syntheticModule">syntheticModule</a><span class="delimiter">(</span><a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.syntheticModule.parser">parser</a>: global.syntaxAnalyzer.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span>, <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.syntheticModule.imports">imports</a>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="List[Eval.this.global.Tree]" id="sbt.compiler;Eval.syntheticModule.definitions">definitions</a>: <span title="List[Eval.this.global.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval.syntheticModule.objectName">objectName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Eval.this.global.TypeName" id="sbt.compiler;Eval.syntheticModule.emptyTypeName">emptyTypeName</a> = <a href="#sbt.compiler;Eval.global" title="Eval.this.global.nme.type">nme</a>.<span title="=&gt; Eval.this.global.nme.NameType">EMPTY</span>.<span title="=&gt; Eval.this.global.TypeName">toTypeName</span>
      <span class="keyword">def</span> <a title="=&gt; Eval.this.global.Ident" id="sbt.compiler;Eval.syntheticModule.emptyPkg">emptyPkg</a> = <a href="#sbt.compiler;Eval.syntheticModule.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="(start: Int, point: Int, end: Int)(t: Eval.this.global.Ident)Eval.this.global.Ident">atPos</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <span title="Int(0)" class="int">0</span>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt.compiler;Eval.global" title="(name: Eval.this.global.Name)Eval.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="Eval.this.global.nme.type">nme</a>.<span title="=&gt; Eval.this.global.nme.NameType">EMPTY_PACKAGE_NAME</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Eval.this.global.DefDef" id="sbt.compiler;Eval.syntheticModule.emptyInit">emptyInit</a> = <a href="#sbt.compiler;Eval.global" title="(mods: Eval.this.global.Modifiers, name: Eval.this.global.Name, tparams: List[Eval.this.global.TypeDef], vparamss: List[List[Eval.this.global.ValDef]], tpt: Eval.this.global.Tree, rhs: Eval.this.global.Tree)Eval.this.global.DefDef">DefDef</a><span class="delimiter">(</span>
        <a href="#sbt.compiler;Eval.global" title="=&gt; Eval.this.global.Modifiers">NoMods</a>,
        <a href="#sbt.compiler;Eval.global" title="Eval.this.global.nme.type">nme</a>.<span title="=&gt; Eval.this.global.nme.NameType">CONSTRUCTOR</span>,
        <span title="scala.collection.immutable.Nil.type">Nil</span>,
        <span title="(xs: scala.collection.immutable.Nil.type*)List[scala.collection.immutable.Nil.type]">List</span><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>,
        <a href="#sbt.compiler;Eval.global" title="()Eval.this.global.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>,
        <a href="#sbt.compiler;Eval.global" title="(stats: List[Eval.this.global.Tree], expr: Eval.this.global.Tree)Eval.this.global.Block">Block</a><span class="delimiter">(</span><span title="(xs: Eval.this.global.Apply*)List[Eval.this.global.Apply]">List</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="(fun: Eval.this.global.Tree, args: List[Eval.this.global.Tree])Eval.this.global.Apply">Apply</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="(qualifier: Eval.this.global.Tree, name: Eval.this.global.Name)Eval.this.global.Select">Select</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="(qual: Eval.this.global.Tree, mix: Eval.this.global.TypeName)Eval.this.global.Super">Super</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="(qual: Eval.this.global.TypeName)Eval.this.global.This">This</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.syntheticModule.emptyTypeName" title="Eval.this.global.TypeName">emptyTypeName</a><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.syntheticModule.emptyTypeName" title="Eval.this.global.TypeName">emptyTypeName</a><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.global" title="Eval.this.global.nme.type">nme</a>.<span title="=&gt; Eval.this.global.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.global" title="(value: Eval.this.global.Constant)Eval.this.global.Literal">Literal</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="(value: Any)Eval.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="=&gt; Eval.this.global.Template" id="sbt.compiler;Eval.syntheticModule.moduleBody">moduleBody</a> = <a href="#sbt.compiler;Eval.global" title="(parents: List[Eval.this.global.Tree], self: Eval.this.global.ValDef, body: List[Eval.this.global.Tree])Eval.this.global.Template">Template</a><span class="delimiter">(</span><span title="(xs: Eval.this.global.gen.global.Select*)List[Eval.this.global.gen.global.Select]">List</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="Eval.this.global.gen.type">gen</a>.<span title="=&gt; Eval.this.global.gen.global.Select">scalaAnyRefConstr</span><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.global" title="Eval.this.global.emptyValDef.type">emptyValDef</a>, <a href="#sbt.compiler;Eval.syntheticModule.emptyInit" title="=&gt; Eval.this.global.DefDef">emptyInit</a> <a href="#sbt.compiler;Eval.syntheticModule.moduleBody.x$21" title="(x: Eval.this.global.Tree)List[Eval.this.global.Tree]">::</a> <a href="#sbt.compiler;Eval.syntheticModule.definitions" title="List[Eval.this.global.Tree]">definitions</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="=&gt; Eval.this.global.ModuleDef" id="sbt.compiler;Eval.syntheticModule.moduleDef">moduleDef</a> = <a href="#sbt.compiler;Eval.global" title="(mods: Eval.this.global.Modifiers, name: Eval.this.global.TermName, impl: Eval.this.global.Template)Eval.this.global.ModuleDef">ModuleDef</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.global" title="=&gt; Eval.this.global.Modifiers">NoMods</a>, <a href="#sbt.compiler;Eval.global" title="(s: String)Eval.this.global.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.syntheticModule.objectName" title="String">objectName</a><span class="delimiter">)</span>, <a href="#sbt.compiler;Eval.syntheticModule.moduleBody" title="=&gt; Eval.this.global.Template">moduleBody</a><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.syntheticModule.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="(start: Int, pkg: Eval.this.global.syntaxAnalyzer.global.Tree, stats: List[Eval.this.global.syntaxAnalyzer.global.Tree])Eval.this.global.syntaxAnalyzer.global.PackageDef">makePackaging</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#sbt.compiler;Eval.syntheticModule.emptyPkg" title="=&gt; Eval.this.global.Ident">emptyPkg</a>, <span class="delimiter">(</span><a href="#sbt.compiler;Eval.syntheticModule.imports" title="Seq[Eval.this.global.Tree]">imports</a> <span title="(elem: Eval.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Eval.this.global.Tree],Eval.this.global.Tree,Seq[Eval.this.global.Tree]])Seq[Eval.this.global.Tree]">:+</span> <a href="#sbt.compiler;Eval.syntheticModule.moduleDef" title="=&gt; Eval.this.global.ModuleDef">moduleDef</a><span class="delimiter">)</span>.<span title="=&gt; List[Eval.this.global.Tree]">toList</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TypeExtractor extends Eval.this.global.Traverser" id="sbt.compiler;Eval;TypeExtractor">TypeExtractor</a> <a href="#sbt.compiler;Eval;TypeExtractor" title="Eval.this.TypeExtractor" class="keyword">extends</a> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.Traverser">Traverser</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="String" id="sbt.compiler;Eval;TypeExtractor.result">result</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">def</span> <a title="(t: Eval.this.global.Tree)String" id="sbt.compiler;Eval;TypeExtractor.getType">getType</a><span class="delimiter">(</span><a title="Eval.this.global.Tree" id="sbt.compiler;Eval;TypeExtractor.getType.t">t</a>: <span title="Eval.this.global.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span> <a href="#sbt.compiler;Eval;TypeExtractor.result" title="String">result</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>; <a href="#sbt.compiler;Eval;TypeExtractor.traverse" title="(tree: Eval.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval;TypeExtractor.getType.t" title="Eval.this.global.Tree">t</a><span class="delimiter">)</span>; <a href="#sbt.compiler;Eval;TypeExtractor.result" title="String">result</a> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Eval.this.global.Tree)Unit" id="sbt.compiler;Eval;TypeExtractor.traverse">traverse</a><span class="delimiter">(</span><a title="Eval.this.global.Tree" id="sbt.compiler;Eval;TypeExtractor.traverse.tree">tree</a>: <span title="Eval.this.global.Tree">Tree</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt.compiler;Eval;TypeExtractor.traverse.tree" title="Eval.this.global.Tree">tree</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Eval.this.global.DefDef" id="sbt.compiler;Eval;TypeExtractor.traverse.d">d</a>: <span title="Eval.this.global.DefDef">DefDef</span> <span class="keyword">if</span> <a href="#sbt.compiler;Eval;TypeExtractor.traverse.d" title="Eval.this.global.DefDef">d</a>.<span title="=&gt; Eval.this.global.Symbol">symbol</span>.<span title="=&gt; String">nameString</span> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;$sbtdef&quot;)">WrapValName</span> =&gt; <a href="#sbt.compiler;Eval;TypeExtractor.result" title="String">result</a> = <a href="#sbt.compiler;Eval;TypeExtractor.traverse.d" title="Eval.this.global.DefDef">d</a>.<span title="=&gt; Eval.this.global.Symbol">symbol</span>.<span title="=&gt; Eval.this.global.Type">tpe</span>.<span title="=&gt; Eval.this.global.Type">finalResultType</span>.<span title="()String">toString</span>
      <span class="keyword">case</span> _ =&gt; <a href="#sbt.compiler;Eval;TypeExtractor" title="Eval.this.TypeExtractor" class="keyword">super</a>.<span title="(tree: Eval.this.global.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;TypeExtractor.traverse.tree" title="Eval.this.global.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/** Tree traverser that obtains the names of vals in a top-level module whose type is a subtype of one of `types`.*/</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ValExtractor extends Eval.this.global.Traverser" id="sbt.compiler;Eval;ValExtractor">ValExtractor</a><a href="#sbt.compiler;Eval;ValExtractor" title="Eval.this.ValExtractor" class="delimiter">(</a><a title="Set[String]" id="sbt.compiler;Eval;ValExtractor.tpes">tpes</a>: <span title="Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.Traverser">Traverser</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[String]" id="sbt.compiler;Eval;ValExtractor.vals">vals</a> = List<span class="delimiter">[</span>String<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(t: Eval.this.global.Tree)List[String]" id="sbt.compiler;Eval;ValExtractor.getVals">getVals</a><span class="delimiter">(</span><a title="Eval.this.global.Tree" id="sbt.compiler;Eval;ValExtractor.getVals.t">t</a>: <span title="Eval.this.global.Tree">Tree</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span> <a href="#sbt.compiler;Eval;ValExtractor.vals" title="List[String]">vals</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>; <a href="#sbt.compiler;Eval;ValExtractor.traverse" title="(tree: Eval.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval;ValExtractor.getVals.t" title="Eval.this.global.Tree">t</a><span class="delimiter">)</span>; <a href="#sbt.compiler;Eval;ValExtractor.vals" title="List[String]">vals</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tpe: Eval.this.global.Type)Boolean" id="sbt.compiler;Eval;ValExtractor.isAcceptableType">isAcceptableType</a><span class="delimiter">(</span><a title="Eval.this.global.Type" id="sbt.compiler;Eval;ValExtractor.isAcceptableType.tpe">tpe</a>: <span title="Eval.this.global.Type">Type</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#sbt.compiler;Eval;ValExtractor.isAcceptableType.tpe" title="Eval.this.global.Type">tpe</a>.<span title="=&gt; List[Eval.this.global.Symbol]">baseClasses</span>.<span title="(p: Eval.this.global.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Eval.this.global.Symbol" id="sbt.compiler;Eval;ValExtractor.isAcceptableType.$anonfun.sym">sym</a> =&gt;
        <a href="#sbt.compiler;Eval;ValExtractor.tpes" title="Set[String]">tpes</a>.<span title="(elem: String)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;ValExtractor.isAcceptableType.$anonfun.sym" title="Eval.this.global.Symbol">sym</a>.<span title="=&gt; String">fullName</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Eval.this.global.Tree)Unit" id="sbt.compiler;Eval;ValExtractor.traverse">traverse</a><span class="delimiter">(</span><a title="Eval.this.global.Tree" id="sbt.compiler;Eval;ValExtractor.traverse.tree">tree</a>: <span title="Eval.this.global.Tree">Tree</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt.compiler;Eval;ValExtractor.traverse.tree" title="Eval.this.global.Tree">tree</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ValDef<span class="delimiter">(</span>_, <a title="Eval.this.global.TermName" id="sbt.compiler;Eval;ValExtractor.traverse.n">n</a>, <a title="Eval.this.global.Tree" id="sbt.compiler;Eval;ValExtractor.traverse.actualTpe">actualTpe</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.compiler;Eval.isTopLevelModule" title="(s: Eval.this.global.Symbol)Boolean">isTopLevelModule</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval;ValExtractor.traverse.tree" title="Eval.this.global.Tree">tree</a>.<span title="=&gt; Eval.this.global.Symbol">symbol</span>.<span title="=&gt; Eval.this.global.Symbol">owner</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.compiler;Eval;ValExtractor.isAcceptableType" title="(tpe: Eval.this.global.Type)Boolean">isAcceptableType</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval;ValExtractor.traverse.actualTpe" title="Eval.this.global.Tree">actualTpe</a>.<span title="=&gt; Eval.this.global.Type">tpe</span><span class="delimiter">)</span> =&gt;
        <a href="#sbt.compiler;Eval;ValExtractor.vals" title="List[String]">vals</a> <span title="(x: String)List[String]">::=</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.nme.type">nme</a>.<span title="(name: Eval.this.global.TermName)Eval.this.global.TermName">localToGetter</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;ValExtractor.traverse.n" title="Eval.this.global.TermName">n</a><span class="delimiter">)</span>.<span title="=&gt; String">encoded</span>
      <span class="keyword">case</span> _ =&gt; <a href="#sbt.compiler;Eval;ValExtractor" title="Eval.this.ValExtractor" class="keyword">super</a>.<span title="(tree: Eval.this.global.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;ValExtractor.traverse.tree" title="Eval.this.global.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">// inlined implemented of Symbol.isTopLevelModule that was removed in e5b050814deb2e7e1d6d05511d3a6cb6b013b549</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(s: Eval.this.global.Symbol)Boolean" id="sbt.compiler;Eval.isTopLevelModule">isTopLevelModule</a><span class="delimiter">(</span><a title="Eval.this.global.Symbol" id="sbt.compiler;Eval.isTopLevelModule.s">s</a>: <span title="Eval.this.global.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#sbt.compiler;Eval.isTopLevelModule.s" title="Eval.this.global.Symbol">s</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span>reflect.internal.Flags.<span title="Long(256L)">MODULE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.compiler;Eval.isTopLevelModule.s" title="Eval.this.global.Symbol">s</a>.<span title="=&gt; Eval.this.global.Symbol">owner</span>.<span title="=&gt; Boolean">isPackageClass</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalIntermediate[T] extends AnyRef" id="sbt.compiler;Eval;EvalIntermediate">EvalIntermediate</a><span class="delimiter">[</span><a title="" id="sbt.compiler;Eval;EvalIntermediate;T">T</a><span class="delimiter">]</span><a href="#sbt.compiler;Eval;EvalIntermediate" title="Eval.this.EvalIntermediate[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="T" id="sbt.compiler;Eval;EvalIntermediate.extra">extra</a>: <a href="#sbt.compiler;Eval;EvalIntermediate;T" title="T">T</a>, <span class="keyword">val</span> <a title="ClassLoader =&gt; ClassLoader" id="sbt.compiler;Eval;EvalIntermediate.loader">loader</a>: ClassLoader =&gt; ClassLoader, <span class="keyword">val</span> <a title="Seq[java.io.File]" id="sbt.compiler;Eval;EvalIntermediate.generated">generated</a>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval;EvalIntermediate.enclosingModule">enclosingModule</a>: <span title="String">String</span><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(dir: java.io.File, name: String)Boolean" id="sbt.compiler;Eval.classExists">classExists</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.classExists.dir">dir</a>: <span title="java.io.File">File</span>, <a title="String" id="sbt.compiler;Eval.classExists.name">name</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">(</span><span title="(x$1: java.io.File, x$2: String)java.io.File" class="keyword">new</span> <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.classExists.dir" title="java.io.File">dir</a>, <a href="#sbt.compiler;Eval.classExists.name" title="String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.class&quot;)" class="string">&quot;.class&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="()Boolean">exists</span>
  <span class="comment">// TODO: use the code from Analyzer</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(backing: Option[java.io.File], moduleName: String)Seq[java.io.File]" id="sbt.compiler;Eval.getGeneratedFiles">getGeneratedFiles</a><span class="delimiter">(</span><a title="Option[java.io.File]" id="sbt.compiler;Eval.getGeneratedFiles.backing">backing</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval.getGeneratedFiles.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span> =
    <a href="#sbt.compiler;Eval.getGeneratedFiles.backing" title="Option[java.io.File]">backing</a> <span title="Seq[java.io.File]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span>      =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.getGeneratedFiles.dir">dir</a><span class="delimiter">)</span> =&gt; <a href="#sbt.compiler;Eval.getGeneratedFiles.dir" title="java.io.File">dir</a> <span title="(xs: Array[java.io.File])scala.collection.mutable.WrappedArray[java.io.File]">listFiles</span> <a href="#sbt.compiler;Eval.moduleFileFilter" title="(moduleName: String)java.io.FilenameFilter">moduleFileFilter</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.getGeneratedFiles.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(backing: Option[java.io.File], moduleName: String)Seq[java.io.File]" id="sbt.compiler;Eval.getClassFiles">getClassFiles</a><span class="delimiter">(</span><a title="Option[java.io.File]" id="sbt.compiler;Eval.getClassFiles.backing">backing</a>: <span title="Option[java.io.File]">Option</span><span class="delimiter">[</span>File<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval.getClassFiles.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Seq[java.io.File]">Seq</span><span class="delimiter">[</span>File<span class="delimiter">]</span> =
    <a href="#sbt.compiler;Eval.getClassFiles.backing" title="Option[java.io.File]">backing</a> <span title="Seq[java.io.File]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span>      =&gt; <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.getClassFiles.dir">dir</a><span class="delimiter">)</span> =&gt; <a href="#sbt.compiler;Eval.getClassFiles.dir" title="java.io.File">dir</a> <span title="(xs: Array[java.io.File])scala.collection.mutable.WrappedArray[java.io.File]">listFiles</span> <a href="#sbt.compiler;Eval.moduleClassFilter" title="(moduleName: String)java.io.FilenameFilter">moduleClassFilter</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.getClassFiles.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(moduleName: String)java.io.FilenameFilter" id="sbt.compiler;Eval.moduleFileFilter">moduleFileFilter</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.moduleFileFilter.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.moduleFileFilter;$anon" title="java.io.FilenameFilter" class="keyword">new</a> <a title="anonymous class $anon extends Object with java.io.FilenameFilter" id="sbt.compiler;Eval.moduleFileFilter;$anon">java</a>.io.<span title="java.io.FilenameFilter">FilenameFilter</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(dir: java.io.File, s: String)Boolean" id="sbt.compiler;Eval.moduleFileFilter;$anon.accept">accept</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.moduleFileFilter;$anon.accept.dir">dir</a>: <span title="java.io.File">File</span>, <a title="String" id="sbt.compiler;Eval.moduleFileFilter;$anon.accept.s">s</a>: <span title="String">String</span><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#sbt.compiler;Eval.moduleFileFilter;$anon.accept.s" title="String">s</a> <span title="(x$1: CharSequence)Boolean">contains</span> <a href="#sbt.compiler;Eval.moduleFileFilter.moduleName" title="String">moduleName</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(moduleName: String)java.io.FilenameFilter" id="sbt.compiler;Eval.moduleClassFilter">moduleClassFilter</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.moduleClassFilter.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.moduleClassFilter;$anon" title="java.io.FilenameFilter" class="keyword">new</a> <a title="anonymous class $anon extends Object with java.io.FilenameFilter" id="sbt.compiler;Eval.moduleClassFilter;$anon">java</a>.io.<span title="java.io.FilenameFilter">FilenameFilter</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(dir: java.io.File, s: String)Boolean" id="sbt.compiler;Eval.moduleClassFilter;$anon.accept">accept</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval.moduleClassFilter;$anon.accept.dir">dir</a>: <span title="java.io.File">File</span>, <a title="String" id="sbt.compiler;Eval.moduleClassFilter;$anon.accept.s">s</a>: <span title="String">String</span><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#sbt.compiler;Eval.moduleClassFilter;$anon.accept.s" title="String">s</a> <span title="(x$1: CharSequence)Boolean">contains</span> <a href="#sbt.compiler;Eval.moduleClassFilter.moduleName" title="String">moduleName</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt.compiler;Eval.moduleClassFilter;$anon.accept.s" title="String">s</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;.class&quot;)" class="string">&quot;.class&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class ParseErrorStrings extends AnyRef" id="sbt.compiler;Eval;ParseErrorStrings">ParseErrorStrings</a><a href="#sbt.compiler;Eval;ParseErrorStrings" title="Eval.this.ParseErrorStrings" class="delimiter">(</a><span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval;ParseErrorStrings.base">base</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval;ParseErrorStrings.extraBlank">extraBlank</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval;ParseErrorStrings.missingBlank">missingBlank</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval;ParseErrorStrings.extraSemi">extraSemi</a>: <span title="String">String</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Eval.this.ParseErrorStrings" id="sbt.compiler;Eval.definitionErrorStrings">definitionErrorStrings</a> = <span title="Eval.this.ParseErrorStrings" class="keyword">new</span> <a href="#sbt.compiler;Eval;ParseErrorStrings" title="Eval.this.ParseErrorStrings">ParseErrorStrings</a><span class="delimiter">(</span>
    base = <span title="String(&quot;Error parsing definition.&quot;)" class="string">&quot;Error parsing definition.&quot;</span>,
    extraBlank = <span title="String(&quot;  Ensure that there are no blank lines within a definition.&quot;)" class="string">&quot;  Ensure that there are no blank lines within a definition.&quot;</span>,
    missingBlank = <span title="String(&quot;  Ensure that definitions are separated by blank lines.&quot;)" class="string">&quot;  Ensure that definitions are separated by blank lines.&quot;</span>,
    extraSemi = <span title="String(&quot;  A trailing semicolon is not permitted for standalone definitions.&quot;)" class="string">&quot;  A trailing semicolon is not permitted for standalone definitions.&quot;</span>
  <span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Eval.this.ParseErrorStrings" id="sbt.compiler;Eval.settingErrorStrings">settingErrorStrings</a> = <span title="Eval.this.ParseErrorStrings" class="keyword">new</span> <a href="#sbt.compiler;Eval;ParseErrorStrings" title="Eval.this.ParseErrorStrings">ParseErrorStrings</a><span class="delimiter">(</span>
    base = <span title="String(&quot;Error parsing expression.&quot;)" class="string">&quot;Error parsing expression.&quot;</span>,
    extraBlank = <span title="String(&quot;  Ensure that there are no blank lines within a setting.&quot;)" class="string">&quot;  Ensure that there are no blank lines within a setting.&quot;</span>,
    missingBlank = <span title="String(&quot;  Ensure that settings are separated by blank lines.&quot;)" class="string">&quot;  Ensure that settings are separated by blank lines.&quot;</span>,
    extraSemi = <span title="String(&quot;  Note that settings are expressions and do not end with semicolons.  (Semicolons are fine within {} blocks, however.)&quot;)" class="string">&quot;  Note that settings are expressions and do not end with semicolons.  (Semicolons are fine within {} blocks, however.)&quot;</span>
  <span class="delimiter">)</span>

  <span class="comment">/**
   * Parses the provided compilation `unit` according to `f` and then performs checks on the final parser state
   * to catch errors that are common when the content is embedded in a blank-line-delimited format.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](unit: Eval.this.global.CompilationUnit, errors: Eval.this.ParseErrorStrings, f: Eval.this.global.syntaxAnalyzer.UnitParser =&gt; T)(Eval.this.global.syntaxAnalyzer.UnitParser, T)" id="sbt.compiler;Eval.parse">parse</a><span class="delimiter">[</span><a title="" id="sbt.compiler;Eval.parse;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.parse.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span>, <a title="Eval.this.ParseErrorStrings" id="sbt.compiler;Eval.parse.errors">errors</a>: <a href="#sbt.compiler;Eval;ParseErrorStrings" title="Eval.this.ParseErrorStrings">ParseErrorStrings</a>, <a title="Eval.this.global.syntaxAnalyzer.UnitParser =&gt; T" id="sbt.compiler;Eval.parse.f">f</a>: syntaxAnalyzer.UnitParser =&gt; T<span class="delimiter">)</span>: <span title="(Eval.this.global.syntaxAnalyzer.UnitParser, T)" class="delimiter">(</span>syntaxAnalyzer.UnitParser, T<span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.parse.parser">parser</a> = <span title="(unit: Eval.this.global.syntaxAnalyzer.global.CompilationUnit)Eval.this.global.syntaxAnalyzer.UnitParser" class="keyword">new</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.syntaxAnalyzer.type">syntaxAnalyzer</a>.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parse.unit" title="Eval.this.global.CompilationUnit">unit</a><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="T" id="sbt.compiler;Eval.parse.tree">tree</a> = <a href="#sbt.compiler;Eval.parse.f" title="(v1: Eval.this.global.syntaxAnalyzer.UnitParser)T">f</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parse.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval.parse.extra">extra</a> = <a href="#sbt.compiler;Eval.parse.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="=&gt; Eval.this.global.syntaxAnalyzer.SourceFileScanner">in</span>.<span title="=&gt; Int">token</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Int(0)">EOF</span> =&gt; <a href="#sbt.compiler;Eval.parse.errors" title="Eval.this.ParseErrorStrings">errors</a>.<a href="#sbt.compiler;Eval;ParseErrorStrings.extraBlank" title="=&gt; String">extraBlank</a>
        <span class="keyword">case</span> _   =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="delimiter">}</span>
      <a href="#sbt.compiler;Eval.checkError" title="(label: String)Unit">checkError</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parse.errors" title="Eval.this.ParseErrorStrings">errors</a>.<a href="#sbt.compiler;Eval;ParseErrorStrings.base" title="=&gt; String">base</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.compiler;Eval.parse.extra" title="String">extra</a><span class="delimiter">)</span>

      <a href="#sbt.compiler;Eval.parse.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="(token: Int)Int">accept</span><span class="delimiter">(</span><span title="Int(0)">EOF</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="sbt.compiler;Eval.parse.extra2">extra2</a> = <a href="#sbt.compiler;Eval.parse.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="=&gt; Eval.this.global.syntaxAnalyzer.SourceFileScanner">in</span>.<span title="=&gt; Int">token</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Int(71)">SEMI</span>               =&gt; <a href="#sbt.compiler;Eval.parse.errors" title="Eval.this.ParseErrorStrings">errors</a>.<a href="#sbt.compiler;Eval;ParseErrorStrings.extraSemi" title="=&gt; String">extraSemi</a>
        <span class="keyword">case</span> <span title="Int(78)">NEWLINE</span> | <span title="Int(79)">NEWLINES</span> =&gt; <a href="#sbt.compiler;Eval.parse.errors" title="Eval.this.ParseErrorStrings">errors</a>.<a href="#sbt.compiler;Eval;ParseErrorStrings.missingBlank" title="=&gt; String">missingBlank</a>
        <span class="keyword">case</span> _                  =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="delimiter">}</span>
      <a href="#sbt.compiler;Eval.checkError" title="(label: String)Unit">checkError</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parse.errors" title="Eval.this.ParseErrorStrings">errors</a>.<a href="#sbt.compiler;Eval;ParseErrorStrings.base" title="=&gt; String">base</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.compiler;Eval.parse.extra2" title="String">extra2</a><span class="delimiter">)</span>

      <span title="(_1: Eval.this.global.syntaxAnalyzer.UnitParser, _2: T)(Eval.this.global.syntaxAnalyzer.UnitParser, T)" class="delimiter">(</span><a href="#sbt.compiler;Eval.parse.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>, <a href="#sbt.compiler;Eval.parse.tree" title="T">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tpe: String)Eval.this.global.Tree" id="sbt.compiler;Eval.parseType">parseType</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.parseType.tpe">tpe</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.parseType.tpeParser">tpeParser</a> = <span title="(unit: Eval.this.global.syntaxAnalyzer.global.CompilationUnit)Eval.this.global.syntaxAnalyzer.UnitParser" class="keyword">new</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.syntaxAnalyzer.type">syntaxAnalyzer</a>.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkUnit" title="(srcName: String, firstLine: Int, s: String)Eval.this.global.CompilationUnit">mkUnit</a><span class="delimiter">(</span><span title="String(&quot;&lt;expected-type&gt;&quot;)" class="string">&quot;&lt;expected-type&gt;&quot;</span>, <a href="#sbt.compiler;Eval.DefaultStartLine" title="=&gt; Int">DefaultStartLine</a>, <a href="#sbt.compiler;Eval.parseType.tpe" title="String">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Eval.this.global.Tree" id="sbt.compiler;Eval.parseType.tpt0">tpt0</a>: <span title="Eval.this.global.Tree">Tree</span> = <a href="#sbt.compiler;Eval.parseType.tpeParser" title="Eval.this.global.syntaxAnalyzer.UnitParser">tpeParser</a>.<span title="()Eval.this.global.syntaxAnalyzer.global.Tree">typ</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.parseType.tpeParser" title="Eval.this.global.syntaxAnalyzer.UnitParser">tpeParser</a>.<span title="(token: Int)Int">accept</span><span class="delimiter">(</span><span title="Int(0)">EOF</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.checkError" title="(label: String)Unit">checkError</a><span class="delimiter">(</span><span title="String(&quot;Error parsing expression type.&quot;)" class="string">&quot;Error parsing expression type.&quot;</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.parseType.tpt0" title="Eval.this.global.Tree">tpt0</a>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(imports: sbt.compiler.EvalImports)Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.parseImports">parseImports</a><span class="delimiter">(</span><a title="sbt.compiler.EvalImports" id="sbt.compiler;Eval.parseImports.imports">imports</a>: <a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a><span class="delimiter">)</span>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
    <a href="#sbt.compiler;Eval.parseImports.imports" title="sbt.compiler.EvalImports">imports</a>.<a href="#sbt.compiler;EvalImports.strings" title="=&gt; Seq[(String, Int)]">strings</a> <span title="(f: ((String, Int)) =&gt; scala.collection.GenTraversableOnce[Eval.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],Eval.this.global.Tree,Seq[Eval.this.global.Tree]])Seq[Eval.this.global.Tree]">flatMap</span> <a href="#sbt.compiler;Eval.parseImports.$anonfun.x0$1" title="Seq[Eval.this.global.Tree]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.parseImports.$anonfun.s">s</a>, <a title="Int" id="sbt.compiler;Eval.parseImports.$anonfun.line">line</a><span class="delimiter">)</span> =&gt; <a href="#sbt.compiler;Eval.parseImport" title="(importUnit: Eval.this.global.CompilationUnit)Seq[Eval.this.global.Tree]">parseImport</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkUnit" title="(srcName: String, firstLine: Int, s: String)Eval.this.global.CompilationUnit">mkUnit</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parseImports.imports" title="sbt.compiler.EvalImports">imports</a>.<a href="#sbt.compiler;EvalImports.srcName" title="=&gt; String">srcName</a>, <a href="#sbt.compiler;Eval.parseImports.$anonfun.line" title="Int">line</a>, <a href="#sbt.compiler;Eval.parseImports.$anonfun.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(importUnit: Eval.this.global.CompilationUnit)Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.parseImport">parseImport</a><span class="delimiter">(</span><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.parseImport.importUnit">importUnit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span><span class="delimiter">)</span>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.parseImport.parser">parser</a> = <span title="(unit: Eval.this.global.syntaxAnalyzer.global.CompilationUnit)Eval.this.global.syntaxAnalyzer.UnitParser" class="keyword">new</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.syntaxAnalyzer.type">syntaxAnalyzer</a>.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parseImport.importUnit" title="Eval.this.global.CompilationUnit">importUnit</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.parseImport.trees">trees</a>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <a href="#sbt.compiler;Eval.parseImport.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="()List[Eval.this.global.syntaxAnalyzer.global.Tree]">importClause</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.parseImport.parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="(token: Int)Int">accept</span><span class="delimiter">(</span><span title="Int(0)">EOF</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.checkError" title="(label: String)Unit">checkError</a><span class="delimiter">(</span><span title="String(&quot;Error parsing imports for expression.&quot;)" class="string">&quot;Error parsing imports for expression.&quot;</span><span class="delimiter">)</span>
      <a href="#sbt.compiler;Eval.parseImport.trees" title="Seq[Eval.this.global.Tree]">trees</a>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(du: Eval.this.global.CompilationUnit)Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.parseDefinitions(051565c453)">parseDefinitions</a><span class="delimiter">(</span><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.parseDefinitions(051565c453).du">du</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span><span class="delimiter">)</span>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
    <a href="#sbt.compiler;Eval.parse" title="(unit: Eval.this.global.CompilationUnit, errors: Eval.this.ParseErrorStrings, f: Eval.this.global.syntaxAnalyzer.UnitParser =&gt; Seq[Eval.this.global.Tree])(Eval.this.global.syntaxAnalyzer.UnitParser, Seq[Eval.this.global.Tree])">parse</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.parseDefinitions(051565c453).du" title="Eval.this.global.CompilationUnit">du</a>, <a href="#sbt.compiler;Eval.definitionErrorStrings" title="=&gt; Eval.this.ParseErrorStrings">definitionErrorStrings</a>, <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80)" title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser)Seq[Eval.this.global.Tree]">parseDefinitions</a><span class="delimiter">)</span>.<span title="=&gt; Seq[Eval.this.global.Tree]">_2</span>

  <span class="comment">/** Parses one or more definitions (defs, vals, lazy vals, classes, traits, modules). */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(parser: Eval.this.global.syntaxAnalyzer.UnitParser)Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval.parseDefinitions(8f8a94dd80)">parseDefinitions</a><span class="delimiter">(</span><a title="Eval.this.global.syntaxAnalyzer.UnitParser" id="sbt.compiler;Eval.parseDefinitions(8f8a94dd80).parser">parser</a>: syntaxAnalyzer.<span title="Eval.this.global.syntaxAnalyzer.UnitParser">UnitParser</span><span class="delimiter">)</span>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Eval.this.global.syntaxAnalyzer.global.Tree]" id="sbt.compiler;Eval.parseDefinitions(8f8a94dd80).defs">defs</a> = <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="=&gt; List[Eval.this.global.syntaxAnalyzer.global.Tree]">nonLocalDefOrDcl</span>
      <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="()Unit">acceptStatSepOpt</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="=&gt; Boolean">isStatSeqEnd</span><span class="delimiter">)</span> <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).while$1" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="List[Eval.this.global.syntaxAnalyzer.global.Tree]" id="sbt.compiler;Eval.parseDefinitions(8f8a94dd80).next">next</a> = <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="=&gt; List[Eval.this.global.syntaxAnalyzer.global.Tree]">nonLocalDefOrDcl</span>
        <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).defs" title="List[Eval.this.global.syntaxAnalyzer.global.Tree]">defs</a> <span title="(that: scala.collection.GenTraversableOnce[Eval.this.global.syntaxAnalyzer.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[Eval.this.global.syntaxAnalyzer.global.Tree],Eval.this.global.syntaxAnalyzer.global.Tree,List[Eval.this.global.syntaxAnalyzer.global.Tree]])List[Eval.this.global.syntaxAnalyzer.global.Tree]">++=</span> <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).next" title="List[Eval.this.global.syntaxAnalyzer.global.Tree]">next</a>
        <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).parser" title="Eval.this.global.syntaxAnalyzer.UnitParser">parser</a>.<span title="()Unit">acceptStatSepOpt</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#sbt.compiler;Eval.parseDefinitions(8f8a94dd80).defs" title="List[Eval.this.global.syntaxAnalyzer.global.Tree]">defs</a>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait EvalType[T] extends AnyRef" id="sbt.compiler;Eval;EvalType">EvalType</a><span class="delimiter">[</span><a title="" id="sbt.compiler;Eval;EvalType;T">T</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="comment">/** Extracts additional information after the compilation unit is evaluated.*/</span>
    <span class="keyword">def</span> <a title="(run: Eval.this.global.Run, unit: Eval.this.global.CompilationUnit)T" id="sbt.compiler;Eval;EvalType.extra">extra</a><span class="delimiter">(</span><a title="Eval.this.global.Run" id="sbt.compiler;Eval;EvalType.extra.run">run</a>: <span title="Eval.this.global.Run">Run</span>, <a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval;EvalType.extra.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span><span class="delimiter">)</span>: <a href="#sbt.compiler;Eval;EvalType;T" title="T">T</a>

    <span class="comment">/** Deserializes the extra information for unchanged inputs from a cache file.*/</span>
    <span class="keyword">def</span> <a title="(file: java.io.File)T" id="sbt.compiler;Eval;EvalType.read">read</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler;Eval;EvalType.read.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <a href="#sbt.compiler;Eval;EvalType;T" title="T">T</a>

    <span class="comment">/** Serializes the extra information to a cache file, where it can be `read` back if inputs haven't changed.*/</span>
    <span class="keyword">def</span> <a title="(value: T, file: java.io.File)Unit" id="sbt.compiler;Eval;EvalType.write">write</a><span class="delimiter">(</span><a title="T" id="sbt.compiler;Eval;EvalType.write.value">value</a>: <a href="#sbt.compiler;Eval;EvalType;T" title="T">T</a>, <a title="java.io.File" id="sbt.compiler;Eval;EvalType.write.file">file</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>

    <span class="comment">/**
     * Constructs the full compilation unit for this evaluation.
     * This is used for error reporting during compilation.
     * The `unitBody` method actually does the parsing and may parse the Tree from another source.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Eval.this.global.CompilationUnit" id="sbt.compiler;Eval;EvalType.makeUnit">makeUnit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span>

    <span class="comment">/** If true, all top-level symbols from this evaluation will be unlinked.*/</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.compiler;Eval;EvalType.unlink">unlink</a>: <span title="Boolean">Boolean</span>

    <span class="comment">/**
     * Constructs the Tree to be compiled.  The full compilation `unit` from `makeUnit` is provided along with the
     * parsed imports `importTrees` to be used.  `moduleName` should be name of the enclosing module.
     * The Tree doesn't need to be parsed from the contents of `unit`.
     */</span>
    <span class="keyword">def</span> <a title="(unit: Eval.this.global.CompilationUnit, importTrees: Seq[Eval.this.global.Tree], moduleName: String)Eval.this.global.Tree" id="sbt.compiler;Eval;EvalType.unitBody">unitBody</a><span class="delimiter">(</span><a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval;EvalType.unitBody.unit">unit</a>: <span title="Eval.this.global.CompilationUnit">CompilationUnit</span>, <a title="Seq[Eval.this.global.Tree]" id="sbt.compiler;Eval;EvalType.unitBody.importTrees">importTrees</a>: <span title="Seq[Eval.this.global.Tree]">Seq</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="String" id="sbt.compiler;Eval;EvalType.unitBody.moduleName">moduleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Eval.this.global.Tree">Tree</span>

    <span class="comment">/** Extra information to include in the hash'd object name to help avoid collisions. */</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="sbt.compiler;Eval;EvalType.extraHash">extraHash</a>: <span title="String">String</span>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="Int" id="sbt.compiler;Eval.DefaultStartLine">DefaultStartLine</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(hash: String)String" id="sbt.compiler;Eval.makeModuleName">makeModuleName</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.makeModuleName.hash">hash</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span> <span title="(x$1: Any)String">+</span> <a href="../Hash.scala.html#sbt.Hash" title="sbt.Hash.type">Hash</a>.<a href="../Hash.scala.html#sbt.Hash.halve" title="(s: String)String">halve</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.makeModuleName.hash" title="String">hash</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; sbt.compiler.EvalImports" id="sbt.compiler;Eval.noImports">noImports</a> = <span title="sbt.compiler.EvalImports" class="keyword">new</span> <a href="#sbt.compiler;EvalImports" title="sbt.compiler.EvalImports">EvalImports</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(srcName: String, firstLine: Int, s: String)Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.mkUnit">mkUnit</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.mkUnit.srcName">srcName</a>: <span title="String">String</span>, <a title="Int" id="sbt.compiler;Eval.mkUnit.firstLine">firstLine</a>: <span title="Int">Int</span>, <a title="String" id="sbt.compiler;Eval.mkUnit.s">s</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="Eval.this.global.CompilationUnit" class="keyword">new</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.CompilationUnit">CompilationUnit</a><span class="delimiter">(</span><span title="Eval.this.EvalSourceFile" class="keyword">new</span> <a href="#sbt.compiler;Eval;EvalSourceFile" title="Eval.this.EvalSourceFile">EvalSourceFile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkUnit.srcName" title="String">srcName</a>, <a href="#sbt.compiler;Eval.mkUnit.firstLine" title="Int">firstLine</a>, <a href="#sbt.compiler;Eval.mkUnit.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(label: String)Unit" id="sbt.compiler;Eval.checkError">checkError</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.checkError.label">label</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler;Eval.reporter" title="=&gt; scala.tools.nsc.reporters.Reporter">reporter</a>.<span title="=&gt; Boolean">hasErrors</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="sbt.compiler.EvalException" class="keyword">new</span> <a href="#sbt.compiler;EvalException" title="sbt.compiler.EvalException">EvalException</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.checkError.label" title="String">label</a><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class EvalSourceFile extends scala.reflect.internal.util.BatchSourceFile" id="sbt.compiler;Eval;EvalSourceFile">EvalSourceFile</a><a href="#sbt.compiler;Eval;EvalSourceFile" title="Eval.this.EvalSourceFile" class="delimiter">(</a><a title="String" id="sbt.compiler;Eval;EvalSourceFile.name">name</a>: <span title="String">String</span>, <a title="Int" id="sbt.compiler;Eval;EvalSourceFile.startLine">startLine</a>: <span title="Int">Int</span>, <a title="String" id="sbt.compiler;Eval;EvalSourceFile.contents">contents</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="scala.reflect.internal.util.BatchSourceFile">BatchSourceFile</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;EvalSourceFile.name" title="String">name</a>, <a href="#sbt.compiler;Eval;EvalSourceFile.contents" title="implicit scala.LowPriorityImplicits.wrapString : (s: String)scala.collection.immutable.WrappedString">contents</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(line: Int)Int" id="sbt.compiler;Eval;EvalSourceFile.lineToOffset">lineToOffset</a><span class="delimiter">(</span><a title="Int" id="sbt.compiler;Eval;EvalSourceFile.lineToOffset.line">line</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#sbt.compiler;Eval;EvalSourceFile" title="Eval.this.EvalSourceFile" class="keyword">super</a>.<span title="(index: Int)Int">lineToOffset</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;EvalSourceFile.lineToOffset.line" title="Int">line</a> <span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">-</span> <a href="#sbt.compiler;Eval;EvalSourceFile.startLine" title="Int">startLine</a><span class="delimiter">)</span> <span title="(that: Int)Int">max</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(offset: Int)Int" id="sbt.compiler;Eval;EvalSourceFile.offsetToLine">offsetToLine</a><span class="delimiter">(</span><a title="Int" id="sbt.compiler;Eval;EvalSourceFile.offsetToLine.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#sbt.compiler;Eval;EvalSourceFile" title="Eval.this.EvalSourceFile" class="keyword">super</a>.<span title="(offset: Int)Int">offsetToLine</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval;EvalSourceFile.offsetToLine.offset" title="Int">offset</a><span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <a href="#sbt.compiler;Eval;EvalSourceFile.startLine" title="Int">startLine</a>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Constructs a CompilationUnit for each definition, which can be used to independently parse the definition into a Tree.
   * Additionally, a CompilationUnit for the combined definitions is constructed for use by combined compilation after parsing.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(srcName: String, definitions: Seq[(String, Range)])(Eval.this.global.CompilationUnit, Seq[Eval.this.global.CompilationUnit])" id="sbt.compiler;Eval.mkDefsUnit">mkDefsUnit</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.mkDefsUnit.srcName">srcName</a>: <span title="String">String</span>, <a title="Seq[(String, Range)]" id="sbt.compiler;Eval.mkDefsUnit.definitions">definitions</a>: <span title="Seq[(String, Range)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, scala.Range<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Eval.this.global.CompilationUnit, Seq[Eval.this.global.CompilationUnit])" class="delimiter">(</span>CompilationUnit, Seq<span class="delimiter">[</span>CompilationUnit<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(content: String, lineMap: Array[Int])Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.mkDefsUnit.fragmentUnit">fragmentUnit</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.mkDefsUnit.fragmentUnit.content">content</a>: <span title="String">String</span>, <a title="Array[Int]" id="sbt.compiler;Eval.mkDefsUnit.fragmentUnit.lineMap">lineMap</a>: <span title="Array[Int]">Array</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="Eval.this.global.CompilationUnit" class="keyword">new</span> <a href="#sbt.compiler;Eval.global" title="Eval.this.global.CompilationUnit">CompilationUnit</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile" title="(srcName: String, content: String, lineMap: Array[Int])scala.reflect.internal.util.BatchSourceFile">fragmentSourceFile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkDefsUnit.srcName" title="String">srcName</a>, <a href="#sbt.compiler;Eval.mkDefsUnit.fragmentUnit.content" title="String">content</a>, <a href="#sbt.compiler;Eval.mkDefsUnit.fragmentUnit.lineMap" title="Array[Int]">lineMap</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">import</span> collection.mutable.ListBuffer
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Int]" id="sbt.compiler;Eval.mkDefsUnit.lines">lines</a> = <span title="scala.collection.mutable.ListBuffer[Int]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Int]">ListBuffer</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Eval.this.global.CompilationUnit]" id="sbt.compiler;Eval.mkDefsUnit.defs">defs</a> = <span title="scala.collection.mutable.ListBuffer[Eval.this.global.CompilationUnit]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Eval.this.global.CompilationUnit]">ListBuffer</span><span class="delimiter">[</span>CompilationUnit<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="StringBuilder" id="sbt.compiler;Eval.mkDefsUnit.fullContent">fullContent</a> = <span title="StringBuilder" class="keyword">new</span> java.lang.<span title="StringBuilder">StringBuilder</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.mkDefsUnit.$anonfun.defString">defString</a>, <a title="Range" id="sbt.compiler;Eval.mkDefsUnit.$anonfun.range">range</a><span class="delimiter">)</span> &lt;- <a href="#sbt.compiler;Eval.mkDefsUnit.definitions" title="(f: ((String, Range)) =&gt; scala.collection.mutable.ListBuffer[Int])Unit">definitions</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#sbt.compiler;Eval.mkDefsUnit.defs" title="scala.collection.mutable.ListBuffer[Eval.this.global.CompilationUnit]">defs</a> <span title="(x: Eval.this.global.CompilationUnit)defs.type">+=</span> <a href="#sbt.compiler;Eval.mkDefsUnit.fragmentUnit" title="(content: String, lineMap: Array[Int])Eval.this.global.CompilationUnit">fragmentUnit</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.defString" title="String">defString</a>, <a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.range" title="Range">range</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Int])Array[Int]">toArray</span><span class="delimiter">)</span>
        <a href="#sbt.compiler;Eval.mkDefsUnit.fullContent" title="StringBuilder">fullContent</a>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.defString" title="String">defString</a><span class="delimiter">)</span>
        <a href="#sbt.compiler;Eval.mkDefsUnit.lines" title="scala.collection.mutable.ListBuffer[Int]">lines</a> <span title="(xs: scala.collection.TraversableOnce[Int])lines.type">++=</span> <a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.range" title="Range">range</a>
        <a href="#sbt.compiler;Eval.mkDefsUnit.fullContent" title="StringBuilder">fullContent</a>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;\n\n&quot;)" class="string">&quot;\n\n&quot;</span><span class="delimiter">)</span>
        <a href="#sbt.compiler;Eval.mkDefsUnit.lines" title="scala.collection.mutable.ListBuffer[Int]">lines</a> <span title="(xs: scala.collection.TraversableOnce[Int])lines.type">++=</span> <span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.range" title="Range">range</a>.<span title="=&gt; Int">end</span> <a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.x$23" title="(x: Int)List[Int]">::</a> <a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.range" title="Range">range</a>.<span title="=&gt; Int">end</span> <a href="#sbt.compiler;Eval.mkDefsUnit.$anonfun.x$22" title="(x: Int)List[Int]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Eval.this.global.CompilationUnit" id="sbt.compiler;Eval.mkDefsUnit.fullUnit">fullUnit</a> = <a href="#sbt.compiler;Eval.mkDefsUnit.fragmentUnit" title="(content: String, lineMap: Array[Int])Eval.this.global.CompilationUnit">fragmentUnit</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.mkDefsUnit.fullContent" title="StringBuilder">fullContent</a>.<span title="()String">toString</span>, <a href="#sbt.compiler;Eval.mkDefsUnit.lines" title="scala.collection.mutable.ListBuffer[Int]">lines</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Int])Array[Int]">toArray</span><span class="delimiter">)</span>
      <span title="(_1: Eval.this.global.CompilationUnit, _2: Seq[Eval.this.global.CompilationUnit])(Eval.this.global.CompilationUnit, Seq[Eval.this.global.CompilationUnit])" class="delimiter">(</span><a href="#sbt.compiler;Eval.mkDefsUnit.fullUnit" title="Eval.this.global.CompilationUnit">fullUnit</a>, <a href="#sbt.compiler;Eval.mkDefsUnit.defs" title="scala.collection.mutable.ListBuffer[Eval.this.global.CompilationUnit]">defs</a>.<span title="=&gt; Seq[Eval.this.global.CompilationUnit]">toSeq</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Source file that can map the offset in the file to and from line numbers that may discontinuous.
   * The values in `lineMap` must be ordered, but need not be consecutive.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(srcName: String, content: String, lineMap: Array[Int])scala.reflect.internal.util.BatchSourceFile" id="sbt.compiler;Eval.fragmentSourceFile">fragmentSourceFile</a><span class="delimiter">(</span><a title="String" id="sbt.compiler;Eval.fragmentSourceFile.srcName">srcName</a>: <span title="String">String</span>, <a title="String" id="sbt.compiler;Eval.fragmentSourceFile.content">content</a>: <span title="String">String</span>, <a title="Array[Int]" id="sbt.compiler;Eval.fragmentSourceFile.lineMap">lineMap</a>: <span title="Array[Int]">Array</span><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon" title="scala.reflect.internal.util.BatchSourceFile{}" class="keyword">new</a> <a title="anonymous class $anon extends scala.reflect.internal.util.BatchSourceFile" id="sbt.compiler;Eval.fragmentSourceFile;$anon">BatchSourceFile</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile.srcName" title="String">srcName</a>, <a href="#sbt.compiler;Eval.fragmentSourceFile.content" title="implicit scala.LowPriorityImplicits.wrapString : (s: String)scala.collection.immutable.WrappedString">content</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(line: Int)Int" id="sbt.compiler;Eval.fragmentSourceFile;$anon.lineToOffset">lineToOffset</a><span class="delimiter">(</span><a title="Int" id="sbt.compiler;Eval.fragmentSourceFile;$anon.lineToOffset.line">line</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon" title="scala.reflect.internal.util.BatchSourceFile{}" class="keyword">super</a>.<span title="(index: Int)Int">lineToOffset</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile.lineMap" title="implicit scala.Predef.intArrayOps : (xs: Array[Int])scala.collection.mutable.ArrayOps[Int]">lineMap</a>.<span title="(p: Int =&gt; Boolean)Int">indexWhere</span><span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.lineToOffset.$anonfun.x$25" title="Int">_</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.lineToOffset.line" title="Int">line</a><span class="delimiter">)</span> <span title="(that: Int)Int">max</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(offset: Int)Int" id="sbt.compiler;Eval.fragmentSourceFile;$anon.offsetToLine">offsetToLine</a><span class="delimiter">(</span><a title="Int" id="sbt.compiler;Eval.fragmentSourceFile;$anon.offsetToLine.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.index" title="(a: Array[Int], i: Int)Int">index</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile.lineMap" title="Array[Int]">lineMap</a>, <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon" title="scala.reflect.internal.util.BatchSourceFile{}" class="keyword">super</a>.<span title="(offset: Int)Int">offsetToLine</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.offsetToLine.offset" title="Int">offset</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// the SourceFile attribute is populated from this method, so we are required to only return the name</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.compiler;Eval.fragmentSourceFile;$anon.toString">toString</a> = <span title="java.io.File" class="keyword">new</span> <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile.srcName" title="String">srcName</a><span class="delimiter">)</span>.<span title="()String">getName</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(a: Array[Int], i: Int)Int" id="sbt.compiler;Eval.fragmentSourceFile;$anon.index">index</a><span class="delimiter">(</span><a title="Array[Int]" id="sbt.compiler;Eval.fragmentSourceFile;$anon.index.a">a</a>: <span title="Array[Int]">Array</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Int" id="sbt.compiler;Eval.fragmentSourceFile;$anon.index.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.index.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.index.i" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.index.a" title="Array[Int]">a</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.index.a" title="(i: Int)Int">a</a><span class="delimiter">(</span><a href="#sbt.compiler;Eval.fragmentSourceFile;$anon.index.i" title="Int">i</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.compiler.Eval.type" id="sbt.compiler.Eval">Eval</a> <a href="#sbt.compiler.Eval" title="sbt.compiler.Eval.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[T](o: Option[T])(f: T =&gt; Array[Byte])Array[Byte]" id="sbt.compiler.Eval.optBytes">optBytes</a><span class="delimiter">[</span><a title="" id="sbt.compiler.Eval.optBytes;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Option[T]" id="sbt.compiler.Eval.optBytes.o">o</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="T =&gt; Array[Byte]" id="sbt.compiler.Eval.optBytes.f">f</a>: T =&gt; Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <a href="#sbt.compiler.Eval.seqBytes" title="(s: Seq[T])(f: T =&gt; Array[Byte])Array[Byte]">seqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.optBytes.o" title="(xo: Option[T])Iterable[T]">o</a>.<span title="=&gt; Seq[T]">toSeq</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.optBytes.f" title="T =&gt; Array[Byte]">f</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(s: Seq[String])Array[Byte]" id="sbt.compiler.Eval.stringSeqBytes">stringSeqBytes</a><span class="delimiter">(</span><a title="Seq[String]" id="sbt.compiler.Eval.stringSeqBytes.s">s</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <a href="#sbt.compiler.Eval.seqBytes" title="(s: Seq[String])(f: String =&gt; Array[Byte])Array[Byte]">seqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.stringSeqBytes.s" title="Seq[String]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(36b13669ca)" title="(s: String)Array[Byte]">bytes</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](s: Seq[T])(f: T =&gt; Array[Byte])Array[Byte]" id="sbt.compiler.Eval.seqBytes">seqBytes</a><span class="delimiter">[</span><a title="" id="sbt.compiler.Eval.seqBytes;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="sbt.compiler.Eval.seqBytes.s">s</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="T =&gt; Array[Byte]" id="sbt.compiler.Eval.seqBytes.f">f</a>: T =&gt; Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <a href="#sbt.compiler.Eval.bytes(70a716c2b0)" title="(b: Seq[Array[Byte]])Array[Byte]">bytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.seqBytes.s" title="Seq[T]">s</a> <span title="(f: T =&gt; Array[Byte])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],Array[Byte],Seq[Array[Byte]]])Seq[Array[Byte]]">map</span> <a href="#sbt.compiler.Eval.seqBytes.f" title="T =&gt; Array[Byte]">f</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(b: Seq[Array[Byte]])Array[Byte]" id="sbt.compiler.Eval.bytes(70a716c2b0)">bytes</a><span class="delimiter">(</span><a title="Seq[Array[Byte]]" id="sbt.compiler.Eval.bytes(70a716c2b0).b">b</a>: <span title="Seq[Array[Byte]]">Seq</span><span class="delimiter">[</span>Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <a href="#sbt.compiler.Eval.bytes(b3915396fe)" title="(i: Int)Array[Byte]">bytes</a><span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]" class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(70a716c2b0).b" title="Seq[Array[Byte]]">b</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[Byte])(implicit bf: scala.collection.generic.CanBuildFrom[Array[Byte],Byte,Array[Byte]])Array[Byte]">++</span> <a href="#sbt.compiler.Eval.bytes(70a716c2b0).b" title="Seq[Array[Byte]]">b</a>.<a href="#sbt.compiler.Eval.bytes(70a716c2b0).$anonfun.xs" title="(implicit asTraversable: Array[Byte] =&gt; scala.collection.GenTraversableOnce[Byte])Seq[Byte]">flatten</a>.<span title="[B &gt;: Byte](implicit evidence$1: scala.reflect.ClassTag[B])Array[B]">toArray</span><span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]" class="delimiter">[</span><span title="Byte">Byte</span><span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(b: Boolean)Array[Byte]" id="sbt.compiler.Eval.bytes(97ade34fae)">bytes</a><span class="delimiter">(</span><a title="Boolean" id="sbt.compiler.Eval.bytes(97ade34fae).b">b</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <span title="[T](xs: T*)(implicit evidence$2: scala.reflect.ClassTag[T])Array[T]">Array</span><span title="(xs: Byte*)(implicit evidence$2: scala.reflect.ClassTag[Byte])Array[Byte]" class="delimiter">[</span><span title="Byte">Byte</span><span class="delimiter">]</span><span title="()scala.reflect.ClassTag[Byte]" class="delimiter">(</span><span title="Byte" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(97ade34fae).b" title="Boolean">b</a><span class="delimiter">)</span> <span title="Byte(1)" class="int">1</span> <span class="keyword">else</span> <span title="Byte(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(fs: Array[java.io.File])Array[Byte]" id="sbt.compiler.Eval.filesModifiedBytes">filesModifiedBytes</a><span class="delimiter">(</span><a title="Array[java.io.File]" id="sbt.compiler.Eval.filesModifiedBytes.fs">fs</a>: <span title="Array[java.io.File]">Array</span><span class="delimiter">[</span>File<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <span title="Array[Byte]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler.Eval.filesModifiedBytes.fs" title="Array[java.io.File]">fs</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#sbt.compiler.Eval.filesModifiedBytes" title="(fs: Array[java.io.File])Array[Byte]">filesModifiedBytes</a><span class="delimiter">(</span><span title="[T](xs: T*)(implicit evidence$2: scala.reflect.ClassTag[T])Array[T]">Array</span><span title="(xs: java.io.File*)(implicit evidence$2: scala.reflect.ClassTag[java.io.File])Array[java.io.File]" class="delimiter">[</span><span title="java.io.File">File</span><span class="delimiter">]</span><span title="()scala.reflect.ClassTag[java.io.File]" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.compiler.Eval.seqBytes" title="(s: Seq[java.io.File])(f: java.io.File =&gt; Array[Byte])Array[Byte]">seqBytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.filesModifiedBytes.fs" title="(xs: Array[java.io.File])scala.collection.mutable.WrappedArray[java.io.File]">fs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.fileModifiedBytes" title="(f: java.io.File)Array[Byte]">fileModifiedBytes</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(f: java.io.File)Array[Byte]" id="sbt.compiler.Eval.fileModifiedBytes">fileModifiedBytes</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler.Eval.fileModifiedBytes.f">f</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> =
    <span class="delimiter">(</span><span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.compiler.Eval.fileModifiedBytes.f" title="java.io.File">f</a>.<span title="()Boolean">isDirectory</span><span class="delimiter">)</span> <a href="#sbt.compiler.Eval.filesModifiedBytes" title="(fs: Array[java.io.File])Array[Byte]">filesModifiedBytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.fileModifiedBytes.f" title="java.io.File">f</a> <span title="(x$1: java.io.FileFilter)Array[java.io.File]">listFiles</span> <a href="#sbt.compiler.Eval.classDirFilter" title="=&gt; sbt.FileFilter">classDirFilter</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.compiler.Eval.bytes(f833010681)" title="(l: Long)Array[Byte]">bytes</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.fileModifiedBytes.f" title="java.io.File">f</a>.<span title="()Long">lastModified</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[Byte])(implicit bf: scala.collection.generic.CanBuildFrom[Array[Byte],Byte,Array[Byte]])Array[Byte]">++</span>
      <a href="#sbt.compiler.Eval.bytes(36b13669ca)" title="(s: String)Array[Byte]">bytes</a><span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]" class="delimiter">(</span><a href="#sbt.compiler.Eval.fileModifiedBytes.f" title="java.io.File">f</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(f: java.io.File)Array[Byte]" id="sbt.compiler.Eval.fileExistsBytes">fileExistsBytes</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.compiler.Eval.fileExistsBytes.f">f</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> =
    <a href="#sbt.compiler.Eval.bytes(97ade34fae)" title="(b: Boolean)Array[Byte]">bytes</a><span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]" class="delimiter">(</span><a href="#sbt.compiler.Eval.fileExistsBytes.f" title="java.io.File">f</a>.<span title="()Boolean">exists</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[Byte])(implicit bf: scala.collection.generic.CanBuildFrom[Array[Byte],Byte,Array[Byte]])Array[Byte]">++</span>
      <a href="#sbt.compiler.Eval.bytes(36b13669ca)" title="(s: String)Array[Byte]">bytes</a><span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]" class="delimiter">(</span><a href="#sbt.compiler.Eval.fileExistsBytes.f" title="java.io.File">f</a>.<span title="()String">getAbsolutePath</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(s: String)Array[Byte]" id="sbt.compiler.Eval.bytes(36b13669ca)">bytes</a><span class="delimiter">(</span><a title="String" id="sbt.compiler.Eval.bytes(36b13669ca).s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> = <a href="#sbt.compiler.Eval.bytes(36b13669ca).s" title="String">s</a> <span title="(x$1: String)Array[Byte]">getBytes</span> <span title="String(&quot;UTF-8&quot;)" class="string">&quot;UTF-8&quot;</span>
  <span class="keyword">def</span> <a title="(l: Long)Array[Byte]" id="sbt.compiler.Eval.bytes(f833010681)">bytes</a><span class="delimiter">(</span><a title="Long" id="sbt.compiler.Eval.bytes(f833010681).l">l</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.nio.ByteBuffer" id="sbt.compiler.Eval.bytes(f833010681).buffer">buffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><span title="Int(8)" class="int">8</span><span class="delimiter">)</span>
      <a href="#sbt.compiler.Eval.bytes(f833010681).buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="(x$1: Long)java.nio.ByteBuffer">putLong</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(f833010681).l" title="Long">l</a><span class="delimiter">)</span>
      <a href="#sbt.compiler.Eval.bytes(f833010681).buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="()Array[Byte]">array</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(i: Int)Array[Byte]" id="sbt.compiler.Eval.bytes(b3915396fe)">bytes</a><span class="delimiter">(</span><a title="Int" id="sbt.compiler.Eval.bytes(b3915396fe).i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.nio.ByteBuffer" id="sbt.compiler.Eval.bytes(b3915396fe).buffer">buffer</a> = <span title="java.nio.ByteBuffer.type">ByteBuffer</span>.<span title="(x$1: Int)java.nio.ByteBuffer">allocate</span><span class="delimiter">(</span><span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
      <a href="#sbt.compiler.Eval.bytes(b3915396fe).buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="(x$1: Int)java.nio.ByteBuffer">putInt</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.bytes(b3915396fe).i" title="Int">i</a><span class="delimiter">)</span>
      <a href="#sbt.compiler.Eval.bytes(b3915396fe).buffer" title="java.nio.ByteBuffer">buffer</a>.<span title="()Array[Byte]">array</span>
    <span class="delimiter">}</span>

  <span class="comment">/** The name of the synthetic val in the synthetic module that an expression is assigned to. */</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;$sbtdef&quot;)" id="sbt.compiler.Eval.WrapValName">WrapValName</a> = <span title="String(&quot;$sbtdef&quot;)" class="string">&quot;$sbtdef&quot;</span>

  <span class="comment">/**
   * Gets the value of the expression wrapped in module `objectName`, which is accessible via `loader`.
   * The module name should not include the trailing `$`.
   */</span>
  <span class="keyword">def</span> <a title="[T](objectName: String, loader: ClassLoader)T" id="sbt.compiler.Eval.getValue">getValue</a><span class="delimiter">[</span><a title="" id="sbt.compiler.Eval.getValue;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="sbt.compiler.Eval.getValue.objectName">objectName</a>: <span title="String">String</span>, <a title="ClassLoader" id="sbt.compiler.Eval.getValue.loader">loader</a>: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span>: <a href="#sbt.compiler.Eval.getValue;T" title="T">T</a> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Any" id="sbt.compiler.Eval.getValue.module">module</a> = <a href="#sbt.compiler.Eval.getModule" title="(moduleName: String, loader: ClassLoader)Any">getModule</a><span class="delimiter">(</span><a href="#sbt.compiler.Eval.getValue.objectName" title="String">objectName</a>, <a href="#sbt.compiler.Eval.getValue.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="java.lang.reflect.Method" id="sbt.compiler.Eval.getValue.accessor">accessor</a> = <a href="#sbt.compiler.Eval.getValue.module" title="Any">module</a>.<span title="()Class[_]">getClass</span>.<span title="(x$1: String, x$2: &lt;repeated...&gt;[Class[_]])java.lang.reflect.Method">getMethod</span><span class="delimiter">(</span><span title="String(&quot;$sbtdef&quot;)">WrapValName</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Object" id="sbt.compiler.Eval.getValue.value">value</a> = <a href="#sbt.compiler.Eval.getValue.accessor" title="java.lang.reflect.Method">accessor</a>.<span title="(x$1: Any, x$2: &lt;repeated...&gt;[Object])Object">invoke</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.getValue.module" title="Any">module</a><span class="delimiter">)</span>
      <a href="#sbt.compiler.Eval.getValue.value" title="Object">value</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#sbt.compiler.Eval.getValue;T" title="T">T</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Gets the top-level module `moduleName` from the provided class `loader`.  The module name should not include the trailing `$`.*/</span>
  <span class="keyword">def</span> <a title="(moduleName: String, loader: ClassLoader)Any" id="sbt.compiler.Eval.getModule">getModule</a><span class="delimiter">(</span><a title="String" id="sbt.compiler.Eval.getModule.moduleName">moduleName</a>: <span title="String">String</span>, <a title="ClassLoader" id="sbt.compiler.Eval.getModule.loader">loader</a>: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span>: <span title="Any">Any</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Class[_]" id="sbt.compiler.Eval.getModule.clazz">clazz</a> = <span title="Class.type">Class</span>.<span title="(x$1: String, x$2: Boolean, x$3: ClassLoader)Class[_]">forName</span><span class="delimiter">(</span><a href="#sbt.compiler.Eval.getModule.moduleName" title="String">moduleName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span>, <span title="Boolean(true)" class="keyword">true</span>, <a href="#sbt.compiler.Eval.getModule.loader" title="ClassLoader">loader</a><span class="delimiter">)</span>
      <a href="#sbt.compiler.Eval.getModule.clazz" title="Class[_]">clazz</a>.<span title="(x$1: String)java.lang.reflect.Field">getField</span><span class="delimiter">(</span><span title="String(&quot;MODULE$&quot;)" class="string">&quot;MODULE$&quot;</span><span class="delimiter">)</span>.<span title="(x$1: Any)Object">get</span><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="sbt.FileFilter" id="sbt.compiler.Eval.classDirFilter">classDirFilter</a>: <a href="../NameFilter.scala.html#sbt;FileFilter" title="sbt.FileFilter">FileFilter</a> = <a href="../NameFilter.scala.html#sbt.DirectoryFilter" title="sbt.DirectoryFilter.type">DirectoryFilter</a> <a href="../NameFilter.scala.html#sbt;FileFilter.||" title="(filter: sbt.FileFilter)sbt.FileFilter">||</a> <a href="../NameFilter.scala.html#sbt.GlobFilter.apply" title="(expression: String)sbt.NameFilter">GlobFilter</a><span class="delimiter">(</span><span title="String(&quot;*.class&quot;)" class="string">&quot;*.class&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
