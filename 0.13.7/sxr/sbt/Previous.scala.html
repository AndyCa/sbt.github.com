<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Previous.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> <a href="Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<span class="delimiter">{</span> Initialize, resolvedScoped, ScopedKey, Setting, streamsManagerKey <span class="delimiter">}</span>
<span class="keyword">import</span> <a href="#sbt.Previous" title="sbt.Previous.type">Previous</a>._
<span class="keyword">import</span> <a href="Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._

<span class="keyword">import</span> java.io.<span class="delimiter">{</span> InputStream, OutputStream <span class="delimiter">}</span>
<span class="keyword">import</span> sbinary.<span class="delimiter">{</span> DefaultProtocol, Format <span class="delimiter">}</span>
<span class="keyword">import</span> <span title="sbinary.DefaultProtocol.type">DefaultProtocol</span>.<span class="delimiter">{</span> StringFormat, withStamp <span class="delimiter">}</span>

<span class="comment">/**
 * Reads the previous value of tasks on-demand.  The read values are cached so that they are only read once per task execution.
 * `referenced` provides the `Format` to use for each key.
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Previous extends AnyRef" id="sbt;Previous">Previous</a><a href="#sbt;Previous" title="sbt.Previous" class="delimiter">(</a><a title="sbt.Previous.Streams" id="sbt;Previous.streams">streams</a>: <a href="std/Streams.scala.html#sbt.std;Streams" title="sbt.Previous.Streams">Streams</a>, <a title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]" id="sbt;Previous.referenced">referenced</a>: <a href="PMap.scala.html#sbt;IMap" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">IMap</a><span class="delimiter">[</span>ScopedTaskKey, Referenced<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.IMap[sbt.Previous.ScopedTaskKey,Previous.this.ReferencedValue]" id="sbt;Previous.map">map</a> = <a href="#sbt;Previous.referenced" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">referenced</a>.<a href="PMap.scala.html#sbt;IMap.mapValues" title="(f: sbt.~&gt;[sbt.Previous.Referenced,Previous.this.ReferencedValue])sbt.IMap[sbt.Previous.ScopedTaskKey,Previous.this.ReferencedValue]">mapValues</a><span class="delimiter">(</span><a href="#sbt;Previous.toValue" title="=&gt; sbt.~&gt;[sbt.Previous.Referenced,Previous.this.ReferencedValue]">toValue</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; sbt.~&gt;[sbt.Previous.Referenced,Previous.this.ReferencedValue]" id="sbt;Previous.toValue">toValue</a> = <a href="#sbt;Previous.toValue;$anon" title="sbt.~&gt;[sbt.Previous.Referenced,Previous.this.ReferencedValue]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[sbt.Previous.Referenced,Previous.this.ReferencedValue]" id="sbt;Previous.toValue;$anon" class="delimiter">(</a>Referenced <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[sbt.Previous.Referenced,Previous.this.ReferencedValue]">~&gt;</a> ReferencedValue<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](x: sbt.Previous.Referenced[T])Previous.this.ReferencedValue[T]" id="sbt;Previous.toValue;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Previous.toValue;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Previous.Referenced[T]" id="sbt;Previous.toValue;$anon.apply.x">x</a>: <a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced[T]">Referenced</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="Previous.this.ReferencedValue[T]" class="keyword">new</span> <a href="#sbt;Previous;ReferencedValue" title="Previous.this.ReferencedValue[T]">ReferencedValue</a><span class="delimiter">(</span><a href="#sbt;Previous.toValue;$anon.apply.x" title="sbt.Previous.Referenced[T]">x</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ReferencedValue[T] extends AnyRef" id="sbt;Previous;ReferencedValue">ReferencedValue</a><span class="delimiter">[</span><a title="" id="sbt;Previous;ReferencedValue;T">T</a><span class="delimiter">]</span><a href="#sbt;Previous;ReferencedValue" title="Previous.this.ReferencedValue[T]" class="delimiter">(</a><a title="sbt.Previous.Referenced[T]" id="sbt;Previous;ReferencedValue.referenced">referenced</a>: <a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced[T]">Referenced</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="#sbt;Previous;ReferencedValue.referenced" title="sbt.Previous.Referenced[T]">referenced</a>.<span class="delimiter">{</span> stamped, task <span class="delimiter">}</span>
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[T]" id="sbt;Previous;ReferencedValue.previousValue">previousValue</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.io.BufferedInputStream" id="sbt;Previous;ReferencedValue.previousValue.in">in</a> = <a href="std/Streams.scala.html#sbt.std;Streams.apply" title="(a: sbt.Def.ScopedKey[_])sbt.std.ManagedStreams[sbt.Def.ScopedKey[_]]">streams</a><span class="delimiter">(</span><a href="#sbt.Previous;Referenced.task" title="=&gt; sbt.Def.ScopedKey[sbt.Task[T]]">task</a><span class="delimiter">)</span>.<a href="std/Streams.scala.html#sbt.std;TaskStreams.readBinary(63f5f649b8)" title="(a: sbt.Def.ScopedKey[_], sid: String)java.io.BufferedInputStream">readBinary</a><span class="delimiter">(</span><a href="#sbt.Previous;Referenced.task" title="=&gt; sbt.Def.ScopedKey[sbt.Task[T]]">task</a>, <span title="String(&quot;previous&quot;)">StreamName</span><span class="delimiter">)</span>
      <span class="keyword">try</span> <a href="#sbt.Previous.read" title="(stream: java.io.InputStream, format: sbinary.Format[T])Option[T]">read</a><span class="delimiter">(</span><a href="#sbt;Previous;ReferencedValue.previousValue.in" title="java.io.BufferedInputStream">in</a>, <a href="#sbt.Previous;Referenced.stamped" title="=&gt; sbinary.Format[T]">stamped</a><span class="delimiter">)</span> <span class="keyword">finally</span> <a href="#sbt;Previous;ReferencedValue.previousValue.in" title="java.io.BufferedInputStream">in</a>.<span title="()Unit">close</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Used by the .previous runtime implemention to get the previous value for task `key`. */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](key: sbt.Def.ScopedKey[sbt.Task[T]])Option[T]" id="sbt;Previous.get">get</a><span class="delimiter">[</span><a title="" id="sbt;Previous.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.ScopedKey[sbt.Task[T]]" id="sbt;Previous.get.key">key</a>: <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[sbt.Task[T]]">ScopedKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt;Previous.map" title="sbt.IMap[sbt.Previous.ScopedTaskKey,Previous.this.ReferencedValue]">map</a>.<a href="PMap.scala.html#sbt;RMap.get" title="(k: sbt.Previous.ScopedTaskKey[T])Option[Previous.this.ReferencedValue[T]]">get</a><span class="delimiter">(</span><a href="#sbt;Previous.get.key" title="sbt.Def.ScopedKey[sbt.Task[T]]">key</a><span class="delimiter">)</span>.<span title="(f: Previous.this.ReferencedValue[T] =&gt; Option[T])Option[T]">flatMap</span><span class="delimiter">(</span><a href="#sbt;Previous.get.$anonfun.x$1" title="Previous.this.ReferencedValue[T]">_</a>.<a href="#sbt;Previous;ReferencedValue.previousValue" title="=&gt; Option[T]">previousValue</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.Previous.type" id="sbt.Previous">Previous</a> <a href="#sbt.Previous" title="sbt.Previous.type" class="delimiter">{</a>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span><span class="keyword">type</span> <a title="[T]sbt.Def.ScopedKey[sbt.Task[T]]" id="sbt.Previous;ScopedTaskKey">ScopedTaskKey</a><span class="delimiter">[</span><a title="" id="sbt.Previous;ScopedTaskKey;T">T</a><span class="delimiter">]</span> = <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[sbt.Task[T]]">ScopedKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">type</span> <a title="sbt.std.Streams[sbt.Def.ScopedKey[_]]" id="sbt.Previous;Streams">Streams</a> = sbt.std.<a href="std/Streams.scala.html#sbt.std;Streams" title="sbt.std.Streams[sbt.Def.ScopedKey[_]]">Streams</a><span class="delimiter">[</span>ScopedKey<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/** The stream where the task value is persisted. */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;previous&quot;)" id="sbt.Previous.StreamName">StreamName</a> = <span title="String(&quot;previous&quot;)" class="string">&quot;previous&quot;</span>

  <span class="comment">/** Represents a reference task.previous*/</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Referenced[T] extends AnyRef" id="sbt.Previous;Referenced">Referenced</a><span class="delimiter">[</span><a title="" id="sbt.Previous;Referenced;T">T</a><span class="delimiter">]</span><a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="sbt.Def.ScopedKey[sbt.Task[T]]" id="sbt.Previous;Referenced.task">task</a>: <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[sbt.Task[T]]">ScopedKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="sbinary.Format[T]" id="sbt.Previous;Referenced.format">format</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbinary.Format[T]" id="sbt.Previous;Referenced.stamped">stamped</a> = <span title="(stamp: String)(binary: sbinary.Format[T])(implicit binS: sbinary.Format[String])sbinary.Format[T]">withStamp</span><span class="delimiter">(</span><a href="#sbt.Previous;Referenced.task" title="=&gt; sbt.Def.ScopedKey[sbt.Task[T]]">task</a>.<a href="Settings.scala.html#sbt;Init;ScopedKey.key" title="=&gt; sbt.AttributeKey[sbt.Task[T]]">key</a>.<a href="Attributes.scala.html#sbt;AttributeKey.manifest" title="=&gt; scala.reflect.Manifest[sbt.Task[T]]">manifest</a>.<span title="()String">toString</span><span class="delimiter">)</span><span title="sbinary.DefaultProtocol.StringFormat.type" class="delimiter">(</span><a href="#sbt.Previous;Referenced.format" title="=&gt; sbinary.Format[T]">format</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(newTask: sbt.Def.ScopedKey[sbt.Task[T]])sbt.Previous.Referenced[T]" id="sbt.Previous;Referenced.setTask">setTask</a><span class="delimiter">(</span><a title="sbt.Def.ScopedKey[sbt.Task[T]]" id="sbt.Previous;Referenced.setTask.newTask">newTask</a>: <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[sbt.Task[T]]">ScopedKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span title="sbt.Previous.Referenced[T]" class="keyword">new</span> <a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced[T]">Referenced</a><span class="delimiter">(</span><a href="#sbt.Previous;Referenced.setTask.newTask" title="sbt.Def.ScopedKey[sbt.Task[T]]">newTask</a>, <a href="#sbt.Previous;Referenced.format" title="=&gt; sbinary.Format[T]">format</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.SettingKey[sbt.Previous.References]" id="sbt.Previous.references">references</a> = <a href="Structure.scala.html#sbt.SettingKey.apply(613c6c1b52)" title="[T](label: String, description: String, rank: Int)(implicit evidence$8: Manifest[T])sbt.SettingKey[T]">SettingKey</a><span title="(label: String, description: String, rank: Int)(implicit evidence$8: Manifest[sbt.Previous.References])sbt.SettingKey[sbt.Previous.References]" class="delimiter">[</span><a href="#sbt.Previous;References" title="sbt.Previous.References">References</a><span class="delimiter">]</span><span title="(clazz: Class[_])scala.reflect.Manifest[sbt.Previous.References]" class="delimiter">(</span><span title="String(&quot;previous-references&quot;)" class="string">&quot;previous-references&quot;</span>, <span title="String(&quot;Collects all static references to previous values of tasks.&quot;)" class="string">&quot;Collects all static references to previous values of tasks.&quot;</span>, <a href="KeyRanks.scala.html#sbt.KeyRanks" title="sbt.KeyRanks.type">KeyRanks</a>.<a href="KeyRanks.scala.html#sbt.KeyRanks.Invisible" title="=&gt; Int">Invisible</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.TaskKey[sbt.Previous]" id="sbt.Previous.cache">cache</a> = <a href="Structure.scala.html#sbt.TaskKey.apply(f1c4babf5a)" title="[T](label: String, description: String, rank: Int)(implicit evidence$4: Manifest[T])sbt.TaskKey[T]">TaskKey</a><span title="(label: String, description: String, rank: Int)(implicit evidence$4: Manifest[sbt.Previous])sbt.TaskKey[sbt.Previous]" class="delimiter">[</span><a href="#sbt;Previous" title="sbt.Previous">Previous</a><span class="delimiter">]</span><span title="(clazz: Class[_])scala.reflect.Manifest[sbt.Previous]" class="delimiter">(</span><span title="String(&quot;previous-cache&quot;)" class="string">&quot;previous-cache&quot;</span>, <span title="String(&quot;Caches previous values of tasks read from disk for the duration of a task execution.&quot;)" class="string">&quot;Caches previous values of tasks read from disk for the duration of a task execution.&quot;</span>, <a href="KeyRanks.scala.html#sbt.KeyRanks" title="sbt.KeyRanks.type">KeyRanks</a>.<a href="KeyRanks.scala.html#sbt.KeyRanks.Invisible" title="=&gt; Int">Invisible</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.AttributeKey[sbt.Previous.Referenced[_]]" id="sbt.Previous.previousReferenced">previousReferenced</a> = <a href="Attributes.scala.html#sbt.AttributeKey.apply(90970e44e2)" title="[T](name: String)(implicit mf: scala.reflect.Manifest[T])sbt.AttributeKey[T]">AttributeKey</a><span title="(name: String)(implicit mf: scala.reflect.Manifest[sbt.Previous.Referenced[_]])sbt.AttributeKey[sbt.Previous.Referenced[_]]" class="delimiter">[</span><a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced[_]">Referenced</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span title="(clazz: Class[sbt.Previous.Referenced[_]], arg1: scala.reflect.Manifest[_], args: scala.reflect.Manifest[_]*)scala.reflect.Manifest[sbt.Previous.Referenced[_]]" class="delimiter">(</span><span title="String(&quot;previous-referenced&quot;)" class="string">&quot;previous-referenced&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Records references to previous task value. This should be completely populated after settings finish loading. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class References extends AnyRef" id="sbt.Previous;References">References</a> <a href="#sbt.Previous;References" title="sbt.Previous.References" class="delimiter">{</a>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]" id="sbt.Previous;References.map">map</a> = <a href="PMap.scala.html#sbt.IMap" title="sbt.IMap.type">IMap</a>.<a href="PMap.scala.html#sbt.IMap.empty" title="[K[_], V[_]]=&gt; sbt.IMap[K,V]">empty</a><span title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]" class="delimiter">[</span><a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Previous.ScopedTaskKey">ScopedTaskKey</a>, <a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced">Referenced</a><span class="delimiter">]</span>

    <span class="comment">// TODO: this arbitrarily chooses a Format.</span>
    <span class="comment">// The need to choose is a fundamental problem with this approach, but this should at least make a stable choice.</span>
    <span class="keyword">def</span> <a title="[T](key: sbt.Def.ScopedKey[sbt.Task[T]], format: sbinary.Format[T])Unit" id="sbt.Previous;References.recordReference">recordReference</a><span class="delimiter">[</span><a title="" id="sbt.Previous;References.recordReference;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.ScopedKey[sbt.Task[T]]" id="sbt.Previous;References.recordReference.key">key</a>: <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[sbt.Task[T]]">ScopedKey</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="sbinary.Format[T]" id="sbt.Previous;References.recordReference.format">format</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt.Previous;References" title="(x$1: Unit)Unit">synchronized</a> <span class="delimiter">{</span>
      <a href="#sbt.Previous;References.map" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">map</a> = <a href="#sbt.Previous;References.map" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">map</a>.<a href="PMap.scala.html#sbt;IMap.put" title="(k: sbt.Previous.ScopedTaskKey[T], v: sbt.Previous.Referenced[T])sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">put</a><span class="delimiter">(</span><a href="#sbt.Previous;References.recordReference.key" title="sbt.Def.ScopedKey[sbt.Task[T]]">key</a>, <span title="sbt.Previous.Referenced[T]" class="keyword">new</span> <a href="#sbt.Previous;Referenced" title="sbt.Previous.Referenced[T]">Referenced</a><span class="delimiter">(</span><a href="#sbt.Previous;References.recordReference.key" title="sbt.Def.ScopedKey[sbt.Task[T]]">key</a>, <a href="#sbt.Previous;References.recordReference.format" title="sbinary.Format[T]">format</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]" id="sbt.Previous;References.getReferences">getReferences</a>: <a href="PMap.scala.html#sbt;IMap" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">IMap</a><span class="delimiter">[</span>ScopedTaskKey, Referenced<span class="delimiter">]</span> = <a href="#sbt.Previous;References" title="(x$1: sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced])sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">synchronized</a> <span class="delimiter">{</span> <a href="#sbt.Previous;References.map" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">map</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Persists values of tasks t where there is some task referencing it via t.previous. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(referenced: sbt.Previous.References, results: sbt.RMap[sbt.Task,sbt.Result], streams: sbt.Previous.Streams)Unit" id="sbt.Previous.complete">complete</a><span class="delimiter">(</span><a title="sbt.Previous.References" id="sbt.Previous.complete.referenced">referenced</a>: <a href="#sbt.Previous;References" title="sbt.Previous.References">References</a>, <a title="sbt.RMap[sbt.Task,sbt.Result]" id="sbt.Previous.complete.results">results</a>: <a href="PMap.scala.html#sbt;RMap" title="sbt.RMap[sbt.Task,sbt.Result]">RMap</a><span class="delimiter">[</span>Task, Result<span class="delimiter">]</span>, <a title="sbt.Previous.Streams" id="sbt.Previous.complete.streams">streams</a>: <a href="std/Streams.scala.html#sbt.std;Streams" title="sbt.Previous.Streams">Streams</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]" id="sbt.Previous.complete.map">map</a> = <a href="#sbt.Previous.complete.referenced" title="sbt.Previous.References">referenced</a>.<a href="#sbt.Previous;References.getReferences" title="=&gt; sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">getReferences</a>
      <span class="keyword">def</span> <a title="[T](key: sbt.Def.ScopedKey[_], result: T)Unit" id="sbt.Previous.complete.impl">impl</a><span class="delimiter">[</span><a title="" id="sbt.Previous.complete.impl;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.Def.ScopedKey[_]" id="sbt.Previous.complete.impl.key">key</a>: <a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Def.ScopedKey[_]">ScopedKey</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="T" id="sbt.Previous.complete.impl.result">result</a>: <a href="#sbt.Previous.complete.impl;T" title="T">T</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="sbt.Previous.Referenced[T]" id="sbt.Previous.complete.impl.$anonfun.i">i</a> &lt;- <a href="#sbt.Previous.complete.map" title="sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">map</a>.<a href="PMap.scala.html#sbt;RMap.get" title="(k: sbt.Previous.ScopedTaskKey[T])Option[sbt.Previous.Referenced[T]]">get</a><span title="(f: sbt.Previous.Referenced[T] =&gt; Unit)Unit" class="delimiter">(</span><a href="#sbt.Previous.complete.impl.key" title="sbt.Def.ScopedKey[_]">key</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="sbt.Previous.ScopedTaskKey[T]" class="delimiter">[</span><a href="Settings.scala.html#sbt;Init;ScopedKey" title="sbt.Previous.ScopedTaskKey[T]">ScopedTaskKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="java.io.BufferedOutputStream" id="sbt.Previous.complete.impl.$anonfun.out">out</a> = <a href="#sbt.Previous.complete.streams" title="sbt.Previous.Streams">streams</a>.<a href="std/Streams.scala.html#sbt.std;Streams.apply" title="(a: sbt.Def.ScopedKey[_])sbt.std.ManagedStreams[sbt.Def.ScopedKey[_]]">apply</a><span class="delimiter">(</span><a href="#sbt.Previous.complete.impl.$anonfun.i" title="sbt.Previous.Referenced[T]">i</a>.<a href="#sbt.Previous;Referenced.task" title="=&gt; sbt.Def.ScopedKey[sbt.Task[T]]">task</a><span class="delimiter">)</span>.<a href="std/Streams.scala.html#sbt.std;TaskStreams.binary" title="(sid: String)java.io.BufferedOutputStream">binary</a><span class="delimiter">(</span><span title="String(&quot;previous&quot;)">StreamName</span><span class="delimiter">)</span>
          <span class="keyword">try</span> <a href="#sbt.Previous.write" title="(stream: java.io.OutputStream, format: sbinary.Format[T], value: T)Unit">write</a><span class="delimiter">(</span><a href="#sbt.Previous.complete.impl.$anonfun.out" title="java.io.BufferedOutputStream">out</a>, <a href="#sbt.Previous.complete.impl.$anonfun.i" title="sbt.Previous.Referenced[T]">i</a>.<a href="#sbt.Previous;Referenced.stamped" title="=&gt; sbinary.Format[T]">stamped</a>, <a href="#sbt.Previous.complete.impl.result" title="T">result</a><span class="delimiter">)</span> <span class="keyword">finally</span> <a href="#sbt.Previous.complete.impl.$anonfun.out" title="java.io.BufferedOutputStream">out</a>.<span title="()Unit">close</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="keyword">for</span> <span class="delimiter">{</span>
        results.TPair<span class="delimiter">(</span>Task<span class="delimiter">(</span><a title="sbt.Info[_$3]" id="sbt.Previous.complete.$anonfun.info">info</a>, _<span class="delimiter">)</span>, Value<span class="delimiter">(</span><a title="_$3" id="sbt.Previous.complete.$anonfun.result">result</a><span class="delimiter">)</span><span class="delimiter">)</span> &lt;- <a href="#sbt.Previous.complete.results" title="sbt.RMap[sbt.Task,sbt.Result]">results</a>.<a href="PMap.scala.html#sbt;RMap.toTypedSeq" title="(f: results.TPair[_] =&gt; Unit)Unit">toTypedSeq</a>
        <a title="sbt.Def.ScopedKey[_]" id="sbt.Previous.complete.$anonfun.$anonfun.key">key</a> &lt;- <a href="#sbt.Previous.complete.$anonfun.info" title="sbt.Info[_$3]">info</a>.<a href="Action.scala.html#sbt;Info.attributes" title="=&gt; sbt.AttributeMap">attributes</a> <a href="Attributes.scala.html#sbt;AttributeMap.get" title="(f: sbt.Def.ScopedKey[_] =&gt; Unit)Unit">get</a> <a href="Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="Def.scala.html#sbt.Def.taskDefinitionKey" title="=&gt; sbt.AttributeKey[sbt.Def.ScopedKey[_]]">taskDefinitionKey</a>
      <span class="delimiter">}</span> <a href="#sbt.Previous.complete.impl" title="(key: sbt.Def.ScopedKey[_], result: _$3)Unit">impl</a><span class="delimiter">(</span><a href="#sbt.Previous.complete.$anonfun.$anonfun.key" title="sbt.Def.ScopedKey[_]">key</a>, <a href="#sbt.Previous.complete.$anonfun.result" title="_$3">result</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](stream: java.io.InputStream, format: sbinary.Format[T])Option[T]" id="sbt.Previous.read">read</a><span class="delimiter">[</span><a title="" id="sbt.Previous.read;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.InputStream" id="sbt.Previous.read.stream">stream</a>: <span title="java.io.InputStream">InputStream</span>, <a title="sbinary.Format[T]" id="sbt.Previous.read.format">format</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="keyword">try</span> <span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#sbt.Previous.read.format" title="sbinary.Format[T]">format</a>.<span title="(in: sbinary.Input)T">reads</span><span class="delimiter">(</span><a href="#sbt.Previous.read.stream" title="implicit sbinary.Input.javaInputToInput : (x: java.io.InputStream)sbinary.JavaInput">stream</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.Previous.read.e">e</a>: <span title="Exception">Exception</span> =&gt; <span title="None.type">None</span> <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](stream: java.io.OutputStream, format: sbinary.Format[T], value: T)Unit" id="sbt.Previous.write">write</a><span class="delimiter">[</span><a title="" id="sbt.Previous.write;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.io.OutputStream" id="sbt.Previous.write.stream">stream</a>: <span title="java.io.OutputStream">OutputStream</span>, <a title="sbinary.Format[T]" id="sbt.Previous.write.format">format</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T" id="sbt.Previous.write.value">value</a>: <a href="#sbt.Previous.write;T" title="T">T</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <span class="keyword">try</span> <a href="#sbt.Previous.write.format" title="sbinary.Format[T]">format</a>.<span title="(out: sbinary.Output, value: T)Unit">writes</span><span class="delimiter">(</span><a href="#sbt.Previous.write.stream" title="implicit sbinary.Output.javaOutputToOutput : (x: java.io.OutputStream)sbinary.JavaOutput">stream</a>, <a href="#sbt.Previous.write.value" title="T">value</a><span class="delimiter">)</span>
    <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.Previous.write.e">e</a>: <span title="Exception">Exception</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** Public as a macro implementation detail.  Do not call directly. */</span>
  <span class="keyword">def</span> <a title="[T](skey: sbt.TaskKey[T])(implicit format: sbinary.Format[T])sbt.Def.Initialize[sbt.Task[Option[T]]]" id="sbt.Previous.runtime">runtime</a><span class="delimiter">[</span><a title="" id="sbt.Previous.runtime;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.TaskKey[T]" id="sbt.Previous.runtime.skey">skey</a>: <a href="Structure.scala.html#sbt;TaskKey" title="sbt.TaskKey[T]">TaskKey</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbinary.Format[T]" id="sbt.Previous.runtime.format">format</a>: <span title="sbinary.Format[T]">Format</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Settings.scala.html#sbt;Init;Initialize" title="sbt.Def.Initialize[sbt.Task[Option[T]]]">Initialize</a><span class="delimiter">[</span>Task<span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.Def.Initialize[((sbt.Task[sbt.Previous], sbt.Def.ScopedKey[sbt.Task[T]]), sbt.Previous.References)]" id="sbt.Previous.runtime.inputs">inputs</a> = <span class="delimiter">(</span><a href="#sbt.Previous.cache" title="=&gt; sbt.TaskKey[sbt.Previous]">cache</a> <a href="Structure.scala.html#sbt;TaskKey.in(ea717d2f88)" title="(scope: sbt.Scope)sbt.TaskKey[sbt.Previous]">in</a> <a href="ScopeAxis.scala.html#sbt.ScopeAxis.scopeAxisToScope" title="implicit sbt.ScopeAxis.scopeAxisToScope : (axis: sbt.ScopeAxis[Nothing])sbt.Scope">Global</a><span class="delimiter">)</span> <a href="Settings.scala.html#sbt;Init;Initialize.zip" title="(o: sbt.Def.Initialize[sbt.Def.ScopedKey[sbt.Task[T]]])sbt.Def.Initialize[(sbt.Task[sbt.Previous], sbt.Def.ScopedKey[sbt.Task[T]])]">zip</a> <a href="Def.scala.html#sbt.Def" title="sbt.Def.type">Def</a>.<a href="Settings.scala.html#sbt;Init.validated" title="(key: sbt.Def.ScopedKey[sbt.Task[T]], selfRefOk: Boolean)sbt.Def.ValidationCapture[sbt.Task[T]]">validated</a><span class="delimiter">(</span><a href="Structure.scala.html#sbt.Scoped.taskScopedToKey" title="(s: sbt.TaskKey[T])sbt.Def.ScopedKey[sbt.Task[T]]">skey</a>, selfRefOk = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <a href="Settings.scala.html#sbt;Init;Initialize.zip" title="(o: sbt.Def.Initialize[sbt.Previous.References])sbt.Def.Initialize[((sbt.Task[sbt.Previous], sbt.Def.ScopedKey[sbt.Task[T]]), sbt.Previous.References)]">zip</a> <span class="delimiter">(</span><a href="#sbt.Previous.references" title="=&gt; sbt.SettingKey[sbt.Previous.References]">references</a> <a href="Structure.scala.html#sbt;SettingKey.in(7e2eebbf08)" title="(scope: sbt.Scope)sbt.SettingKey[sbt.Previous.References]">in</a> <a href="ScopeAxis.scala.html#sbt.ScopeAxis.scopeAxisToScope" title="implicit sbt.ScopeAxis.scopeAxisToScope : (axis: sbt.ScopeAxis[Nothing])sbt.Scope">Global</a><span class="delimiter">)</span>
      <a href="Settings.scala.html#sbt;Init;Initialize.apply" title="(g: (((sbt.Task[sbt.Previous], sbt.Def.ScopedKey[sbt.Task[T]]), sbt.Previous.References)) =&gt; sbt.Task[Option[T]])sbt.Def.Initialize[sbt.Task[Option[T]]]">inputs</a> <a href="#sbt.Previous.runtime.$anonfun.x0$1" title="sbt.Task[Option[T]]" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="sbt.Task[sbt.Previous]" id="sbt.Previous.runtime.$anonfun.prevTask">prevTask</a>, <a title="sbt.Def.ScopedKey[sbt.Task[T]]" id="sbt.Previous.runtime.$anonfun.resolved">resolved</a><span class="delimiter">)</span>, <a title="sbt.Previous.References" id="sbt.Previous.runtime.$anonfun.refs">refs</a><span class="delimiter">)</span> =&gt;
          <a href="#sbt.Previous.runtime.$anonfun.refs" title="sbt.Previous.References">refs</a>.<a href="#sbt.Previous;References.recordReference" title="(key: sbt.Def.ScopedKey[sbt.Task[T]], format: sbinary.Format[T])Unit">recordReference</a><span class="delimiter">(</span><a href="#sbt.Previous.runtime.$anonfun.resolved" title="sbt.Def.ScopedKey[sbt.Task[T]]">resolved</a>, <a href="#sbt.Previous.runtime.format" title="sbinary.Format[T]">format</a><span class="delimiter">)</span> <span class="comment">// always evaluated on project load</span>
          <span class="keyword">import</span> std.<a href="std/TaskExtra.scala.html#sbt.std.TaskExtra" title="sbt.std.TaskExtra.type">TaskExtra</a>._
          <a href="std/TaskExtra.scala.html#sbt.std;TaskExtra.singleInputTask" title="(in: sbt.Task[sbt.Previous])sbt.std.SingleInTask[sbt.Previous]">prevTask</a>.<a href="std/TaskExtra.scala.html#sbt.std;SingleInTask.map" title="(f: sbt.Previous =&gt; Option[T])sbt.Task[Option[T]]">map</a><span class="delimiter">(</span><a href="#sbt.Previous.runtime.$anonfun.$anonfun.x$3" title="sbt.Previous">_</a> <a href="#sbt;Previous.get" title="(key: sbt.Def.ScopedKey[sbt.Task[T]])Option[T]">get</a> <a href="#sbt.Previous.runtime.$anonfun.resolved" title="sbt.Def.ScopedKey[sbt.Task[T]]">resolved</a><span class="delimiter">)</span> <span class="comment">// evaluated if this task is evaluated</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; sbt.Def.Initialize[sbt.Task[sbt.Previous]]" id="sbt.Previous.cacheSetting">cacheSetting</a> = <a href="Structure.scala.html#sbt.Scoped.t2ToTable2" title="(t2: (sbt.ScopedTaskable[sbt.std.Streams[sbt.Def.ScopedKey[_]]], sbt.ScopedTaskable[sbt.Previous.References]))sbt.Scoped.RichTaskable2[sbt.std.Streams[sbt.Def.ScopedKey[_]],sbt.Previous.References]" class="delimiter">(</a><a href="Def.scala.html#sbt.Def.streamsManagerKey" title="=&gt; sbt.TaskKey[sbt.std.Streams[sbt.Def.ScopedKey[_]]]">streamsManagerKey</a>, <a href="#sbt.Previous.references" title="=&gt; sbt.SettingKey[sbt.Previous.References]">references</a><span class="delimiter">)</span> <a href="Structure.scala.html#sbt.Scoped;RichTaskables.map" title="(f: (sbt.std.Streams[sbt.Def.ScopedKey[_]], sbt.Previous.References) =&gt; sbt.Previous)sbt.Def.Initialize[sbt.Task[sbt.Previous]]">map</a> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="sbt.std.Streams[sbt.Def.ScopedKey[_]]" id="sbt.Previous.cacheSetting.$anonfun.s">s</a>, <a title="sbt.Previous.References" id="sbt.Previous.cacheSetting.$anonfun.refs">refs</a><span class="delimiter">)</span> =&gt; <span title="sbt.Previous" class="keyword">new</span> <a href="#sbt;Previous" title="sbt.Previous">Previous</a><span class="delimiter">(</span><a href="#sbt.Previous.cacheSetting.$anonfun.s" title="sbt.std.Streams[sbt.Def.ScopedKey[_]]">s</a>, <a href="#sbt.Previous.cacheSetting.$anonfun.refs" title="sbt.Previous.References">refs</a>.<a href="#sbt.Previous;References.getReferences" title="=&gt; sbt.IMap[sbt.Previous.ScopedTaskKey,sbt.Previous.Referenced]">getReferences</a><span class="delimiter">)</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
