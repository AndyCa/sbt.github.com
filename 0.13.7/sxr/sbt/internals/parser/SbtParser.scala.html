<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/internals/parser/SbtParser.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> internals
<span class="keyword">package</span> parser

<span class="keyword">import</span> java.io.File

<span class="keyword">import</span> sbt.internals.parser.<a href="#sbt.internals.parser.SbtParser.readResolve" title="sbt.internals.parser.SbtParser.type">SbtParser</a>._

<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> scala.reflect.runtime.<span title="=&gt; scala.reflect.api.JavaUniverse">universe</span>._

<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.internals.parser.SbtParser.type" id="sbt.internals.parser.SbtParser.readResolve">SbtParser</a> <a href="#sbt.internals.parser.SbtParser.readResolve" title="sbt.internals.parser.SbtParser.type" class="delimiter">{</a>
  <span class="keyword">val</span> <a title="Char" id="sbt.internals.parser.SbtParser.END_OF_LINE_CHAR">END_OF_LINE_CHAR</a> = <span title="Char('\n')" class="char">'\n'</span>
  <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.SbtParser.END_OF_LINE">END_OF_LINE</a> = <span title="String.type">String</span>.<span title="(x$1: Char)String">valueOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.END_OF_LINE_CHAR" title="=&gt; Char">END_OF_LINE_CHAR</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>parser<span class="delimiter">]</span> <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.SbtParser.NOT_FOUND_INDEX">NOT_FOUND_INDEX</a> = -<span title="Int(-1)" class="int">1</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">val</span> <a title="java.io.File" id="sbt.internals.parser.SbtParser.FAKE_FILE">FAKE_FILE</a> = <span title="java.io.File" class="keyword">new</span> <span title="java.io.File">File</span><span class="delimiter">(</span><span title="String(&quot;fake&quot;)" class="string">&quot;fake&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * This method soley exists to add scaladoc to members in SbtParser which
 * are defined using pattern matching.
 */</span>
<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ParsedSbtFileExpressions extends AnyRef" id="sbt.internals.parser;ParsedSbtFileExpressions">ParsedSbtFileExpressions</a> <span class="delimiter">{</span>
  <span class="comment">/** The set of parsed import expressions. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(String, Int)]" id="sbt.internals.parser;ParsedSbtFileExpressions.imports">imports</a>: <span title="Seq[(String, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>

  <span class="comment">/** The set of parsed defintions and/or sbt build settings. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(String, sbt.LineRange)]" id="sbt.internals.parser;ParsedSbtFileExpressions.settings">settings</a>: <span title="Seq[(String, sbt.LineRange)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>

  <span class="comment">/** The set of scala tree's for parsed definitions/settings and the underlying string representation.. */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[(String, reflect.runtime.universe.Tree)]" id="sbt.internals.parser;ParsedSbtFileExpressions.settingsTrees">settingsTrees</a>: <span title="Seq[(String, reflect.runtime.universe.Tree)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Tree<span class="delimiter">)</span><span class="delimiter">]</span>

  <span class="comment">/** Represents the changes we had to perform to the sbt file so that XML will parse correctly. */</span>
  <span class="keyword">def</span> <a title="=&gt; String" id="sbt.internals.parser;ParsedSbtFileExpressions.modifiedContent">modifiedContent</a>: <span title="String">String</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * An initial parser/splitter of .sbt files.
 *
 * This class is responsible for chunking a `.sbt` file into expression ranges
 * which we can then compile using the Scala compiler.
 *
 * Example:
 *
 * {{{
 *   val parser = SbtParser(myFile, IO.readLines(myFile))
 *   // All import statements
 *   val imports = parser.imports
 *   // All other statements (val x =, or raw settings)
 *   val settings = parser.settings
 * }}}
 *
 * @param file  The file we're parsing (may be a dummy file)
 * @param lines The parsed &quot;lines&quot; of the file, where each string is a line.
 */</span>
<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">case class</span> <a title="(file: java.io.File, lines: Seq[String])sbt.internals.parser.SbtParser" id="sbt.internals.parser;SbtParser.equals">SbtParser</a><a href="#sbt.internals.parser;SbtParser.equals" title="Product" class="delimiter">(</a><a title="java.io.File" id="sbt.internals.parser;SbtParser.copy$default$1">file</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.internals.parser;SbtParser.copy$default$2">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.internals.parser;ParsedSbtFileExpressions" title="sbt.internals.parser.ParsedSbtFileExpressions">ParsedSbtFileExpressions</a> <span class="delimiter">{</span>
  <span class="comment">//settingsTrees,modifiedContent needed for &quot;session save&quot;</span>
  <span class="comment">// TODO - We should look into splitting out &quot;defintiions&quot; vs. &quot;settings&quot; here instead of further string lookups, since we have the</span>
  <span class="comment">// parsed trees.</span>
  <span class="keyword">val</span> <a href="#sbt.internals.parser;SbtParser.imports" title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)], String)" class="delimiter">(</a><a href="#sbt.internals.parser;SbtParser.x$1" title="Seq[(String, Int)]" id="sbt.internals.parser;SbtParser.imports">imports</a>, <a href="#sbt.internals.parser;SbtParser.x$1" title="Seq[(String, sbt.LineRange)]" id="sbt.internals.parser;SbtParser.settings">settings</a>, <a href="#sbt.internals.parser;SbtParser.x$1" title="Seq[(String, reflect.runtime.universe.Tree)]" id="sbt.internals.parser;SbtParser.settingsTrees">settingsTrees</a>, <a href="#sbt.internals.parser;SbtParser.x$1" title="String" id="sbt.internals.parser;SbtParser.modifiedContent">modifiedContent</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.splitExpressions" title="(file: java.io.File, lines: Seq[String])(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)], String)">splitExpressions</a><span title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)], String) @unchecked" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.copy$default$1" title="=&gt; java.io.File">file</a>, <a href="#sbt.internals.parser;SbtParser.copy$default$2" title="=&gt; Seq[String]">lines</a><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(file: java.io.File, lines: Seq[String])(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)], String)" id="sbt.internals.parser;SbtParser.splitExpressions">splitExpressions</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.internals.parser;SbtParser.splitExpressions.file">file</a>: <span title="java.io.File">File</span>, <a title="Seq[String]" id="sbt.internals.parser;SbtParser.splitExpressions.lines">lines</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)], String)" class="delimiter">(</span>Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, Int<span class="delimiter">)</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, LineRange<span class="delimiter">)</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, Tree<span class="delimiter">)</span><span class="delimiter">]</span>, String<span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> sbt.internals.parser.<a href="#sbt.internals.parser.MissingBracketHandler" title="sbt.internals.parser.MissingBracketHandler.type">MissingBracketHandler</a>._
    <span class="keyword">import</span> sbt.internals.parser.<a href="#sbt.internals.parser.XmlContent" title="sbt.internals.parser.XmlContent.type">XmlContent</a>._

    <span class="keyword">import</span> scala.compat.<span title="scala.compat.Platform.type">Platform</span>.EOL
    <span class="keyword">import</span> scala.reflect.runtime._
    <span class="keyword">import</span> scala.tools.reflect.<span class="delimiter">{</span> ToolBox, ToolBoxError <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="reflect.runtime.universe.Mirror" id="sbt.internals.parser;SbtParser.splitExpressions.mirror">mirror</a> = <span title="=&gt; scala.reflect.api.JavaUniverse">universe</span>.<span title="(cl: ClassLoader)reflect.runtime.universe.Mirror">runtimeMirror</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.equals" title="SbtParser.this.type" class="keyword">this</a>.<span title="()Class[_]">getClass</span>.<span title="()ClassLoader">getClassLoader</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox">toolbox</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.mirror" title="scala.tools.reflect.ToolBoxFactory[reflect.runtime.universe.type] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox.qual$1">mirror</a>.<a title="scala.tools.reflect.FrontEnd" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox.x$19">mkToolBox</a><span class="delimiter">(</span>options = <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.toolbox.x$18" class="string">&quot;-Yrangepos&quot;</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[String]" id="sbt.internals.parser;SbtParser.splitExpressions.indexedLines">indexedLines</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.lines" title="Seq[String]">lines</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[String]">toIndexedSeq</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.original">original</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.indexedLines" title="scala.collection.immutable.IndexedSeq[String]">indexedLines</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.END_OF_LINE" title="=&gt; String">END_OF_LINE</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.modifiedContent">modifiedContent</a> = <a href="#sbt.internals.parser.XmlContent.handleXmlContent" title="(original: String)String">handleXmlContent</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.original" title="String">original</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.fileName">fileName</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.file" title="java.io.File">file</a>.<span title="()String">getAbsolutePath</span>

    <span class="keyword">val</span> <a title="toolbox.u.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parsed">parsed</a> =
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="(code: String)toolbox.u.Tree">parse</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="scala.tools.reflect.ToolBoxError" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.e">e</a>: <span title="scala.tools.reflect.ToolBoxError">ToolBoxError</span> =&gt;
          <span class="keyword">val</span> <a title="scala.collection.mutable.LinkedHashSet[String]" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.seq">seq</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="=&gt; scala.tools.reflect.FrontEnd">frontEnd</span>.<span title="(=&gt; scala.collection.mutable.LinkedHashSet[_1375.Info]) forSome { val _1375: scala.tools.reflect.FrontEnd }">infos</span>.<span title="(f: _1165.Info =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.mutable.LinkedHashSet[_1165.Info],String,scala.collection.mutable.LinkedHashSet[String]])scala.collection.mutable.LinkedHashSet[String]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.mutable.LinkedHashSet.Coll,String,scala.collection.mutable.LinkedHashSet[String]]" class="delimiter">{</span> <a title="_1165.Info" id="sbt.internals.parser;SbtParser.splitExpressions.parsed.seq.$anonfun.i">i</a> =&gt;
            <span title="(args: Any*)String">s</span>&quot;&quot;&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.fileName" title="String">fileName</a><span title="String(&quot;]:&quot;)">]:$</span><span class="delimiter">{</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.seq.$anonfun.i" title="_1165.Info">i</a>.<span title="=&gt; scala.reflect.internal.util.Position">pos</span>.<span title="=&gt; Int">line</span><span class="delimiter">}</span><span title="String(&quot;: &quot;)">: $</span><span class="delimiter">{</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.seq.$anonfun.i" title="_1165.Info">i</a>.<span title="=&gt; String">msg</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span>
          <span class="delimiter">}</span>
          <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="../../MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span>
            <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>&quot;&quot;&quot;<span title="String(&quot;======\n               |&quot;)">======
               |$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a><span title="String(&quot;\n               |======\n               |&quot;)">
               |======
               |$</span><span class="delimiter">{</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed.seq" title="scala.collection.mutable.LinkedHashSet[String]">seq</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="=&gt; String">EOL</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span>.<span title="=&gt; String">stripMargin</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees">parsedTrees</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsed" title="toolbox.u.Tree">parsed</a> <span title="Seq[reflect.runtime.universe.Tree]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.<unapply-selector>" title="(block: reflect.runtime.universe.Block)Option[(List[reflect.runtime.universe.Tree], reflect.runtime.universe.Tree)]">Block</a><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.Block]" class="delimiter">(</a><a title="List[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.stmt">stmt</a>, <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.expr">expr</a><span class="delimiter">)</span> =&gt;
        <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.stmt" title="List[reflect.runtime.universe.Tree]">stmt</a> <span title="(elem: reflect.runtime.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[reflect.runtime.universe.Tree],reflect.runtime.universe.Tree,List[reflect.runtime.universe.Tree]])List[reflect.runtime.universe.Tree]">:+</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.expr" title="reflect.runtime.universe.Tree">expr</a>
      <span class="keyword">case</span> <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.t">t</a>: <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.Tree]">Tree</a> =&gt;
        <span title="(elems: reflect.runtime.universe.Tree*)Seq[reflect.runtime.universe.Tree]">Seq</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees.t" title="reflect.runtime.universe.Tree">t</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// Check No val (a,b) = foo *or* val a,b = foo as these are problematic to range positions and the WHOLE architecture.</span>
    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree)Boolean" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef">isBadValDef</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.t" title="reflect.runtime.universe.Tree">t</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="toolbox.u.ValDef" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.x">x</a> @ <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="=&gt; reflect.runtime.universe.type">u</span>.<a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.<unapply-selector>" title="(valDef: toolbox.u.ValDef)Option[(toolbox.u.Modifiers, toolbox.u.TermName, toolbox.u.Tree, toolbox.u.Tree)]">ValDef</a><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.ValDef]" class="delimiter">(</a>_, _, _, <a title="toolbox.u.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.rhs">rhs</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.rhs" title="toolbox.u.Tree">rhs</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="=&gt; reflect.runtime.universe.type">u</span>.<span title="=&gt; toolbox.u.Tree">EmptyTree</span> =&gt;
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.content">content</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.x" title="toolbox.u.ValDef">x</a>.<span title="=&gt; toolbox.u.Position">pos</span>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.x" title="toolbox.u.ValDef">x</a>.<span title="=&gt; toolbox.u.Position">pos</span>.<span title="=&gt; Int">end</span><span class="delimiter">)</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef.content" title="String">content</a> <span title="(x$1: CharSequence)Boolean">contains</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span>
    <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees" title="Seq[reflect.runtime.universe.Tree]">parsedTrees</a>.<span title="(p: reflect.runtime.universe.Tree =&gt; Boolean)Seq[reflect.runtime.universe.Tree]">filter</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.isBadValDef" title="(t: reflect.runtime.universe.Tree)Boolean">isBadValDef</a><span class="delimiter">)</span>.<span title="(f: reflect.runtime.universe.Tree =&gt; Nothing)Unit">foreach</span> <span class="delimiter">{</span> <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.badTree">badTree</a> =&gt;
      <span class="comment">// Issue errors</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.positionLine">positionLine</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.badTree" title="reflect.runtime.universe.Tree">badTree</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">line</span>
      <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="../../MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>&quot;&quot;&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.fileName" title="String">fileName</a><span title="String(&quot;]:&quot;)">]:$</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.positionLine" title="Int">positionLine</a><span title="String(&quot;: Pattern matching in val statements is not supported&quot;)" class="string">: Pattern matching in val statements is not supported&quot;&quot;&quot;</span>.<span title="=&gt; String">stripMargin</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.imports" title="(Seq[reflect.runtime.universe.Tree], Seq[reflect.runtime.universe.Tree])" class="delimiter">(</a><a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2" title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.imports">imports</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2" title="Seq[reflect.runtime.universe.Tree]" id="sbt.internals.parser;SbtParser.splitExpressions.statements">statements</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parsedTrees" title="Seq[reflect.runtime.universe.Tree]">parsedTrees</a> <span title="(p: reflect.runtime.universe.Tree =&gt; Boolean)(Seq[reflect.runtime.universe.Tree], Seq[reflect.runtime.universe.Tree])">partition</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2.$anonfun.x0$1" title="Boolean" class="delimiter">{</a>
      <span class="keyword">case</span> _: <a href="#sbt.internals.parser;SbtParser.splitExpressions.x$2.$anonfun.<unapply-selector>" title="(x: Any)Option[reflect.runtime.universe.Import]">Import</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> _         =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree)(String, Int)" id="sbt.internals.parser;SbtParser.splitExpressions.convertImport">convertImport</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.convertImport.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="(String, Int)" class="delimiter">(</span>String, Int<span class="delimiter">)</span> =
      <span title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertImport.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertImport.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">end</span><span class="delimiter">)</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertImport.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">line</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

    <span class="comment">/**
     * See BugInParser
     * @param t - tree
     * @param originalStatement - original
     * @return originalStatement or originalStatement with missing bracket
     */</span>
    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree, originalStatement: String)String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain">parseStatementAgain</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span>, <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement">originalStatement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement">statement</a> = util.<span title="(r: =&gt; toolbox.u.Tree)scala.util.Try[toolbox.u.Tree]">Try</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.toolbox" title="scala.tools.reflect.ToolBox[reflect.runtime.universe.type]">toolbox</a>.<span title="(code: String)toolbox.u.Tree">parse</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement" title="String">originalStatement</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> util.Failure<span class="delimiter">(</span><a title="Throwable" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.th">th</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.missingText">missingText</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText" title="(content: String, positionEnd: Int, positionLine: Int, fileName: String, originalException: Throwable)String">findMissingText</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">end</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span>.<span title="=&gt; Int">line</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.fileName" title="String">fileName</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.th" title="Throwable">th</a><span class="delimiter">)</span>
          <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement" title="String">originalStatement</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement.missingText" title="String">missingText</a>
        <span class="keyword">case</span> _ =&gt;
          <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.originalStatement" title="String">originalStatement</a>
      <span class="delimiter">}</span>
      <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain.statement" title="String">statement</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(t: reflect.runtime.universe.Tree)Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)]" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement">convertStatement</a><span class="delimiter">(</span><a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t">t</a>: <span title="reflect.runtime.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Tree, LineRange<span class="delimiter">)</span><span class="delimiter">]</span> =
      <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t" title="reflect.runtime.universe.Tree">t</a>.<span title="=&gt; reflect.runtime.universe.Position">pos</span> <span title="Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="=&gt; reflect.runtime.universe.Position">NoPosition</span> =&gt;
          <span title="None.type">None</span>
        <span class="keyword">case</span> <a title="reflect.runtime.universe.Position" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position">position</a> =&gt;
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.originalStatement">originalStatement</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">start</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">end</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.statement">statement</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.parseStatementAgain" title="(t: reflect.runtime.universe.Tree, originalStatement: String)String">parseStatementAgain</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t" title="reflect.runtime.universe.Tree">t</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.originalStatement" title="String">originalStatement</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser;SbtParser.splitExpressions.convertStatement.numberLines">numberLines</a> = <a href="#sbt.internals.parser;SbtParser.countLines" title="(statement: String)Int">countLines</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.statement" title="String">statement</a><span class="delimiter">)</span>
          <span title="(x: (String, reflect.runtime.universe.Tree, sbt.LineRange))Some[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">Some</span><span class="delimiter">(</span><span title="(_1: String, _2: reflect.runtime.universe.Tree, _3: sbt.LineRange)(String, reflect.runtime.universe.Tree, sbt.LineRange)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.statement" title="String">statement</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.t" title="reflect.runtime.universe.Tree">t</a>, <a href="../../Positions.scala.html#sbt;LineRange" title="(start: Int, end: Int)sbt.LineRange">LineRange</a><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">line</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.position" title="reflect.runtime.universe.Position">position</a>.<span title="=&gt; Int">line</span> <span title="(x: Int)Int">+</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement.numberLines" title="Int">numberLines</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]" id="sbt.internals.parser;SbtParser.splitExpressions.stmtTreeLineRange">stmtTreeLineRange</a> = <a href="#sbt.internals.parser;SbtParser.splitExpressions.statements" title="Seq[reflect.runtime.universe.Tree]">statements</a> <span title="(f: reflect.runtime.universe.Tree =&gt; scala.collection.GenTraversableOnce[(String, reflect.runtime.universe.Tree, sbt.LineRange)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[reflect.runtime.universe.Tree],(String, reflect.runtime.universe.Tree, sbt.LineRange),Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]])Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">flatMap</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertStatement" title="(xo: Option[(String, reflect.runtime.universe.Tree, sbt.LineRange)])Iterable[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">convertStatement</a>
    <span title="(_1: Seq[(String, Int)], _2: Seq[(String, sbt.LineRange)], _3: Seq[(String, reflect.runtime.universe.Tree)], _4: String)(Seq[(String, Int)], Seq[(String, sbt.LineRange)], Seq[(String, reflect.runtime.universe.Tree)], String)" class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.splitExpressions.imports" title="Seq[reflect.runtime.universe.Tree]">imports</a> <span title="(f: reflect.runtime.universe.Tree =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[reflect.runtime.universe.Tree],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">map</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.convertImport" title="(t: reflect.runtime.universe.Tree)(String, Int)">convertImport</a>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.stmtTreeLineRange" title="Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">stmtTreeLineRange</a>.<span title="(f: ((String, reflect.runtime.universe.Tree, sbt.LineRange)) =&gt; (String, sbt.LineRange))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)],(String, sbt.LineRange),Seq[(String, sbt.LineRange)]])Seq[(String, sbt.LineRange)]">map</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.x0$2" title="(String, sbt.LineRange)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">stmt</span>, _, <a title="sbt.LineRange" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.lr">lr</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: sbt.LineRange)(String, sbt.LineRange)" class="delimiter">(</span><span title="String">stmt</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.lr" title="sbt.LineRange">lr</a><span class="delimiter">)</span> <span class="delimiter">}</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.stmtTreeLineRange" title="Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)]">stmtTreeLineRange</a>.<span title="(f: ((String, reflect.runtime.universe.Tree, sbt.LineRange)) =&gt; (String, reflect.runtime.universe.Tree))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, reflect.runtime.universe.Tree, sbt.LineRange)],(String, reflect.runtime.universe.Tree),Seq[(String, reflect.runtime.universe.Tree)]])Seq[(String, reflect.runtime.universe.Tree)]">map</span> <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.x0$3" title="(String, reflect.runtime.universe.Tree)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">stmt</span>, <a title="reflect.runtime.universe.Tree" id="sbt.internals.parser;SbtParser.splitExpressions.$anonfun.tree">tree</a>, _<span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: reflect.runtime.universe.Tree)(String, reflect.runtime.universe.Tree)" class="delimiter">(</span><span title="String">stmt</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.$anonfun.tree" title="reflect.runtime.universe.Tree">tree</a><span class="delimiter">)</span> <span class="delimiter">}</span>, <a href="#sbt.internals.parser;SbtParser.splitExpressions.modifiedContent" title="String">modifiedContent</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(statement: String)Int" id="sbt.internals.parser;SbtParser.countLines">countLines</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser;SbtParser.countLines.statement">statement</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#sbt.internals.parser;SbtParser.countLines.statement" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">statement</a>.<span title="(p: Char =&gt; Boolean)Int">count</span><span class="delimiter">(</span><a title="Char" id="sbt.internals.parser;SbtParser.countLines.$anonfun.c">c</a> =&gt; <a href="#sbt.internals.parser;SbtParser.countLines.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.END_OF_LINE_CHAR" title="=&gt; Char">END_OF_LINE_CHAR</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Scala parser cuts last bracket -
 * @see https://github.com/scala/scala/pull/3991
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.internals.parser.MissingBracketHandler.type" id="sbt.internals.parser.MissingBracketHandler">MissingBracketHandler</a> <a href="#sbt.internals.parser.MissingBracketHandler" title="sbt.internals.parser.MissingBracketHandler.type" class="delimiter">{</a>
  <span class="comment">/**
   *
   * @param content - parsed file
   * @param positionEnd - from index
   * @param positionLine - number of start position line
   * @param fileName - file name
   * @param originalException - original exception
   * @return missing text
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(content: String, positionEnd: Int, positionLine: Int, fileName: String, originalException: Throwable)String" id="sbt.internals.parser.MissingBracketHandler.findMissingText">findMissingText</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findMissingText.positionEnd">positionEnd</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findMissingText.positionLine">positionLine</a>: <span title="Int">Int</span>, <a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.fileName">fileName</a>: <span title="String">String</span>, <a title="Throwable" id="sbt.internals.parser.MissingBracketHandler.findMissingText.originalException">originalException</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex" title="(content: String, from: Int)Option[Int]">findClosingBracketIndex</a><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.content" title="String">content</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionEnd" title="Int">positionEnd</a><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="Int" id="sbt.internals.parser.MissingBracketHandler.findMissingText.index">index</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.text">text</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionEnd" title="Int">positionEnd</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.index" title="Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.MissingBracketHandler.findMissingText.textWithoutBracket">textWithoutBracket</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.text" title="String">text</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.text" title="String">text</a>.<span title="()Int">length</span> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        util.<span title="(r: =&gt; sbt.internals.parser.SbtParser)scala.util.Try[sbt.internals.parser.SbtParser]">Try</span><span class="delimiter">(</span><a href="#sbt.internals.parser;SbtParser.equals" title="(file: java.io.File, lines: Seq[String])sbt.internals.parser.SbtParser">SbtParser</a><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.FAKE_FILE" title="=&gt; java.io.File">FAKE_FILE</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.textWithoutBracket" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">textWithoutBracket</a>.<span title="=&gt; Iterator[String]">lines</span>.<span title="=&gt; Seq[String]">toSeq</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> util.Success<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.text" title="String">text</a>
          <span class="keyword">case</span> util.Failure<span class="delimiter">(</span><a title="Throwable" id="sbt.internals.parser.MissingBracketHandler.findMissingText.th">th</a><span class="delimiter">)</span> =&gt;
            <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText" title="(content: String, positionEnd: Int, positionLine: Int, fileName: String, originalException: Throwable)String">findMissingText</a><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.content" title="String">content</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.index" title="Int">index</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionLine" title="Int">positionLine</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.fileName" title="String">fileName</a>, <a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.originalException" title="Throwable">originalException</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <span title="Nothing" class="keyword">throw</span> <span title="sbt.MessageOnlyException" class="keyword">new</span> <a href="../../MessageOnlyException.scala.html#sbt;MessageOnlyException" title="sbt.MessageOnlyException">MessageOnlyException</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>&quot;&quot;&quot;<span title="String(&quot;[&quot;)">[$</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.fileName" title="String">fileName</a><span title="String(&quot;]:&quot;)">]:$</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.positionLine" title="Int">positionLine</a><span title="String(&quot;: &quot;)">: $</span><span class="delimiter">{</span><a href="#sbt.internals.parser.MissingBracketHandler.findMissingText.originalException" title="Throwable">originalException</a>.<span title="()String">getMessage</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;&quot;</span>.<span title="=&gt; String">stripMargin</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *
   * @param content - parsed file
   * @param from - start index
   * @return first not commented index or None
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(content: String, from: Int)Option[Int]" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex">findClosingBracketIndex</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.from">from</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index">index</a> = <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.content" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">content</a>.<span title="(p: Char =&gt; Boolean, from: Int)Int">indexWhere</span><span class="delimiter">(</span><a title="Char" id="sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index.$anonfun.c">c</a> =&gt; <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char('}')" class="char">'}'</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char(')')" class="char">')'</span>, <a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.from" title="Int">from</a><span class="delimiter">)</span>
    <span title="Option[Int]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index" title="Int">index</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="None.type">None</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#sbt.internals.parser.MissingBracketHandler.findClosingBracketIndex.index" title="Int">index</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * #ToolBox#parse(String) will fail for xml sequence:
 * &lt;pre&gt;
 * val xml = &lt;div&gt;txt&lt;/div&gt;
 * &lt;a&gt;rr&lt;/a&gt;
 * &lt;/pre&gt;
 * At least brackets have to be added
 * &lt;pre&gt;
 * val xml = (&lt;div&gt;txt&lt;/div&gt;
 * &lt;a&gt;rr&lt;/a&gt;)
 * &lt;/pre&gt;
 */</span>
<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.internals.parser.XmlContent.type" id="sbt.internals.parser.XmlContent">XmlContent</a> <a href="#sbt.internals.parser.XmlContent" title="sbt.internals.parser.XmlContent.type" class="delimiter">{</a>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Char" id="sbt.internals.parser.XmlContent.OPEN_PARENTHESIS">OPEN_PARENTHESIS</a> = <span title="Char('{')" class="char">'{'</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Char" id="sbt.internals.parser.XmlContent.OPEN_CURLY_BRACKET">OPEN_CURLY_BRACKET</a> = <span title="Char('(')" class="char">'('</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.DOUBLE_SLASH">DOUBLE_SLASH</a> = <span title="String(&quot;//&quot;)" class="string">&quot;//&quot;</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.OPEN_BRACKET">OPEN_BRACKET</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><a href="#sbt.internals.parser.XmlContent.OPEN_CURLY_BRACKET" title="=&gt; Char">OPEN_CURLY_BRACKET</a><span title="String(&quot;&quot;)" class="string">&quot;</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.CLOSE_BRACKET">CLOSE_BRACKET</a> = <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>

  <span class="comment">/**
   *
   * @param original - file content
   * @return original content or content with brackets added to xml parts
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(original: String)String" id="sbt.internals.parser.XmlContent.handleXmlContent">handleXmlContent</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.handleXmlContent.original">original</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.handleXmlContent.xmlParts">xmlParts</a> = <a href="#sbt.internals.parser.XmlContent.findXmlParts" title="(content: String)Seq[(String, Int, Int)]">findXmlParts</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.handleXmlContent.original" title="String">original</a><span class="delimiter">)</span>
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.handleXmlContent.xmlParts" title="Seq[(String, Int, Int)]">xmlParts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.handleXmlContent.original" title="String">original</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent" title="(content: String, xmlParts: Seq[(String, Int, Int)])String">addExplicitXmlContent</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.handleXmlContent.original" title="String">original</a>, <a href="#sbt.internals.parser.XmlContent.handleXmlContent.xmlParts" title="Seq[(String, Int, Int)]">xmlParts</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Cut file for normal text - xml - normal text - xml ....
   * @param content - content
   * @param ts - import/statements
   * @return Seq - Right(xml,whiteSpaces) - for xml, Left(statement) - for text
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, ts: Seq[(String, Int, Int)])Seq[Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.splitFile">splitFile</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.splitFile.content">content</a>: <span title="String">String</span>, <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.splitFile.ts">ts</a>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Either[String,(String, String)]]">Seq</span><span class="delimiter">[</span>Either<span class="delimiter">[</span><span class="delimiter">(</span>String<span class="delimiter">)</span>, <span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a href="#sbt.internals.parser.XmlContent.splitFile.statements" title="(Seq[Either[String,(String, String)]], Int)" class="delimiter">(</a><a href="#sbt.internals.parser.XmlContent.splitFile.x$3" title="Seq[Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.splitFile.statements">statements</a>, <a href="#sbt.internals.parser.XmlContent.splitFile.x$3" title="Int" id="sbt.internals.parser.XmlContent.splitFile.lastIndex">lastIndex</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser.XmlContent.splitFile.ts" title="Seq[(String, Int, Int)]">ts</a>.<span title="(z: (Seq[Either[String,(String, String)]], Int))(op: ((Seq[Either[String,(String, String)]], Int), (String, Int, Int)) =&gt; (Seq[Either[String,(String, String)]], Int))(Seq[Either[String,(String, String)]], Int)">foldLeft</span><span class="delimiter">(</span><span title="(_1: Seq[Either[String,(String, String)]], _2: Int)(Seq[Either[String,(String, String)]], Int)" class="delimiter">(</span><span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[Either[String,(String, String)]]" class="delimiter">[</span><span title="Either[String,(String, String)]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span>String<span class="delimiter">)</span>, <span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.x0$4" title="(Seq[Either[String,(String, String)]], Int)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Seq[Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.accSeq">accSeq</a>, <a title="Int" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.index">index</a><span class="delimiter">)</span>, <span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.statement">statement</a>, <a title="Int" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.startIndex">startIndex</a>, <a title="Int" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.endIndex">endIndex</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Seq[Product with Serializable with scala.util.Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.toAdd">toAdd</a> = <span title="Seq[Product with Serializable with scala.util.Either[String,(String, String)]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.index" title="Int">index</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.startIndex" title="Int">startIndex</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="(elems: scala.util.Right[Nothing,(String, String)]*)Seq[scala.util.Right[Nothing,(String, String)]]">Seq</span><span class="delimiter">(</span><span title="(b: (String, String))scala.util.Right[Nothing,(String, String)]">Right</span><span class="delimiter">(</span><span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.statement" title="String">statement</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.toAdd.s">s</a> = <a href="#sbt.internals.parser.XmlContent.splitFile.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.index" title="Int">index</a>, <a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.startIndex" title="Int">startIndex</a><span class="delimiter">)</span>
          <span title="Seq[Product with Serializable with scala.util.Either[String,(String, String)]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.toAdd.s" title="String">s</a>.<span title="()String">trim</span>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="(elems: scala.util.Right[Nothing,(String, String)]*)Seq[scala.util.Right[Nothing,(String, String)]]">Seq</span><span class="delimiter">(</span><span title="(b: (String, String))scala.util.Right[Nothing,(String, String)]">Right</span><span class="delimiter">(</span><span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.statement" title="String">statement</a>, <a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.toAdd.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="(elems: Product with Serializable with scala.util.Either[String,(String, String)]*)Seq[Product with Serializable with scala.util.Either[String,(String, String)]]">Seq</span><span class="delimiter">(</span><span title="(b: (String, String))scala.util.Right[Nothing,(String, String)]">Right</span><span class="delimiter">(</span><span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.statement" title="String">statement</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(a: String)scala.util.Left[String,Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.toAdd.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span title="(_1: Seq[Either[String,(String, String)]], _2: Int)(Seq[Either[String,(String, String)]], Int)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.toAdd" title="Seq[Product with Serializable with scala.util.Either[String,(String, String)]]">toAdd</a> <span title="(that: scala.collection.GenTraversableOnce[Either[String,(String, String)]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Product with Serializable with scala.util.Either[String,(String, String)]],Either[String,(String, String)],Seq[Either[String,(String, String)]]])Seq[Either[String,(String, String)]]">++</span> <a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.accSeq" title="Seq[Either[String,(String, String)]]">accSeq</a>, <a href="#sbt.internals.parser.XmlContent.splitFile.x$3.$anonfun.endIndex" title="Int">endIndex</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.splitFile.endOfFile">endOfFile</a> = <a href="#sbt.internals.parser.XmlContent.splitFile.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.lastIndex" title="Int">lastIndex</a>, <a href="#sbt.internals.parser.XmlContent.splitFile.content" title="String">content</a>.<span title="()Int">length</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Seq[Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.splitFile.withEndOfFile">withEndOfFile</a> = <span title="Seq[Either[String,(String, String)]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.endOfFile" title="String">endOfFile</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.internals.parser.XmlContent.splitFile.statements" title="Seq[Either[String,(String, String)]]">statements</a> <span class="keyword">else</span> <span title="(a: String)scala.util.Left[String,Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.splitFile.endOfFile" title="String">endOfFile</a><span class="delimiter">)</span> <a href="#sbt.internals.parser.XmlContent.splitFile.withEndOfFile.x$4" title="(elem: Either[String,(String, String)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Either[String,(String, String)]],Either[String,(String, String)],Seq[Either[String,(String, String)]]])Seq[Either[String,(String, String)]]">+:</a> <a href="#sbt.internals.parser.XmlContent.splitFile.statements" title="Seq[Either[String,(String, String)]]">statements</a>
    <a href="#sbt.internals.parser.XmlContent.splitFile.withEndOfFile" title="Seq[Either[String,(String, String)]]">withEndOfFile</a>.<span title="=&gt; Seq[Either[String,(String, String)]]">reverse</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Cut potential xmls from content
   * @param content - content
   * @return sorted by openIndex xml parts
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String)Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findXmlParts">findXmlParts</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.findXmlParts.content">content</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findXmlParts.xmlParts">xmlParts</a> = <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags" title="(content: String, offsetIndex: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]">findModifiedOpeningTags</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findXmlParts.content" title="String">content</a>, <span title="Int(0)" class="int">0</span>, <span title="scala.collection.Seq.type">Seq</span>.<span title="Seq[Nothing]">empty</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[(String, Int, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int, Int)],(String, Int, Int),Seq[(String, Int, Int)]])Seq[(String, Int, Int)]">++</span> <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags" title="(content: String, current: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]">findNotModifiedOpeningTags</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findXmlParts.content" title="String">content</a>, <span title="Int(0)" class="int">0</span>, <span title="scala.collection.Seq.type">Seq</span>.<span title="Seq[Nothing]">empty</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findXmlParts.rootXmlParts">rootXmlParts</a> = <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts" title="(xmlParts: Seq[(String, Int, Int)])Seq[(String, Int, Int)]">removeEmbeddedXmlParts</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findXmlParts.xmlParts" title="Seq[(String, Int, Int)]">xmlParts</a><span class="delimiter">)</span>
    <a href="#sbt.internals.parser.XmlContent.findXmlParts.rootXmlParts" title="Seq[(String, Int, Int)]">rootXmlParts</a>.<span title="(f: ((String, Int, Int)) =&gt; Int)(implicit ord: scala.math.Ordering[Int])Seq[(String, Int, Int)]">sortBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><a title="(String, Int, Int)" id="sbt.internals.parser.XmlContent.findXmlParts.$anonfun.z">z</a> =&gt; <a href="#sbt.internals.parser.XmlContent.findXmlParts.$anonfun.z" title="(String, Int, Int)">z</a>.<span title="=&gt; Int">_2</span><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(text: String, startIndex: Int, endIndex: Int)String" id="sbt.internals.parser.XmlContent.searchForTagName">searchForTagName</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.searchForTagName.text">text</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.searchForTagName.startIndex">startIndex</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.XmlContent.searchForTagName.endIndex">endIndex</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.searchForTagName.subs">subs</a> = <a href="#sbt.internals.parser.XmlContent.searchForTagName.text" title="String">text</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.searchForTagName.startIndex" title="Int">startIndex</a>, <a href="#sbt.internals.parser.XmlContent.searchForTagName.endIndex" title="Int">endIndex</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.searchForTagName.spaceIndex">spaceIndex</a> = <a href="#sbt.internals.parser.XmlContent.searchForTagName.subs" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">subs</a>.<span title="(p: Char =&gt; Boolean, from: Int)Int">indexWhere</span><span class="delimiter">(</span><a title="Char" id="sbt.internals.parser.XmlContent.searchForTagName.spaceIndex.$anonfun.c">c</a> =&gt; <a href="#sbt.internals.parser.XmlContent.searchForTagName.spaceIndex.$anonfun.c" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">c</a>.<span title="=&gt; Boolean">isWhitespace</span>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.searchForTagName.spaceIndex" title="Int">spaceIndex</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.searchForTagName.subs" title="String">subs</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.searchForTagName.subs" title="String">subs</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#sbt.internals.parser.XmlContent.searchForTagName.spaceIndex" title="Int">spaceIndex</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.CLOSE_XML_TAG">CLOSE_XML_TAG</a> = <span title="String(&quot;/&gt;&quot;)" class="string">&quot;/&gt;&quot;</span>

  <span class="comment">/**
   * Modified Opening Tag - &lt;aaa/&gt;
   * @param offsetIndex - index
   * @param acc - result
   * @return Set with tags and positions
   */</span>
  @tailrec
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, offsetIndex: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags">findModifiedOpeningTags</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags.offsetIndex">offsetIndex</a>: <span title="Int">Int</span>, <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags.acc">acc</a>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags.endIndex">endIndex</a> = <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.content" title="String">content</a>.<span title="(x$1: String, x$2: Int)Int">indexOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.CLOSE_XML_TAG" title="=&gt; String">CLOSE_XML_TAG</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.offsetIndex" title="Int">offsetIndex</a><span class="delimiter">)</span>
    <span title="Seq[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.endIndex" title="Int">endIndex</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.acc" title="Seq[(String, Int, Int)]">acc</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Option[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags.xmlFragment">xmlFragment</a> = <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag" title="(content: String, offsetIndex: Int, endIndex: Int)Option[(String, Int, Int)]">findModifiedOpeningTag</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.offsetIndex" title="Int">offsetIndex</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.endIndex" title="Int">endIndex</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findModifiedOpeningTags.newAcc">newAcc</a> = <a href="#sbt.internals.parser.XmlContent.addOptionToCollection" title="(ts: Seq[(String, Int, Int)], option: Option[(String, Int, Int)])Seq[(String, Int, Int)]">addOptionToCollection</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.acc" title="Seq[(String, Int, Int)]">acc</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.xmlFragment" title="Option[(String, Int, Int)]">xmlFragment</a><span class="delimiter">)</span>
      <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags" title="(content: String, offsetIndex: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]">findModifiedOpeningTags</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.endIndex" title="Int">endIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(2)" class="int">2</span>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTags.newAcc" title="Seq[(String, Int, Int)]">newAcc</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, offsetIndex: Int, endIndex: Int)Option[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findModifiedOpeningTag">findModifiedOpeningTag</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.findModifiedOpeningTag.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.findModifiedOpeningTag.offsetIndex">offsetIndex</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.XmlContent.findModifiedOpeningTag.endIndex">endIndex</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[(String, Int, Int)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.findModifiedOpeningTag.startIndex">startIndex</a> = <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.offsetIndex" title="Int">offsetIndex</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.endIndex" title="Int">endIndex</a><span class="delimiter">)</span>.<span title="(x$1: String)Int">lastIndexOf</span><span class="delimiter">(</span><span title="String(&quot;&lt;&quot;)" class="string">&quot;&lt;&quot;</span><span class="delimiter">)</span>
    <span title="Option[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.startIndex" title="Int">startIndex</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="None.type">None</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.findModifiedOpeningTag.tagName">tagName</a> = <a href="#sbt.internals.parser.XmlContent.searchForTagName" title="(text: String, startIndex: Int, endIndex: Int)String">searchForTagName</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.startIndex" title="Int">startIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span> <span title="(x: Int)Int">+</span> <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.offsetIndex" title="Int">offsetIndex</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.endIndex" title="Int">endIndex</a><span class="delimiter">)</span>
      <span title="Option[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span>xml.<span title="scala.xml.Utility.type">Utility</span>.<span title="(s: String)Boolean">isName</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.tagName" title="String">tagName</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#sbt.internals.parser.XmlContent.xmlFragmentOption" title="(content: String, openIndex: Int, closeIndex: Int)Option[(String, Int, Int)]">xmlFragmentOption</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.startIndex" title="Int">startIndex</a> <span title="(x: Int)Int">+</span> <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.offsetIndex" title="Int">offsetIndex</a>, <a href="#sbt.internals.parser.XmlContent.findModifiedOpeningTag.endIndex" title="Int">endIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="None.type">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(text: String, closeTagStartIndex: Int, tagName: String)Int" id="sbt.internals.parser.XmlContent.searchForOpeningIndex">searchForOpeningIndex</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.searchForOpeningIndex.text">text</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.searchForOpeningIndex.closeTagStartIndex">closeTagStartIndex</a>: <span title="Int">Int</span>, <a title="String" id="sbt.internals.parser.XmlContent.searchForOpeningIndex.tagName">tagName</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.searchForOpeningIndex.subs">subs</a> = <a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.text" title="String">text</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.closeTagStartIndex" title="Int">closeTagStartIndex</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.searchForOpeningIndex.index">index</a> = <a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.subs" title="String">subs</a>.<span title="(x$1: String)Int">lastIndexOf</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&lt;&quot;)">&lt;$</span><a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.tagName" title="String">tagName</a><span title="String(&quot;&gt;&quot;)" class="string">&gt;&quot;</span><span class="delimiter">)</span>
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.index" title="Int">index</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.subs" title="String">subs</a>.<span title="(x$1: String)Int">lastIndexOf</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&lt;&quot;)">&lt;$</span><a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.tagName" title="String">tagName</a><span title="String(&quot; &quot;)" class="string"> &quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex.index" title="Int">index</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Xml like - &lt;aaa&gt;...&lt;aaa/&gt;
   * @param current - index
   * @param acc - result
   * @return Set with tags and positions
   */</span>
  @tailrec
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, current: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags">findNotModifiedOpeningTags</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.current">current</a>: <span title="Int">Int</span>, <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.acc">acc</a>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagStartIndex">closeTagStartIndex</a> = <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.content" title="String">content</a>.<span title="(x$1: String, x$2: Int)Int">indexOf</span><span class="delimiter">(</span><span title="String(&quot;&lt;/&quot;)" class="string">&quot;&lt;/&quot;</span>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.current" title="Int">current</a><span class="delimiter">)</span>
    <span title="Seq[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagStartIndex" title="Int">closeTagStartIndex</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.acc" title="Seq[(String, Int, Int)]">acc</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagEndIndex">closeTagEndIndex</a> = <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.content" title="String">content</a>.<span title="(x$1: String, x$2: Int)Int">indexOf</span><span class="delimiter">(</span><span title="String(&quot;&gt;&quot;)" class="string">&quot;&gt;&quot;</span>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagStartIndex" title="Int">closeTagStartIndex</a><span class="delimiter">)</span>
      <span title="Seq[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagEndIndex" title="Int">closeTagEndIndex</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags" title="(content: String, current: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]">findNotModifiedOpeningTags</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagStartIndex" title="Int">closeTagStartIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(2)" class="int">2</span>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.acc" title="Seq[(String, Int, Int)]">acc</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Option[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.xmlFragment">xmlFragment</a> = <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag" title="(content: String, closeTagStartIndex: Int, closeTagEndIndex: Int)Option[(String, Int, Int)]">findNotModifiedOpeningTag</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagStartIndex" title="Int">closeTagStartIndex</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagEndIndex" title="Int">closeTagEndIndex</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.newAcc">newAcc</a> = <a href="#sbt.internals.parser.XmlContent.addOptionToCollection" title="(ts: Seq[(String, Int, Int)], option: Option[(String, Int, Int)])Seq[(String, Int, Int)]">addOptionToCollection</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.acc" title="Seq[(String, Int, Int)]">acc</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.xmlFragment" title="Option[(String, Int, Int)]">xmlFragment</a><span class="delimiter">)</span>
        <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags" title="(content: String, current: Int, acc: Seq[(String, Int, Int)])Seq[(String, Int, Int)]">findNotModifiedOpeningTags</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.closeTagEndIndex" title="Int">closeTagEndIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTags.newAcc" title="Seq[(String, Int, Int)]">newAcc</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(xmlParts: Seq[(String, Int, Int)])Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts">removeEmbeddedXmlParts</a><span class="delimiter">(</span><a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.xmlParts">xmlParts</a>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(el: (String, Int, Int), open: Int, close: Int)Boolean" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween">isElementBetween</a><span class="delimiter">(</span><a title="(String, Int, Int)" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.el">el</a>: <span title="(String, Int, Int)" class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span>, <a title="Int" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.open">open</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.close">close</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.xmlParts" title="Seq[(String, Int, Int)]">xmlParts</a>.<span title="(p: ((String, Int, Int)) =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span>
        <a title="(String, Int, Int)" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.element">element</a> =&gt;
          <span class="keyword">val</span> <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.openIndex" title="(Int, Int)" class="delimiter">(</a>_, <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.x$5" title="Int" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.openIndex">openIndex</a>, <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.x$5" title="Int" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.closeIndex">closeIndex</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.element" title="(String, Int, Int)">element</a>
          <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.el" title="(String, Int, Int)">el</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.element" title="(String, Int, Int)">element</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.open" title="Int">open</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.openIndex" title="Int">openIndex</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.close" title="Int">close</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween.$anonfun.closeIndex" title="Int">closeIndex</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.xmlParts" title="Seq[(String, Int, Int)]">xmlParts</a>.<span title="(p: ((String, Int, Int)) =&gt; Boolean)Seq[(String, Int, Int)]">filterNot</span> <span class="delimiter">{</span> <a title="(String, Int, Int)" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.el">el</a> =&gt;
      <span class="keyword">val</span> <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.open" title="(Int, Int)" class="delimiter">(</a>_, <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.x$6" title="Int" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.open">open</a>, <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.x$6" title="Int" id="sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.close">close</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.el" title="(String, Int, Int)">el</a>
      <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.isElementBetween" title="(el: (String, Int, Int), open: Int, close: Int)Boolean">isElementBetween</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.el" title="(String, Int, Int)">el</a>, <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.open" title="Int">open</a>, <a href="#sbt.internals.parser.XmlContent.removeEmbeddedXmlParts.$anonfun.close" title="Int">close</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *
   * @param content - content
   * @param xmlParts - xmlParts
   * @return content with xml with brackets
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, xmlParts: Seq[(String, Int, Int)])String" id="sbt.internals.parser.XmlContent.addExplicitXmlContent">addExplicitXmlContent</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.content">content</a>: <span title="String">String</span>, <a title="Seq[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.xmlParts">xmlParts</a>: <span title="Seq[(String, Int, Int)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.statements">statements</a> = <a href="#sbt.internals.parser.XmlContent.splitFile" title="(content: String, ts: Seq[(String, Int, Int)])Seq[Either[String,(String, String)]]">splitFile</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.xmlParts" title="Seq[(String, Int, Int)]">xmlParts</a><span class="delimiter">)</span>

    <span class="keyword">val</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.seq" title="(Seq[String], Boolean)" class="delimiter">(</a>_, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15" title="Seq[String]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.seq">seq</a>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15" title="Boolean" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.lastAdd">lastAdd</a><span class="delimiter">)</span> = <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.statements" title="Seq[Either[String,(String, String)]]">statements</a>.<span title="[B](z: B)(op: (B, Either[String,(String, String)]) =&gt; B)B">foldLeft</span><span title="(z: (Option[Either[String,(String, String)]], Seq[String], Boolean))(op: ((Option[Either[String,(String, String)]], Seq[String], Boolean), Either[String,(String, String)]) =&gt; (Option[Either[String,(String, String)]], Seq[String], Boolean))(Option[Either[String,(String, String)]], Seq[String], Boolean)" class="delimiter">[</span><span title="(Option[Either[String,(String, String)]], Seq[String], Boolean)" class="delimiter">(</span>Option<span class="delimiter">[</span>Either<span class="delimiter">[</span><span class="delimiter">(</span>String<span class="delimiter">)</span>, <span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span>, Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, Boolean<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: None.type, _2: Seq[String], _3: Boolean)(None.type, Seq[String], Boolean)" class="delimiter">(</span><span title="None.type">None</span>, <span title="scala.collection.Seq.type">Seq</span>.<span title="[A]=&gt; Seq[A]">empty</span><span title="Seq[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x0$5" title="(Option[Either[String,(String, String)]], Seq[String], Boolean)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Option[Either[String,(String, String)]]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.previousOption">previousOption</a>, <a title="Seq[String]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.acc">acc</a>, <a title="Boolean" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.add">add</a><span class="delimiter">)</span>, <a title="Either[String,(String, String)]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.element">element</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.newAcc" title="(Seq[String], Boolean)" class="delimiter">(</a><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14" title="Seq[String]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.newAcc">newAcc</a>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14" title="Boolean" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.newAdd">newAdd</a><span class="delimiter">)</span> = <span title="(_1: Either[String,(String, String)], _2: Option[Either[String,(String, String)]])(Either[String,(String, String)], Option[Either[String,(String, String)]])" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.element" title="Either[String,(String, String)]">element</a>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.previousOption" title="Option[Either[String,(String, String)]]">previousOption</a><span class="delimiter">)</span> <span title="(Seq[String], Boolean)" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span class="delimiter">(</span>Left<span class="delimiter">(</span><span title="String">text</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="Seq[String]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.accWithClose">accWithClose</a> = <span title="Seq[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.add" title="Boolean">add</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#sbt.internals.parser.XmlContent.addCloseBracket" title="(statements: Seq[String])Seq[String]">addCloseBracket</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.acc" title="Seq[String]">acc</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.acc" title="Seq[String]">acc</a>
            <span class="delimiter">}</span>
            <span title="(_1: Seq[String], _2: Boolean)(Seq[String], Boolean)" class="delimiter">(</span><span title="String">text</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$7" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.accWithClose" title="Seq[String]">accWithClose</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span class="delimiter">(</span>Right<span class="delimiter">(</span><span class="delimiter">(</span><span title="String">xml</span>, <span title="String">nonXml</span><span class="delimiter">)</span><span class="delimiter">)</span>, Some<span class="delimiter">(</span>Left<span class="delimiter">(</span><span title="String">text</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.accWithOpen" title="(Seq[String], Boolean)" class="delimiter">(</a><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$9" title="Seq[String]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.accWithOpen">accWithOpen</a>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$9" title="Boolean" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.added">added</a><span class="delimiter">)</span> = <span title="(Seq[String], Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary" title="(statement: String)Boolean">areBracketsNecessary</a><span class="delimiter">(</span><span title="String">text</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="(_1: Seq[String], _2: Boolean)(Seq[String], Boolean)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.OPEN_BRACKET" title="=&gt; String">OPEN_BRACKET</a> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$9.x$8" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.acc" title="Seq[String]">acc</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <span title="(_1: Seq[String], _2: Boolean)(Seq[String], Boolean)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.acc" title="Seq[String]">acc</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="(_1: Seq[String], _2: Boolean)(Seq[String], Boolean)" class="delimiter">(</span><span title="String">xml</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$11" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <span class="delimiter">(</span><span title="String">nonXml</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$10" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.accWithOpen" title="Seq[String]">accWithOpen</a><span class="delimiter">)</span>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.added" title="Boolean">added</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span class="delimiter">(</span>Right<span class="delimiter">(</span><span class="delimiter">(</span><span title="String">xml</span>, <span title="String">nonXml</span><span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt;
            <span title="(_1: Seq[String], _2: Boolean)(Seq[String], Boolean)" class="delimiter">(</span><span title="String">xml</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$13" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <span class="delimiter">(</span><span title="String">nonXml</span> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.x$14.x$12" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.acc" title="Seq[String]">acc</a><span class="delimiter">)</span>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.add" title="Boolean">add</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span title="(_1: Some[Either[String,(String, String)]], _2: Seq[String], _3: Boolean)(Some[Either[String,(String, String)]], Seq[String], Boolean)" class="delimiter">(</span><span title="(x: Either[String,(String, String)])Some[Either[String,(String, String)]]">Some</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.element" title="Either[String,(String, String)]">element</a><span class="delimiter">)</span>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.newAcc" title="Seq[String]">newAcc</a>, <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.x$15.$anonfun.newAdd" title="Boolean">newAdd</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="Seq[String]" id="sbt.internals.parser.XmlContent.addExplicitXmlContent.correctedSeq">correctedSeq</a> = <span title="Seq[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.lastAdd" title="Boolean">lastAdd</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.addCloseBracket" title="(statements: Seq[String])Seq[String]">addCloseBracket</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.seq" title="Seq[String]">seq</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.seq" title="Seq[String]">seq</a>
    <span class="delimiter">}</span>
    <a href="#sbt.internals.parser.XmlContent.addExplicitXmlContent.correctedSeq" title="Seq[String]">correctedSeq</a>.<span title="=&gt; Seq[String]">reverse</span>.<span title="=&gt; String">mkString</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(statements: Seq[String])Seq[String]" id="sbt.internals.parser.XmlContent.addCloseBracket">addCloseBracket</a><span class="delimiter">(</span><a title="Seq[String]" id="sbt.internals.parser.XmlContent.addCloseBracket.statements">statements</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.internals.parser.XmlContent.CLOSE_BRACKET" title="=&gt; String">CLOSE_BRACKET</a> <a href="#sbt.internals.parser.XmlContent.addCloseBracket.x$16" title="(elem: String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">+:</a> <a href="#sbt.internals.parser.XmlContent.addCloseBracket.statements" title="Seq[String]">statements</a>

  <span class="comment">/**
   * Add to head if option is not empty
   * @param ts - seq
   * @param option - option
   * @tparam T - type
   * @return original seq for None, add to head for Some[T]
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](ts: Seq[T], option: Option[T])Seq[T]" id="sbt.internals.parser.XmlContent.addOptionToCollection">addOptionToCollection</a><span class="delimiter">[</span><a title="" id="sbt.internals.parser.XmlContent.addOptionToCollection;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="sbt.internals.parser.XmlContent.addOptionToCollection.ts">ts</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Option[T]" id="sbt.internals.parser.XmlContent.addOptionToCollection.option">option</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.internals.parser.XmlContent.addOptionToCollection.option" title="Option[T]">option</a>.<span title="(ifEmpty: =&gt; Seq[T])(f: T =&gt; Seq[T])Seq[T]">fold</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.addOptionToCollection.ts" title="Seq[T]">ts</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="T" id="sbt.internals.parser.XmlContent.addOptionToCollection.$anonfun.el">el</a> =&gt; <a href="#sbt.internals.parser.XmlContent.addOptionToCollection.$anonfun.el" title="T">el</a> <a href="#sbt.internals.parser.XmlContent.addOptionToCollection.$anonfun.x$17" title="(elem: T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">+:</a> <a href="#sbt.internals.parser.XmlContent.addOptionToCollection.ts" title="Seq[T]">ts</a><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, closeTagStartIndex: Int, closeTagEndIndex: Int)Option[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTag">findNotModifiedOpeningTag</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.closeTagStartIndex">closeTagStartIndex</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.closeTagEndIndex">closeTagEndIndex</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[(String, Int, Int)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>

    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.tagName">tagName</a> = <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.closeTagStartIndex" title="Int">closeTagStartIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(2)" class="int">2</span>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.closeTagEndIndex" title="Int">closeTagEndIndex</a><span class="delimiter">)</span>
    <span title="Option[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span>xml.<span title="scala.xml.Utility.type">Utility</span>.<span title="(s: String)Boolean">isName</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.tagName" title="String">tagName</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.openTagIndex">openTagIndex</a> = <a href="#sbt.internals.parser.XmlContent.searchForOpeningIndex" title="(text: String, closeTagStartIndex: Int, tagName: String)Int">searchForOpeningIndex</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.closeTagStartIndex" title="Int">closeTagStartIndex</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.tagName" title="String">tagName</a><span class="delimiter">)</span>
      <span title="Option[(String, Int, Int)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.openTagIndex" title="Int">openTagIndex</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="None.type">None</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#sbt.internals.parser.XmlContent.xmlFragmentOption" title="(content: String, openIndex: Int, closeIndex: Int)Option[(String, Int, Int)]">xmlFragmentOption</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.content" title="String">content</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.openTagIndex" title="Int">openTagIndex</a>, <a href="#sbt.internals.parser.XmlContent.findNotModifiedOpeningTag.closeTagEndIndex" title="Int">closeTagEndIndex</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Check, if xmlPart is valid xml. If not - None is returned
   * @param content - file content
   * @param openIndex - open index
   * @param closeIndex - close index
   * @return Some((String,Int,Int))
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(content: String, openIndex: Int, closeIndex: Int)Option[(String, Int, Int)]" id="sbt.internals.parser.XmlContent.xmlFragmentOption">xmlFragmentOption</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.xmlFragmentOption.content">content</a>: <span title="String">String</span>, <a title="Int" id="sbt.internals.parser.XmlContent.xmlFragmentOption.openIndex">openIndex</a>: <span title="Int">Int</span>, <a title="Int" id="sbt.internals.parser.XmlContent.xmlFragmentOption.closeIndex">closeIndex</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[(String, Int, Int)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Int, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.xmlFragmentOption.xmlPart">xmlPart</a> = <a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.content" title="String">content</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.openIndex" title="Int">openIndex</a>, <a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.closeIndex" title="Int">closeIndex</a><span class="delimiter">)</span>
    util.<span title="(r: =&gt; scala.xml.Elem)scala.util.Try[scala.xml.Elem]">Try</span><span class="delimiter">(</span>xml.<span title="scala.xml.XML.type">XML</span>.<span title="(string: String)scala.xml.Elem">loadString</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.xmlPart" title="String">xmlPart</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Option[(String, Int, Int)]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> util.Success<span class="delimiter">(</span>_<span class="delimiter">)</span>  =&gt; <span title="(x: (String, Int, Int))Some[(String, Int, Int)]">Some</span><span class="delimiter">(</span><span title="(_1: String, _2: Int, _3: Int)(String, Int, Int)" class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.xmlPart" title="String">xmlPart</a>, <a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.openIndex" title="Int">openIndex</a>, <a href="#sbt.internals.parser.XmlContent.xmlFragmentOption.closeIndex" title="Int">closeIndex</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> util.Failure<span class="delimiter">(</span><a title="Throwable" id="sbt.internals.parser.XmlContent.xmlFragmentOption.th">th</a><span class="delimiter">)</span> =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * If xml is in brackets - we do not need to add them
   * @param statement - statement
   * @return are brackets necessary?
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(statement: String)Boolean" id="sbt.internals.parser.XmlContent.areBracketsNecessary">areBracketsNecessary</a><span class="delimiter">(</span><a title="String" id="sbt.internals.parser.XmlContent.areBracketsNecessary.statement">statement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.areBracketsNecessary.doubleSlash">doubleSlash</a> = <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.statement" title="String">statement</a>.<span title="(x$1: String)Int">indexOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.DOUBLE_SLASH" title="=&gt; String">DOUBLE_SLASH</a><span class="delimiter">)</span>

    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.doubleSlash" title="Int">doubleSlash</a> <span title="(x: Int)Boolean">!=</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.areBracketsNecessary.endOfLine">endOfLine</a> = <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.statement" title="String">statement</a>.<span title="(x$1: String, x$2: Int)Int">indexOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.SbtParser.END_OF_LINE" title="=&gt; String">END_OF_LINE</a>, <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.doubleSlash" title="Int">doubleSlash</a><span class="delimiter">)</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.endOfLine" title="Int">endOfLine</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary" title="(statement: String)Boolean">areBracketsNecessary</a><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.statement" title="String">statement</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.endOfLine" title="Int">endOfLine</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.areBracketsNecessary.roundBrackets">roundBrackets</a> = <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.statement" title="String">statement</a>.<span title="(x$1: Int)Int">lastIndexOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.OPEN_CURLY_BRACKET" title="=&gt; Int">OPEN_CURLY_BRACKET</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.areBracketsNecessary.braces">braces</a> = <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.statement" title="String">statement</a>.<span title="(x$1: Int)Int">lastIndexOf</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.OPEN_PARENTHESIS" title="=&gt; Int">OPEN_PARENTHESIS</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.internals.parser.XmlContent.areBracketsNecessary.max">max</a> = <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.roundBrackets" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">roundBrackets</a>.<span title="(that: Int)Int">max</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.braces" title="Int">braces</a><span class="delimiter">)</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.max" title="Int">max</a> <span title="(x: Int)Boolean">==</span> <a href="#sbt.internals.parser.SbtParser.NOT_FOUND_INDEX" title="=&gt; Int">NOT_FOUND_INDEX</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="sbt.internals.parser.XmlContent.areBracketsNecessary.trimmed">trimmed</a> = <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.statement" title="String">statement</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.max" title="Int">max</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<span title="()String">trim</span>
        <a href="#sbt.internals.parser.XmlContent.areBracketsNecessary.trimmed" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">trimmed</a>.<span title="=&gt; Boolean">nonEmpty</span>
      <span class="delimiter">}</span>

    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
