<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/logic/Logic.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> logic

<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> <a href="#sbt.logic.Formula" title="sbt.logic.Formula.type">Formula</a>.<span class="delimiter">{</span> And, True <span class="delimiter">}</span>

<span class="comment">/*
Defines a propositional logic with negation as failure and only allows stratified rule sets (negation must be acyclic) in order to have a unique minimal model.

For example, this is not allowed:
  + p :- not q
  + q :- not p
but this is:
  + p :- q
  + q :- p
as is this:
  + p :- q
  + q := not r


 Some useful links:
  + https://en.wikipedia.org/wiki/Nonmonotonic_logic
  + https://en.wikipedia.org/wiki/Negation_as_failure
  + https://en.wikipedia.org/wiki/Propositional_logic
  + https://en.wikipedia.org/wiki/Stable_model_semantics
  + http://www.w3.org/2005/rules/wg/wiki/negation
*/</span>

<span class="comment">/** Disjunction (or) of the list of clauses. */</span>
<span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Clauses extends AnyRef with Product with Serializable" id="sbt.logic.Clauses.readResolve">Clauses</a><a href="#sbt.logic.Clauses.readResolve" title="Product" class="delimiter">(</a><a title="List[sbt.logic.Clause]" id="sbt.logic;Clauses.clauses">clauses</a>: <span title="List[sbt.logic.Clause]">List</span><span class="delimiter">[</span>Clause<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a>.<span title="=&gt; Boolean">nonEmpty</span>, <span title="String(&quot;At least one clause is required.&quot;)" class="string">&quot;At least one clause is required.&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/** When the `body` Formula succeeds, atoms in `head` are true. */</span>
<span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Clause extends AnyRef with Product with Serializable" id="sbt.logic.Clause.readResolve">Clause</a><a href="#sbt.logic.Clause.readResolve" title="Product" class="delimiter">(</a><a title="sbt.logic.Formula" id="sbt.logic;Clause.body">body</a>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a>, <a title="Set[sbt.logic.Atom]" id="sbt.logic;Clause.head">head</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span>

<span class="comment">/** A literal is an [[Atom]] or its [[negation|Negated]]. */</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Literal extends sbt.logic.Formula" id="sbt.logic;Literal">Literal</a> <a href="#sbt.logic;Literal" title="sbt.logic.Literal" class="keyword">extends</a> <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a> <span class="delimiter">{</span>
  <span class="comment">/** The underlying (positive) atom. */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.logic.Atom" id="sbt.logic;Literal.atom">atom</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a>
  <span class="comment">/** Negates this literal.*/</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.logic.Literal" id="sbt.logic;Literal.unary_!">unary_!</a> : <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a>
<span class="delimiter">}</span>
<span class="comment">/** A variable with name `label`. */</span>
<span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Atom extends sbt.logic.Literal with Product with Serializable" id="sbt.logic.Atom.readResolve">Atom</a><a href="#sbt.logic.Atom.readResolve" title="Product" class="delimiter">(</a><a title="String" id="sbt.logic;Atom.label">label</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.logic.Atom" id="sbt.logic;Atom.atom">atom</a> = <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom" class="keyword">this</a>
  <span class="keyword">def</span> <a title="=&gt; sbt.logic.Negated" id="sbt.logic;Atom.unary_!">unary_!</a> : <a href="#sbt.logic.Negated.readResolve" title="sbt.logic.Negated">Negated</a> = <a href="#sbt.logic.Negated.readResolve" title="(atom: sbt.logic.Atom)sbt.logic.Negated">Negated</a><span class="delimiter">(</span><a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom" class="keyword">this</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="comment">/**
 * A negated atom, in the sense of negation as failure, not logical negation.
 * That is, it is true if `atom` is not known/defined.
 */</span>
<span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Negated extends sbt.logic.Literal with Product with Serializable" id="sbt.logic.Negated.readResolve">Negated</a><a href="#sbt.logic.Negated.readResolve" title="Product" class="delimiter">(</a><a title="sbt.logic.Atom" id="sbt.logic;Negated.atom">atom</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.logic.Atom" id="sbt.logic;Negated.unary_!">unary_!</a> : <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a> = <a href="#sbt.logic;Negated.atom" title="=&gt; sbt.logic.Atom">atom</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * A formula consists of variables, negation, and conjunction (and).
 * (Disjunction is not currently included- it is modeled at the level of a sequence of clauses.
 *  This is less convenient when defining clauses, but is not less powerful.)
 */</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Formula extends AnyRef" id="sbt.logic;Formula">Formula</a> <a href="#sbt.logic;Formula" title="sbt.logic.Formula" class="delimiter">{</a>
  <span class="comment">/** Constructs a clause that proves `atoms` when this formula is true. */</span>
  <span class="keyword">def</span> <a title="(atom: sbt.logic.Atom, atoms: sbt.logic.Atom*)sbt.logic.Clause" id="sbt.logic;Formula.proves">proves</a><span class="delimiter">(</span><a title="sbt.logic.Atom" id="sbt.logic;Formula.proves.atom">atom</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a>, <a title="sbt.logic.Atom*" id="sbt.logic;Formula.proves.atoms">atoms</a>: <span title="sbt.logic.Atom*">Atom</span>*<span class="delimiter">)</span>: <a href="#sbt.logic.Clause.readResolve" title="sbt.logic.Clause">Clause</a> = <a href="#sbt.logic.Clause.readResolve" title="(body: sbt.logic.Formula, head: Set[sbt.logic.Atom])sbt.logic.Clause">Clause</a><span class="delimiter">(</span><a href="#sbt.logic;Formula" title="sbt.logic.Formula" class="keyword">this</a>, <span class="delimiter">(</span><a href="#sbt.logic;Formula.proves.atom" title="sbt.logic.Atom">atom</a> <a href="#sbt.logic;Formula.proves.x$1" title="(elem: sbt.logic.Atom)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.logic.Atom],sbt.logic.Atom,Seq[sbt.logic.Atom]])Seq[sbt.logic.Atom]">+:</a> <a href="#sbt.logic;Formula.proves.atoms" title="sbt.logic.Atom*">atoms</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">toSet</span><span class="delimiter">)</span>

  <span class="comment">/** Constructs a formula that is true iff this formula and `f` are both true.*/</span>
  <span class="keyword">def</span> <a title="(f: sbt.logic.Formula)sbt.logic.Formula" id="sbt.logic;Formula.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic;Formula.&&.f">f</a>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a><span class="delimiter">)</span>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a> = <span title="(_1: sbt.logic.Formula, _2: sbt.logic.Formula)(sbt.logic.Formula, sbt.logic.Formula)" class="delimiter">(</span><a href="#sbt.logic;Formula" title="sbt.logic.Formula" class="keyword">this</a>, <a href="#sbt.logic;Formula.&&.f" title="sbt.logic.Formula">f</a><span class="delimiter">)</span> <span title="sbt.logic.Formula" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a>, <span title="sbt.logic.Formula">x</span><span class="delimiter">)</span>                =&gt; <span title="sbt.logic.Formula">x</span>
    <span class="keyword">case</span> <span class="delimiter">(</span><span title="sbt.logic.Formula">x</span>, <a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a><span class="delimiter">)</span>                =&gt; <span title="sbt.logic.Formula">x</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>And<span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">as</span><span class="delimiter">)</span>, And<span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">bs</span><span class="delimiter">)</span><span class="delimiter">)</span>       =&gt; <a href="#sbt.logic.Formula.And.readResolve" title="(literals: Set[sbt.logic.Literal])sbt.logic.Formula.And">And</a><span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">as</span> <span title="(elems: scala.collection.GenTraversableOnce[sbt.logic.Literal])scala.collection.immutable.Set[sbt.logic.Literal]">++</span> <span title="Set[sbt.logic.Literal]">bs</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>And<span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">as</span><span class="delimiter">)</span>, <span title="sbt.logic.Literal">b</span>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a><span class="delimiter">)</span>    =&gt; <a href="#sbt.logic.Formula.And.readResolve" title="(literals: Set[sbt.logic.Literal])sbt.logic.Formula.And">And</a><span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">as</span> <span title="(elem: sbt.logic.Literal)scala.collection.immutable.Set[sbt.logic.Literal]">+</span> <span title="sbt.logic.Literal">b</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span><span title="sbt.logic.Literal">a</span>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a>, And<span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">bs</span><span class="delimiter">)</span><span class="delimiter">)</span>    =&gt; <a href="#sbt.logic.Formula.And.readResolve" title="(literals: Set[sbt.logic.Literal])sbt.logic.Formula.And">And</a><span class="delimiter">(</span><span title="Set[sbt.logic.Literal]">bs</span> <span title="(elem: sbt.logic.Literal)scala.collection.immutable.Set[sbt.logic.Literal]">+</span> <span title="sbt.logic.Literal">a</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span><span title="sbt.logic.Literal">a</span>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a>, <span title="sbt.logic.Literal">b</span>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a><span class="delimiter">)</span> =&gt; <a href="#sbt.logic.Formula.And.readResolve" title="(literals: Set[sbt.logic.Literal])sbt.logic.Formula.And">And</a><span class="delimiter">(</span><span title="(elems: sbt.logic.Literal*)scala.collection.immutable.Set[sbt.logic.Literal]">Set</span><span class="delimiter">(</span><span title="sbt.logic.Literal">a</span>, <span title="sbt.logic.Literal">b</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="sbt.logic.Formula.type" id="sbt.logic.Formula">Formula</a> <a href="#sbt.logic.Formula" title="sbt.logic.Formula.type" class="delimiter">{</a>
  <span class="comment">/** A conjunction of literals. */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class And extends sbt.logic.Formula with Product with Serializable" id="sbt.logic.Formula.And.readResolve">And</a><a href="#sbt.logic.Formula.And.readResolve" title="Product" class="delimiter">(</a><a title="Set[sbt.logic.Literal]" id="sbt.logic.Formula;And.literals">literals</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a> <span class="delimiter">{</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.logic.Formula;And.literals" title="=&gt; Set[sbt.logic.Literal]">literals</a>.<span title="=&gt; Boolean">nonEmpty</span>, <span title="String(&quot;\'And\' requires at least one literal.&quot;)" class="string">&quot;'And' requires at least one literal.&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">case object</span> <a href="#sbt.logic.Formula.True.productElement.x$1" title="sbt.logic.Formula.True.type" id="sbt.logic.Formula.True.readResolve">True</a> <span title="Product" class="keyword">extends</span> <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="sbt.logic.Logic.type" id="sbt.logic.Logic">Logic</a> <a href="#sbt.logic.Logic" title="sbt.logic.Logic.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="(clauses: List[sbt.logic.Clause], initialFacts: Set[sbt.logic.Literal])Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]" id="sbt.logic.Logic.reduceAll">reduceAll</a><span class="delimiter">(</span><a title="List[sbt.logic.Clause]" id="sbt.logic.Logic.reduceAll.clauses">clauses</a>: <span title="List[sbt.logic.Clause]">List</span><span class="delimiter">[</span>Clause<span class="delimiter">]</span>, <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.reduceAll.initialFacts">initialFacts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]">Either</span><span class="delimiter">[</span>LogicException, Matched<span class="delimiter">]</span> =
    <a href="#sbt.logic.Logic.reduce" title="(clauses: sbt.logic.Clauses, initialFacts: Set[sbt.logic.Literal])Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]">reduce</a><span class="delimiter">(</span><a href="#sbt.logic.Clauses.readResolve" title="(clauses: List[sbt.logic.Clause])sbt.logic.Clauses">Clauses</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduceAll.clauses" title="List[sbt.logic.Clause]">clauses</a><span class="delimiter">)</span>, <a href="#sbt.logic.Logic.reduceAll.initialFacts" title="Set[sbt.logic.Literal]">initialFacts</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Computes the variables in the unique stable model for the program represented by `clauses` and `initialFacts`.
   * `clause` may not have any negative feedback (that is, negation is acyclic)
   * and `initialFacts` cannot be in the head of any clauses in `clause`.
   * These restrictions ensure that the logic program has a unique minimal model.
   */</span>
  <span class="keyword">def</span> <a title="(clauses: sbt.logic.Clauses, initialFacts: Set[sbt.logic.Literal])Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]" id="sbt.logic.Logic.reduce">reduce</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.reduce.clauses">clauses</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a>, <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.reduce.initialFacts">initialFacts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]">Either</span><span class="delimiter">[</span>LogicException, Matched<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#sbt.logic.Logic.reduce.posSeq" title="(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])" class="delimiter">(</a><a href="#sbt.logic.Logic.reduce.x$2" title="Seq[sbt.logic.Atom]" id="sbt.logic.Logic.reduce.posSeq">posSeq</a>, <a href="#sbt.logic.Logic.reduce.x$2" title="Seq[sbt.logic.Atom]" id="sbt.logic.Logic.reduce.negSeq">negSeq</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.separate" title="(lits: Seq[sbt.logic.Literal])(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])">separate</a><span title="(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom]) @unchecked" class="delimiter">(</span><a href="#sbt.logic.Logic.reduce.initialFacts" title="Set[sbt.logic.Literal]">initialFacts</a>.<span title="=&gt; Seq[sbt.logic.Literal]">toSeq</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a href="#sbt.logic.Logic.reduce.pos" title="(scala.collection.immutable.Set[sbt.logic.Atom], scala.collection.immutable.Set[sbt.logic.Atom])" class="delimiter">(</a><a href="#sbt.logic.Logic.reduce.x$3" title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.reduce.pos">pos</a>, <a href="#sbt.logic.Logic.reduce.x$3" title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.reduce.neg">neg</a><span class="delimiter">)</span> = <span title="(_1: scala.collection.immutable.Set[sbt.logic.Atom], _2: scala.collection.immutable.Set[sbt.logic.Atom])(scala.collection.immutable.Set[sbt.logic.Atom], scala.collection.immutable.Set[sbt.logic.Atom])" class="delimiter">(</span><a href="#sbt.logic.Logic.reduce.posSeq" title="Seq[sbt.logic.Atom]">posSeq</a>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">toSet</span>, <a href="#sbt.logic.Logic.reduce.negSeq" title="Seq[sbt.logic.Atom]">negSeq</a>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">toSet</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="Option[sbt.logic.Logic.LogicException]" id="sbt.logic.Logic.reduce.problem">problem</a> =
        <a href="#sbt.logic.Logic.checkContradictions" title="(pos: Set[sbt.logic.Atom], neg: Set[sbt.logic.Atom])Option[sbt.logic.Logic.InitialContradictions]">checkContradictions</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce.pos" title="scala.collection.immutable.Set[sbt.logic.Atom]">pos</a>, <a href="#sbt.logic.Logic.reduce.neg" title="scala.collection.immutable.Set[sbt.logic.Atom]">neg</a><span class="delimiter">)</span> <span title="(alternative: =&gt; Option[sbt.logic.Logic.LogicException])Option[sbt.logic.Logic.LogicException]">orElse</span>
          <a href="#sbt.logic.Logic.checkOverlap" title="(clauses: sbt.logic.Clauses, initialFacts: Set[sbt.logic.Atom])Option[sbt.logic.Logic.InitialOverlap]">checkOverlap</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce.clauses" title="sbt.logic.Clauses">clauses</a>, <a href="#sbt.logic.Logic.reduce.pos" title="scala.collection.immutable.Set[sbt.logic.Atom]">pos</a><span class="delimiter">)</span> <span title="(alternative: =&gt; Option[sbt.logic.Logic.LogicException])Option[sbt.logic.Logic.LogicException]">orElse</span>
          <a href="#sbt.logic.Logic.checkAcyclic" title="(clauses: sbt.logic.Clauses)Option[sbt.logic.Logic.CyclicNegation]">checkAcyclic</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce.clauses" title="sbt.logic.Clauses">clauses</a><span class="delimiter">)</span>

      <a href="#sbt.logic.Logic.reduce.problem" title="Option[sbt.logic.Logic.LogicException]">problem</a>.<span title="(right: =&gt; sbt.logic.Logic.Matched)Serializable with Product with scala.util.Either[sbt.logic.Logic.LogicException,sbt.logic.Logic.Matched]">toLeft</span><span class="delimiter">(</span>
        <a href="#sbt.logic.Logic.reduce0" title="(clauses: sbt.logic.Clauses, factsToProcess: Set[sbt.logic.Literal], state: sbt.logic.Logic.Matched)sbt.logic.Logic.Matched">reduce0</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce.clauses" title="sbt.logic.Clauses">clauses</a>, <a href="#sbt.logic.Logic.reduce.initialFacts" title="Set[sbt.logic.Literal]">initialFacts</a>, <a href="#sbt.logic.Logic.Matched" title="sbt.logic.Logic.Matched.type">Matched</a>.<a href="#sbt.logic.Logic.Matched.empty" title="=&gt; sbt.logic.Logic.Matched">empty</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Verifies `initialFacts` are not in the head of any `clauses`.
   * This avoids the situation where an atom is proved but no clauses prove it.
   * This isn't necessarily a problem, but the main sbt use cases expects
   * a proven atom to have at least one clause satisfied.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(clauses: sbt.logic.Clauses, initialFacts: Set[sbt.logic.Atom])Option[sbt.logic.Logic.InitialOverlap]" id="sbt.logic.Logic.checkOverlap">checkOverlap</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.checkOverlap.clauses">clauses</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a>, <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.checkOverlap.initialFacts">initialFacts</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[sbt.logic.Logic.InitialOverlap]">Option</span><span class="delimiter">[</span>InitialOverlap<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="sbt.logic.Logic.Atoms" id="sbt.logic.Logic.checkOverlap.as">as</a> = <a href="#sbt.logic.Logic.atoms(8961cb1e56)" title="(cs: sbt.logic.Clauses)sbt.logic.Logic.Atoms">atoms</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkOverlap.clauses" title="sbt.logic.Clauses">clauses</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.checkOverlap.initialOverlap">initialOverlap</a> = <a href="#sbt.logic.Logic.checkOverlap.initialFacts" title="Set[sbt.logic.Atom]">initialFacts</a>.<span title="(p: sbt.logic.Atom =&gt; Boolean)scala.collection.immutable.Set[sbt.logic.Atom]">filter</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkOverlap.as" title="sbt.logic.Logic.Atoms">as</a>.<a href="#sbt.logic.Logic;Atoms.inHead" title="=&gt; Set[sbt.logic.Atom]">inHead</a><span class="delimiter">)</span>
    <span title="Option[sbt.logic.Logic.InitialOverlap]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.checkOverlap.initialOverlap" title="scala.collection.immutable.Set[sbt.logic.Atom]">initialOverlap</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span title="(x: sbt.logic.Logic.InitialOverlap)Some[sbt.logic.Logic.InitialOverlap]">Some</span><span class="delimiter">(</span><span title="sbt.logic.Logic.InitialOverlap" class="keyword">new</span> <a href="#sbt.logic.Logic;InitialOverlap" title="sbt.logic.Logic.InitialOverlap">InitialOverlap</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkOverlap.initialOverlap" title="scala.collection.immutable.Set[sbt.logic.Atom]">initialOverlap</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="None.type">None</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(pos: Set[sbt.logic.Atom], neg: Set[sbt.logic.Atom])Option[sbt.logic.Logic.InitialContradictions]" id="sbt.logic.Logic.checkContradictions">checkContradictions</a><span class="delimiter">(</span><a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.checkContradictions.pos">pos</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span>, <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.checkContradictions.neg">neg</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[sbt.logic.Logic.InitialContradictions]">Option</span><span class="delimiter">[</span>InitialContradictions<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.checkContradictions.contradictions">contradictions</a> = <a href="#sbt.logic.Logic.checkContradictions.pos" title="Set[sbt.logic.Atom]">pos</a> <span title="(that: scala.collection.GenSet[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">intersect</span> <a href="#sbt.logic.Logic.checkContradictions.neg" title="Set[sbt.logic.Atom]">neg</a>
    <span title="Option[sbt.logic.Logic.InitialContradictions]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.checkContradictions.contradictions" title="scala.collection.immutable.Set[sbt.logic.Atom]">contradictions</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span title="(x: sbt.logic.Logic.InitialContradictions)Some[sbt.logic.Logic.InitialContradictions]">Some</span><span class="delimiter">(</span><span title="sbt.logic.Logic.InitialContradictions" class="keyword">new</span> <a href="#sbt.logic.Logic;InitialContradictions" title="sbt.logic.Logic.InitialContradictions">InitialContradictions</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkContradictions.contradictions" title="scala.collection.immutable.Set[sbt.logic.Atom]">contradictions</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="None.type">None</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(clauses: sbt.logic.Clauses)Option[sbt.logic.Logic.CyclicNegation]" id="sbt.logic.Logic.checkAcyclic">checkAcyclic</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.checkAcyclic.clauses">clauses</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a><span class="delimiter">)</span>: <span title="Option[sbt.logic.Logic.CyclicNegation]">Option</span><span class="delimiter">[</span>CyclicNegation<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" id="sbt.logic.Logic.checkAcyclic.deps">deps</a> = <a href="#sbt.logic.Logic.dependencyMap" title="(clauses: sbt.logic.Clauses)Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">dependencyMap</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkAcyclic.clauses" title="sbt.logic.Clauses">clauses</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="List[sbt.logic.Literal]" id="sbt.logic.Logic.checkAcyclic.cycle">cycle</a> = <a href="../Dag.scala.html#sbt.Dag" title="sbt.Dag.type">Dag</a>.<a href="../Dag.scala.html#sbt.Dag.findNegativeCycle" title="(graph: sbt.Dag.DirectedSignedGraph[sbt.logic.Atom])List[graph.Arrow]">findNegativeCycle</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.graph" title="(deps: Map[sbt.logic.Atom,Set[sbt.logic.Literal]])sbt.Dag.DirectedSignedGraph[sbt.logic.Atom]{type Arrow = sbt.logic.Literal; def nodes: List[sbt.logic.Atom]}">graph</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkAcyclic.deps" title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">deps</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="Option[sbt.logic.Logic.CyclicNegation]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.checkAcyclic.cycle" title="List[sbt.logic.Literal]">cycle</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span title="(x: sbt.logic.Logic.CyclicNegation)Some[sbt.logic.Logic.CyclicNegation]">Some</span><span class="delimiter">(</span><span title="sbt.logic.Logic.CyclicNegation" class="keyword">new</span> <a href="#sbt.logic.Logic;CyclicNegation" title="sbt.logic.Logic.CyclicNegation">CyclicNegation</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.checkAcyclic.cycle" title="List[sbt.logic.Literal]">cycle</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="None.type">None</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(deps: Map[sbt.logic.Atom,Set[sbt.logic.Literal]])sbt.Dag.DirectedSignedGraph[sbt.logic.Atom]{type Arrow = sbt.logic.Literal; def nodes: List[sbt.logic.Atom]}" id="sbt.logic.Logic.graph">graph</a><span class="delimiter">(</span><a title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" id="sbt.logic.Logic.graph.deps">deps</a>: <span title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">Map</span><span class="delimiter">[</span>Atom, Set<span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.graph;$anon" title="sbt.Dag.DirectedSignedGraph[sbt.logic.Atom]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.Dag.DirectedSignedGraph[sbt.logic.Atom]" id="sbt.logic.Logic.graph;$anon">Dag</a>.<a href="../Dag.scala.html#sbt.Dag;DirectedSignedGraph" title="sbt.Dag.DirectedSignedGraph[sbt.logic.Atom]">DirectedSignedGraph</a><span class="delimiter">[</span>Atom<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="sbt.logic.Literal" id="sbt.logic.Logic.graph;$anon;Arrow">Arrow</a> = <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a>
    <span class="keyword">def</span> <a title="=&gt; List[sbt.logic.Atom]" id="sbt.logic.Logic.graph;$anon.nodes">nodes</a> = <a href="#sbt.logic.Logic.graph.deps" title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">deps</a>.<span title="=&gt; Iterable[sbt.logic.Atom]">keys</span>.<span title="=&gt; List[sbt.logic.Atom]">toList</span>
    <span class="keyword">def</span> <a title="(a: sbt.logic.Atom)List[sbt.logic.Literal]" id="sbt.logic.Logic.graph;$anon.dependencies">dependencies</a><span class="delimiter">(</span><a title="sbt.logic.Atom" id="sbt.logic.Logic.graph;$anon.dependencies.a">a</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.graph.deps" title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">deps</a>.<span title="(key: sbt.logic.Atom, default: =&gt; Set[sbt.logic.Literal])Set[sbt.logic.Literal]">getOrElse</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.graph;$anon.dependencies.a" title="sbt.logic.Atom">a</a>, <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[sbt.logic.Literal]">empty</span><span class="delimiter">)</span>.<span title="=&gt; List[sbt.logic.Literal]">toList</span>
    <span class="keyword">def</span> <a title="(b: sbt.logic.Literal)Boolean" id="sbt.logic.Logic.graph;$anon.isNegative">isNegative</a><span class="delimiter">(</span><a title="sbt.logic.Literal" id="sbt.logic.Logic.graph;$anon.isNegative.b">b</a>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.graph;$anon.isNegative.b" title="sbt.logic.Literal">b</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Negated<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> Atom<span class="delimiter">(</span>_<span class="delimiter">)</span>    =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(b: sbt.logic.Literal)sbt.logic.Atom" id="sbt.logic.Logic.graph;$anon.head">head</a><span class="delimiter">(</span><a title="sbt.logic.Literal" id="sbt.logic.Logic.graph;$anon.head.b">b</a>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.graph;$anon.head.b" title="sbt.logic.Literal">b</a>.<a href="#sbt.logic;Literal.atom" title="=&gt; sbt.logic.Atom">atom</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(clauses: sbt.logic.Clauses)Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" id="sbt.logic.Logic.dependencyMap">dependencyMap</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.dependencyMap.clauses">clauses</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a><span class="delimiter">)</span>: <span title="Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">Map</span><span class="delimiter">[</span>Atom, Set<span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" class="delimiter">[</span><a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a>, <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">]</span> <a href="#sbt.logic.Logic.dependencyMap.x$4" title="(z: scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]])(op: (scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]], sbt.logic.Clause) =&gt; scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]])scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">/:</a> <a href="#sbt.logic.Logic.dependencyMap.clauses" title="sbt.logic.Clauses">clauses</a>.<a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a><span class="delimiter">)</span> <a href="#sbt.logic.Logic.dependencyMap.$anonfun.x0$1" title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" id="sbt.logic.Logic.dependencyMap.$anonfun.m">m</a>, Clause<span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.dependencyMap.$anonfun.formula">formula</a>, <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.dependencyMap.$anonfun.heads">heads</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.dependencyMap.$anonfun.deps">deps</a> = <a href="#sbt.logic.Logic.literals" title="(formula: sbt.logic.Formula)Set[sbt.logic.Literal]">literals</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.dependencyMap.$anonfun.formula" title="sbt.logic.Formula">formula</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#sbt.logic.Logic.dependencyMap.$anonfun.m" title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">m</a> <a href="#sbt.logic.Logic.dependencyMap.$anonfun.x$5" title="(z: scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]])(op: (scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]], sbt.logic.Atom) =&gt; scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]])scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">/:</a> <a href="#sbt.logic.Logic.dependencyMap.$anonfun.heads" title="Set[sbt.logic.Atom]">heads</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]" id="sbt.logic.Logic.dependencyMap.$anonfun.$anonfun.n">n</a>, <a title="sbt.logic.Atom" id="sbt.logic.Logic.dependencyMap.$anonfun.$anonfun.head">head</a><span class="delimiter">)</span> =&gt; <a href="#sbt.logic.Logic.dependencyMap.$anonfun.$anonfun.n" title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">n</a>.<span title="(key: sbt.logic.Atom, value: Set[sbt.logic.Literal])scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">updated</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.dependencyMap.$anonfun.$anonfun.head" title="sbt.logic.Atom">head</a>, <a href="#sbt.logic.Logic.dependencyMap.$anonfun.$anonfun.n" title="scala.collection.immutable.Map[sbt.logic.Atom,Set[sbt.logic.Literal]]">n</a>.<span title="(key: sbt.logic.Atom, default: =&gt; Set[sbt.logic.Literal])Set[sbt.logic.Literal]">getOrElse</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.dependencyMap.$anonfun.$anonfun.head" title="sbt.logic.Atom">head</a>, <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[sbt.logic.Literal]">empty</span><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[sbt.logic.Literal])scala.collection.immutable.Set[sbt.logic.Literal]">++</span> <a href="#sbt.logic.Logic.dependencyMap.$anonfun.deps" title="Set[sbt.logic.Literal]">deps</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LogicException extends AnyRef" id="sbt.logic.Logic;LogicException">LogicException</a><a href="#sbt.logic.Logic;LogicException" title="sbt.logic.Logic.LogicException" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="String" id="sbt.logic.Logic;LogicException.toString">toString</a>: <span title="String">String</span><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class InitialContradictions extends sbt.logic.Logic.LogicException" id="sbt.logic.Logic;InitialContradictions">InitialContradictions</a><a href="#sbt.logic.Logic;InitialContradictions" title="sbt.logic.Logic.InitialContradictions" class="delimiter">(</a><span class="keyword">val</span> <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic;InitialContradictions.literals">literals</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.logic.Logic;LogicException" title="sbt.logic.Logic.LogicException">LogicException</a><span class="delimiter">(</span><span title="String(&quot;Initial facts cannot be both true and false:\n\t&quot;)" class="string">&quot;Initial facts cannot be both true and false:\n\t&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.logic.Logic;InitialContradictions.literals" title="Set[sbt.logic.Atom]">literals</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class InitialOverlap extends sbt.logic.Logic.LogicException" id="sbt.logic.Logic;InitialOverlap">InitialOverlap</a><a href="#sbt.logic.Logic;InitialOverlap" title="sbt.logic.Logic.InitialOverlap" class="delimiter">(</a><span class="keyword">val</span> <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic;InitialOverlap.literals">literals</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.logic.Logic;LogicException" title="sbt.logic.Logic.LogicException">LogicException</a><span class="delimiter">(</span><span title="String(&quot;Initial positive facts cannot be implied by any clauses:\n\t&quot;)" class="string">&quot;Initial positive facts cannot be implied by any clauses:\n\t&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.logic.Logic;InitialOverlap.literals" title="Set[sbt.logic.Atom]">literals</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class CyclicNegation extends sbt.logic.Logic.LogicException" id="sbt.logic.Logic;CyclicNegation">CyclicNegation</a><a href="#sbt.logic.Logic;CyclicNegation" title="sbt.logic.Logic.CyclicNegation" class="delimiter">(</a><span class="keyword">val</span> <a title="List[sbt.logic.Literal]" id="sbt.logic.Logic;CyclicNegation.cycle">cycle</a>: <span title="List[sbt.logic.Literal]">List</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.logic.Logic;LogicException" title="sbt.logic.Logic.LogicException">LogicException</a><span class="delimiter">(</span><span title="String(&quot;Negation may not be involved in a cycle:\n\t&quot;)" class="string">&quot;Negation may not be involved in a cycle:\n\t&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.logic.Logic;CyclicNegation.cycle" title="List[sbt.logic.Literal]">cycle</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Tracks proven atoms in the reverse order they were proved. */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Matched extends AnyRef" id="sbt.logic.Logic;Matched">Matched</a> <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched" class="keyword">private</a> <span class="delimiter">(</span><span class="keyword">val</span> <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic;Matched.provenSet">provenSet</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span>, <a title="List[sbt.logic.Atom]" id="sbt.logic.Logic;Matched.reverseOrdered">reverseOrdered</a>: <span title="List[sbt.logic.Atom]">List</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(atoms: Set[sbt.logic.Atom])sbt.logic.Logic.Matched" id="sbt.logic.Logic;Matched.add(0d116b2e54)">add</a><span class="delimiter">(</span><a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic;Matched.add(0d116b2e54).atoms">atoms</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched">Matched</a> = <a href="#sbt.logic.Logic;Matched.add(039bc5a6d5)" title="(atoms: List[sbt.logic.Atom])sbt.logic.Logic.Matched">add</a><span class="delimiter">(</span><a href="#sbt.logic.Logic;Matched.add(0d116b2e54).atoms" title="Set[sbt.logic.Atom]">atoms</a>.<span title="=&gt; List[sbt.logic.Atom]">toList</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(atoms: List[sbt.logic.Atom])sbt.logic.Logic.Matched" id="sbt.logic.Logic;Matched.add(039bc5a6d5)">add</a><span class="delimiter">(</span><a title="List[sbt.logic.Atom]" id="sbt.logic.Logic;Matched.add(039bc5a6d5).atoms">atoms</a>: <span title="List[sbt.logic.Atom]">List</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched">Matched</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[sbt.logic.Atom]" id="sbt.logic.Logic;Matched.add(039bc5a6d5).newOnly">newOnly</a> = <a href="#sbt.logic.Logic;Matched.add(039bc5a6d5).atoms" title="List[sbt.logic.Atom]">atoms</a>.<span title="(p: sbt.logic.Atom =&gt; Boolean)List[sbt.logic.Atom]">filterNot</span><span class="delimiter">(</span><a href="#sbt.logic.Logic;Matched.provenSet" title="=&gt; Set[sbt.logic.Atom]">provenSet</a><span class="delimiter">)</span>
      <span title="sbt.logic.Logic.Matched" class="keyword">new</span> <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched">Matched</a><span class="delimiter">(</span><a href="#sbt.logic.Logic;Matched.provenSet" title="=&gt; Set[sbt.logic.Atom]">provenSet</a> <span title="(elems: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">++</span> <a href="#sbt.logic.Logic;Matched.add(039bc5a6d5).newOnly" title="List[sbt.logic.Atom]">newOnly</a>, <a href="#sbt.logic.Logic;Matched.add(039bc5a6d5).newOnly" title="List[sbt.logic.Atom]">newOnly</a> <a href="#sbt.logic.Logic;Matched.add(039bc5a6d5).x$6" title="(prefix: List[sbt.logic.Atom])List[sbt.logic.Atom]">:::</a> <a href="#sbt.logic.Logic;Matched.reverseOrdered" title="List[sbt.logic.Atom]">reverseOrdered</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; List[sbt.logic.Atom]" id="sbt.logic.Logic;Matched.ordered">ordered</a>: <span title="List[sbt.logic.Atom]">List</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> = <a href="#sbt.logic.Logic;Matched.reverseOrdered" title="List[sbt.logic.Atom]">reverseOrdered</a>.<span title="=&gt; List[sbt.logic.Atom]">reverse</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.logic.Logic;Matched.toString">toString</a> = <a href="#sbt.logic.Logic;Matched.ordered" title="=&gt; List[sbt.logic.Atom]">ordered</a>.<span title="(f: sbt.logic.Atom =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.logic.Atom],String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><a href="#sbt.logic.Logic;Matched.toString.$anonfun.x$7" title="sbt.logic.Atom">_</a>.<a href="#sbt.logic;Atom.label" title="=&gt; String">label</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;Matched(&quot;)" class="string">&quot;Matched(&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="sbt.logic.Logic.Matched.type" id="sbt.logic.Logic.Matched">Matched</a> <a href="#sbt.logic.Logic.Matched" title="sbt.logic.Logic.Matched.type" class="delimiter">{</a>
    <span class="keyword">val</span> <a title="sbt.logic.Logic.Matched" id="sbt.logic.Logic.Matched.empty">empty</a> = <span title="sbt.logic.Logic.Matched" class="keyword">new</span> <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched">Matched</a><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">empty</span>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Separates a sequence of literals into `(pos, neg)` atom sequences. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(lits: Seq[sbt.logic.Literal])(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])" id="sbt.logic.Logic.separate">separate</a><span class="delimiter">(</span><a title="Seq[sbt.logic.Literal]" id="sbt.logic.Logic.separate.lits">lits</a>: <span title="Seq[sbt.logic.Literal]">Seq</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])" class="delimiter">(</span>Seq<span class="delimiter">[</span>Atom<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<a href="../Util.scala.html#sbt.Util.separate" title="(ps: Seq[sbt.logic.Literal])(f: sbt.logic.Literal =&gt; Either[sbt.logic.Atom,sbt.logic.Atom])(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])">separate</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.separate.lits" title="Seq[sbt.logic.Literal]">lits</a><span class="delimiter">)</span> <a href="#sbt.logic.Logic.separate.$anonfun.x0$2" title="Either[sbt.logic.Atom,sbt.logic.Atom]" class="delimiter">{</a>
    <span class="keyword">case</span> <a title="sbt.logic.Atom" id="sbt.logic.Logic.separate.$anonfun.a">a</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a>    =&gt; <span title="(a: sbt.logic.Atom)scala.util.Left[sbt.logic.Atom,Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.separate.$anonfun.a" title="sbt.logic.Atom">a</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Negated<span class="delimiter">(</span><a title="sbt.logic.Atom" id="sbt.logic.Logic.separate.$anonfun.n">n</a><span class="delimiter">)</span> =&gt; <span title="(b: sbt.logic.Atom)scala.util.Right[Nothing,sbt.logic.Atom]">Right</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.separate.$anonfun.n" title="sbt.logic.Atom">n</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Finds clauses that have no body and thus prove their head.
   * Returns `(&lt;proven atoms&gt;, &lt;remaining unproven clauses&gt;)`.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(c: sbt.logic.Clauses)(Set[sbt.logic.Atom], List[sbt.logic.Clause])" id="sbt.logic.Logic.findProven">findProven</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.findProven.c">c</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a><span class="delimiter">)</span>: <span title="(Set[sbt.logic.Atom], List[sbt.logic.Clause])" class="delimiter">(</span>Set<span class="delimiter">[</span>Atom<span class="delimiter">]</span>, List<span class="delimiter">[</span>Clause<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#sbt.logic.Logic.findProven.proven" title="(List[sbt.logic.Clause], List[sbt.logic.Clause])" class="delimiter">(</a><a href="#sbt.logic.Logic.findProven.x$9" title="List[sbt.logic.Clause]" id="sbt.logic.Logic.findProven.proven">proven</a>, <a href="#sbt.logic.Logic.findProven.x$9" title="List[sbt.logic.Clause]" id="sbt.logic.Logic.findProven.unproven">unproven</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.findProven.c" title="sbt.logic.Clauses">c</a>.<a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a>.<span title="(p: sbt.logic.Clause =&gt; Boolean)(List[sbt.logic.Clause], List[sbt.logic.Clause])">partition</span><span title="(List[sbt.logic.Clause], List[sbt.logic.Clause]) @unchecked" class="delimiter">(</span><a href="#sbt.logic.Logic.findProven.x$9.$anonfun.x$8" title="sbt.logic.Clause">_</a>.<a href="#sbt.logic;Clause.body" title="=&gt; sbt.logic.Formula">body</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a><span class="delimiter">)</span>
      <span title="(_1: scala.collection.immutable.Set[sbt.logic.Atom], _2: List[sbt.logic.Clause])(scala.collection.immutable.Set[sbt.logic.Atom], List[sbt.logic.Clause])" class="delimiter">(</span><a href="#sbt.logic.Logic.findProven.proven" title="List[sbt.logic.Clause]">proven</a>.<span title="(f: sbt.logic.Clause =&gt; scala.collection.GenTraversableOnce[sbt.logic.Atom])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.logic.Clause],sbt.logic.Atom,List[sbt.logic.Atom]])List[sbt.logic.Atom]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,sbt.logic.Atom,List[sbt.logic.Atom]]" class="delimiter">(</span><a href="#sbt.logic.Logic.findProven.$anonfun.x$10" title="sbt.logic.Clause">_</a>.<a href="#sbt.logic;Clause.head" title="=&gt; Set[sbt.logic.Atom]">head</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">toSet</span>, <a href="#sbt.logic.Logic.findProven.unproven" title="List[sbt.logic.Clause]">unproven</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(lits: Set[sbt.logic.Literal])Set[sbt.logic.Atom]" id="sbt.logic.Logic.keepPositive">keepPositive</a><span class="delimiter">(</span><a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.keepPositive.lits">lits</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> =
    <a href="#sbt.logic.Logic.keepPositive.lits" title="Set[sbt.logic.Literal]">lits</a>.<span title="(pf: PartialFunction[sbt.logic.Literal,sbt.logic.Atom])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.logic.Literal],sbt.logic.Atom,scala.collection.immutable.Set[sbt.logic.Atom]])scala.collection.immutable.Set[sbt.logic.Atom]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[sbt.logic.Literal,sbt.logic.Atom] with Serializable" id="sbt.logic.Logic.keepPositive;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <a title="sbt.logic.Atom" id="sbt.logic.Logic.keepPositive;$anonfun.isDefinedAt.a">a</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a> =&gt; <a href="#sbt.logic.Logic.keepPositive;$anonfun.isDefinedAt.a" title="sbt.logic.Atom">a</a> <span class="delimiter">}</span>.<span title="scala.collection.immutable.Set[sbt.logic.Atom]">toSet</span>

  <span class="comment">// precondition: factsToProcess contains no contradictions</span>
  @tailrec
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(clauses: sbt.logic.Clauses, factsToProcess: Set[sbt.logic.Literal], state: sbt.logic.Logic.Matched)sbt.logic.Logic.Matched" id="sbt.logic.Logic.reduce0">reduce0</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.reduce0.clauses">clauses</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a>, <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.reduce0.factsToProcess">factsToProcess</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span>, <a title="sbt.logic.Logic.Matched" id="sbt.logic.Logic.reduce0.state">state</a>: <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched">Matched</a><span class="delimiter">)</span>: <a href="#sbt.logic.Logic;Matched" title="sbt.logic.Logic.Matched">Matched</a> =
    <a href="#sbt.logic.Logic.applyAll(b3c87b29cc)" title="(cs: sbt.logic.Clauses, facts: Set[sbt.logic.Literal])Option[sbt.logic.Clauses]">applyAll</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.clauses" title="sbt.logic.Clauses">clauses</a>, <a href="#sbt.logic.Logic.reduce0.factsToProcess" title="Set[sbt.logic.Literal]">factsToProcess</a><span class="delimiter">)</span> <span title="sbt.logic.Logic.Matched" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <span class="comment">// all of the remaining clauses failed on the new facts</span>
        <a href="#sbt.logic.Logic.reduce0.state" title="sbt.logic.Logic.Matched">state</a>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.reduce0.applied">applied</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a href="#sbt.logic.Logic.reduce0.proven" title="(Set[sbt.logic.Atom], List[sbt.logic.Clause])" class="delimiter">(</a><a href="#sbt.logic.Logic.reduce0.x$11" title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.reduce0.proven">proven</a>, <a href="#sbt.logic.Logic.reduce0.x$11" title="List[sbt.logic.Clause]" id="sbt.logic.Logic.reduce0.unprovenClauses">unprovenClauses</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.findProven" title="(c: sbt.logic.Clauses)(Set[sbt.logic.Atom], List[sbt.logic.Clause])">findProven</a><span title="(Set[sbt.logic.Atom], List[sbt.logic.Clause]) @unchecked" class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.applied" title="sbt.logic.Clauses">applied</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="sbt.logic.Logic.Matched" id="sbt.logic.Logic.reduce0.processedFacts">processedFacts</a> = <a href="#sbt.logic.Logic.reduce0.state" title="sbt.logic.Logic.Matched">state</a> <a href="#sbt.logic.Logic;Matched.add(0d116b2e54)" title="(atoms: Set[sbt.logic.Atom])sbt.logic.Logic.Matched">add</a> <a href="#sbt.logic.Logic.keepPositive" title="(lits: Set[sbt.logic.Literal])Set[sbt.logic.Atom]">keepPositive</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.factsToProcess" title="Set[sbt.logic.Literal]">factsToProcess</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.reduce0.newlyProven">newlyProven</a> = <a href="#sbt.logic.Logic.reduce0.proven" title="Set[sbt.logic.Atom]">proven</a> <span title="(xs: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">--</span> <a href="#sbt.logic.Logic.reduce0.processedFacts" title="sbt.logic.Logic.Matched">processedFacts</a>.<a href="#sbt.logic.Logic;Matched.provenSet" title="=&gt; Set[sbt.logic.Atom]">provenSet</a>
        <span class="keyword">val</span> <a title="sbt.logic.Logic.Matched" id="sbt.logic.Logic.reduce0.newState">newState</a> = <a href="#sbt.logic.Logic.reduce0.processedFacts" title="sbt.logic.Logic.Matched">processedFacts</a> <a href="#sbt.logic.Logic;Matched.add(0d116b2e54)" title="(atoms: Set[sbt.logic.Atom])sbt.logic.Logic.Matched">add</a> <a href="#sbt.logic.Logic.reduce0.newlyProven" title="scala.collection.immutable.Set[sbt.logic.Atom]">newlyProven</a>
        <span title="sbt.logic.Logic.Matched" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.unprovenClauses" title="List[sbt.logic.Clause]">unprovenClauses</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <a href="#sbt.logic.Logic.reduce0.newState" title="sbt.logic.Logic.Matched">newState</a> <span class="comment">// no remaining clauses, done.</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="sbt.logic.Clauses" id="sbt.logic.Logic.reduce0.unproven">unproven</a> = <a href="#sbt.logic.Clauses.readResolve" title="(clauses: List[sbt.logic.Clause])sbt.logic.Clauses">Clauses</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.unprovenClauses" title="List[sbt.logic.Clause]">unprovenClauses</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.reduce0.nextFacts">nextFacts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <span title="scala.collection.immutable.Set[sbt.logic.Literal]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.newlyProven" title="scala.collection.immutable.Set[sbt.logic.Atom]">newlyProven</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#sbt.logic.Logic.reduce0.newlyProven" title="scala.collection.immutable.Set[sbt.logic.Atom]">newlyProven</a>.<span title="scala.collection.immutable.Set[sbt.logic.Literal]">toSet</span> <span class="keyword">else</span> <a href="#sbt.logic.Logic.inferFailure" title="(clauses: sbt.logic.Clauses)Set[sbt.logic.Literal]">inferFailure</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.unproven" title="sbt.logic.Clauses">unproven</a><span class="delimiter">)</span>
          <a href="#sbt.logic.Logic.reduce0" title="(clauses: sbt.logic.Clauses, factsToProcess: Set[sbt.logic.Literal], state: sbt.logic.Logic.Matched)sbt.logic.Logic.Matched">reduce0</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.reduce0.unproven" title="sbt.logic.Clauses">unproven</a>, <a href="#sbt.logic.Logic.reduce0.nextFacts" title="Set[sbt.logic.Literal]">nextFacts</a>, <a href="#sbt.logic.Logic.reduce0.newState" title="sbt.logic.Logic.Matched">newState</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Finds negated atoms under the negation as failure rule and returns them.
   * This should be called only after there are no more known atoms to be substituted.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(clauses: sbt.logic.Clauses)Set[sbt.logic.Literal]" id="sbt.logic.Logic.inferFailure">inferFailure</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.inferFailure.clauses">clauses</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a><span class="delimiter">)</span>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="comment">/* At this point, there is at least one clause and one of the following is the case as the result of the acyclic negation rule:
				i. there is at least one variable that occurs in a clause body but not in the head of a clause
				ii. there is at least one variable that occurs in the head of a clause and does not transitively depend on a negated variable
			In either case, each such variable x cannot be proven true and therefore proves 'not x' (negation as failure, !x in the code).
		*/</span>
      <span class="keyword">val</span> <a title="sbt.logic.Logic.Atoms" id="sbt.logic.Logic.inferFailure.allAtoms">allAtoms</a> = <a href="#sbt.logic.Logic.atoms(8961cb1e56)" title="(cs: sbt.logic.Clauses)sbt.logic.Logic.Atoms">atoms</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.inferFailure.clauses" title="sbt.logic.Clauses">clauses</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.inferFailure.newFacts">newFacts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.negated" title="(atoms: Set[sbt.logic.Atom])Set[sbt.logic.Literal]">negated</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.inferFailure.allAtoms" title="sbt.logic.Logic.Atoms">allAtoms</a>.<a href="#sbt.logic.Logic;Atoms.triviallyFalse" title="=&gt; Set[sbt.logic.Atom]">triviallyFalse</a><span class="delimiter">)</span>
      <span title="Set[sbt.logic.Literal]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.inferFailure.newFacts" title="Set[sbt.logic.Literal]">newFacts</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
        <a href="#sbt.logic.Logic.inferFailure.newFacts" title="Set[sbt.logic.Literal]">newFacts</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[sbt.logic.Atom]" id="sbt.logic.Logic.inferFailure.possiblyTrue">possiblyTrue</a> = <a href="#sbt.logic.Logic.hasNegatedDependency" title="(clauses: Seq[sbt.logic.Clause], posDeps: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], negDeps: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])List[sbt.logic.Atom]">hasNegatedDependency</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.inferFailure.clauses" title="sbt.logic.Clauses">clauses</a>.<a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a>, <a href="../Relation.scala.html#sbt.Relation" title="sbt.Relation.type">Relation</a>.<a href="../Relation.scala.html#sbt.Relation.empty" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">empty</a>, <a href="../Relation.scala.html#sbt.Relation" title="sbt.Relation.type">Relation</a>.<a href="../Relation.scala.html#sbt.Relation.empty" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">empty</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.inferFailure.newlyFalse">newlyFalse</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.negated" title="(atoms: Set[sbt.logic.Atom])Set[sbt.logic.Literal]">negated</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.inferFailure.allAtoms" title="sbt.logic.Logic.Atoms">allAtoms</a>.<a href="#sbt.logic.Logic;Atoms.inHead" title="=&gt; Set[sbt.logic.Atom]">inHead</a> <span title="(xs: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">--</span> <a href="#sbt.logic.Logic.inferFailure.possiblyTrue" title="List[sbt.logic.Atom]">possiblyTrue</a><span class="delimiter">)</span>
        <span title="Set[sbt.logic.Literal]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.inferFailure.newlyFalse" title="Set[sbt.logic.Literal]">newlyFalse</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
          <a href="#sbt.logic.Logic.inferFailure.newlyFalse" title="Set[sbt.logic.Literal]">newlyFalse</a>
        <span class="keyword">else</span> <span class="comment">// should never happen due to the acyclic negation rule</span>
          sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;No progress:\\n\\tclauses: &quot;)">No progress:\n\tclauses: $</span><a href="#sbt.logic.Logic.inferFailure.clauses" title="sbt.logic.Clauses">clauses</a><span title="String(&quot;\\n\\tpossibly true: &quot;)">\n\tpossibly true: $</span><a href="#sbt.logic.Logic.inferFailure.possiblyTrue" title="List[sbt.logic.Atom]">possiblyTrue</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(atoms: Set[sbt.logic.Atom])Set[sbt.logic.Literal]" id="sbt.logic.Logic.negated">negated</a><span class="delimiter">(</span><a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.negated.atoms">atoms</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.negated.atoms" title="Set[sbt.logic.Atom]">atoms</a>.<span title="(f: sbt.logic.Atom =&gt; sbt.logic.Negated)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.logic.Atom],sbt.logic.Negated,Set[sbt.logic.Literal]])Set[sbt.logic.Literal]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,sbt.logic.Literal,scala.collection.immutable.Set[sbt.logic.Literal]]" class="delimiter">(</span><a title="sbt.logic.Atom" id="sbt.logic.Logic.negated.$anonfun.a">a</a> =&gt; <a href="#sbt.logic.Negated.readResolve" title="(atom: sbt.logic.Atom)sbt.logic.Negated">Negated</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.negated.$anonfun.a" title="sbt.logic.Atom">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Computes the set of atoms in `clauses` that directly or transitively take a negated atom as input.
   * For example, for the following clauses, this method would return `List(a, d)` :
   *  a :- b, not c
   *  d :- a
   */</span>
  @tailrec
  <span class="keyword">def</span> <a title="(clauses: Seq[sbt.logic.Clause], posDeps: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], negDeps: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])List[sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency">hasNegatedDependency</a><span class="delimiter">(</span><a title="Seq[sbt.logic.Clause]" id="sbt.logic.Logic.hasNegatedDependency.clauses">clauses</a>: <span title="Seq[sbt.logic.Clause]">Seq</span><span class="delimiter">[</span>Clause<span class="delimiter">]</span>, <a title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.posDeps">posDeps</a>: <a href="../Relation.scala.html#sbt;Relation" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">Relation</a><span class="delimiter">[</span>Atom, Atom<span class="delimiter">]</span>, <a title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.negDeps">negDeps</a>: <a href="../Relation.scala.html#sbt;Relation" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">Relation</a><span class="delimiter">[</span>Atom, Atom<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[sbt.logic.Atom]">List</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> =
    <a href="#sbt.logic.Logic.hasNegatedDependency.clauses" title="Seq[sbt.logic.Clause]">clauses</a> <span title="List[sbt.logic.Atom]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#sbt.logic.Logic.hasNegatedDependency.<unapply-selector>" title="(x: Seq[sbt.logic.Clause])Some[Seq[sbt.logic.Clause]]">Seq</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
        <span class="comment">// because cycles between positive literals are allowed, this isn't strictly a topological sort</span>
        <a href="../Dag.scala.html#sbt.Dag" title="sbt.Dag.type">Dag</a>.<a href="../Dag.scala.html#sbt.Dag.topologicalSortUnchecked(99aedd81e8)" title="(nodes: Iterable[sbt.logic.Atom])(dependencies: sbt.logic.Atom =&gt; Iterable[sbt.logic.Atom])List[sbt.logic.Atom]">topologicalSortUnchecked</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.negDeps" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">negDeps</a>.<a href="../Relation.scala.html#sbt;Relation._1s" title="=&gt; scala.collection.Set[sbt.logic.Atom]">_1s</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.posDeps" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">posDeps</a>.<a href="../Relation.scala.html#sbt;Relation.reverse" title="(_2: sbt.logic.Atom)Set[sbt.logic.Atom]">reverse</a><span class="delimiter">)</span>
      <span class="keyword">case</span> Clause<span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.hasNegatedDependency.formula">formula</a>, <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.head">head</a><span class="delimiter">)</span> <a href="#sbt.logic.Logic.hasNegatedDependency.<unapply-selector>" title="(t: Seq[sbt.logic.Clause] with scala.collection.SeqLike[sbt.logic.Clause,Seq[sbt.logic.Clause]])Option[(sbt.logic.Clause, Seq[sbt.logic.Clause])]">+:</a> <a title="Seq[sbt.logic.Clause]" id="sbt.logic.Logic.hasNegatedDependency.tail">tail</a> =&gt;
        <span class="comment">// collect direct positive and negative literals and track them in separate graphs</span>
        <span class="keyword">val</span> <a href="#sbt.logic.Logic.hasNegatedDependency.pos" title="(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])" class="delimiter">(</a><a href="#sbt.logic.Logic.hasNegatedDependency.x$12" title="Seq[sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.pos">pos</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.x$12" title="Seq[sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.neg">neg</a><span class="delimiter">)</span> = <a href="#sbt.logic.Logic.directDeps" title="(formula: sbt.logic.Formula)(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])">directDeps</a><span title="(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom]) @unchecked" class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.formula" title="sbt.logic.Formula">formula</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a href="#sbt.logic.Logic.hasNegatedDependency.newPos" title="(sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])" class="delimiter">(</a><a href="#sbt.logic.Logic.hasNegatedDependency.x$14" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.newPos">newPos</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.x$14" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.newNeg">newNeg</a><span class="delimiter">)</span> = <span class="delimiter">(</span><span title="(_1: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], _2: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])(sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])" class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.posDeps" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">posDeps</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.negDeps" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">negDeps</a><span class="delimiter">)</span> <a href="#sbt.logic.Logic.hasNegatedDependency.x$14.x$13" title="(z: (sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]))(op: ((sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]), sbt.logic.Atom) =&gt; (sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]))(sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])">/:</a> <a href="#sbt.logic.Logic.hasNegatedDependency.head" title="Set[sbt.logic.Atom]">head</a><span class="delimiter">)</span> <a href="#sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.x0$3" title="(sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])" class="delimiter">{</a>
          <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.pdeps">pdeps</a>, <a title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]" id="sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.ndeps">ndeps</a><span class="delimiter">)</span>, <a title="sbt.logic.Atom" id="sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.d">d</a><span class="delimiter">)</span> =&gt;
            <span title="(_1: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], _2: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])(sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])" class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.pdeps" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">pdeps</a> <a href="../Relation.scala.html#sbt;Relation.+(743958e096)" title="(a: sbt.logic.Atom, bs: Traversable[sbt.logic.Atom])sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">+</a> <span class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.d" title="sbt.logic.Atom">d</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.pos" title="Seq[sbt.logic.Atom]">pos</a><span class="delimiter">)</span>, <a href="#sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.ndeps" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">ndeps</a> <a href="../Relation.scala.html#sbt;Relation.+(743958e096)" title="(a: sbt.logic.Atom, bs: Traversable[sbt.logic.Atom])sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">+</a> <span class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.x$14.$anonfun.d" title="sbt.logic.Atom">d</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.neg" title="Seq[sbt.logic.Atom]">neg</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#sbt.logic.Logic.hasNegatedDependency" title="(clauses: Seq[sbt.logic.Clause], posDeps: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom], negDeps: sbt.Relation[sbt.logic.Atom,sbt.logic.Atom])List[sbt.logic.Atom]">hasNegatedDependency</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.hasNegatedDependency.tail" title="Seq[sbt.logic.Clause]">tail</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.newPos" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">newPos</a>, <a href="#sbt.logic.Logic.hasNegatedDependency.newNeg" title="sbt.Relation[sbt.logic.Atom,sbt.logic.Atom]">newNeg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Computes the `(positive, negative)` literals in `formula`. */</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(formula: sbt.logic.Formula)(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])" id="sbt.logic.Logic.directDeps">directDeps</a><span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.directDeps.formula">formula</a>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a><span class="delimiter">)</span>: <span title="(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])" class="delimiter">(</span>Seq<span class="delimiter">[</span>Atom<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="../Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<a href="../Util.scala.html#sbt.Util.separate" title="(ps: Seq[sbt.logic.Literal])(f: sbt.logic.Literal =&gt; Either[sbt.logic.Atom,sbt.logic.Atom])(Seq[sbt.logic.Atom], Seq[sbt.logic.Atom])">separate</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.literals" title="(formula: sbt.logic.Formula)Set[sbt.logic.Literal]">literals</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.directDeps.formula" title="sbt.logic.Formula">formula</a><span class="delimiter">)</span>.<span title="=&gt; Seq[sbt.logic.Literal]">toSeq</span><span class="delimiter">)</span> <a href="#sbt.logic.Logic.directDeps.$anonfun.x0$4" title="Either[sbt.logic.Atom,sbt.logic.Atom]" class="delimiter">{</a>
      <span class="keyword">case</span> Negated<span class="delimiter">(</span><span title="sbt.logic.Atom">a</span><span class="delimiter">)</span> =&gt; <span title="(b: sbt.logic.Atom)scala.util.Right[Nothing,sbt.logic.Atom]">Right</span><span class="delimiter">(</span><span title="sbt.logic.Atom">a</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="sbt.logic.Atom">a</span>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a>    =&gt; <span title="(a: sbt.logic.Atom)scala.util.Left[sbt.logic.Atom,Nothing]">Left</span><span class="delimiter">(</span><span title="sbt.logic.Atom">a</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(formula: sbt.logic.Formula)Set[sbt.logic.Literal]" id="sbt.logic.Logic.literals">literals</a><span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.literals.formula">formula</a>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a><span class="delimiter">)</span>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.literals.formula" title="sbt.logic.Formula">formula</a> <span title="Set[sbt.logic.Literal]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.literals.lits">lits</a><span class="delimiter">)</span>  =&gt; <a href="#sbt.logic.Logic.literals.lits" title="Set[sbt.logic.Literal]">lits</a>
    <span class="keyword">case</span> <a title="sbt.logic.Literal" id="sbt.logic.Logic.literals.l">l</a>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a> =&gt; <span title="(elems: sbt.logic.Literal*)scala.collection.immutable.Set[sbt.logic.Literal]">Set</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.literals.l" title="sbt.logic.Literal">l</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a>       =&gt; <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[sbt.logic.Literal]">empty</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Computes the atoms in the heads and bodies of the clauses in `clause`. */</span>
  <span class="keyword">def</span> <a title="(cs: sbt.logic.Clauses)sbt.logic.Logic.Atoms" id="sbt.logic.Logic.atoms(8961cb1e56)">atoms</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.atoms(8961cb1e56).cs">cs</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a><span class="delimiter">)</span>: <a href="#sbt.logic.Logic.Atoms.readResolve" title="sbt.logic.Logic.Atoms">Atoms</a> = <a href="#sbt.logic.Logic.atoms(8961cb1e56).cs" title="sbt.logic.Clauses">cs</a>.<a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a>.<span title="(f: sbt.logic.Clause =&gt; sbt.logic.Logic.Atoms)(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.logic.Clause],sbt.logic.Logic.Atoms,List[sbt.logic.Logic.Atoms]])List[sbt.logic.Logic.Atoms]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,sbt.logic.Logic.Atoms,List[sbt.logic.Logic.Atoms]]" class="delimiter">(</span><a title="sbt.logic.Clause" id="sbt.logic.Logic.atoms(8961cb1e56).$anonfun.c">c</a> =&gt; <a href="#sbt.logic.Logic.Atoms.readResolve" title="(inHead: Set[sbt.logic.Atom], inFormula: Set[sbt.logic.Atom])sbt.logic.Logic.Atoms">Atoms</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.atoms(8961cb1e56).$anonfun.c" title="sbt.logic.Clause">c</a>.<a href="#sbt.logic;Clause.head" title="=&gt; Set[sbt.logic.Atom]">head</a>, <a href="#sbt.logic.Logic.atoms(2691e75f9a)" title="(formula: sbt.logic.Formula)Set[sbt.logic.Atom]">atoms</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.atoms(8961cb1e56).$anonfun.c" title="sbt.logic.Clause">c</a>.<a href="#sbt.logic;Clause.body" title="=&gt; sbt.logic.Formula">body</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(op: (sbt.logic.Logic.Atoms, sbt.logic.Logic.Atoms) =&gt; sbt.logic.Logic.Atoms)sbt.logic.Logic.Atoms">reduce</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.atoms(8961cb1e56).$anonfun.x$15" title="sbt.logic.Logic.Atoms">_</a> <a href="#sbt.logic.Logic;Atoms.++" title="(as: sbt.logic.Logic.Atoms)sbt.logic.Logic.Atoms">++</a> <a href="#sbt.logic.Logic.atoms(8961cb1e56).$anonfun.x$16" title="sbt.logic.Logic.Atoms">_</a><span class="delimiter">)</span>

  <span class="comment">/** Computes the set of all atoms in `formula`. */</span>
  <span class="keyword">def</span> <a title="(formula: sbt.logic.Formula)Set[sbt.logic.Atom]" id="sbt.logic.Logic.atoms(2691e75f9a)">atoms</a><span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.atoms(2691e75f9a).formula">formula</a>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a><span class="delimiter">)</span>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.atoms(2691e75f9a).formula" title="sbt.logic.Formula">formula</a> <span title="Set[sbt.logic.Atom]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.atoms(2691e75f9a).lits">lits</a><span class="delimiter">)</span>    =&gt; <a href="#sbt.logic.Logic.atoms(2691e75f9a).lits" title="Set[sbt.logic.Literal]">lits</a>.<span title="(f: sbt.logic.Literal =&gt; sbt.logic.Atom)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.logic.Literal],sbt.logic.Atom,Set[sbt.logic.Atom]])Set[sbt.logic.Atom]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,sbt.logic.Atom,scala.collection.immutable.Set[sbt.logic.Atom]]" class="delimiter">(</span><a href="#sbt.logic.Logic.atoms(2691e75f9a).$anonfun.x$17" title="sbt.logic.Literal">_</a>.<a href="#sbt.logic;Literal.atom" title="=&gt; sbt.logic.Atom">atom</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Negated<span class="delimiter">(</span><a title="sbt.logic.Atom" id="sbt.logic.Logic.atoms(2691e75f9a).lit">lit</a><span class="delimiter">)</span> =&gt; <span title="(elems: sbt.logic.Atom*)scala.collection.immutable.Set[sbt.logic.Atom]">Set</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.atoms(2691e75f9a).lit" title="sbt.logic.Atom">lit</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.logic.Atom" id="sbt.logic.Logic.atoms(2691e75f9a).a">a</a>: <a href="#sbt.logic.Atom.readResolve" title="sbt.logic.Atom">Atom</a>      =&gt; <span title="(elems: sbt.logic.Atom*)scala.collection.immutable.Set[sbt.logic.Atom]">Set</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.atoms(2691e75f9a).a" title="sbt.logic.Atom">a</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a>         =&gt; <span title="(elems: sbt.logic.Atom*)scala.collection.immutable.Set[sbt.logic.Atom]">Set</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Represents the set of atoms in the heads of clauses and in the bodies (formulas) of clauses. */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Atoms extends AnyRef with Product with Serializable" id="sbt.logic.Logic.Atoms.readResolve">Atoms</a><a href="#sbt.logic.Logic.Atoms.readResolve" title="Product" class="delimiter">(</a><span class="keyword">val</span> <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic;Atoms.inHead">inHead</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Set[sbt.logic.Atom]" id="sbt.logic.Logic;Atoms.inFormula">inFormula</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/** Concatenates this with `as`. */</span>
    <span class="keyword">def</span> <a title="(as: sbt.logic.Logic.Atoms)sbt.logic.Logic.Atoms" id="sbt.logic.Logic;Atoms.++">++</a><span class="delimiter">(</span><a title="sbt.logic.Logic.Atoms" id="sbt.logic.Logic;Atoms.++.as">as</a>: <a href="#sbt.logic.Logic.Atoms.readResolve" title="sbt.logic.Logic.Atoms">Atoms</a><span class="delimiter">)</span>: <a href="#sbt.logic.Logic.Atoms.readResolve" title="sbt.logic.Logic.Atoms">Atoms</a> = <a href="#sbt.logic.Logic.Atoms.readResolve" title="(inHead: Set[sbt.logic.Atom], inFormula: Set[sbt.logic.Atom])sbt.logic.Logic.Atoms">Atoms</a><span class="delimiter">(</span><a href="#sbt.logic.Logic;Atoms.inHead" title="=&gt; Set[sbt.logic.Atom]">inHead</a> <span title="(elems: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">++</span> <a href="#sbt.logic.Logic;Atoms.++.as" title="sbt.logic.Logic.Atoms">as</a>.<a href="#sbt.logic.Logic;Atoms.inHead" title="=&gt; Set[sbt.logic.Atom]">inHead</a>, <a href="#sbt.logic.Logic;Atoms.inFormula" title="=&gt; Set[sbt.logic.Atom]">inFormula</a> <span title="(elems: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">++</span> <a href="#sbt.logic.Logic;Atoms.++.as" title="sbt.logic.Logic.Atoms">as</a>.<a href="#sbt.logic.Logic;Atoms.inFormula" title="=&gt; Set[sbt.logic.Atom]">inFormula</a><span class="delimiter">)</span>
    <span class="comment">/** Atoms that cannot be true because they do not occur in a head. */</span>
    <span class="keyword">def</span> <a title="=&gt; Set[sbt.logic.Atom]" id="sbt.logic.Logic;Atoms.triviallyFalse">triviallyFalse</a>: <span title="Set[sbt.logic.Atom]">Set</span><span class="delimiter">[</span>Atom<span class="delimiter">]</span> = <a href="#sbt.logic.Logic;Atoms.inFormula" title="=&gt; Set[sbt.logic.Atom]">inFormula</a> <span title="(xs: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">--</span> <a href="#sbt.logic.Logic;Atoms.inHead" title="=&gt; Set[sbt.logic.Atom]">inHead</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Applies known facts to `clause`s, deriving a new, possibly empty list of clauses.
   * 1. If a fact is in the body of a clause, the derived clause has that fact removed from the body.
   * 2. If the negation of a fact is in a body of a clause, that clause fails and is removed.
   * 3. If a fact or its negation is in the head of a clause, the derived clause has that fact (or its negation) removed from the head.
   * 4. If a head is empty, the clause proves nothing and is removed.
   *
   * NOTE: empty bodies do not cause a clause to succeed yet.
   *       All known facts must be applied before this can be done in order to avoid inconsistencies.
   * Precondition: no contradictions in `facts`
   * Postcondition: no atom in `facts` is present in the result
   * Postcondition: No clauses have an empty head
   */</span>
  <span class="keyword">def</span> <a title="(cs: sbt.logic.Clauses, facts: Set[sbt.logic.Literal])Option[sbt.logic.Clauses]" id="sbt.logic.Logic.applyAll(b3c87b29cc)">applyAll</a><span class="delimiter">(</span><a title="sbt.logic.Clauses" id="sbt.logic.Logic.applyAll(b3c87b29cc).cs">cs</a>: <a href="#sbt.logic.Clauses.readResolve" title="sbt.logic.Clauses">Clauses</a>, <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.applyAll(b3c87b29cc).facts">facts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[sbt.logic.Clauses]">Option</span><span class="delimiter">[</span>Clauses<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[sbt.logic.Clause]" id="sbt.logic.Logic.applyAll(b3c87b29cc).newClauses">newClauses</a> =
        <span title="List[sbt.logic.Clause]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(b3c87b29cc).facts" title="Set[sbt.logic.Literal]">facts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <a href="#sbt.logic.Logic.applyAll(b3c87b29cc).cs" title="sbt.logic.Clauses">cs</a>.<a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a>.<span title="(p: sbt.logic.Clause =&gt; Boolean)List[sbt.logic.Clause]">filter</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(b3c87b29cc).newClauses.$anonfun.x$18" title="sbt.logic.Clause">_</a>.<a href="#sbt.logic;Clause.head" title="=&gt; Set[sbt.logic.Atom]">head</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="comment">// still need to drop clauses with an empty head</span>
        <span class="keyword">else</span>
          <a href="#sbt.logic.Logic.applyAll(b3c87b29cc).cs" title="sbt.logic.Clauses">cs</a>.<a href="#sbt.logic;Clauses.clauses" title="=&gt; List[sbt.logic.Clause]">clauses</a>.<span title="(f: sbt.logic.Clause =&gt; Option[sbt.logic.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[List[sbt.logic.Clause],Option[sbt.logic.Clause],List[Option[sbt.logic.Clause]]])List[Option[sbt.logic.Clause]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Option[sbt.logic.Clause],List[Option[sbt.logic.Clause]]]" class="delimiter">(</span><a title="sbt.logic.Clause" id="sbt.logic.Logic.applyAll(b3c87b29cc).newClauses.$anonfun.c">c</a> =&gt; <a href="#sbt.logic.Logic.applyAll(95aeb00767)" title="(c: sbt.logic.Clause, facts: Set[sbt.logic.Literal])Option[sbt.logic.Clause]">applyAll</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(b3c87b29cc).newClauses.$anonfun.c" title="sbt.logic.Clause">c</a>, <a href="#sbt.logic.Logic.applyAll(b3c87b29cc).facts" title="Set[sbt.logic.Literal]">facts</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: Option[sbt.logic.Clause] =&gt; scala.collection.GenTraversableOnce[sbt.logic.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[List[Option[sbt.logic.Clause]],sbt.logic.Clause,List[sbt.logic.Clause]])List[sbt.logic.Clause]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,sbt.logic.Clause,List[sbt.logic.Clause]]" class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(b3c87b29cc).newClauses.$anonfun.x$19" title="Option[sbt.logic.Clause]">_</a>.<span title="=&gt; List[sbt.logic.Clause]">toList</span><span class="delimiter">)</span>
      <span title="Option[sbt.logic.Clauses]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(b3c87b29cc).newClauses" title="List[sbt.logic.Clause]">newClauses</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="None.type">None</span> <span class="keyword">else</span> <span title="(x: sbt.logic.Clauses)Some[sbt.logic.Clauses]">Some</span><span class="delimiter">(</span><a href="#sbt.logic.Clauses.readResolve" title="(clauses: List[sbt.logic.Clause])sbt.logic.Clauses">Clauses</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(b3c87b29cc).newClauses" title="List[sbt.logic.Clause]">newClauses</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(c: sbt.logic.Clause, facts: Set[sbt.logic.Literal])Option[sbt.logic.Clause]" id="sbt.logic.Logic.applyAll(95aeb00767)">applyAll</a><span class="delimiter">(</span><a title="sbt.logic.Clause" id="sbt.logic.Logic.applyAll(95aeb00767).c">c</a>: <a href="#sbt.logic.Clause.readResolve" title="sbt.logic.Clause">Clause</a>, <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.applyAll(95aeb00767).facts">facts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[sbt.logic.Clause]">Option</span><span class="delimiter">[</span>Clause<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.applyAll(95aeb00767).atoms">atoms</a> = <a href="#sbt.logic.Logic.applyAll(95aeb00767).facts" title="Set[sbt.logic.Literal]">facts</a>.<span title="(f: sbt.logic.Literal =&gt; sbt.logic.Atom)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.logic.Literal],sbt.logic.Atom,scala.collection.immutable.Set[sbt.logic.Atom]])scala.collection.immutable.Set[sbt.logic.Atom]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,sbt.logic.Atom,scala.collection.immutable.Set[sbt.logic.Atom]]" class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(95aeb00767).atoms.$anonfun.x$20" title="sbt.logic.Literal">_</a>.<a href="#sbt.logic;Literal.atom" title="=&gt; sbt.logic.Atom">atom</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.logic.Atom]" id="sbt.logic.Logic.applyAll(95aeb00767).newHead">newHead</a> = <a href="#sbt.logic.Logic.applyAll(95aeb00767).c" title="sbt.logic.Clause">c</a>.<a href="#sbt.logic;Clause.head" title="=&gt; Set[sbt.logic.Atom]">head</a> <span title="(xs: scala.collection.GenTraversableOnce[sbt.logic.Atom])scala.collection.immutable.Set[sbt.logic.Atom]">--</span> <a href="#sbt.logic.Logic.applyAll(95aeb00767).atoms" title="scala.collection.immutable.Set[sbt.logic.Atom]">atoms</a> <span class="comment">// 3.</span>
      <span title="Option[sbt.logic.Clause]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(95aeb00767).newHead" title="scala.collection.immutable.Set[sbt.logic.Atom]">newHead</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="comment">// 4. empty head</span>
        <span title="None.type">None</span>
      <span class="keyword">else</span>
        <a href="#sbt.logic.Logic.substitute" title="(formula: sbt.logic.Formula, facts: Set[sbt.logic.Literal])Option[sbt.logic.Formula]">substitute</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(95aeb00767).c" title="sbt.logic.Clause">c</a>.<a href="#sbt.logic;Clause.body" title="=&gt; sbt.logic.Formula">body</a>, <a href="#sbt.logic.Logic.applyAll(95aeb00767).facts" title="Set[sbt.logic.Literal]">facts</a><span class="delimiter">)</span>.<span title="(f: sbt.logic.Formula =&gt; sbt.logic.Clause)Option[sbt.logic.Clause]">map</span><span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.applyAll(95aeb00767).$anonfun.f">f</a> =&gt; <a href="#sbt.logic.Clause.readResolve" title="(body: sbt.logic.Formula, head: Set[sbt.logic.Atom])sbt.logic.Clause">Clause</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.applyAll(95aeb00767).$anonfun.f" title="sbt.logic.Formula">f</a>, <a href="#sbt.logic.Logic.applyAll(95aeb00767).newHead" title="scala.collection.immutable.Set[sbt.logic.Atom]">newHead</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// 1, 2</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Derives the formula that results from substituting `facts` into `formula`. */</span>
  @tailrec
  <span class="keyword">def</span> <a title="(formula: sbt.logic.Formula, facts: Set[sbt.logic.Literal])Option[sbt.logic.Formula]" id="sbt.logic.Logic.substitute">substitute</a><span class="delimiter">(</span><a title="sbt.logic.Formula" id="sbt.logic.Logic.substitute.formula">formula</a>: <a href="#sbt.logic;Formula" title="sbt.logic.Formula">Formula</a>, <a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.substitute.facts">facts</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[sbt.logic.Formula]">Option</span><span class="delimiter">[</span>Formula<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.substitute.formula" title="sbt.logic.Formula">formula</a> <span title="Option[sbt.logic.Formula]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> And<span class="delimiter">(</span><a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.substitute.lits">lits</a><span class="delimiter">)</span> =&gt;
      <span class="keyword">def</span> <a title="(lits: Set[sbt.logic.Literal])Set[sbt.logic.Literal]" id="sbt.logic.Logic.substitute.negated">negated</a><span class="delimiter">(</span><a title="Set[sbt.logic.Literal]" id="sbt.logic.Logic.substitute.negated.lits">lits</a>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[sbt.logic.Literal]">Set</span><span class="delimiter">[</span>Literal<span class="delimiter">]</span> = <a href="#sbt.logic.Logic.substitute.negated.lits" title="Set[sbt.logic.Literal]">lits</a>.<span title="(f: sbt.logic.Literal =&gt; sbt.logic.Literal)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[sbt.logic.Literal],sbt.logic.Literal,Set[sbt.logic.Literal]])Set[sbt.logic.Literal]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,sbt.logic.Literal,scala.collection.immutable.Set[sbt.logic.Literal]]" class="delimiter">(</span><a title="sbt.logic.Literal" id="sbt.logic.Logic.substitute.negated.$anonfun.a">a</a> =&gt; <a href="#sbt.logic;Literal.unary_!" title="=&gt; sbt.logic.Literal">!</a><a href="#sbt.logic.Logic.substitute.negated.$anonfun.a" title="sbt.logic.Literal">a</a><span class="delimiter">)</span>
      <span title="Option[sbt.logic.Formula]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.lits" title="Set[sbt.logic.Literal]">lits</a>.<span title="(p: sbt.logic.Literal =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.negated" title="(lits: Set[sbt.logic.Literal])Set[sbt.logic.Literal]">negated</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.facts" title="Set[sbt.logic.Literal]">facts</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// 2.</span>
        <span title="None.type">None</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[sbt.logic.Literal]" id="sbt.logic.Logic.substitute.newLits">newLits</a> = <a href="#sbt.logic.Logic.substitute.lits" title="Set[sbt.logic.Literal]">lits</a> <span title="(xs: scala.collection.GenTraversableOnce[sbt.logic.Literal])scala.collection.immutable.Set[sbt.logic.Literal]">--</span> <a href="#sbt.logic.Logic.substitute.facts" title="Set[sbt.logic.Literal]">facts</a>
        <span class="keyword">val</span> <a title="logic extends Product with Serializable with sbt.logic.Formula" id="sbt.logic.Logic.substitute.newF">newF</a> = <span title="logic extends Product with Serializable with sbt.logic.Formula" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.newLits" title="scala.collection.immutable.Set[sbt.logic.Literal]">newLits</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a> <span class="keyword">else</span> <a href="#sbt.logic.Formula.And.readResolve" title="(literals: Set[sbt.logic.Literal])sbt.logic.Formula.And">And</a><span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.newLits" title="scala.collection.immutable.Set[sbt.logic.Literal]">newLits</a><span class="delimiter">)</span>
        <span title="(x: Product with Serializable with sbt.logic.Formula)Some[Product with Serializable with sbt.logic.Formula]">Some</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.newF" title="logic extends Product with Serializable with sbt.logic.Formula">newF</a><span class="delimiter">)</span> <span class="comment">// 1.</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a> =&gt; <span title="(x: sbt.logic.Formula.True.type)Some[sbt.logic.Formula.True.type]">Some</span><span class="delimiter">(</span><a href="#sbt.logic.Formula.True.readResolve" title="sbt.logic.Formula.True.type">True</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.logic.Literal" id="sbt.logic.Logic.substitute.lit">lit</a>: <a href="#sbt.logic;Literal" title="sbt.logic.Literal">Literal</a> =&gt; <span class="comment">// define in terms of And</span>
      <a href="#sbt.logic.Logic.substitute" title="(formula: sbt.logic.Formula, facts: Set[sbt.logic.Literal])Option[sbt.logic.Formula]">substitute</a><span class="delimiter">(</span><a href="#sbt.logic.Formula.And.readResolve" title="(literals: Set[sbt.logic.Literal])sbt.logic.Formula.And">And</a><span class="delimiter">(</span><span title="(elems: sbt.logic.Literal*)scala.collection.immutable.Set[sbt.logic.Literal]">Set</span><span class="delimiter">(</span><a href="#sbt.logic.Logic.substitute.lit" title="sbt.logic.Literal">lit</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#sbt.logic.Logic.substitute.facts" title="Set[sbt.logic.Literal]">facts</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
