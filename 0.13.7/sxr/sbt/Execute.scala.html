<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/Execute.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2010 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">import</span> <a href="ErrorHandling.scala.html#sbt.ErrorHandling" title="sbt.ErrorHandling.type">ErrorHandling</a>.wideConvert
<span class="keyword">import</span> <a href="Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>._
<span class="keyword">import</span> <a href="#sbt.Execute" title="sbt.Execute.type">Execute</a>._

<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> mutable, JavaConversions <span class="delimiter">}</span>
<span class="keyword">import</span> mutable.Map

<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.Execute.type" id="sbt.Execute">Execute</a> <a href="#sbt.Execute" title="sbt.Execute.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[A, B]=&gt; scala.collection.mutable.Map[A,B]" id="sbt.Execute.idMap">idMap</a><span class="delimiter">[</span><a title="" id="sbt.Execute.idMap;A">A</a>, <a title="" id="sbt.Execute.idMap;B">B</a><span class="delimiter">]</span>: <span title="scala.collection.mutable.Map[A,B]">Map</span><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <span title="scala.collection.JavaConversions.type">JavaConversions</span>.<span title="(m: java.util.Map[A,B])scala.collection.mutable.Map[A,B]">mapAsScalaMap</span><span class="delimiter">(</span><span title="java.util.IdentityHashMap[A,B]" class="keyword">new</span> java.util.<span title="java.util.IdentityHashMap[A,B]">IdentityHashMap</span><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[A[_], B[_]]=&gt; sbt.PMap[A,B]" id="sbt.Execute.pMap">pMap</a><span class="delimiter">[</span><a title="[_]" id="sbt.Execute.pMap;A">A</a><span class="delimiter">[</span><a title="" id="sbt.Execute.pMap;A;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt.Execute.pMap;B">B</a><span class="delimiter">[</span><a title="" id="sbt.Execute.pMap;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span>: <a href="PMap.scala.html#sbt;PMap" title="sbt.PMap[A,B]">PMap</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <span title="sbt.DelegatingPMap[A,B]" class="keyword">new</span> <a href="PMap.scala.html#sbt;DelegatingPMap" title="sbt.DelegatingPMap[A,B]">DelegatingPMap</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt.Execute.idMap" title="scala.collection.mutable.Map[A[_],B[_]]">idMap</a><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(p: =&gt; Unit)sbt.Completed" id="sbt.Execute.completed">completed</a><span class="delimiter">(</span><a title="=&gt; Unit" id="sbt.Execute.completed.p">p</a>: =&gt; Unit<span class="delimiter">)</span>: <a href="#sbt;Completed" title="sbt.Completed">Completed</a> = <a href="#sbt.Execute.completed;$anon" title="sbt.Completed" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.Completed" id="sbt.Execute.completed;$anon">Completed</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="()Unit" id="sbt.Execute.completed;$anon.process">process</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt.Execute.completed.p" title="=&gt; Unit">p</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[A[_]]=&gt; sbt.Triggers[A]" id="sbt.Execute.noTriggers">noTriggers</a><span class="delimiter">[</span><a title="[_]" id="sbt.Execute.noTriggers;A">A</a><span class="delimiter">[</span><a title="" id="sbt.Execute.noTriggers;A;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="sbt.Triggers[A]" class="keyword">new</span> <a href="#sbt;Triggers" title="sbt.Triggers[A]">Triggers</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><span title="scala.collection.mutable.Map.type">Map</span>.<span title="scala.collection.mutable.Map[A[_],Nothing]">empty</span>, <span title="scala.collection.mutable.Map.type">Map</span>.<span title="scala.collection.mutable.Map[A[_],Nothing]">empty</span>, <a href="TypeFunctions.scala.html#sbt;TypeFunctions.idFun" title="sbt.RMap[A,sbt.Result] =&gt; sbt.RMap[A,sbt.Result]">idFun</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(checkCycles: Boolean, overwriteNode: sbt.Incomplete =&gt; Boolean)sbt.Execute.Config" id="sbt.Execute.config">config</a><span class="delimiter">(</span><a title="Boolean" id="sbt.Execute.config.checkCycles">checkCycles</a>: <span title="Boolean">Boolean</span>, <a title="sbt.Incomplete =&gt; Boolean" id="sbt.Execute.config$default$2">overwriteNode</a>: Incomplete =&gt; Boolean = <a href="TypeFunctions.scala.html#sbt;TypeFunctions.const" title="(b: Boolean)sbt.Incomplete =&gt; Boolean">const</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#sbt.Execute;Config" title="sbt.Execute.Config">Config</a> = <span title="sbt.Execute.Config" class="keyword">new</span> <a href="#sbt.Execute;Config" title="sbt.Execute.Config">Config</a><span class="delimiter">(</span><a href="#sbt.Execute.config.checkCycles" title="Boolean">checkCycles</a>, <a href="#sbt.Execute.config$default$2" title="sbt.Incomplete =&gt; Boolean">overwriteNode</a><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Config extends AnyRef" id="sbt.Execute;Config">Config</a> <a href="#sbt.Execute;Config" title="sbt.Execute.Config" class="keyword">private</a><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="delimiter">(</span><span class="keyword">val</span> <a title="Boolean" id="sbt.Execute;Config.checkCycles">checkCycles</a>: <span title="Boolean">Boolean</span>, <span class="keyword">val</span> <a title="sbt.Incomplete =&gt; Boolean" id="sbt.Execute;Config.overwriteNode">overwriteNode</a>: Incomplete =&gt; Boolean<span class="delimiter">)</span>
<span title="AnyRef" class="delimiter">}</span>
<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Completed extends AnyRef" id="sbt;Completed">Completed</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="()Unit" id="sbt;Completed.process">process</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait NodeView[A[_]] extends AnyRef" id="sbt;NodeView">NodeView</a><span class="delimiter">[</span><a title="[_]" id="sbt;NodeView;A">A</a><span class="delimiter">[</span><a title="" id="sbt;NodeView;A;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](a: A[T])sbt.Node[A,T]" id="sbt;NodeView.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;NodeView.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;NodeView.apply.a">a</a>: <a href="#sbt;NodeView;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Node.scala.html#sbt;Node" title="sbt.Node[A,T]">Node</a><span class="delimiter">[</span>A, T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[T](a: A[T])Option[() =&gt; T]" id="sbt;NodeView.inline">inline</a><span class="delimiter">[</span><a title="" id="sbt;NodeView.inline;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;NodeView.inline.a">a</a>: <a href="#sbt;NodeView;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[() =&gt; T]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">]</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a title="class Triggers[A[_]] extends AnyRef" id="sbt;Triggers">Triggers</a><span class="delimiter">[</span><a title="[_]" id="sbt;Triggers;A">A</a><span class="delimiter">[</span><a title="" id="sbt;Triggers;A;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#sbt;Triggers" title="sbt.Triggers[A]" class="delimiter">(</a><span class="keyword">val</span> <a title="scala.collection.Map[A[_],Seq[A[_]]]" id="sbt;Triggers.runBefore">runBefore</a>: collection.<span title="scala.collection.Map[A[_],Seq[A[_]]]">Map</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="scala.collection.Map[A[_],Seq[A[_]]]" id="sbt;Triggers.injectFor">injectFor</a>: collection.<span title="scala.collection.Map[A[_],Seq[A[_]]]">Map</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">val</span> <a title="sbt.RMap[A,sbt.Result] =&gt; sbt.RMap[A,sbt.Result]" id="sbt;Triggers.onComplete">onComplete</a>: RMap<span class="delimiter">[</span>A, Result<span class="delimiter">]</span> =&gt; RMap<span class="delimiter">[</span>A, Result<span class="delimiter">]</span><span class="delimiter">)</span>

<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Execute[A[_] &lt;: AnyRef] extends AnyRef" id="sbt;Execute">Execute</a><span class="delimiter">[</span><a title="[_] &lt;: AnyRef" id="sbt;Execute;A">A</a><span class="delimiter">[</span><a title="" id="sbt;Execute;A;_">_</a><span class="delimiter">]</span> &lt;: AnyRef<span class="delimiter">]</span><a href="#sbt;Execute" title="sbt.Execute[A]" class="delimiter">(</a><a title="sbt.Execute.Config" id="sbt;Execute.config">config</a>: <a href="#sbt.Execute;Config" title="sbt.Execute.Config">Config</a>, <a title="sbt.Triggers[A]" id="sbt;Execute.triggers">triggers</a>: <a href="#sbt;Triggers" title="sbt.Triggers[A]">Triggers</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.ExecuteProgress[A]" id="sbt;Execute.progress">progress</a>: <a href="ExecuteProgress.scala.html#sbt;ExecuteProgress" title="sbt.ExecuteProgress[A]">ExecuteProgress</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="sbt.NodeView[A]" id="sbt;Execute.view">view</a>: <a href="#sbt;NodeView" title="sbt.NodeView[A]">NodeView</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">type</span> <a title="sbt.CompletionService[A[_],sbt.Completed]" id="sbt;Execute;Strategy">Strategy</a> = <a href="CompletionService.scala.html#sbt;CompletionService" title="sbt.CompletionService[A[_],sbt.Completed]">CompletionService</a><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span>, Completed<span class="delimiter">]</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]" id="sbt;Execute.forward">forward</a> = <a href="#sbt.Execute.idMap" title="[A, B]=&gt; scala.collection.mutable.Map[A,B]">idMap</a><span title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a href="IDSet.scala.html#sbt;IDSet" title="sbt.IDSet[A[_]]">IDSet</a><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]" id="sbt;Execute.reverse">reverse</a> = <a href="#sbt.Execute.idMap" title="[A, B]=&gt; scala.collection.mutable.Map[A,B]">idMap</a><span title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span title="Iterable[A[_]]">Iterable</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]" id="sbt;Execute.callers">callers</a> = <a href="#sbt.Execute.pMap" title="[A[_], B[_]]=&gt; sbt.PMap[A,B]">pMap</a><span title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A">A</a>, Compose<span class="delimiter">[</span>IDSet, A<span class="delimiter">]</span>#<a href="IDSet.scala.html#sbt;IDSet" title="[T]sbt.IDSet[A[T]]">Apply</a><span class="delimiter">]</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[A[_],Execute.this.State]" id="sbt;Execute.state">state</a> = <a href="#sbt.Execute.idMap" title="[A, B]=&gt; scala.collection.mutable.Map[A,B]">idMap</a><span title="scala.collection.mutable.Map[A[_],Execute.this.State]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span title="Execute.this.State">State</span><span class="delimiter">]</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.PMap[A,[t]sbt.Node[A,t]]" id="sbt;Execute.viewCache">viewCache</a> = <a href="#sbt.Execute.pMap" title="[A[_], B[_]]=&gt; sbt.PMap[A,B]">pMap</a><span title="sbt.PMap[A,[t]sbt.Node[A,t]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A">A</a>, <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> l<span class="delimiter">[</span>t<span class="delimiter">]</span> = Node<span class="delimiter">[</span>A, t<span class="delimiter">]</span> <span class="delimiter">}</span><span class="delimiter">)</span>#<a href="Node.scala.html#sbt;Node" title="[t]sbt.Node[A,t]">l</a><span class="delimiter">]</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.PMap[A,sbt.Result]" id="sbt;Execute.results">results</a> = <a href="#sbt.Execute.pMap" title="[A[_], B[_]]=&gt; sbt.PMap[A,B]">pMap</a><span title="sbt.PMap[A,sbt.Result]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A">A</a>, <a href="Result.scala.html#sbt;Result" title="sbt.Result">Result</a><span class="delimiter">]</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="sbt.~&gt;[A,sbt.Result]" id="sbt;Execute.getResult">getResult</a>: A <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[A,sbt.Result]">~&gt;</a> Result = <a href="#sbt;Execute.getResult;$anon" title="sbt.~&gt;[A,sbt.Result]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[A,sbt.Result]" id="sbt;Execute.getResult;$anon" class="delimiter">(</a>A <a href="TypeFunctions.scala.html#sbt;~>" title="sbt.~&gt;[A,sbt.Result]">~&gt;</a> Result<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](a: A[T])sbt.Result[T]" id="sbt;Execute.getResult;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;Execute.getResult;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.getResult;$anon.apply.a">a</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Result.scala.html#sbt;Result" title="sbt.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;Execute.view" title="sbt.NodeView[A]">view</a>.<a href="#sbt;NodeView.inline" title="(a: A[T])Option[() =&gt; T]">inline</a><span class="delimiter">(</span><a href="#sbt;Execute.getResult;$anon.apply.a" title="A[T]">a</a><span class="delimiter">)</span> <span title="sbt.Result[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="() =&gt; T" id="sbt;Execute.getResult;$anon.apply.v">v</a><span class="delimiter">)</span> =&gt; <a href="Result.scala.html#sbt;Value" title="(value: T)sbt.Value[T]">Value</a><span class="delimiter">(</span><a href="#sbt;Execute.getResult;$anon.apply.v" title="()T">v</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">None</span>    =&gt; <a href="PMap.scala.html#sbt;RMap.apply" title="(k: A[T])sbt.Result[T]">results</a><span class="delimiter">(</span><a href="#sbt;Execute.getResult;$anon.apply.a" title="A[T]">a</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Execute.this.progress.S" id="sbt;Execute.progressState">progressState</a>: progress.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress;S" title="Execute.this.progress.S">S</a> = <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.initial" title="=&gt; Execute.this.progress.S">initial</a>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span><span class="keyword">type</span> <a title="Execute.this.State.Value" id="sbt;Execute;State">State</a> = State.<span title="Execute.this.State.Value">Value</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">object</span> <a title="Execute.this.State.type" id="sbt;Execute.State">State</a> <a href="#sbt;Execute.State" title="Execute.this.State.type" class="keyword">extends</a> <span title="Enumeration">Enumeration</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="sbt.Execute.State.Value" id="sbt;Execute.State.Pending">Pending</a>, <a title="sbt.Execute.State.Value" id="sbt;Execute.State.Running">Running</a>, <a title="sbt.Execute.State.Value" id="sbt;Execute.State.Calling">Calling</a>, <a title="sbt.Execute.State.Value" id="sbt;Execute.State.Done">Done</a> = <span title="=&gt; sbt.Execute.State.Value">Value</span>
  <span class="delimiter">}</span>
  <span class="keyword">import</span> <a href="#sbt;Execute.State" title="Execute.this.State.type">State</a>.<span class="delimiter">{</span> Pending, Running, Calling, Done <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="=&gt; String" id="sbt;Execute.dump">dump</a>: <span title="String">String</span> = <span title="String(&quot;State: &quot;)" class="string">&quot;State: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n\nResults: &quot;)" class="string">&quot;\n\nResults: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.results" title="sbt.PMap[A,sbt.Result]">results</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n\nCalls: &quot;)" class="string">&quot;\n\nCalls: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n\n&quot;)" class="string">&quot;\n\n&quot;</span>

  <span class="keyword">def</span> <a title="[T](root: A[T])(implicit strategy: Execute.this.Strategy)sbt.Result[T]" id="sbt;Execute.run">run</a><span class="delimiter">[</span><a title="" id="sbt;Execute.run;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.run.root">root</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.run.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span>: <a href="Result.scala.html#sbt;Result" title="sbt.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt;Execute.runKeep" title="(root: A[T])(implicit strategy: Execute.this.Strategy)sbt.RMap[A,sbt.Result]">runKeep</a><span class="delimiter">(</span><a href="#sbt;Execute.run.root" title="A[T]">root</a><span class="delimiter">)</span><a href="PMap.scala.html#sbt;RMap.apply" title="(k: A[T])sbt.Result[T]" class="delimiter">(</a><a href="#sbt;Execute.run.strategy" title="Execute.this.Strategy">strategy</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt;Execute.run.root" title="A[T]">root</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="sbt.Incomplete" id="sbt;Execute.run.i">i</a>: <a href="Incomplete.scala.html#sbt;Incomplete" title="sbt.Incomplete">Incomplete</a> =&gt; <a href="Result.scala.html#sbt;Inc" title="(cause: sbt.Incomplete)sbt.Inc">Inc</a><span class="delimiter">(</span><a href="#sbt;Execute.run.i" title="sbt.Incomplete">i</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[T](root: A[T])(implicit strategy: Execute.this.Strategy)sbt.RMap[A,sbt.Result]" id="sbt;Execute.runKeep">runKeep</a><span class="delimiter">[</span><a title="" id="sbt;Execute.runKeep;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.runKeep.root">root</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.runKeep.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span>: <a href="PMap.scala.html#sbt;RMap" title="sbt.RMap[A,sbt.Result]">RMap</a><span class="delimiter">[</span>A, Result<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a>.<span title="=&gt; Boolean">isEmpty</span>, <span title="String(&quot;Execute already running/ran.&quot;)" class="string">&quot;Execute already running/ran.&quot;</span><span class="delimiter">)</span>

      <a href="#sbt;Execute.addNew" title="(node: A[T])(implicit strategy: Execute.this.Strategy)Unit">addNew</a><a href="#sbt;Execute.runKeep.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.runKeep.root" title="A[T]">root</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.processAll" title="()(implicit strategy: Execute.this.Strategy)Unit">processAll</a><a href="#sbt;Execute.runKeep.strategy" title="Execute.this.Strategy" class="delimiter">(</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.results" title="sbt.PMap[A,sbt.Result]">results</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: A[T])Boolean">contains</a> <a href="#sbt;Execute.runKeep.root" title="A[T]">root</a>, <span title="String(&quot;No result for root node.&quot;)" class="string">&quot;No result for root node.&quot;</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="sbt.RMap[A,sbt.Result]" id="sbt;Execute.runKeep.finalResults">finalResults</a> = <a href="#sbt;Execute.triggers" title="sbt.Triggers[A]">triggers</a>.<a href="#sbt;Triggers.onComplete" title="(v1: sbt.RMap[A,sbt.Result])sbt.RMap[A,sbt.Result]">onComplete</a><span class="delimiter">(</span><a href="#sbt;Execute.results" title="sbt.PMap[A,sbt.Result]">results</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a> = <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.allCompleted" title="(state: Execute.this.progress.S, results: sbt.RMap[A,sbt.Result])Execute.this.progress.S">allCompleted</a><span class="delimiter">(</span><a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a>, <a href="#sbt;Execute.runKeep.finalResults" title="sbt.RMap[A,sbt.Result]">finalResults</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.runKeep.finalResults" title="sbt.RMap[A,sbt.Result]">finalResults</a>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="()(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.processAll">processAll</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.processAll.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="()Unit" id="sbt;Execute.processAll.next">next</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt;Execute.pre" title="(f: =&gt; Unit)Unit">pre</a> <span class="delimiter">{</span>
        <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a>.<span title="=&gt; Boolean">isEmpty</span>, <span title="String(&quot;Nothing to process.&quot;)" class="string">&quot;Nothing to process.&quot;</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a>.<span title="=&gt; Iterable[Execute.this.State]">values</span>.<span title="(p: Execute.this.State =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#sbt;Execute.processAll.next.$anonfun.x$1" title="Execute.this.State">_</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;Execute.State.Running" title="=&gt; Execute.this.State.Value">Running</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#sbt;Execute.snapshotCycleCheck" title="()Unit">snapshotCycleCheck</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <span title="String(&quot;Internal task engine error: nothing running.  This usually indicates a cycle in tasks.\n  Calling tasks (internal task engine state):\n&quot;)" class="string">&quot;Internal task engine error: nothing running.  This usually indicates a cycle in tasks.\n  Calling tasks (internal task engine state):\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.dumpCalling" title="=&gt; String">dumpCalling</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="delimiter">(</span><a href="#sbt;Execute.processAll.strategy" title="Execute.this.Strategy">strategy</a>.<a href="CompletionService.scala.html#sbt;CompletionService.take" title="()sbt.Completed">take</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#sbt;Completed.process" title="()Unit">process</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt;Execute.processAll.next" title="()Unit">next</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#sbt;Execute.processAll.next" title="()Unit">next</a><span class="delimiter">(</span><span class="delimiter">)</span>

    <a href="#sbt;Execute.post" title="(f: =&gt; Unit)Unit">post</a> <span class="delimiter">{</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a>.<span title="=&gt; Boolean">isEmpty</span>, <span title="String(&quot;Did not process everything.&quot;)" class="string">&quot;Did not process everything.&quot;</span><span class="delimiter">)</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.complete" title="=&gt; Boolean">complete</a>, <span title="String(&quot;Not all state was Done.&quot;)" class="string">&quot;Not all state was Done.&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; String" id="sbt;Execute.dumpCalling">dumpCalling</a>: <span title="String">String</span> = <a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a>.<span title="(p: ((A[_], Execute.this.State)) =&gt; Boolean)scala.collection.mutable.Map[A[_],Execute.this.State]">filter</span><span class="delimiter">(</span><a href="#sbt;Execute.dumpCalling.$anonfun.x$2" title="(A[_], Execute.this.State)">_</a>.<span title="=&gt; Execute.this.State">_2</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;Execute.State.Calling" title="=&gt; Execute.this.State.Value">Calling</a><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n\t&quot;)" class="string">&quot;\n\t&quot;</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](node: A[T], target: A[T])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.call">call</a><span class="delimiter">[</span><a title="" id="sbt;Execute.call;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.call.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="A[T]" id="sbt;Execute.call.target">target</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.call.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.config" title="sbt.Execute.Config">config</a>.<a href="#sbt.Execute;Config.checkCycles" title="=&gt; Boolean">checkCycles</a><span class="delimiter">)</span> <a href="#sbt;Execute.cycleCheck" title="(node: A[T], target: A[T])Unit">cycleCheck</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a>, <a href="#sbt;Execute.call.target" title="A[T]">target</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.pre" title="(f: =&gt; Unit)Unit">pre</a> <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.running" title="(d: A[_])Boolean">running</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt;Execute.readyInv" title="(node: A[_])Unit">readyInv</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#sbt;Execute.results" title="sbt.PMap[A,sbt.Result]">results</a>.<a href="PMap.scala.html#sbt;RMap.get" title="(k: A[T])Option[sbt.Result[T]]">get</a><span class="delimiter">(</span><a href="#sbt;Execute.call.target" title="A[T]">target</a><span class="delimiter">)</span> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="sbt.Result[T]" id="sbt;Execute.call.result">result</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Execute.retire" title="(node: A[T], result: sbt.Result[T])(implicit strategy: Execute.this.Strategy)Unit">retire</a><a href="#sbt;Execute.call.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.call.node" title="A[T]">node</a>, <a href="#sbt;Execute.call.result" title="sbt.Result[T]">result</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">None</span> =&gt;
        <a href="#sbt;Execute.state" title="(key: A[_], value: Execute.this.State)Unit">state</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span> = <a href="#sbt;Execute.State.Calling" title="=&gt; Execute.this.State.Value">Calling</a>
        <a href="#sbt;Execute.addChecked" title="(node: A[T])(implicit strategy: Execute.this.Strategy)Unit">addChecked</a><a href="#sbt;Execute.call.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.call.target" title="A[T]">target</a><span class="delimiter">)</span>
        <a href="#sbt;Execute.addCaller" title="(caller: A[T], target: A[T])Unit">addCaller</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a>, <a href="#sbt;Execute.call.target" title="A[T]">target</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#sbt;Execute.post" title="(f: =&gt; Unit)Unit">post</a> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">(</span><a href="#sbt;Execute.call.target" title="A[T]">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.calling" title="(d: A[_])Boolean">calling</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="PMap.scala.html#sbt;RMap.apply" title="(k: A[T])sbt.IDSet[A[T]]">callers</a><span class="delimiter">(</span><a href="#sbt;Execute.call.target" title="A[T]">target</a><span class="delimiter">)</span> <a href="IDSet.scala.html#sbt;IDSet.contains" title="(t: A[T])Boolean">contains</a> <a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#sbt;Execute.readyInv" title="(node: A[_])Unit">readyInv</a><span class="delimiter">(</span><a href="#sbt;Execute.call.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T](node: A[T], result: sbt.Result[T])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.retire">retire</a><span class="delimiter">[</span><a title="" id="sbt;Execute.retire;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.retire.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.Result[T]" id="sbt;Execute.retire.result">result</a>: <a href="Result.scala.html#sbt;Result" title="sbt.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.retire.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#sbt;Execute.pre" title="(f: =&gt; Unit)Unit">pre</a> <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.running" title="(d: A[_])Boolean">running</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">|</span> <a href="#sbt;Execute.calling" title="(d: A[_])Boolean">calling</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt;Execute.readyInv" title="(node: A[_])Unit">readyInv</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="PMap.scala.html#sbt;PMap.update" title="(k: A[T], v: sbt.Result[T])Unit">results</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> = <a href="#sbt;Execute.retire.result" title="sbt.Result[T]">result</a>
    <a href="#sbt;Execute.state" title="(key: A[_], value: Execute.this.State)Unit">state</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> = <a href="#sbt;Execute.State.Done" title="=&gt; Execute.this.State.Value">Done</a>
    <a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a> = <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.completed" title="(state: Execute.this.progress.S, task: A[T], result: sbt.Result[T])Execute.this.progress.S">completed</a><span class="delimiter">(</span><a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a>, <a href="#sbt;Execute.retire.node" title="A[T]">node</a>, <a href="#sbt;Execute.retire.result" title="sbt.Result[T]">result</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.remove" title="(map: scala.collection.mutable.Map[A[_],Iterable[A[_]]], k: A[_])Iterable[A[_]]">remove</a><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a>, <a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> <span title="(f: A[_] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="A[_]" id="sbt;Execute.retire.$anonfun.dep">dep</a> =&gt; <a href="#sbt;Execute.notifyDone" title="(node: A[_], dependent: A[_])(implicit strategy: Execute.this.Strategy)Unit">notifyDone</a><a href="#sbt;Execute.retire.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.retire.node" title="A[T]">node</a>, <a href="#sbt;Execute.retire.$anonfun.dep" title="A[_]">dep</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a>.<a href="PMap.scala.html#sbt;PMap.remove" title="(k: A[T])Option[sbt.IDSet[A[T]]]">remove</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span>.<span title="=&gt; List[sbt.IDSet[A[T]]]">toList</span>.<a href="IDSet.scala.html#sbt.IDSet.toTraversable" title="(implicit asTraversable: sbt.IDSet[A[T]] =&gt; scala.collection.GenTraversableOnce[A[T]])List[A[T]]">flatten</a>.<span title="(f: A[T] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="A[T]" id="sbt;Execute.retire.$anonfun.c">c</a> =&gt; <a href="#sbt;Execute.retire" title="(node: A[T], result: sbt.Result[T])(implicit strategy: Execute.this.Strategy)Unit">retire</a><a href="#sbt;Execute.retire.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.retire.$anonfun.c" title="A[T]">c</a>, <a href="#sbt;Execute.callerResult" title="(node: A[T], result: sbt.Result[T])sbt.Result[T]">callerResult</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.$anonfun.c" title="A[T]">c</a>, <a href="#sbt;Execute.retire.result" title="sbt.Result[T]">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#sbt;Execute.triggeredBy" title="(node: A[_])Seq[A[_]]">triggeredBy</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> <span title="(f: A[_] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="A[_]" id="sbt;Execute.retire.$anonfun.t">t</a> =&gt; <a href="#sbt;Execute.addChecked" title="(node: A[_$23])(implicit strategy: Execute.this.Strategy)Unit">addChecked</a><a href="#sbt;Execute.retire.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.retire.$anonfun.t" title="A[_]">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    <a href="#sbt;Execute.post" title="(f: =&gt; Unit)Unit">post</a> <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="PMap.scala.html#sbt;RMap.apply" title="(k: A[T])sbt.Result[T]">results</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;Execute.retire.result" title="sbt.Result[T]">result</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.readyInv" title="(node: A[_])Unit">readyInv</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: A[T])Boolean">contains</a> <a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.triggeredBy" title="(node: A[_])Seq[A[_]]">triggeredBy</a><span class="delimiter">(</span><a href="#sbt;Execute.retire.node" title="A[T]">node</a><span class="delimiter">)</span> <span title="(p: A[_] =&gt; Boolean)Boolean">forall</span> <a href="#sbt;Execute.added" title="(d: A[_])Boolean">added</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[T](node: A[T], result: sbt.Result[T])sbt.Result[T]" id="sbt;Execute.callerResult">callerResult</a><span class="delimiter">[</span><a title="" id="sbt;Execute.callerResult;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.callerResult.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.Result[T]" id="sbt;Execute.callerResult.result">result</a>: <a href="Result.scala.html#sbt;Result" title="sbt.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Result.scala.html#sbt;Result" title="sbt.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt;Execute.callerResult.result" title="sbt.Result[T]">result</a> <span title="sbt.Result[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> _: <a href="Result.scala.html#sbt;Value" title="sbt.Value[T]">Value</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; <a href="#sbt;Execute.callerResult.result" title="sbt.Result[T]">result</a>
      <span class="keyword">case</span> Inc<span class="delimiter">(</span><a title="sbt.Incomplete" id="sbt;Execute.callerResult.i">i</a><span class="delimiter">)</span>      =&gt; <a href="Result.scala.html#sbt;Inc" title="(cause: sbt.Incomplete)sbt.Inc">Inc</a><span class="delimiter">(</span><a href="Incomplete.scala.html#sbt.Incomplete.apply$default$3" title="Option[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.callerResult.x$16">Incomplete</a><span class="delimiter">(</span><span title="(x: A[T])Some[A[T]]">Some</span><a title="Some[A[T]] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.callerResult.x$12" class="delimiter">(</a><a href="#sbt;Execute.callerResult.node" title="A[T]">node</a><span class="delimiter">)</span>, tpe = <a href="#sbt;Execute.callerResult.i" title="sbt.Incomplete">i</a>.<a href="Incomplete.scala.html#sbt;Incomplete.tpe" title="sbt.Incomplete.Value" id="sbt;Execute.callerResult.x$13">tpe</a>, causes = <a href="#sbt;Execute.callerResult.i" title="sbt.Incomplete">i</a> <a href="#sbt;Execute.callerResult.x$14.x$3" title="List[sbt.Incomplete] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.callerResult.x$14">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(node: A[_], dependent: A[_])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.notifyDone">notifyDone</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.notifyDone.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="A[_]" id="sbt;Execute.notifyDone.dependent">dependent</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.notifyDone.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="sbt.IDSet[A[_]]" id="sbt;Execute.notifyDone.f">f</a> = <a href="#sbt;Execute.forward" title="(key: A[_])sbt.IDSet[A[_]]">forward</a><span class="delimiter">(</span><a href="#sbt;Execute.notifyDone.dependent" title="A[_]">dependent</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.notifyDone.f" title="sbt.IDSet[A[_]]">f</a> <a href="IDSet.scala.html#sbt;IDSet.-=" title="(t: A[_])Boolean">-=</a> <a href="#sbt;Execute.notifyDone.node" title="A[_]">node</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.notifyDone.f" title="sbt.IDSet[A[_]]">f</a>.<a href="IDSet.scala.html#sbt;IDSet.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt;Execute.remove" title="(map: scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]], k: A[_])sbt.IDSet[A[_]]">remove</a><span class="delimiter">(</span><a href="#sbt;Execute.forward" title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]">forward</a>, <a href="#sbt;Execute.notifyDone.dependent" title="A[_]">dependent</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.ready" title="(node: A[_$12])(implicit strategy: Execute.this.Strategy)Unit">ready</a><a href="#sbt;Execute.notifyDone.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.notifyDone.dependent" title="A[_]">dependent</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Ensures the given node has been added to the system.
   * Once added, a node is pending until its inputs and dependencies have completed.
   * Its computation is then evaluated and made available for nodes that have it as an input.
   */</span>
  <span class="keyword">def</span> <a title="[T](node: A[T])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.addChecked">addChecked</a><span class="delimiter">[</span><a title="" id="sbt;Execute.addChecked;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.addChecked.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.addChecked.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt;Execute.added" title="(d: A[_])Boolean">added</a><span class="delimiter">(</span><a href="#sbt;Execute.addChecked.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt;Execute.addNew" title="(node: A[T])(implicit strategy: Execute.this.Strategy)Unit">addNew</a><a href="#sbt;Execute.addChecked.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.addChecked.node" title="A[T]">node</a><span class="delimiter">)</span>

    <a href="#sbt;Execute.post" title="(f: =&gt; Unit)Unit">post</a> <span class="delimiter">{</span> <a href="#sbt;Execute.addedInv" title="(node: A[_])Unit">addedInv</a><span class="delimiter">(</span><a href="#sbt;Execute.addChecked.node" title="A[T]">node</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Adds a node that has not yet been registered with the system.
   * If all of the node's dependencies have finished, the node's computation is scheduled to run.
   * The node's dependencies will be added (transitively) if they are not already registered.
   */</span>
  <span class="keyword">def</span> <a title="[T](node: A[T])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.addNew">addNew</a><span class="delimiter">[</span><a title="" id="sbt;Execute.addNew;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.addNew.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.addNew.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#sbt;Execute.pre" title="(f: =&gt; Unit)Unit">pre</a> <span class="delimiter">{</span> <a href="#sbt;Execute.newPre" title="(node: A[_])Unit">newPre</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="sbt.Node[A,T]" id="sbt;Execute.addNew.v">v</a> = <a href="#sbt;Execute.register" title="(node: A[T])sbt.Node[A,T]">register</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Iterable[A[_]]" id="sbt;Execute.addNew.deps">deps</a> = <a href="#sbt;Execute.dependencies(fd28f19800)" title="(v: sbt.Node[A, _])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.v" title="sbt.Node[A,T]">v</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[A[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[A[_]],A[_],Iterable[A[_]]])Iterable[A[_]]">++</span> <a href="#sbt;Execute.runBefore" title="(node: A[_])Seq[A[_]]">runBefore</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="sbt.IDSet[A[_]]" id="sbt;Execute.addNew.active">active</a> = <a href="IDSet.scala.html#sbt.IDSet.apply(24873e4e8a)" title="[T](values: Iterable[T])sbt.IDSet[T]">IDSet</a><span title="(values: Iterable[A[_]])sbt.IDSet[A[_]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;Execute.addNew.deps" title="Iterable[A[_]]">deps</a> <span title="(p: A[_] =&gt; Boolean)Iterable[A[_]]">filter</span> <a href="#sbt;Execute.notDone" title="(d: A[_])Boolean">notDone</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a> = <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.registered" title="(state: Execute.this.progress.S, task: A[_], allDeps: Iterable[A[_]], pendingDeps: Iterable[A[_]])Execute.this.progress.S">registered</a><span class="delimiter">(</span><a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a>, <a href="#sbt;Execute.addNew.node" title="A[T]">node</a>, <a href="#sbt;Execute.addNew.deps" title="Iterable[A[_]]">deps</a>, <a href="#sbt;Execute.addNew.active" title="sbt.IDSet[A[_]]">active</a>.<a href="IDSet.scala.html#sbt;IDSet.toList" title="=&gt; List[A[_]]">toList</a> <span class="comment">/** active is mutable, so take a snapshot */</span> <span class="delimiter">)</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.addNew.active" title="sbt.IDSet[A[_]]">active</a>.<a href="IDSet.scala.html#sbt;IDSet.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.ready" title="(node: A[T])(implicit strategy: Execute.this.Strategy)Unit">ready</a><a href="#sbt;Execute.addNew.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#sbt;Execute.forward" title="(key: A[_], value: sbt.IDSet[A[_]])Unit">forward</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span> = <a href="#sbt;Execute.addNew.active" title="sbt.IDSet[A[_]]">active</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.addNew.$anonfun.a">a</a> &lt;- <a href="IDSet.scala.html#sbt;IDSet.foreach" title="(f: A[_] =&gt; Unit)Unit">active</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#sbt;Execute.addChecked" title="(node: A[_$13])(implicit strategy: Execute.this.Strategy)Unit">addChecked</a><a href="#sbt;Execute.addNew.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.addNew.$anonfun.a" title="A[_]">a</a><span class="delimiter">)</span>
        <a href="#sbt;Execute.addReverse" title="(node: A[_], dependent: A[_])Unit">addReverse</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.$anonfun.a" title="A[_]">a</a>, <a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#sbt;Execute.post" title="(f: =&gt; Unit)Unit">post</a> <span class="delimiter">{</span>
      <a href="#sbt;Execute.addedInv" title="(node: A[_])Unit">addedInv</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.running" title="(d: A[_])Boolean">running</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">^</span> <a href="#sbt;Execute.pending" title="(d: A[_])Boolean">pending</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.running" title="(d: A[_])Boolean">running</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt;Execute.runningInv" title="(node: A[_])Unit">runningInv</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.pending" title="(d: A[_])Boolean">pending</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt;Execute.pendingInv" title="(node: A[_])Unit">pendingInv</a><span class="delimiter">(</span><a href="#sbt;Execute.addNew.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/** Called when a pending 'node' becomes runnable.  All of its dependencies must be done.  This schedules the node's computation with 'strategy'.*/</span>
  <span class="keyword">def</span> <a title="[T](node: A[T])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.ready">ready</a><span class="delimiter">[</span><a title="" id="sbt;Execute.ready;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.ready.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.ready.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#sbt;Execute.pre" title="(f: =&gt; Unit)Unit">pre</a> <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.pending" title="(d: A[_])Boolean">pending</a><span class="delimiter">(</span><a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt;Execute.readyInv" title="(node: A[_])Unit">readyInv</a><span class="delimiter">(</span><a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#sbt;Execute.state" title="(key: A[_], value: Execute.this.State)Unit">state</a><span class="delimiter">(</span><a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span> = <a href="#sbt;Execute.State.Running" title="=&gt; Execute.this.State.Value">Running</a>
    <a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a> = <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.ready" title="(state: Execute.this.progress.S, task: A[_])Execute.this.progress.S">ready</a><span class="delimiter">(</span><a href="#sbt;Execute.progressState" title="Execute.this.progress.S">progressState</a>, <a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.submit" title="(node: A[T])(implicit strategy: Execute.this.Strategy)Unit">submit</a><a href="#sbt;Execute.ready.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span>

    <a href="#sbt;Execute.post" title="(f: =&gt; Unit)Unit">post</a> <span class="delimiter">{</span>
      <a href="#sbt;Execute.readyInv" title="(node: A[_])Unit">readyInv</a><span class="delimiter">(</span><a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.running" title="(d: A[_])Boolean">running</a><span class="delimiter">(</span><a href="#sbt;Execute.ready.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/** Enters the given node into the system. */</span>
  <span class="keyword">def</span> <a title="[T](node: A[T])sbt.Node[A,T]" id="sbt;Execute.register">register</a><span class="delimiter">[</span><a title="" id="sbt;Execute.register;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.register.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Node.scala.html#sbt;Node" title="sbt.Node[A,T]">Node</a><span class="delimiter">[</span>A, T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <a href="#sbt;Execute.state" title="(key: A[_], value: Execute.this.State)Unit">state</a><span class="delimiter">(</span><a href="#sbt;Execute.register.node" title="A[T]">node</a><span class="delimiter">)</span> = <a href="#sbt;Execute.State.Pending" title="=&gt; Execute.this.State.Value">Pending</a>
      <a href="#sbt;Execute.reverse" title="(key: A[_], value: Iterable[A[_]])Unit">reverse</a><span class="delimiter">(</span><a href="#sbt;Execute.register.node" title="A[T]">node</a><span class="delimiter">)</span> = <span title="(elems: Nothing*)Seq[Nothing]">Seq</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#sbt;Execute.viewCache" title="sbt.PMap[A,[t]sbt.Node[A,t]]">viewCache</a>.<a href="PMap.scala.html#sbt;PMap.getOrUpdate" title="(k: A[T], make: =&gt; sbt.Node[A,T])sbt.Node[A,T]">getOrUpdate</a><span class="delimiter">(</span><a href="#sbt;Execute.register.node" title="A[T]">node</a>, <a href="#sbt;NodeView.apply" title="(a: A[T])sbt.Node[A,T]">view</a><span class="delimiter">(</span><a href="#sbt;Execute.register.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="comment">/** Send the work for this node to the provided Strategy. */</span>
  <span class="keyword">def</span> <a title="[T](node: A[T])(implicit strategy: Execute.this.Strategy)Unit" id="sbt;Execute.submit">submit</a><span class="delimiter">[</span><a title="" id="sbt;Execute.submit;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.submit.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.submit.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="sbt.Node[A,T]" id="sbt;Execute.submit.v">v</a> = <a href="PMap.scala.html#sbt;RMap.apply" title="(k: A[T])sbt.Node[A,T]">viewCache</a><span class="delimiter">(</span><a href="#sbt;Execute.submit.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="v.K[sbt.Result]" id="sbt;Execute.submit.rs">rs</a> = <a href="#sbt;Execute.submit.v" title="sbt.Node[A,T]">v</a>.<a href="Node.scala.html#sbt;Node.alist" title="=&gt; sbt.AList[v.K]">alist</a>.<a href="AList.scala.html#sbt;AList.transform" title="(value: v.K[A], f: sbt.~&gt;[A,sbt.Result])v.K[sbt.Result]">transform</a><span class="delimiter">(</span><a href="#sbt;Execute.submit.v" title="sbt.Node[A,T]">v</a>.<a href="Node.scala.html#sbt;Node.in" title="=&gt; v.K[A]">in</a>, <a href="#sbt;Execute.getResult" title="sbt.~&gt;[A,sbt.Result]">getResult</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.submit.strategy" title="Execute.this.Strategy">strategy</a>.<a href="CompletionService.scala.html#sbt;CompletionService.submit" title="(node: A[_], work: () =&gt; sbt.Completed)Unit">submit</a><span class="delimiter">(</span><a href="#sbt;Execute.submit.node" title="A[T]">node</a>, <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#sbt;Execute.work" title="(node: A[T], f: =&gt; Either[A[T],T])(implicit strategy: Execute.this.Strategy)sbt.Completed">work</a><a href="#sbt;Execute.submit.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.submit.node" title="A[T]">node</a>, <a href="#sbt;Execute.submit.v" title="sbt.Node[A,T]">v</a>.<a href="Node.scala.html#sbt;Node.work" title="(inputs: v.K[sbt.Result])Either[A[T],T]">work</a><span class="delimiter">(</span><a href="#sbt;Execute.submit.rs" title="v.K[sbt.Result]">rs</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Evaluates the computation 'f' for 'node'.
   * This returns a Completed instance, which contains the post-processing to perform after the result is retrieved from the Strategy.
   */</span>
  <span class="keyword">def</span> <a title="[T](node: A[T], f: =&gt; Either[A[T],T])(implicit strategy: Execute.this.Strategy)sbt.Completed" id="sbt;Execute.work">work</a><span class="delimiter">[</span><a title="" id="sbt;Execute.work;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.work.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Either[A[T],T]" id="sbt;Execute.work.f">f</a>: =&gt; Either<span class="delimiter">[</span>A<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Execute.this.Strategy" id="sbt;Execute.work.strategy">strategy</a>: <a href="CompletionService.scala.html#sbt;CompletionService" title="Execute.this.Strategy">Strategy</a><span class="delimiter">)</span>: <a href="#sbt;Completed" title="sbt.Completed">Completed</a> =
    <span class="delimiter">{</span>
      <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.workStarting" title="(task: A[_])Unit">workStarting</a><span class="delimiter">(</span><a href="#sbt;Execute.work.node" title="A[T]">node</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Either extends Serializable with Product with scala.util.Either[sbt.Incomplete,Either[A[T],T]]" id="sbt;Execute.work.rawResult">rawResult</a> = <a href="ErrorHandling.scala.html#sbt.ErrorHandling.wideConvert" title="(f: =&gt; Either[A[T],T])Either[Throwable,Either[A[T],T]]">wideConvert</a><span class="delimiter">(</span><a href="#sbt;Execute.work.f" title="=&gt; Either[A[T],T]">f</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.LeftProjection[Throwable,Either[A[T],T]]">left</span>.<span title="(f: Throwable =&gt; sbt.Incomplete)Serializable with Product with scala.util.Either[sbt.Incomplete,Either[A[T],T]]">map</span> <a href="#sbt;Execute.work.rawResult.$anonfun.x0$1" title="sbt.Incomplete" class="delimiter">{</a>
        <span class="keyword">case</span> <a title="sbt.Incomplete" id="sbt;Execute.work.rawResult.$anonfun.i">i</a>: <a href="Incomplete.scala.html#sbt;Incomplete" title="sbt.Incomplete">Incomplete</a> =&gt; <span title="sbt.Incomplete" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.config" title="sbt.Execute.Config">config</a>.<a href="#sbt.Execute;Config.overwriteNode" title="(v1: sbt.Incomplete)Boolean">overwriteNode</a><span class="delimiter">(</span><a href="#sbt;Execute.work.rawResult.$anonfun.i" title="sbt.Incomplete">i</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt;Execute.work.rawResult.$anonfun.i" title="sbt.Incomplete">i</a>.<a href="Incomplete.scala.html#sbt;Incomplete.copy" title="(node: Option[AnyRef], tpe: sbt.Incomplete.Value, message: Option[String], causes: Seq[sbt.Incomplete], directCause: Option[Throwable])sbt.Incomplete">copy</a><span class="delimiter">(</span>node = <span title="(x: A[T])Some[A[T]]">Some</span><span class="delimiter">(</span><a href="#sbt;Execute.work.node" title="A[T]">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt;Execute.work.rawResult.$anonfun.i" title="sbt.Incomplete">i</a>
        <span class="keyword">case</span> <a title="Throwable" id="sbt;Execute.work.rawResult.$anonfun.e">e</a>             =&gt; <a href="Incomplete.scala.html#sbt.Incomplete.apply$default$3" title="Option[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.work.rawResult.$anonfun.x$21">Incomplete</a><span class="delimiter">(</span><span title="(x: A[T])Some[A[T]]">Some</span><a title="Some[A[T]] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.work.rawResult.$anonfun.x$17" class="delimiter">(</a><a href="#sbt;Execute.work.node" title="A[T]">node</a><span class="delimiter">)</span>, <a href="Incomplete.scala.html#sbt.Incomplete" title="sbt.Incomplete.type">Incomplete</a>.<a href="Incomplete.scala.html#sbt.Incomplete.Error" title="sbt.Incomplete.Value" id="sbt;Execute.work.rawResult.$anonfun.x$18">Error</a>, directCause = <span title="(x: Throwable)Some[Throwable]">Some</span><a title="Some[Throwable] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.work.rawResult.$anonfun.x$19" class="delimiter">(</a><a href="#sbt;Execute.work.rawResult.$anonfun.e" title="Throwable">e</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Either[A[T],sbt.Result[T]]" id="sbt;Execute.work.result">result</a> = <a href="#sbt;Execute.rewrap" title="(rawResult: Either[sbt.Incomplete,Either[A[T],T]])Either[A[T],sbt.Result[T]]">rewrap</a><span class="delimiter">(</span><a href="#sbt;Execute.work.rawResult" title="Either extends Serializable with Product with scala.util.Either[sbt.Incomplete,Either[A[T],T]]">rawResult</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.progress" title="sbt.ExecuteProgress[A]">progress</a>.<a href="ExecuteProgress.scala.html#sbt;ExecuteProgress.workFinished" title="(task: A[T], result: Either[A[T],sbt.Result[T]])Unit">workFinished</a><span class="delimiter">(</span><a href="#sbt;Execute.work.node" title="A[T]">node</a>, <a href="#sbt;Execute.work.result" title="Either[A[T],sbt.Result[T]]">result</a><span class="delimiter">)</span>
      <a href="#sbt.Execute.completed" title="(p: =&gt; Unit)sbt.Completed">completed</a> <span class="delimiter">{</span>
        <a href="#sbt;Execute.work.result" title="Either[A[T],sbt.Result[T]]">result</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="sbt.Result[T]" id="sbt;Execute.work.v">v</a><span class="delimiter">)</span>     =&gt; <a href="#sbt;Execute.retire" title="(node: A[T], result: sbt.Result[T])(implicit strategy: Execute.this.Strategy)Unit">retire</a><a href="#sbt;Execute.work.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.work.node" title="A[T]">node</a>, <a href="#sbt;Execute.work.v" title="sbt.Result[T]">v</a><span class="delimiter">)</span>
          <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.work.target">target</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Execute.call" title="(node: A[T], target: A[T])(implicit strategy: Execute.this.Strategy)Unit">call</a><a href="#sbt;Execute.work.strategy" title="Execute.this.Strategy" class="delimiter">(</a><a href="#sbt;Execute.work.node" title="A[T]">node</a>, <a href="#sbt;Execute.work.target" title="A[T]">target</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](rawResult: Either[sbt.Incomplete,Either[A[T],T]])Either[A[T],sbt.Result[T]]" id="sbt;Execute.rewrap">rewrap</a><span class="delimiter">[</span><a title="" id="sbt;Execute.rewrap;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Either[sbt.Incomplete,Either[A[T],T]]" id="sbt;Execute.rewrap.rawResult">rawResult</a>: <span title="Either[sbt.Incomplete,Either[A[T],T]]">Either</span><span class="delimiter">[</span>Incomplete, Either<span class="delimiter">[</span>A<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[A[T],sbt.Result[T]]">Either</span><span class="delimiter">[</span>A<span class="delimiter">[</span>T<span class="delimiter">]</span>, Result<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt;Execute.rewrap.rawResult" title="Either[sbt.Incomplete,Either[A[T],T]]">rawResult</a> <span title="Either[A[T],sbt.Result[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="sbt.Incomplete" id="sbt;Execute.rewrap.i">i</a><span class="delimiter">)</span>             =&gt; <span title="(b: sbt.Inc)scala.util.Right[Nothing,sbt.Inc]">Right</span><span class="delimiter">(</span><a href="Result.scala.html#sbt;Inc" title="(cause: sbt.Incomplete)sbt.Inc">Inc</a><span class="delimiter">(</span><a href="#sbt;Execute.rewrap.i" title="sbt.Incomplete">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> Right<span class="delimiter">(</span>Right<span class="delimiter">(</span><a title="T" id="sbt;Execute.rewrap.v">v</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(b: sbt.Value[T])scala.util.Right[Nothing,sbt.Value[T]]">Right</span><span class="delimiter">(</span><a href="Result.scala.html#sbt;Value" title="(value: T)sbt.Value[T]">Value</a><span class="delimiter">(</span><a href="#sbt;Execute.rewrap.v" title="T">v</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> Right<span class="delimiter">(</span>Left<span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.rewrap.target">target</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(a: A[T])scala.util.Left[A[T],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;Execute.rewrap.target" title="A[T]">target</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[K, V](map: scala.collection.mutable.Map[K,V], k: K)V" id="sbt;Execute.remove">remove</a><span class="delimiter">[</span><a title="" id="sbt;Execute.remove;K">K</a>, <a title="" id="sbt;Execute.remove;V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.mutable.Map[K,V]" id="sbt;Execute.remove.map">map</a>: <span title="scala.collection.mutable.Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="K" id="sbt;Execute.remove.k">k</a>: <a href="#sbt;Execute.remove;K" title="K">K</a><span class="delimiter">)</span>: <a href="#sbt;Execute.remove;V" title="V">V</a> = <a href="#sbt;Execute.remove.map" title="scala.collection.mutable.Map[K,V]">map</a>.<span title="(key: K)Option[V]">remove</span><span class="delimiter">(</span><a href="#sbt;Execute.remove.k" title="K">k</a><span class="delimiter">)</span>.<span title="(default: =&gt; V)V">getOrElse</span><span class="delimiter">(</span>sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Key \'&quot;)" class="string">&quot;Key '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.remove.k" title="K">k</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\' not in map :\n&quot;)" class="string">&quot;' not in map :\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.remove.map" title="scala.collection.mutable.Map[K,V]">map</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(node: A[_], dependent: A[_])Unit" id="sbt;Execute.addReverse">addReverse</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.addReverse.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="A[_]" id="sbt;Execute.addReverse.dependent">dependent</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt;Execute.reverse" title="(key: A[_], value: Iterable[A[_]])Unit">reverse</a><span class="delimiter">(</span><a href="#sbt;Execute.addReverse.node" title="A[_]">node</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[A[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[A[_]],A[_],Iterable[A[_]]])Iterable[A[_]]">++=</span> <span title="(elems: A[_$15]*)Seq[A[_$15]]">Seq</span><span class="delimiter">(</span><a href="#sbt;Execute.addReverse.dependent" title="A[_]">dependent</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](caller: A[T], target: A[T])Unit" id="sbt;Execute.addCaller">addCaller</a><span class="delimiter">[</span><a title="" id="sbt;Execute.addCaller;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.addCaller.caller">caller</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="A[T]" id="sbt;Execute.addCaller.target">target</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a>.<a href="PMap.scala.html#sbt;PMap.getOrUpdate" title="(k: A[T], make: =&gt; sbt.IDSet[A[T]])sbt.IDSet[A[T]]">getOrUpdate</a><span class="delimiter">(</span><a href="#sbt;Execute.addCaller.target" title="A[T]">target</a>, <a href="IDSet.scala.html#sbt.IDSet" title="sbt.IDSet.type">IDSet</a>.<a href="IDSet.scala.html#sbt.IDSet.create" title="[T]=&gt; sbt.IDSet[T]">create</a><span title="sbt.IDSet[A[T]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <a href="IDSet.scala.html#sbt;IDSet.+=" title="(t: A[T])Unit">+=</a> <a href="#sbt;Execute.addCaller.caller" title="A[T]">caller</a>

  <span class="keyword">def</span> <a title="(node: A[_])Iterable[A[_]]" id="sbt;Execute.dependencies(ecd132e6e4)">dependencies</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.dependencies(ecd132e6e4).node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[A[_]]">Iterable</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Execute.dependencies(fd28f19800)" title="(v: sbt.Node[A, _])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="PMap.scala.html#sbt;RMap.apply" title="(k: A[_$16])sbt.Node[A,_$16]">viewCache</a><span class="delimiter">(</span><a href="#sbt;Execute.dependencies(ecd132e6e4).node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(v: sbt.Node[A, _])Iterable[A[_]]" id="sbt;Execute.dependencies(fd28f19800)">dependencies</a><span class="delimiter">(</span><a title="sbt.Node[A, _]" id="sbt;Execute.dependencies(fd28f19800).v">v</a>: <a href="Node.scala.html#sbt;Node" title="sbt.Node[A, _]">Node</a><span class="delimiter">[</span>A, _<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[A[_]]">Iterable</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Execute.dependencies(fd28f19800).v" title="sbt.Node[A, _]">v</a>.<a href="Node.scala.html#sbt;Node.alist" title="=&gt; sbt.AList[v.K]">alist</a>.<a href="AList.scala.html#sbt;AList.toList" title="(value: v.K[A])List[A[_]]">toList</a><span class="delimiter">(</span><a href="#sbt;Execute.dependencies(fd28f19800).v" title="sbt.Node[A, _]">v</a>.<a href="Node.scala.html#sbt;Node.in" title="=&gt; v.K[A]">in</a><span class="delimiter">)</span>.<span title="(p: A[_] =&gt; Boolean)List[A[_]]">filter</span><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.dependencies(fd28f19800).$anonfun.dep">dep</a> =&gt; <a href="#sbt;Execute.view" title="sbt.NodeView[A]">view</a>.<a href="#sbt;NodeView.inline" title="(a: A[_$2])Option[() =&gt; _$2]">inline</a><span class="delimiter">(</span><a href="#sbt;Execute.dependencies(fd28f19800).$anonfun.dep" title="A[_]">dep</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(node: A[_])Seq[A[_]]" id="sbt;Execute.runBefore">runBefore</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.runBefore.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[A[_]]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Execute.getSeq" title="(map: scala.collection.Map[A[_],Seq[A[_]]], node: A[_])Seq[A[_]]">getSeq</a><span class="delimiter">(</span><a href="#sbt;Execute.triggers" title="sbt.Triggers[A]">triggers</a>.<a href="#sbt;Triggers.runBefore" title="=&gt; scala.collection.Map[A[_],Seq[A[_]]]">runBefore</a>, <a href="#sbt;Execute.runBefore.node" title="A[_]">node</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(node: A[_])Seq[A[_]]" id="sbt;Execute.triggeredBy">triggeredBy</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.triggeredBy.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[A[_]]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Execute.getSeq" title="(map: scala.collection.Map[A[_],Seq[A[_]]], node: A[_])Seq[A[_]]">getSeq</a><span class="delimiter">(</span><a href="#sbt;Execute.triggers" title="sbt.Triggers[A]">triggers</a>.<a href="#sbt;Triggers.injectFor" title="=&gt; scala.collection.Map[A[_],Seq[A[_]]]">injectFor</a>, <a href="#sbt;Execute.triggeredBy.node" title="A[_]">node</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(map: scala.collection.Map[A[_],Seq[A[_]]], node: A[_])Seq[A[_]]" id="sbt;Execute.getSeq">getSeq</a><span class="delimiter">(</span><a title="scala.collection.Map[A[_],Seq[A[_]]]" id="sbt;Execute.getSeq.map">map</a>: collection.<span title="scala.collection.Map[A[_],Seq[A[_]]]">Map</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="A[_]" id="sbt;Execute.getSeq.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[A[_]]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;Execute.getSeq.map" title="scala.collection.Map[A[_],Seq[A[_]]]">map</a>.<span title="(key: A[_], default: =&gt; Seq[A[_]])Seq[A[_]]">getOrElse</span><span class="delimiter">(</span><a href="#sbt;Execute.getSeq.node" title="A[_]">node</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>

  <span class="comment">// Contracts</span>

  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.addedInv">addedInv</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.addedInv.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#sbt;Execute.topologicalSort" title="(node: A[_])Seq[A[_]]">topologicalSort</a><span class="delimiter">(</span><a href="#sbt;Execute.addedInv.node" title="A[_]">node</a><span class="delimiter">)</span> <span title="(f: A[_] =&gt; Unit)Unit">foreach</span> <a href="#sbt;Execute.addedCheck" title="(node: A[_])Unit">addedCheck</a>
  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.addedCheck">addedCheck</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.addedCheck.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.added" title="(d: A[_])Boolean">added</a><span class="delimiter">(</span><a href="#sbt;Execute.addedCheck.node" title="A[_]">node</a><span class="delimiter">)</span>, <span title="String(&quot;Not added: &quot;)" class="string">&quot;Not added: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.addedCheck.node" title="A[_]">node</a><span class="delimiter">)</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.viewCache" title="sbt.PMap[A,[t]sbt.Node[A,t]]">viewCache</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: A[_$29])Boolean">contains</a> <a href="#sbt;Execute.addedCheck.node" title="A[_]">node</a>, <span title="String(&quot;Not in view cache: &quot;)" class="string">&quot;Not in view cache: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt;Execute.addedCheck.node" title="A[_]">node</a><span class="delimiter">)</span>
    <a href="#sbt;Execute.dependencyCheck" title="(node: A[_])Unit">dependencyCheck</a><span class="delimiter">(</span><a href="#sbt;Execute.addedCheck.node" title="A[_]">node</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.dependencyCheck">dependencyCheck</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.dependencyCheck.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#sbt;Execute.dependencies(ecd132e6e4)" title="(node: A[_])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.node" title="A[_]">node</a><span class="delimiter">)</span> <span title="(f: A[_] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="A[_]" id="sbt;Execute.dependencyCheck.$anonfun.dep">dep</a> =&gt;
      <span class="keyword">def</span> <a title="[T](o: Option[T])(f: T =&gt; Boolean)Boolean" id="sbt;Execute.dependencyCheck.$anonfun.onOpt">onOpt</a><span class="delimiter">[</span><a title="" id="sbt;Execute.dependencyCheck.$anonfun.onOpt;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Option[T]" id="sbt;Execute.dependencyCheck.$anonfun.onOpt.o">o</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="T =&gt; Boolean" id="sbt;Execute.dependencyCheck.$anonfun.onOpt.f">f</a>: T =&gt; Boolean<span class="delimiter">)</span> = <a href="#sbt;Execute.dependencyCheck.$anonfun.onOpt.o" title="Option[T]">o</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>; <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="T" id="sbt;Execute.dependencyCheck.$anonfun.onOpt.x">x</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Execute.dependencyCheck.$anonfun.onOpt.f" title="(v1: T)Boolean">f</a><span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.$anonfun.onOpt.x" title="T">x</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Execute.dependencyCheck.$anonfun.checkForward">checkForward</a> = <a href="#sbt;Execute.dependencyCheck.$anonfun.onOpt" title="(o: Option[sbt.IDSet[A[_]]])(f: sbt.IDSet[A[_]] =&gt; Boolean)Boolean">onOpt</a><span class="delimiter">(</span><a href="#sbt;Execute.forward" title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]">forward</a>.<span title="(key: A[_])Option[sbt.IDSet[A[_]]]">get</span><span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt;Execute.dependencyCheck.$anonfun.checkForward.$anonfun.x$4" title="sbt.IDSet[A[_]]">_</a> <a href="IDSet.scala.html#sbt;IDSet.contains" title="(t: A[_])Boolean">contains</a> <a href="#sbt;Execute.dependencyCheck.$anonfun.dep" title="A[_]">dep</a> <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Execute.dependencyCheck.$anonfun.checkReverse">checkReverse</a> = <a href="#sbt;Execute.dependencyCheck.$anonfun.onOpt" title="(o: Option[Iterable[A[_]]])(f: Iterable[A[_]] =&gt; Boolean)Boolean">onOpt</a><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a>.<span title="(key: A[_])Option[Iterable[A[_]]]">get</span><span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.$anonfun.dep" title="A[_]">dep</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt;Execute.dependencyCheck.$anonfun.checkReverse.$anonfun.x$5" title="Iterable[A[_]]">_</a>.<span title="(p: A[_] =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.$anonfun.checkReverse.$anonfun.$anonfun.x$6" title="A[_]">_</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;Execute.dependencyCheck.node" title="A[_]">node</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.$anonfun.dep" title="A[_]">dep</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">^</span> <span class="delimiter">(</span><a href="#sbt;Execute.dependencyCheck.$anonfun.checkForward" title="=&gt; Boolean">checkForward</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt;Execute.dependencyCheck.$anonfun.checkReverse" title="=&gt; Boolean">checkReverse</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.pendingInv">pendingInv</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.pendingInv.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.atState" title="(d: A[_], s: Execute.this.State)Boolean">atState</a><span class="delimiter">(</span><a href="#sbt;Execute.pendingInv.node" title="A[_]">node</a>, <a href="#sbt;Execute.State.Pending" title="=&gt; Execute.this.State.Value">Pending</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#sbt;Execute.dependencies(ecd132e6e4)" title="(node: A[_])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="#sbt;Execute.pendingInv.node" title="A[_]">node</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[A[_]])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[A[_]],A[_],Iterable[A[_]]])Iterable[A[_]]">++</span> <a href="#sbt;Execute.runBefore" title="(node: A[_])Seq[A[_]]">runBefore</a><span class="delimiter">(</span><a href="#sbt;Execute.pendingInv.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(p: A[_] =&gt; Boolean)Boolean">exists</span> <a href="#sbt;Execute.notDone" title="(d: A[_])Boolean">notDone</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.runningInv">runningInv</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.runningInv.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.dependencies(ecd132e6e4)" title="(node: A[_])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="#sbt;Execute.runningInv.node" title="A[_]">node</a><span class="delimiter">)</span> <span title="(p: A[_] =&gt; Boolean)Boolean">forall</span> <a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.forward" title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]">forward</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.runningInv.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.newPre">newPre</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.newPre.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#sbt;Execute.isNew" title="(d: A[_])Boolean">isNew</a><span class="delimiter">(</span><a href="#sbt;Execute.newPre.node" title="A[_]">node</a><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.reverse" title="scala.collection.mutable.Map[A[_],Iterable[A[_]]]">reverse</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.newPre.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.forward" title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]">forward</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.newPre.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: A[_$33])Boolean">contains</a> <a href="#sbt;Execute.newPre.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.viewCache" title="sbt.PMap[A,[t]sbt.Node[A,t]]">viewCache</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: A[_$33])Boolean">contains</a> <a href="#sbt;Execute.newPre.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.results" title="sbt.PMap[A,sbt.Result]">results</a> <a href="PMap.scala.html#sbt;RMap.contains" title="(k: A[_$33])Boolean">contains</a> <a href="#sbt;Execute.newPre.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(node: A[_])Seq[A[_]]" id="sbt;Execute.topologicalSort">topologicalSort</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.topologicalSort.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[A[_]]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.IDSet[A[_]]" id="sbt;Execute.topologicalSort.seen">seen</a> = <a href="IDSet.scala.html#sbt.IDSet" title="sbt.IDSet.type">IDSet</a>.<a href="IDSet.scala.html#sbt.IDSet.create" title="[T]=&gt; sbt.IDSet[T]">create</a><span title="sbt.IDSet[A[_]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(n: A[_])List[A[_]]" id="sbt;Execute.topologicalSort.visit">visit</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.topologicalSort.visit.n">n</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[A[_]]">List</span><span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> =
        <span class="delimiter">(</span><a href="#sbt;Execute.topologicalSort.seen" title="sbt.IDSet[A[_]]">seen</a> <a href="IDSet.scala.html#sbt;IDSet.process" title="(t: A[_])(ifSeen: List[A[_]])(ifNew: =&gt; List[A[_]])List[A[_]]">process</a> <a href="#sbt;Execute.topologicalSort.visit.n" title="A[_]">n</a><span class="delimiter">)</span><span class="delimiter">(</span>List<span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#sbt;Execute.topologicalSort.node" title="A[_]">node</a> <a href="#sbt;Execute.topologicalSort.visit.x$9" title="(x: A[_])List[A[_]]">::</a> <span class="delimiter">(</span>List<span class="delimiter">[</span>A<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span> <a href="#sbt;Execute.topologicalSort.visit.x$7" title="(z: List[A[_]])(op: (List[A[_]], A[_]) =&gt; List[A[_]])List[A[_]]">/:</a> <a href="#sbt;Execute.dependencies(ecd132e6e4)" title="(node: A[_])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="#sbt;Execute.topologicalSort.visit.n" title="A[_]">n</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="List[A[_]]" id="sbt;Execute.topologicalSort.visit.$anonfun.ss">ss</a>, <a title="A[_]" id="sbt;Execute.topologicalSort.visit.$anonfun.dep">dep</a><span class="delimiter">)</span> =&gt; <a href="#sbt;Execute.topologicalSort.visit" title="(n: A[_])List[A[_]]">visit</a><span class="delimiter">(</span><a href="#sbt;Execute.topologicalSort.visit.$anonfun.dep" title="A[_]">dep</a><span class="delimiter">)</span> <a href="#sbt;Execute.topologicalSort.visit.$anonfun.x$8" title="(prefix: List[A[_]])List[A[_]]">:::</a> <a href="#sbt;Execute.topologicalSort.visit.$anonfun.ss" title="List[A[_]]">ss</a> <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <a href="#sbt;Execute.topologicalSort.visit" title="(n: A[_])List[A[_]]">visit</a><span class="delimiter">(</span><a href="#sbt;Execute.topologicalSort.node" title="A[_]">node</a><span class="delimiter">)</span>.<span title="=&gt; List[A[_]]">reverse</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(node: A[_])Unit" id="sbt;Execute.readyInv">readyInv</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.readyInv.node">node</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt;Execute.dependencies(ecd132e6e4)" title="(node: A[_])Iterable[A[_]]">dependencies</a><span class="delimiter">(</span><a href="#sbt;Execute.readyInv.node" title="A[_]">node</a><span class="delimiter">)</span> <span title="(p: A[_] =&gt; Boolean)Boolean">forall</span> <a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#sbt;Execute.forward" title="scala.collection.mutable.Map[A[_],sbt.IDSet[A[_]]]">forward</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.readyInv.node" title="A[_]">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// cyclic reference checking</span>

  <span class="keyword">def</span> <a title="()Unit" id="sbt;Execute.snapshotCycleCheck">snapshotCycleCheck</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="A[c]" id="sbt;Execute.snapshotCycleCheck.$anonfun.called">called</a>: <a href="#sbt;Execute;A" title="A[c]">A</a><span class="delimiter">[</span>c<span class="delimiter">]</span>, <a title="sbt.IDSet[A[_0]] forSome { type _0; type _$2 }" id="sbt;Execute.snapshotCycleCheck.$anonfun.callers">callers</a><span class="delimiter">)</span> &lt;- <a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a>.<a href="PMap.scala.html#sbt;RMap.toSeq" title="(f: ((A[_], sbt.IDSet[A[_$2]] forSome { type _$2 })) =&gt; Unit)Unit">toSeq</a>; <a title="A[_0]" id="sbt;Execute.snapshotCycleCheck.$anonfun.$anonfun.caller">caller</a> &lt;- <a href="IDSet.scala.html#sbt;IDSet.foreach" title="(f: A[_0] =&gt; Unit)Unit">callers</a><span class="delimiter">)</span>
      <a href="#sbt;Execute.cycleCheck" title="(node: A[c], target: A[c])Unit">cycleCheck</a><span class="delimiter">(</span><a href="#sbt;Execute.snapshotCycleCheck.$anonfun.$anonfun.caller" title="A[_0]">caller</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="A[c]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[c]">A</a><span class="delimiter">[</span>c<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#sbt;Execute.snapshotCycleCheck.$anonfun.called" title="A[c]">called</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](node: A[T], target: A[T])Unit" id="sbt;Execute.cycleCheck">cycleCheck</a><span class="delimiter">[</span><a title="" id="sbt;Execute.cycleCheck;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.cycleCheck.node">node</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="A[T]" id="sbt;Execute.cycleCheck.target">target</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.node" title="A[T]">node</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#sbt;Execute.cycleCheck.target" title="A[T]">target</a><span class="delimiter">)</span> <a href="#sbt;Execute.cyclic" title="(caller: A[T], target: A[T], msg: String)Nothing">cyclic</a><span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.node" title="A[T]">node</a>, <a href="#sbt;Execute.cycleCheck.target" title="A[T]">target</a>, <span title="String(&quot;Cannot call self&quot;)" class="string">&quot;Cannot call self&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="sbt.IDSet[A[T]]" id="sbt;Execute.cycleCheck.all">all</a> = <a href="IDSet.scala.html#sbt.IDSet" title="sbt.IDSet.type">IDSet</a>.<a href="IDSet.scala.html#sbt.IDSet.create" title="[T]=&gt; sbt.IDSet[T]">create</a><span title="sbt.IDSet[A[T]]" class="delimiter">[</span><a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="(n: A[T])Unit" id="sbt;Execute.cycleCheck.allCallers">allCallers</a><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.cycleCheck.allCallers.n">n</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.all" title="sbt.IDSet[A[T]]">all</a> <a href="IDSet.scala.html#sbt;IDSet.process" title="(t: A[T])(ifSeen: Unit)(ifNew: =&gt; Unit)Unit">process</a> <a href="#sbt;Execute.cycleCheck.allCallers.n" title="A[T]">n</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#sbt;Execute.callers" title="sbt.PMap[A,[T]sbt.IDSet[A[T]]]">callers</a>.<a href="PMap.scala.html#sbt;RMap.get" title="(k: A[T])Option[sbt.IDSet[A[T]]]">get</a><span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.allCallers.n" title="A[T]">n</a><span class="delimiter">)</span>.<span title="=&gt; List[sbt.IDSet[A[T]]]">toList</span>.<a href="IDSet.scala.html#sbt.IDSet.toTraversable" title="(implicit asTraversable: sbt.IDSet[A[T]] =&gt; scala.collection.GenTraversableOnce[A[T]])List[A[T]]">flatten</a>.<span title="(f: A[T] =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.allCallers" title="(n: A[T])Unit">allCallers</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#sbt;Execute.cycleCheck.allCallers" title="(n: A[T])Unit">allCallers</a><span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.node" title="A[T]">node</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.all" title="sbt.IDSet[A[T]]">all</a> <a href="IDSet.scala.html#sbt;IDSet.contains" title="(t: A[T])Boolean">contains</a> <a href="#sbt;Execute.cycleCheck.target" title="A[T]">target</a><span class="delimiter">)</span> <a href="#sbt;Execute.cyclic" title="(caller: A[T], target: A[T], msg: String)Nothing">cyclic</a><span class="delimiter">(</span><a href="#sbt;Execute.cycleCheck.node" title="A[T]">node</a>, <a href="#sbt;Execute.cycleCheck.target" title="A[T]">target</a>, <span title="String(&quot;Cyclic reference&quot;)" class="string">&quot;Cyclic reference&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[T](caller: A[T], target: A[T], msg: String)Nothing" id="sbt;Execute.cyclic">cyclic</a><span class="delimiter">[</span><a title="" id="sbt;Execute.cyclic;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;Execute.cyclic.caller">caller</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="A[T]" id="sbt;Execute.cyclic.target">target</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt;Execute.cyclic.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="Nothing" class="keyword">throw</span> <a href="Incomplete.scala.html#sbt.Incomplete.<init>$default$2" title="sbt.Incomplete.Value" id="sbt;Execute.cyclic.x$26" class="keyword">new</a> <a href="Incomplete.scala.html#sbt.Incomplete" title="sbt.Incomplete.type">Incomplete</a><span class="delimiter">(</span><span title="(x: A[T])Some[A[T]]">Some</span><a title="Some[A[T]] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.cyclic.x$22" class="delimiter">(</a><a href="#sbt;Execute.cyclic.caller" title="A[T]">caller</a><span class="delimiter">)</span>, message = <span title="(x: String)Some[String]">Some</span><a title="Some[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.cyclic.x$23" class="delimiter">(</a><a href="#sbt;Execute.cyclic.msg" title="String">msg</a><span class="delimiter">)</span>, directCause = <span title="(x: Execute.this.CyclicException[T])Some[Execute.this.CyclicException[T]]">Some</span><a title="Some[Execute.this.CyclicException[T]] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt;Execute.cyclic.x$24" class="delimiter">(</a><span title="Execute.this.CyclicException[T]" class="keyword">new</span> <a href="#sbt;Execute;CyclicException" title="Execute.this.CyclicException[T]">CyclicException</a><span class="delimiter">(</span><a href="#sbt;Execute.cyclic.caller" title="A[T]">caller</a>, <a href="#sbt;Execute.cyclic.target" title="A[T]">target</a>, <a href="#sbt;Execute.cyclic.msg" title="String">msg</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class CyclicException[T] extends Exception" id="sbt;Execute;CyclicException">CyclicException</a><span class="delimiter">[</span><a title="" id="sbt;Execute;CyclicException;T">T</a><span class="delimiter">]</span><a href="#sbt;Execute;CyclicException" title="Execute.this.CyclicException[T]" class="delimiter">(</a><span class="keyword">val</span> <a title="A[T]" id="sbt;Execute;CyclicException.caller">caller</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="A[T]" id="sbt;Execute;CyclicException.target">target</a>: <a href="#sbt;Execute;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt;Execute;CyclicException.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Exception">Exception</span><span class="delimiter">(</span><a href="#sbt;Execute;CyclicException.msg" title="String">msg</a><span class="delimiter">)</span>

  <span class="comment">// state testing</span>

  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.pending">pending</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.pending.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Execute.atState" title="(d: A[_], s: Execute.this.State)Boolean">atState</a><span class="delimiter">(</span><a href="#sbt;Execute.pending.d" title="A[_]">d</a>, <a href="#sbt;Execute.State.Pending" title="=&gt; Execute.this.State.Value">Pending</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.running">running</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.running.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Execute.atState" title="(d: A[_], s: Execute.this.State)Boolean">atState</a><span class="delimiter">(</span><a href="#sbt;Execute.running.d" title="A[_]">d</a>, <a href="#sbt;Execute.State.Running" title="=&gt; Execute.this.State.Value">Running</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.calling">calling</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.calling.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Execute.atState" title="(d: A[_], s: Execute.this.State)Boolean">atState</a><span class="delimiter">(</span><a href="#sbt;Execute.calling.d" title="A[_]">d</a>, <a href="#sbt;Execute.State.Calling" title="=&gt; Execute.this.State.Value">Calling</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.done">done</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.done.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Execute.atState" title="(d: A[_], s: Execute.this.State)Boolean">atState</a><span class="delimiter">(</span><a href="#sbt;Execute.done.d" title="A[_]">d</a>, <a href="#sbt;Execute.State.Done" title="=&gt; Execute.this.State.Value">Done</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.notDone">notDone</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.notDone.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="=&gt; Boolean">!</span><a href="#sbt;Execute.done" title="(d: A[_])Boolean">done</a><span class="delimiter">(</span><a href="#sbt;Execute.notDone.d" title="A[_]">d</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_], s: Execute.this.State)Boolean" id="sbt;Execute.atState">atState</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.atState.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Execute.this.State" id="sbt;Execute.atState.s">s</a>: <span title="Execute.this.State">State</span><span class="delimiter">)</span> = <a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a>.<span title="(key: A[_])Option[Execute.this.State]">get</span><span class="delimiter">(</span><a href="#sbt;Execute.atState.d" title="A[_]">d</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">==</span> <span title="(x: Execute.this.State)Some[Execute.this.State]">Some</span><span class="delimiter">(</span><a href="#sbt;Execute.atState.s" title="Execute.this.State">s</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.isNew">isNew</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.isNew.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="=&gt; Boolean">!</span><a href="#sbt;Execute.added" title="(d: A[_])Boolean">added</a><span class="delimiter">(</span><a href="#sbt;Execute.isNew.d" title="A[_]">d</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(d: A[_])Boolean" id="sbt;Execute.added">added</a><span class="delimiter">(</span><a title="A[_]" id="sbt;Execute.added.d">d</a>: <a href="#sbt;Execute;A" title="A[_]">A</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a> <span title="(key: A[_])Boolean">contains</span> <a href="#sbt;Execute.added.d" title="A[_]">d</a>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt;Execute.complete">complete</a> = <a href="#sbt;Execute.state" title="scala.collection.mutable.Map[A[_],Execute.this.State]">state</a>.<span title="=&gt; Iterable[Execute.this.State]">values</span>.<span title="(p: Execute.this.State =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#sbt;Execute.complete.$anonfun.x$11" title="Execute.this.State">_</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#sbt;Execute.State.Done" title="=&gt; Execute.this.State.Value">Done</a><span class="delimiter">)</span>

  <span class="keyword">import</span> scala.annotation.elidable
  <span class="keyword">import</span> <span title="scala.annotation.elidable.type">elidable</span>._
  @elidable<span class="delimiter">(</span>ASSERTION<span class="delimiter">)</span> <span class="keyword">def</span> <a title="(f: =&gt; Unit)Unit" id="sbt;Execute.pre">pre</a><span class="delimiter">(</span><a title="=&gt; Unit" id="sbt;Execute.pre.f">f</a>: =&gt; Unit<span class="delimiter">)</span> = <a href="#sbt;Execute.pre.f" title="=&gt; Unit">f</a>
  @elidable<span class="delimiter">(</span>ASSERTION<span class="delimiter">)</span> <span class="keyword">def</span> <a title="(f: =&gt; Unit)Unit" id="sbt;Execute.post">post</a><span class="delimiter">(</span><a title="=&gt; Unit" id="sbt;Execute.post.f">f</a>: =&gt; Unit<span class="delimiter">)</span> = <a href="#sbt;Execute.post.f" title="=&gt; Unit">f</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
