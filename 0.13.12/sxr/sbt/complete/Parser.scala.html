<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/complete/Parser.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2008, 2010, 2011  Mark Harrah
 */</span>
<span class="keyword">package</span> sbt.complete

<span class="keyword">import</span> <a href="#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>._
<span class="keyword">import</span> sbt.<a href="../Types.scala.html#sbt.Types" title="sbt.Types.type">Types</a>.<span class="delimiter">{</span> left, right, some <span class="delimiter">}</span>
<span class="keyword">import</span> sbt.<a href="../Util.scala.html#sbt.Util" title="sbt.Util.type">Util</a>.<span class="delimiter">{</span> makeList, separate <span class="delimiter">}</span>

<span class="comment">/**
 * A String parser that provides semi-automatic tab completion.
 * A successful parse results in a value of type `T`.
 * The methods in this trait are what must be implemented to define a new Parser implementation, but are not typically useful for common usage.
 * Instead, most useful methods for combining smaller parsers into larger parsers are implicitly added by the [[RichParser]] type.
 */</span>
<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Parser[+T] extends AnyRef" id="sbt.complete;Parser">Parser</a><span class="delimiter">[</span>+<a title="" id="sbt.complete;Parser;T">T</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(i: Char)sbt.complete.Parser[T]" id="sbt.complete;Parser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parser.derive.i">i</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[T]" id="sbt.complete;Parser.resultEmpty">resultEmpty</a>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Option[T]" id="sbt.complete;Parser.result">result</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;Parser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Parser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Completions.scala.html#sbt.complete;Completions" title="sbt.complete.Completions">Completions</a>
  <span class="keyword">def</span> <a title="=&gt; Option[sbt.complete.Parser.Failure]" id="sbt.complete;Parser.failure">failure</a>: <span title="Option[sbt.complete.Parser.Failure]">Option</span><span class="delimiter">[</span>Failure<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;Parser.isTokenStart">isTokenStart</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">def</span> <a title="[S](p: =&gt; sbt.complete.Parser[S])sbt.complete.Parser[S]" id="sbt.complete;Parser.ifValid">ifValid</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parser.ifValid;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser[S]" id="sbt.complete;Parser.ifValid.p">p</a>: =&gt; Parser<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[S]">Parser</a><span class="delimiter">[</span>S<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;Parser.valid">valid</a>: <span title="Boolean">Boolean</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait RichParser[A] extends AnyRef" id="sbt.complete;RichParser">RichParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser;A">A</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/** Apply the original Parser and then apply `next` (in order).  The result of both is provides as a pair. */</span>
  <span class="keyword">def</span> <a title="[B](next: sbt.complete.Parser[B])sbt.complete.Parser[(A, B)]" id="sbt.complete;RichParser.~">~</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.~;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;RichParser.~.next">next</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[(A, B)]">Parser</a><span class="delimiter">[</span><span class="delimiter">(</span>A, B<span class="delimiter">)</span><span class="delimiter">]</span>

  <span class="comment">/** Apply the original Parser one or more times and provide the non-empty sequence of results.*/</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Seq[A]]" id="sbt.complete;RichParser.+">+</a> : <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[A]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/** Apply the original Parser zero or more times and provide the (potentially empty) sequence of results.*/</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Seq[A]]" id="sbt.complete;RichParser.*">*</a> : <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[A]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/** Apply the original Parser zero or one times, returning None if it was applied zero times or the result wrapped in Some if it was applied once.*/</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Option[A]]" id="sbt.complete;RichParser.?">?</a> : <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Option[A]]">Parser</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/** Apply either the original Parser or `b`.*/</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](b: sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete;RichParser.|">|</a><span class="delimiter">[</span><a title=" &gt;: A" id="sbt.complete;RichParser.|;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;RichParser.|.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/** Apply either the original Parser or `b`.*/</span>
  <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[Either[A,B]]" id="sbt.complete;RichParser.||">||</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.||;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;RichParser.||.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Either[A,B]]">Parser</a><span class="delimiter">[</span>Either<span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/** Apply the original Parser to the input and then apply `f` to the result.*/</span>
  <span class="keyword">def</span> <a title="[B](f: A =&gt; B)sbt.complete.Parser[B]" id="sbt.complete;RichParser.map">map</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="sbt.complete;RichParser.map.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/**
   * Returns the original parser.  This is useful for converting literals to Parsers.
   * For example, `'c'.id` or `&quot;asdf&quot;.id`
   */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[A]" id="sbt.complete;RichParser.id">id</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/** Apply the original Parser, but provide `value` as the result if it succeeds. */</span>
  <span class="keyword">def</span> <a title="[B](value: B)sbt.complete.Parser[B]" id="sbt.complete;RichParser.^^^">^^^</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.^^^;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="sbt.complete;RichParser.^^^.value">value</a>: <a href="#sbt.complete;RichParser.^^^;B" title="B">B</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/** Apply the original Parser, but provide `alt` as the result if it fails.*/</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](alt: B)sbt.complete.Parser[B]" id="sbt.complete;RichParser.??">??</a><span class="delimiter">[</span><a title=" &gt;: A" id="sbt.complete;RichParser.??;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="sbt.complete;RichParser.??.alt">alt</a>: <a href="#sbt.complete;RichParser.??;B" title="B">B</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/**
   * Produces a Parser that applies the original Parser and then applies `next` (in order), discarding the result of `next`.
   * (The arrow point in the direction of the retained result.)
   */</span>
  <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[A]" id="sbt.complete;RichParser.<~">&lt;~</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.<~;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;RichParser.<~.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/**
   * Produces a Parser that applies the original Parser and then applies `next` (in order), discarding the result of the original parser.
   * (The arrow point in the direction of the retained result.)
   */</span>
  <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete;RichParser.~>">~&gt;</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.~>;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;RichParser.~>.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/** Uses the specified message if the original Parser fails.*/</span>
  <span class="keyword">def</span> <a title="(msg: String)sbt.complete.Parser[A]" id="sbt.complete;RichParser.!!!">!!!</a><span class="delimiter">(</span><a title="String" id="sbt.complete;RichParser.!!!.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/**
   * If an exception is thrown by the original Parser,
   * capture it and fail locally instead of allowing the exception to propagate up and terminate parsing.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[A]" id="sbt.complete;RichParser.failOnException">failOnException</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `not` and explicitly provide the failure message&quot;</span>, <span class="string">&quot;0.12.2&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Unit]" id="sbt.complete;RichParser.unary_-">unary_-</a> : <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Unit]">Parser</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span>

  <span class="comment">/**
   * Apply the original parser, but only succeed if `o` also succeeds.
   * Note that `o` does not need to consume the same amount of input to satisfy this condition.
   */</span>
  <span class="keyword">def</span> <a title="(o: sbt.complete.Parser[_])sbt.complete.Parser[A]" id="sbt.complete;RichParser.&">&amp;</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;RichParser.&.o">o</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `and` and `not` and explicitly provide the failure message&quot;</span>, <span class="string">&quot;0.12.2&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(o: sbt.complete.Parser[_])sbt.complete.Parser[A]" id="sbt.complete;RichParser.-">-</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;RichParser.-.o">o</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/** Explicitly defines the completions for the original Parser.*/</span>
  <span class="keyword">def</span> <a title="(s: String*)sbt.complete.Parser[A]" id="sbt.complete;RichParser.examples(88b70d78c2)">examples</a><span class="delimiter">(</span><a title="String*" id="sbt.complete;RichParser.examples(88b70d78c2).s">s</a>: <span title="String*">String</span>*<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/** Explicitly defines the completions for the original Parser.*/</span>
  <span class="keyword">def</span> <a title="(s: Set[String], check: Boolean)sbt.complete.Parser[A]" id="sbt.complete;RichParser.examples(dc06e66187)">examples</a><span class="delimiter">(</span><a title="Set[String]" id="sbt.complete;RichParser.examples(dc06e66187).s">s</a>: <span title="Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete;RichParser.examples$default$2">check</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/**
   * @param exampleSource the source of examples when displaying completions to the user.
   * @param maxNumberOfExamples limits the number of examples that the source of examples should return. This can
   *                            prevent lengthy pauses and avoids bad interactive user experience.
   * @param removeInvalidExamples indicates whether completion examples should be checked for validity (against the
   *                              given parser). Invalid examples will be filtered out and only valid suggestions will
   *                              be displayed.
   * @return a new parser with a new source of completions.
   */</span>
  <span class="keyword">def</span> <a title="(exampleSource: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]" id="sbt.complete;RichParser.examples(99c5ffc98b)">examples</a><span class="delimiter">(</span><a title="sbt.complete.ExampleSource" id="sbt.complete;RichParser.examples(99c5ffc98b).exampleSource">exampleSource</a>: <a href="ExampleSource.scala.html#sbt.complete;ExampleSource" title="sbt.complete.ExampleSource">ExampleSource</a>, <a title="Int" id="sbt.complete;RichParser.examples(99c5ffc98b).maxNumberOfExamples">maxNumberOfExamples</a>: <span title="Int">Int</span>, <a title="Boolean" id="sbt.complete;RichParser.examples(99c5ffc98b).removeInvalidExamples">removeInvalidExamples</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/**
   * @param exampleSource the source of examples when displaying completions to the user.
   * @return a new parser with a new source of completions. It displays at most 25 completion examples and does not
   *         remove invalid examples.
   */</span>
  <span class="keyword">def</span> <a title="(exampleSource: sbt.complete.ExampleSource)sbt.complete.Parser[A]" id="sbt.complete;RichParser.examples(ae3d7e057f)">examples</a><span class="delimiter">(</span><a title="sbt.complete.ExampleSource" id="sbt.complete;RichParser.examples(ae3d7e057f).exampleSource">exampleSource</a>: <a href="ExampleSource.scala.html#sbt.complete;ExampleSource" title="sbt.complete.ExampleSource">ExampleSource</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete;RichParser.examples(99c5ffc98b)" title="(exampleSource: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]">examples</a><span class="delimiter">(</span><a href="#sbt.complete;RichParser.examples(ae3d7e057f).exampleSource" title="sbt.complete.ExampleSource">exampleSource</a>, maxNumberOfExamples = <span title="Int(25)" class="int">25</span>, removeInvalidExamples = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="comment">/** Converts a Parser returning a Char sequence to a Parser returning a String.*/</span>
  <span class="keyword">def</span> <a title="(implicit ev: &lt;:&lt;[A,Seq[Char]])sbt.complete.Parser[String]" id="sbt.complete;RichParser.string">string</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="&lt;:&lt;[A,Seq[Char]]" id="sbt.complete;RichParser.string.ev">ev</a>: A <span title="&lt;:&lt;[A,Seq[Char]]">&lt;:&lt;</span> Seq<span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span>

  <span class="comment">/**
   * Produces a Parser that filters the original parser.
   * If 'f' is not true when applied to the output of the original parser, the Parser returned by this method fails.
   * The failure message is constructed by applying `msg` to the String that was successfully parsed by the original parser.
   */</span>
  <span class="keyword">def</span> <a title="(f: A =&gt; Boolean, msg: String =&gt; String)sbt.complete.Parser[A]" id="sbt.complete;RichParser.filter">filter</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="sbt.complete;RichParser.filter.f">f</a>: A =&gt; Boolean, <a title="String =&gt; String" id="sbt.complete;RichParser.filter.msg">msg</a>: String =&gt; String<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/** Applies the original parser, applies `f` to the result to get the next parser, and applies that parser and uses its result for the overall result. */</span>
  <span class="keyword">def</span> <a title="[B](f: A =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete;RichParser.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="sbt.complete;RichParser.flatMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; sbt.complete.Parser[B]" id="sbt.complete;RichParser.flatMap.f">f</a>: A =&gt; Parser<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/** Applied both the original parser and `b` on the same input and returns the results produced by each parser */</span>
  <span class="keyword">def</span> <a title="(b: sbt.complete.Parser[A])sbt.complete.Parser[Seq[A]]" id="sbt.complete;RichParser.combinedWith">combinedWith</a><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete;RichParser.combinedWith.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[A]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">/** Contains Parser implementation helper methods not typically needed for using parsers. */</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.complete.Parser.type" id="sbt.complete.Parser">Parser</a> <a href="#sbt.complete.Parser" title="sbt.complete.Parser.type" class="keyword">extends</a> <a href="#sbt.complete;ParserMain" title="sbt.complete.ParserMain">ParserMain</a> <span class="delimiter">{</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Result[+T] extends AnyRef" id="sbt.complete.Parser;Result">Result</a><span class="delimiter">[</span>+<a title="" id="sbt.complete.Parser;Result;T">T</a><span class="delimiter">]</span> <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete.Parser;Result.isFailure">isFailure</a>: <span title="Boolean">Boolean</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete.Parser;Result.isValid">isValid</a>: <span title="Boolean">Boolean</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[String]" id="sbt.complete.Parser;Result.errors">errors</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[B &gt;: T](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.or">or</a><span class="delimiter">[</span><a title=" &gt;: T" id="sbt.complete.Parser;Result.or;B">B</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.or.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[B](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[Either[T,B]]" id="sbt.complete.Parser;Result.either">either</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Result.either;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.either.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[Either[T,B]]">Result</a><span class="delimiter">[</span>Either<span class="delimiter">[</span>T, B<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[B](f: T =&gt; B)sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.map">map</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Result.map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; B" id="sbt.complete.Parser;Result.map.f">f</a>: T =&gt; B<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[B](f: T =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Result.flatMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.flatMap.f">f</a>: T =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="(b: =&gt; sbt.complete.Parser.Result[_])sbt.complete.Parser.Result[T]" id="sbt.complete.Parser;Result.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[_]" id="sbt.complete.Parser;Result.&&.b">b</a>: =&gt; Result<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="(f: T =&gt; Boolean, msg: =&gt; String)sbt.complete.Parser.Result[T]" id="sbt.complete.Parser;Result.filter">filter</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="sbt.complete.Parser;Result.filter.f">f</a>: T =&gt; Boolean, <a title="=&gt; String" id="sbt.complete.Parser;Result.filter.msg">msg</a>: =&gt; String<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[B](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[(T, B)]" id="sbt.complete.Parser;Result.seq">seq</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Result.seq;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.seq.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[(T, B)]">Result</a><span class="delimiter">[</span><span class="delimiter">(</span>T, B<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Result.app" title="(b: =&gt; sbt.complete.Parser.Result[B])(f: (T, B) =&gt; (T, B))sbt.complete.Parser.Result[(T, B)]">app</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Result.seq.b" title="=&gt; sbt.complete.Parser.Result[B]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="T" id="sbt.complete.Parser;Result.seq.$anonfun.m">m</a>, <a title="B" id="sbt.complete.Parser;Result.seq.$anonfun.n">n</a><span class="delimiter">)</span> =&gt; <span title="(_1: T, _2: B)(T, B)" class="delimiter">(</span><a href="#sbt.complete.Parser;Result.seq.$anonfun.m" title="T">m</a>, <a href="#sbt.complete.Parser;Result.seq.$anonfun.n" title="B">n</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B, C](b: =&gt; sbt.complete.Parser.Result[B])(f: (T, B) =&gt; C)sbt.complete.Parser.Result[C]" id="sbt.complete.Parser;Result.app">app</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Result.app;B">B</a>, <a title="" id="sbt.complete.Parser;Result.app;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Result.app.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(T, B) =&gt; C" id="sbt.complete.Parser;Result.app.f">f</a>: <span class="delimiter">(</span>T, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[C]">Result</a><span class="delimiter">[</span>C<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="=&gt; Either[() =&gt; Seq[String],T]" id="sbt.complete.Parser;Result.toEither">toEither</a>: <span title="Either[() =&gt; Seq[String],T]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, T<span class="delimiter">]</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a href="#sbt.complete.Parser;Value.productElement.x$1" title="class Value[+T] extends sbt.complete.Parser.Result[T] with Product with Serializable" id="sbt.complete.Parser.Value.readResolve">Value</a><span class="delimiter">[</span>+<a title="" id="sbt.complete.Parser;Value;T">T</a><span class="delimiter">]</span><a href="#sbt.complete.Parser.Value.readResolve" title="Product" class="delimiter">(</a><a title="T" id="sbt.complete.Parser;Value.value">value</a>: <a href="#sbt.complete.Parser;Value;T" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete.Parser;Value.isFailure">isFailure</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete.Parser;Value.isValid">isValid</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="sbt.complete.Parser;Value.errors">errors</a> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="keyword">def</span> <a title="[B, C](b: =&gt; sbt.complete.Parser.Result[B])(f: (T, B) =&gt; C)sbt.complete.Parser.Result[C]" id="sbt.complete.Parser;Value.app">app</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Value.app;B">B</a>, <a title="" id="sbt.complete.Parser;Value.app;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.app.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(T, B) =&gt; C" id="sbt.complete.Parser;Value.app.f">f</a>: <span class="delimiter">(</span>T, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[C]">Result</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Value.app.b" title="=&gt; sbt.complete.Parser.Result[B]">b</a> <span title="sbt.complete.Parser.Result[C]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete.Parser;Value.app.fail">fail</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="#sbt.complete.Parser;Value.app.fail" title="sbt.complete.Parser.Failure">fail</a>
      <span class="keyword">case</span> Value<span class="delimiter">(</span><a title="B" id="sbt.complete.Parser;Value.app.bv">bv</a><span class="delimiter">)</span>     =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: C)sbt.complete.Parser.Value[C]">Value</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.app.f" title="(v1: T, v2: B)C">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.value" title="=&gt; T">value</a>, <a href="#sbt.complete.Parser;Value.app.bv" title="B">bv</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(b: =&gt; sbt.complete.Parser.Result[_])sbt.complete.Parser.Result[T]" id="sbt.complete.Parser;Value.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[_]" id="sbt.complete.Parser;Value.&&.b">b</a>: =&gt; Result<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Value.&&.b" title="=&gt; sbt.complete.Parser.Result[_]">b</a> <span title="sbt.complete.Parser.Result[T]" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete.Parser;Value.&&.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="#sbt.complete.Parser;Value.&&.f" title="sbt.complete.Parser.Failure">f</a>; <span class="keyword">case</span> _ =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="sbt.complete.Parser.Value[T]" class="keyword">this</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[B &gt;: T](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.or">or</a><span class="delimiter">[</span><a title=" &gt;: T" id="sbt.complete.Parser;Value.or;B">B</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.or.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.Value.readResolve" title="sbt.complete.Parser.Value[T]" class="keyword">this</a>
    <span class="keyword">def</span> <a title="[B](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[Either[T,B]]" id="sbt.complete.Parser;Value.either">either</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Value.either;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.either.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[Either[T,B]]">Result</a><span class="delimiter">[</span>Either<span class="delimiter">[</span>T, B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.complete.Parser.Value.readResolve" title="(value: scala.util.Left[T,Nothing])sbt.complete.Parser.Value[scala.util.Left[T,Nothing]]">Value</a><span class="delimiter">(</span><span title="(a: T)scala.util.Left[T,Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.value" title="=&gt; T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B](f: T =&gt; B)sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.map">map</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Value.map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; B" id="sbt.complete.Parser;Value.map.f">f</a>: T =&gt; B<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.Value.readResolve" title="(value: B)sbt.complete.Parser.Value[B]">Value</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.map.f" title="(v1: T)B">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.value" title="=&gt; T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B](f: T =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Value.flatMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Value.flatMap.f">f</a>: T =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Value.flatMap.f" title="(v1: T)sbt.complete.Parser.Result[B]">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.value" title="=&gt; T">value</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(f: T =&gt; Boolean, msg: =&gt; String)sbt.complete.Parser.Result[T]" id="sbt.complete.Parser;Value.filter">filter</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="sbt.complete.Parser;Value.filter.f">f</a>: T =&gt; Boolean, <a title="=&gt; String" id="sbt.complete.Parser;Value.filter.msg">msg</a>: =&gt; String<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="sbt.complete.Parser.Result[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.filter.f" title="(v1: T)Boolean">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.value" title="=&gt; T">value</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.complete.Parser.Value.readResolve" title="sbt.complete.Parser.Value[T]" class="keyword">this</a> <span class="keyword">else</span> <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.filter.msg" title="=&gt; String">msg</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; scala.util.Right[Nothing,T]" id="sbt.complete.Parser;Value.toEither">toEither</a> = <span title="(b: T)scala.util.Right[Nothing,T]">Right</span><span class="delimiter">(</span><a href="#sbt.complete.Parser;Value.value" title="=&gt; T">value</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Failure extends sbt.complete.Parser.Result[Nothing]" id="sbt.complete.Parser;Failure">Failure</a> <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">private</a><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="delimiter">(</span><a title="=&gt; Seq[String]" id="sbt.complete.Parser;Failure.mkErrors">mkErrors</a>: =&gt; Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Boolean" id="sbt.complete.Parser;Failure.definitive">definitive</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[Nothing]">Result</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Seq[String]" id="sbt.complete.Parser;Failure.errors">errors</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Failure.mkErrors" title="=&gt; Seq[String]">mkErrors</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete.Parser;Failure.isFailure">isFailure</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete.Parser;Failure.isValid">isValid</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">def</span> <a title="[B](f: Nothing =&gt; B)sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.map">map</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Failure.map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; B" id="sbt.complete.Parser;Failure.map.f">f</a>: Nothing =&gt; B<span class="delimiter">)</span> = <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a>
    <span class="keyword">def</span> <a title="[B](f: Nothing =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Failure.flatMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Failure.flatMap.f">f</a>: Nothing =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a>
    <span class="keyword">def</span> <a title="[B](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Failure.or">or</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Failure.or;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Failure.or.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[B]">Result</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Failure.or.b" title="=&gt; sbt.complete.Parser.Result[B]">b</a> <span title="sbt.complete.Parser.Result[B]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="sbt.complete.Parser.Value[B]" id="sbt.complete.Parser;Failure.or.v">v</a>: <a href="#sbt.complete.Parser.Value.readResolve" title="sbt.complete.Parser.Value[B]">Value</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =&gt; <a href="#sbt.complete.Parser;Failure.or.v" title="sbt.complete.Parser.Value[B]">v</a>
      <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.or.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a>  =&gt; <span title="sbt.complete.Parser.Failure" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser;Failure.definitive" title="=&gt; Boolean">definitive</a><span class="delimiter">)</span> <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a> <span class="keyword">else</span> <a href="#sbt.complete.Parser;Failure" title="Failure.this.type" class="keyword">this</a> <a href="#sbt.complete.Parser;Failure.++" title="(f: sbt.complete.Parser.Failure)sbt.complete.Parser.Failure">++</a> <a href="#sbt.complete.Parser;Failure.or.f" title="sbt.complete.Parser.Failure">f</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[B](b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[Either[Nothing,B]]" id="sbt.complete.Parser;Failure.either">either</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Failure.either;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Failure.either.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[Either[Nothing,B]]">Result</a><span class="delimiter">[</span>Either<span class="delimiter">[</span>Nothing, B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Failure.either.b" title="=&gt; sbt.complete.Parser.Result[B]">b</a> <span title="sbt.complete.Parser.Result[Either[Nothing,B]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Value<span class="delimiter">(</span><a title="B" id="sbt.complete.Parser;Failure.either.v">v</a><span class="delimiter">)</span>   =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: scala.util.Right[Nothing,B])sbt.complete.Parser.Value[scala.util.Right[Nothing,B]]">Value</a><span class="delimiter">(</span><span title="(b: B)scala.util.Right[Nothing,B]">Right</span><span class="delimiter">(</span><a href="#sbt.complete.Parser;Failure.either.v" title="B">v</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.either.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <span title="sbt.complete.Parser.Failure" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser;Failure.definitive" title="=&gt; Boolean">definitive</a><span class="delimiter">)</span> <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a> <span class="keyword">else</span> <a href="#sbt.complete.Parser;Failure" title="Failure.this.type" class="keyword">this</a> <a href="#sbt.complete.Parser;Failure.++" title="(f: sbt.complete.Parser.Failure)sbt.complete.Parser.Failure">++</a> <a href="#sbt.complete.Parser;Failure.either.f" title="sbt.complete.Parser.Failure">f</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(f: Nothing =&gt; Boolean, msg: =&gt; String)sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.filter">filter</a><span class="delimiter">(</span><a title="Nothing =&gt; Boolean" id="sbt.complete.Parser;Failure.filter.f">f</a>: Nothing =&gt; Boolean, <a title="=&gt; String" id="sbt.complete.Parser;Failure.filter.msg">msg</a>: =&gt; String<span class="delimiter">)</span> = <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a>
    <span class="keyword">def</span> <a title="[B, C](b: =&gt; sbt.complete.Parser.Result[B])(f: (Nothing, B) =&gt; C)sbt.complete.Parser.Result[C]" id="sbt.complete.Parser;Failure.app">app</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser;Failure.app;B">B</a>, <a title="" id="sbt.complete.Parser;Failure.app;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[B]" id="sbt.complete.Parser;Failure.app.b">b</a>: =&gt; Result<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(Nothing, B) =&gt; C" id="sbt.complete.Parser;Failure.app.f">f</a>: <span class="delimiter">(</span>Nothing, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[C]">Result</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(b: =&gt; sbt.complete.Parser.Result[_])sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.&&">&amp;&amp;</a><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser.Result[_]" id="sbt.complete.Parser;Failure.&&.b">b</a>: =&gt; Result<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure" class="keyword">this</a>
    <span class="keyword">def</span> <a title="=&gt; scala.util.Left[() =&gt; Seq[String],Nothing]" id="sbt.complete.Parser;Failure.toEither">toEither</a> = <span title="(a: () =&gt; Seq[String])scala.util.Left[() =&gt; Seq[String],Nothing]">Left</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a><span class="delimiter">)</span>

    <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(f: sbt.complete.Parser.Failure)sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.++">++</a><span class="delimiter">(</span><a title="sbt.complete.Parser.Failure" id="sbt.complete.Parser;Failure.++.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.mkFailures" title="(errors: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser.Failure">mkFailures</a><span class="delimiter">(</span><a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">++</span> <a href="#sbt.complete.Parser;Failure.++.f" title="sbt.complete.Parser.Failure">f</a>.<a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(errors: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser.Failure" id="sbt.complete.Parser.mkFailures">mkFailures</a><span class="delimiter">(</span><a title="=&gt; Seq[String]" id="sbt.complete.Parser.mkFailures.errors">errors</a>: =&gt; Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete.Parser.mkFailures$default$2">definitive</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> = <span title="sbt.complete.Parser.Failure" class="keyword">new</span> <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mkFailures.errors" title="=&gt; Seq[String]">errors</a>.<span title="=&gt; Seq[String]">distinct</span>, <a href="#sbt.complete.Parser.mkFailures$default$2" title="Boolean">definitive</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure" id="sbt.complete.Parser.mkFailure">mkFailure</a><span class="delimiter">(</span><a title="=&gt; String" id="sbt.complete.Parser.mkFailure.error">error</a>: =&gt; String, <a title="Boolean" id="sbt.complete.Parser.mkFailure$default$2">definitive</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> = <span title="sbt.complete.Parser.Failure" class="keyword">new</span> <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mkFailure.error" title="=&gt; String">error</a> <a href="#sbt.complete.Parser.mkFailure.x$1" title="(x: String)List[String]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.complete.Parser.mkFailure$default$2" title="Boolean">definitive</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;This method is deprecated and will be removed in the next major version. Use the parser directly to check for invalid completions.&quot;</span>, since = <span class="string">&quot;0.13.2&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(a: sbt.complete.Parser[_], completions: Seq[String])Unit" id="sbt.complete.Parser.checkMatches">checkMatches</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete.Parser.checkMatches.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Seq[String]" id="sbt.complete.Parser.checkMatches.completions">completions</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[String]" id="sbt.complete.Parser.checkMatches.bad">bad</a> = <a href="#sbt.complete.Parser.checkMatches.completions" title="Seq[String]">completions</a>.<span title="(p: String =&gt; Boolean)Seq[String]">filter</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[_$6])(s: String)sbt.complete.Parser[_$6]">apply</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.checkMatches.a" title="sbt.complete.Parser[_]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete.Parser.checkMatches.bad.$anonfun.x$2" title="String">_</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[_$6]">resultEmpty</a>.<a href="#sbt.complete.Parser;Result.isFailure" title="=&gt; Boolean">isFailure</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser.checkMatches.bad" title="Seq[String]">bad</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Invalid example completions: &quot;)" class="string">&quot;Invalid example completions: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete.Parser.checkMatches.bad" title="Seq[String]">bad</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span>, <span title="String(&quot;\', \'&quot;)" class="string">&quot;', '&quot;</span>, <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B](a: Option[A], b: Option[B])Option[(A, B)]" id="sbt.complete.Parser.tuple">tuple</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.tuple;A">A</a>, <a title="" id="sbt.complete.Parser.tuple;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Option[A]" id="sbt.complete.Parser.tuple.a">a</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Option[B]" id="sbt.complete.Parser.tuple.b">b</a>: <span title="Option[B]">Option</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[(A, B)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>A, B<span class="delimiter">)</span><span class="delimiter">]</span> =
    <span title="(_1: Option[A], _2: Option[B])(Option[A], Option[B])" class="delimiter">(</span><a href="#sbt.complete.Parser.tuple.a" title="Option[A]">a</a>, <a href="#sbt.complete.Parser.tuple.b" title="Option[B]">b</a><span class="delimiter">)</span> <span title="Option[(A, B)]" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span class="delimiter">(</span>Some<span class="delimiter">(</span><a title="A" id="sbt.complete.Parser.tuple.av">av</a><span class="delimiter">)</span>, Some<span class="delimiter">(</span><a title="B" id="sbt.complete.Parser.tuple.bv">bv</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(x: (A, B))Some[(A, B)]">Some</span><span class="delimiter">(</span><span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><a href="#sbt.complete.Parser.tuple.av" title="A">av</a>, <a href="#sbt.complete.Parser.tuple.bv" title="B">bv</a><span class="delimiter">)</span><span class="delimiter">)</span>; <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span> <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B](a: sbt.complete.Parser[A], f: A =&gt; B)sbt.complete.Parser[B]" id="sbt.complete.Parser.mapParser">mapParser</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.mapParser;A">A</a>, <a title="" id="sbt.complete.Parser.mapParser;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete.Parser.mapParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; B" id="sbt.complete.Parser.mapParser.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser.mapParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]">ifValid</a> <span class="delimiter">{</span>
      <a href="#sbt.complete.Parser.mapParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a> <span title="sbt.complete.Parser[B]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="A" id="sbt.complete.Parser.mapParser.av">av</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;ParserMain.success" title="(value: B)sbt.complete.Parser[B]">success</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mapParser.f" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mapParser.av" title="A">av</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="None.type">None</span>     =&gt; <span title="sbt.complete.MapParser[A,B]" class="keyword">new</span> <a href="#sbt.complete;MapParser" title="sbt.complete.MapParser[A,B]">MapParser</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mapParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete.Parser.mapParser.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B](a: sbt.complete.Parser[A], f: A =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete.Parser.bindParser">bindParser</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.bindParser;A">A</a>, <a title="" id="sbt.complete.Parser.bindParser;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete.Parser.bindParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; sbt.complete.Parser[B]" id="sbt.complete.Parser.bindParser.f">f</a>: A =&gt; Parser<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser.bindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]">ifValid</a> <span class="delimiter">{</span>
      <a href="#sbt.complete.Parser.bindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a> <span title="sbt.complete.Parser[B]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="A" id="sbt.complete.Parser.bindParser.av">av</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.Parser.bindParser.f" title="(v1: A)sbt.complete.Parser[B]">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.bindParser.av" title="A">av</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="None.type">None</span>     =&gt; <span title="sbt.complete.BindParser[A,B]" class="keyword">new</span> <a href="#sbt.complete;BindParser" title="sbt.complete.BindParser[A,B]">BindParser</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.bindParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete.Parser.bindParser.f" title="A =&gt; sbt.complete.Parser[B]">f</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T](a: sbt.complete.Parser[T], f: T =&gt; Boolean, seen: String, msg: String =&gt; String)sbt.complete.Parser[T]" id="sbt.complete.Parser.filterParser">filterParser</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.filterParser;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.filterParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T =&gt; Boolean" id="sbt.complete.Parser.filterParser.f">f</a>: T =&gt; Boolean, <a title="String" id="sbt.complete.Parser.filterParser.seen">seen</a>: <span title="String">String</span>, <a title="String =&gt; String" id="sbt.complete.Parser.filterParser.msg">msg</a>: String =&gt; String<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser.filterParser.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">ifValid</a> <span class="delimiter">{</span>
      <a href="#sbt.complete.Parser.filterParser.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a> <span title="sbt.complete.Parser[T]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="T" id="sbt.complete.Parser.filterParser.av">av</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.complete.Parser.filterParser.f" title="(v1: T)Boolean">f</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.filterParser.av" title="T">av</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;ParserMain.success" title="(value: T)sbt.complete.Parser[T]">success</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.filterParser.av" title="T">av</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _                 =&gt; <span title="sbt.complete.Filter[T]" class="keyword">new</span> <a href="#sbt.complete;Filter" title="sbt.complete.Filter[T]">Filter</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.filterParser.a" title="sbt.complete.Parser[T]">a</a>, <a href="#sbt.complete.Parser.filterParser.f" title="T =&gt; Boolean">f</a>, <a href="#sbt.complete.Parser.filterParser.seen" title="String">seen</a>, <a href="#sbt.complete.Parser.filterParser.msg" title="String =&gt; String">msg</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B](a: sbt.complete.Parser[A], b: sbt.complete.Parser[B])sbt.complete.Parser[(A, B)]" id="sbt.complete.Parser.seqParser">seqParser</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.seqParser;A">A</a>, <a title="" id="sbt.complete.Parser.seqParser;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete.Parser.seqParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[B]" id="sbt.complete.Parser.seqParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[(A, B)]">Parser</a><span class="delimiter">[</span><span class="delimiter">(</span>A, B<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser.seqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[(A, B)])sbt.complete.Parser[(A, B)]">ifValid</a> <span class="delimiter">{</span>
      <a href="#sbt.complete.Parser.seqParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[(A, B)])sbt.complete.Parser[(A, B)]">ifValid</a> <span class="delimiter">{</span>
        <span title="(_1: Option[A], _2: Option[B])(Option[A], Option[B])" class="delimiter">(</span><a href="#sbt.complete.Parser.seqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a>, <a href="#sbt.complete.Parser.seqParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[B]">result</a><span class="delimiter">)</span> <span title="sbt.complete.Parser[(A, B)]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span class="delimiter">(</span>Some<span class="delimiter">(</span><span title="A">av</span><span class="delimiter">)</span>, Some<span class="delimiter">(</span><span title="B">bv</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;ParserMain.success" title="(value: (A, B))sbt.complete.Parser[(A, B)]">success</a><span class="delimiter">(</span><span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><span title="A">av</span>, <span title="B">bv</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span class="delimiter">(</span>Some<span class="delimiter">(</span><span title="A">av</span><span class="delimiter">)</span>, <span title="None.type">None</span><span class="delimiter">)</span>     =&gt; <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[B])sbt.complete.RichParser[B]">b</a> <a href="#sbt.complete;RichParser.map" title="(f: B =&gt; (A, B))sbt.complete.Parser[(A, B)]">map</a> <span class="delimiter">{</span> <a title="B" id="sbt.complete.Parser.seqParser.$anonfun.bv">bv</a> =&gt; <span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><span title="A">av</span>, <a href="#sbt.complete.Parser.seqParser.$anonfun.bv" title="B">bv</a><span class="delimiter">)</span> <span class="delimiter">}</span>
          <span class="keyword">case</span> <span class="delimiter">(</span><span title="None.type">None</span>, Some<span class="delimiter">(</span><span title="B">bv</span><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a> <a href="#sbt.complete;RichParser.map" title="(f: A =&gt; (A, B))sbt.complete.Parser[(A, B)]">map</a> <span class="delimiter">{</span> <a title="A" id="sbt.complete.Parser.seqParser.$anonfun.av">av</a> =&gt; <span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><a href="#sbt.complete.Parser.seqParser.$anonfun.av" title="A">av</a>, <span title="B">bv</span><span class="delimiter">)</span> <span class="delimiter">}</span>
          <span class="keyword">case</span> <span class="delimiter">(</span><span title="None.type">None</span>, <span title="None.type">None</span><span class="delimiter">)</span>         =&gt; <span title="sbt.complete.SeqParser[A,B]" class="keyword">new</span> <a href="#sbt.complete;SeqParser" title="sbt.complete.SeqParser[A,B]">SeqParser</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.seqParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete.Parser.seqParser.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B](a: sbt.complete.Parser[A], b: sbt.complete.Parser[B])sbt.complete.Parser[Either[A,B]]" id="sbt.complete.Parser.choiceParser">choiceParser</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.choiceParser;A">A</a>, <a title="" id="sbt.complete.Parser.choiceParser;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete.Parser.choiceParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[B]" id="sbt.complete.Parser.choiceParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Either[A,B]]">Parser</a><span class="delimiter">[</span>Either<span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[Either[A,B]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser.choiceParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span>
      <span title="sbt.complete.Parser[Either[A,B]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser.choiceParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <span title="sbt.complete.HetParser[A,B]" class="keyword">new</span> <a href="#sbt.complete;HetParser" title="sbt.complete.HetParser[A,B]">HetParser</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.choiceParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete.Parser.choiceParser.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a>.<a href="#sbt.complete;RichParser.map" title="(f: A =&gt; scala.util.Left[A,Nothing])sbt.complete.Parser[scala.util.Left[A,Nothing]]">map</a><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.left" title="=&gt; sbt.~&gt;[sbt.Types.Id,[B]scala.util.Left[B,Nothing]]">left</a>.<a href="../TypeFunctions.scala.html#sbt;~>.fn" title="sbt.Types.Id[A] =&gt; scala.util.Left[A,Nothing]">fn</a><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[B])sbt.complete.RichParser[B]">b</a>.<a href="#sbt.complete;RichParser.map" title="(f: B =&gt; scala.util.Right[Nothing,B])sbt.complete.Parser[scala.util.Right[Nothing,B]]">map</a><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.right" title="=&gt; sbt.~&gt;[sbt.Types.Id,[B]scala.util.Right[Nothing,B]]">right</a>.<a href="../TypeFunctions.scala.html#sbt;~>.fn" title="sbt.Types.Id[B] =&gt; scala.util.Right[Nothing,B]">fn</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](a: sbt.complete.Parser[T])sbt.complete.Parser[Option[T]]" id="sbt.complete.Parser.opt">opt</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.opt;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.opt.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Option[T]]">Parser</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[Option[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser.opt.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <span title="sbt.complete.Optional[T]" class="keyword">new</span> <a href="#sbt.complete;Optional" title="sbt.complete.Optional[T]">Optional</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.opt.a" title="sbt.complete.Parser[T]">a</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.success" title="(value: None.type)sbt.complete.Parser[None.type]">success</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](delegate: sbt.complete.Parser[T], msg: String)sbt.complete.Parser[T]" id="sbt.complete.Parser.onFailure">onFailure</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.onFailure;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.onFailure.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete.Parser.onFailure.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser.onFailure.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <span title="sbt.complete.OnFailure[T]" class="keyword">new</span> <a href="#sbt.complete;OnFailure" title="sbt.complete.OnFailure[T]">OnFailure</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.onFailure.delegate" title="sbt.complete.Parser[T]">delegate</a>, <a href="#sbt.complete.Parser.onFailure.msg" title="String">msg</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.failure" title="(msg: =&gt; String, definitive: Boolean)sbt.complete.Parser[Nothing]">failure</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.onFailure.msg" title="String">msg</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](delegate: sbt.complete.Parser[T])sbt.complete.Parser[T]" id="sbt.complete.Parser.trapAndFail">trapAndFail</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.trapAndFail;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.trapAndFail.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser.trapAndFail.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">ifValid</a><span class="delimiter">(</span><span title="sbt.complete.TrapAndFail[T]" class="keyword">new</span> <a href="#sbt.complete;TrapAndFail" title="sbt.complete.TrapAndFail[T]">TrapAndFail</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.trapAndFail.delegate" title="sbt.complete.Parser[T]">delegate</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T])sbt.complete.Parser[Seq[T]]" id="sbt.complete.Parser.zeroOrMore">zeroOrMore</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.zeroOrMore;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.zeroOrMore.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.complete.Parser.repeat(ee491394ee)" title="(p: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound)sbt.complete.Parser[Seq[T]]">repeat</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.zeroOrMore.p" title="sbt.complete.Parser[T]">p</a>, <span title="Int(0)" class="int">0</span>, <a href="UpperBound.scala.html#sbt.complete.Infinite" title="sbt.complete.Infinite.type">Infinite</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T])sbt.complete.Parser[Seq[T]]" id="sbt.complete.Parser.oneOrMore">oneOrMore</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.oneOrMore;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.oneOrMore.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.complete.Parser.repeat(ee491394ee)" title="(p: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound)sbt.complete.Parser[Seq[T]]">repeat</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.oneOrMore.p" title="sbt.complete.Parser[T]">p</a>, <span title="Int(1)" class="int">1</span>, <a href="UpperBound.scala.html#sbt.complete.Infinite" title="sbt.complete.Infinite.type">Infinite</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound)sbt.complete.Parser[Seq[T]]" id="sbt.complete.Parser.repeat(ee491394ee)">repeat</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.repeat$default$3;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.repeat(ee491394ee).p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int" id="sbt.complete.Parser.repeat$default$2">min</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>, <a title="sbt.complete.UpperBound" id="sbt.complete.Parser.repeat$default$3">max</a>: <a href="UpperBound.scala.html#sbt.complete;UpperBound" title="sbt.complete.UpperBound">UpperBound</a> = <a href="UpperBound.scala.html#sbt.complete.Infinite" title="sbt.complete.Infinite.type">Infinite</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser.repeat(c6e62f4296)" title="(partial: Option[sbt.complete.Parser[T]], repeated: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound, revAcc: List[T])sbt.complete.Parser[Seq[T]]">repeat</a><span class="delimiter">(</span><span title="None.type">None</span>, <a href="#sbt.complete.Parser.repeat(ee491394ee).p" title="sbt.complete.Parser[T]">p</a>, <a href="#sbt.complete.Parser.repeat$default$2" title="Int">min</a>, <a href="#sbt.complete.Parser.repeat$default$3" title="sbt.complete.UpperBound">max</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  <span class="keyword">private</span><span class="delimiter">[</span>complete<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](partial: Option[sbt.complete.Parser[T]], repeated: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound, revAcc: List[T])sbt.complete.Parser[Seq[T]]" id="sbt.complete.Parser.repeat(c6e62f4296)">repeat</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.repeat(c6e62f4296);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Option[sbt.complete.Parser[T]]" id="sbt.complete.Parser.repeat(c6e62f4296).partial">partial</a>: <span title="Option[sbt.complete.Parser[T]]">Option</span><span class="delimiter">[</span>Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.repeat(c6e62f4296).repeated">repeated</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int" id="sbt.complete.Parser.repeat(c6e62f4296).min">min</a>: <span title="Int">Int</span>, <a title="sbt.complete.UpperBound" id="sbt.complete.Parser.repeat(c6e62f4296).max">max</a>: <a href="UpperBound.scala.html#sbt.complete;UpperBound" title="sbt.complete.UpperBound">UpperBound</a>, <a title="List[T]" id="sbt.complete.Parser.repeat(c6e62f4296).revAcc">revAcc</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span title="(assumption: Boolean, message: =&gt; Any)Unit">assume</span><span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;Minimum must be greater than or equal to zero (was &quot;)" class="string">&quot;Minimum must be greater than or equal to zero (was &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
      <span title="(assumption: Boolean, message: =&gt; Any)Unit">assume</span><span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).max" title="sbt.complete.UpperBound">max</a> <a href="UpperBound.scala.html#sbt.complete;UpperBound.>=" title="(min: Int)Boolean">&gt;=</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a>, <span title="String(&quot;Minimum must be less than or equal to maximum (min: &quot;)" class="string">&quot;Minimum must be less than or equal to maximum (min: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, max: &quot;)" class="string">&quot;, max: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete.Parser.repeat(c6e62f4296).max" title="sbt.complete.UpperBound">max</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(invalidButOptional: =&gt; sbt.complete.Parser[Seq[T]])sbt.complete.Parser[Seq[T]]" id="sbt.complete.Parser.repeat(c6e62f4296).checkRepeated">checkRepeated</a><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser[Seq[T]]" id="sbt.complete.Parser.repeat(c6e62f4296).checkRepeated.invalidButOptional">invalidButOptional</a>: =&gt; Parser<span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
        <a href="#sbt.complete.Parser.repeat(c6e62f4296).repeated" title="sbt.complete.Parser[T]">repeated</a> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="sbt.complete.Invalid">i</span>: <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid">Invalid</a> <span class="keyword">if</span> <a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#sbt.complete.Parser.repeat(c6e62f4296).checkRepeated.invalidButOptional" title="=&gt; sbt.complete.Parser[Seq[T]]">invalidButOptional</a>
          <span class="keyword">case</span> <span title="sbt.complete.Invalid">i</span>: <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid">Invalid</a>             =&gt; <span title="sbt.complete.Invalid">i</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#sbt.complete.Parser.repeat(c6e62f4296).repeated" title="sbt.complete.Parser[T]">repeated</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="T" id="sbt.complete.Parser.repeat(c6e62f4296).checkRepeated.value">value</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;ParserMain.success" title="(value: List[T])sbt.complete.Parser[List[T]]">success</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).revAcc" title="List[T]">revAcc</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).checkRepeated.x$4" title="(prefix: List[T])List[T]">reverse_:::</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).checkRepeated.value" title="T">value</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).checkRepeated.x$3" title="(x: T)List[T]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="comment">// revAcc should be Nil here</span>
              <span class="keyword">case</span> <span title="None.type">None</span>        =&gt; <span title="sbt.complete.Parser[Seq[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).max" title="sbt.complete.UpperBound">max</a>.<a href="UpperBound.scala.html#sbt.complete;UpperBound.isZero" title="=&gt; Boolean">isZero</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.success" title="(value: List[T])sbt.complete.Parser[List[T]]">success</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).revAcc" title="List[T]">revAcc</a>.<span title="=&gt; List[T]">reverse</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="sbt.complete.Repeat[T]" class="keyword">new</span> <a href="#sbt.complete;Repeat" title="sbt.complete.Repeat[T]">Repeat</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).partial" title="Option[sbt.complete.Parser[T]]">partial</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).repeated" title="sbt.complete.Parser[T]">repeated</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).max" title="sbt.complete.UpperBound">max</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).revAcc" title="List[T]">revAcc</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <a href="#sbt.complete.Parser.repeat(c6e62f4296).partial" title="Option[sbt.complete.Parser[T]]">partial</a> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.repeat(c6e62f4296).part">part</a><span class="delimiter">)</span> =&gt;
          <a href="#sbt.complete.Parser.repeat(c6e62f4296).part" title="sbt.complete.Parser[T]">part</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[Seq[T]])sbt.complete.Parser[Seq[T]]">ifValid</a> <span class="delimiter">{</span>
            <a href="#sbt.complete.Parser.repeat(c6e62f4296).part" title="sbt.complete.Parser[T]">part</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="T" id="sbt.complete.Parser.repeat(c6e62f4296).value">value</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.Parser.repeat(c6e62f4296)" title="(partial: Option[sbt.complete.Parser[T]], repeated: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound, revAcc: List[T])sbt.complete.Parser[Seq[T]]">repeat</a><span class="delimiter">(</span><span title="None.type">None</span>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).repeated" title="sbt.complete.Parser[T]">repeated</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).min" title="Int">min</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).max" title="sbt.complete.UpperBound">max</a>, <a href="#sbt.complete.Parser.repeat(c6e62f4296).value" title="T">value</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).x$5" title="(x: T)List[T]">::</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).revAcc" title="List[T]">revAcc</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="None.type">None</span>        =&gt; <a href="#sbt.complete.Parser.repeat(c6e62f4296).checkRepeated" title="(invalidButOptional: =&gt; sbt.complete.Parser[Seq[T]])sbt.complete.Parser[Seq[T]]">checkRepeated</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">part</a>.<a href="#sbt.complete;RichParser.map" title="(f: T =&gt; List[T])sbt.complete.Parser[List[T]]">map</a><span class="delimiter">(</span><a title="T" id="sbt.complete.Parser.repeat(c6e62f4296).$anonfun.lv">lv</a> =&gt; <span class="delimiter">(</span><a href="#sbt.complete.Parser.repeat(c6e62f4296).$anonfun.lv" title="T">lv</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).$anonfun.x$6" title="(x: T)List[T]">::</a> <a href="#sbt.complete.Parser.repeat(c6e62f4296).revAcc" title="List[T]">revAcc</a><span class="delimiter">)</span>.<span title="=&gt; List[T]">reverse</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#sbt.complete.Parser.repeat(c6e62f4296).checkRepeated" title="(invalidButOptional: =&gt; sbt.complete.Parser[Seq[T]])sbt.complete.Parser[Seq[T]]">checkRepeated</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.success" title="(value: scala.collection.immutable.Nil.type)sbt.complete.Parser[scala.collection.immutable.Nil.type]">success</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Explicitly call `and` and `not` to provide the failure message.&quot;</span>, <span class="string">&quot;0.12.2&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](a: sbt.complete.Parser[T], b: sbt.complete.Parser[_])sbt.complete.Parser[T]" id="sbt.complete.Parser.sub">sub</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.sub;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.sub.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete.Parser.sub.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.and" title="(a: sbt.complete.Parser[T], b: sbt.complete.Parser[_])sbt.complete.Parser[T]">and</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.sub.a" title="sbt.complete.Parser[T]">a</a>, <a href="#sbt.complete;ParserMain.not(bfcd18eaec)" title="(p: sbt.complete.Parser[_])sbt.complete.Parser[Unit]">not</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.sub.b" title="sbt.complete.Parser[_]">b</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](a: sbt.complete.Parser[T], b: sbt.complete.Parser[_])sbt.complete.Parser[T]" id="sbt.complete.Parser.and">and</a><span class="delimiter">[</span><a title="" id="sbt.complete.Parser.and;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete.Parser.and.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete.Parser.and.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.and.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">ifValid</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.and.b" title="sbt.complete.Parser[_]">b</a>.<a href="#sbt.complete;Parser.ifValid" title="(p: =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">ifValid</a><span class="delimiter">(</span><span title="sbt.complete.And[T]" class="keyword">new</span> <a href="#sbt.complete;And" title="sbt.complete.And[T]">And</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.and.a" title="sbt.complete.Parser[T]">a</a>, <a href="#sbt.complete.Parser.and.b" title="sbt.complete.Parser[_]">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="keyword">trait</span> <a title="trait ParserMain extends AnyRef" id="sbt.complete;ParserMain">ParserMain</a> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/** Provides combinators for Parsers.*/</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A](a: sbt.complete.Parser[A])sbt.complete.RichParser[A]" id="sbt.complete;ParserMain.richParser">richParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;RichParser" title="sbt.complete.RichParser[A]">RichParser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser;$anon" title="sbt.complete.RichParser[A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.complete.RichParser[A]" id="sbt.complete;ParserMain.richParser;$anon">RichParser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[(A, B)]" id="sbt.complete;ParserMain.richParser;$anon.~">~</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.~;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.~.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.seqParser" title="(a: sbt.complete.Parser[A], b: sbt.complete.Parser[B])sbt.complete.Parser[(A, B)]">seqParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.~.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[Either[A,B]]" id="sbt.complete;ParserMain.richParser;$anon.||">||</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.||;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.||.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.choiceParser" title="(a: sbt.complete.Parser[A], b: sbt.complete.Parser[B])sbt.complete.Parser[Either[A,B]]">choiceParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.||.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B &gt;: A](b: sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.|">|</a><span class="delimiter">[</span><a title=" &gt;: A" id="sbt.complete;ParserMain.richParser;$anon.|;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.|.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete;ParserMain.homParser" title="(a: sbt.complete.Parser[B], b: sbt.complete.Parser[B])sbt.complete.Parser[B]">homParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.|.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Option[A]]" id="sbt.complete;ParserMain.richParser;$anon.?">?</a> = <a href="#sbt.complete.Parser.opt" title="(a: sbt.complete.Parser[A])sbt.complete.Parser[Option[A]]">opt</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Seq[A]]" id="sbt.complete;ParserMain.richParser;$anon.*">*</a> = <a href="#sbt.complete.Parser.zeroOrMore" title="(p: sbt.complete.Parser[A])sbt.complete.Parser[Seq[A]]">zeroOrMore</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Seq[A]]" id="sbt.complete;ParserMain.richParser;$anon.+">+</a> = <a href="#sbt.complete.Parser.oneOrMore" title="(p: sbt.complete.Parser[A])sbt.complete.Parser[Seq[A]]">oneOrMore</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B](f: A =&gt; B)sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.map">map</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.map;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="sbt.complete;ParserMain.richParser;$anon.map.f">f</a>: A =&gt; B<span class="delimiter">)</span> = <a href="#sbt.complete.Parser.mapParser" title="(a: sbt.complete.Parser[A], f: A =&gt; B)sbt.complete.Parser[B]">mapParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.map.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.id">id</a> = <a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>

    <span class="keyword">def</span> <a title="[B](value: B)sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.^^^">^^^</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.^^^;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="sbt.complete;ParserMain.richParser;$anon.^^^.value">value</a>: <a href="#sbt.complete;ParserMain.richParser;$anon.^^^;B" title="B">B</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a> <a href="#sbt.complete;RichParser.map" title="(f: A =&gt; B)sbt.complete.Parser[B]">map</a> <span class="delimiter">{</span> <a title="A" id="sbt.complete;ParserMain.richParser;$anon.^^^.$anonfun.x$7">_</a> =&gt; <a href="#sbt.complete;ParserMain.richParser;$anon.^^^.value" title="B">value</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[B &gt;: A](alt: B)sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.??">??</a><span class="delimiter">[</span><a title=" &gt;: A" id="sbt.complete;ParserMain.richParser;$anon.??;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="sbt.complete;ParserMain.richParser;$anon.??.alt">alt</a>: <a href="#sbt.complete;ParserMain.richParser;$anon.??;B" title="B">B</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a>.<a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Option[A]])sbt.complete.RichParser[Option[A]]">?</a> <a href="#sbt.complete;RichParser.map" title="(f: Option[A] =&gt; B)sbt.complete.Parser[B]">map</a> <span class="delimiter">{</span> <a href="#sbt.complete;ParserMain.richParser;$anon.??.$anonfun.x$8" title="Option[A]">_</a> <span title="(default: =&gt; B)B">getOrElse</span> <a href="#sbt.complete;ParserMain.richParser;$anon.??.alt" title="B">alt</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.<~">&lt;~</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.<~;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.<~.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(A, B)])sbt.complete.RichParser[(A, B)]">~</a> <a href="#sbt.complete;ParserMain.richParser;$anon.<~.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.map" title="(f: ((A, B)) =&gt; A)sbt.complete.Parser[A]">map</a> <a href="#sbt.complete;ParserMain.richParser;$anon.<~.$anonfun.x0$1" title="A" class="delimiter">{</a> <span class="keyword">case</span> <a title="A" id="sbt.complete;ParserMain.richParser;$anon.<~.$anonfun.av">av</a> <a href="#sbt.complete;ParserMain.~.unapply" title="(t: (A, B))Some[(A, B)]">~</a> _ =&gt; <a href="#sbt.complete;ParserMain.richParser;$anon.<~.$anonfun.av" title="A">av</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="[B](b: sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.~>">~&gt;</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.~>;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.~>.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(A, B)])sbt.complete.RichParser[(A, B)]">~</a> <a href="#sbt.complete;ParserMain.richParser;$anon.~>.b" title="sbt.complete.Parser[B]">b</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.map" title="(f: ((A, B)) =&gt; B)sbt.complete.Parser[B]">map</a> <a href="#sbt.complete;ParserMain.richParser;$anon.~>.$anonfun.x0$2" title="B" class="delimiter">{</a> <span class="keyword">case</span> _ <a href="#sbt.complete;ParserMain.~.unapply" title="(t: (A, B))Some[(A, B)]">~</a> <a title="B" id="sbt.complete;ParserMain.richParser;$anon.~>.$anonfun.bv">bv</a> =&gt; <a href="#sbt.complete;ParserMain.richParser;$anon.~>.$anonfun.bv" title="B">bv</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(msg: String)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.!!!">!!!</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.richParser;$anon.!!!.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.onFailure" title="(delegate: sbt.complete.Parser[A], msg: String)sbt.complete.Parser[A]">onFailure</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.!!!.msg" title="String">msg</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.failOnException">failOnException</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.trapAndFail" title="(delegate: sbt.complete.Parser[A])sbt.complete.Parser[A]">trapAndFail</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Unit]" id="sbt.complete;ParserMain.richParser;$anon.unary_-">unary_-</a> = <a href="#sbt.complete;ParserMain.not(bfcd18eaec)" title="(p: sbt.complete.Parser[_])sbt.complete.Parser[Unit]">not</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(o: sbt.complete.Parser[_])sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.&">&amp;</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.richParser;$anon.&.o">o</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.and" title="(a: sbt.complete.Parser[A], b: sbt.complete.Parser[_])sbt.complete.Parser[A]">and</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.&.o" title="sbt.complete.Parser[_]">o</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(o: sbt.complete.Parser[_])sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.-">-</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.richParser;$anon.-.o">o</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.sub" title="(a: sbt.complete.Parser[A], b: sbt.complete.Parser[_])sbt.complete.Parser[A]">sub</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.-.o" title="sbt.complete.Parser[_]">o</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(s: String*)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.examples(88b70d78c2)">examples</a><span class="delimiter">(</span><a title="String*" id="sbt.complete;ParserMain.richParser;$anon.examples(88b70d78c2).s">s</a>: <span title="String*">String</span>*<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser;$anon.examples(dc06e66187)" title="(s: Set[String], check: Boolean)sbt.complete.Parser[A]">examples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser;$anon.examples(88b70d78c2).s" title="String*">s</a>.<span title="scala.collection.immutable.Set[String]">toSet</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(s: Set[String], check: Boolean)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.examples(dc06e66187)">examples</a><span class="delimiter">(</span><a title="Set[String]" id="sbt.complete;ParserMain.richParser;$anon.examples(dc06e66187).s">s</a>: <span title="Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete;ParserMain.richParser;$anon.examples$default$2">check</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5)" title="(s: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]">examples</a><span class="delimiter">(</span><span title="sbt.complete.FixedSetExamples" class="keyword">new</span> <a href="ExampleSource.scala.html#sbt.complete;FixedSetExamples" title="sbt.complete.FixedSetExamples">FixedSetExamples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser;$anon.examples(dc06e66187).s" title="Set[String]">s</a><span class="delimiter">)</span>, <a href="#sbt.complete;ParserMain.richParser;$anon.examples(dc06e66187).s" title="Set[String]">s</a>.<span title="=&gt; Int">size</span>, <a href="#sbt.complete;ParserMain.richParser;$anon.examples$default$2" title="Boolean">check</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(s: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5)">examples</a><span class="delimiter">(</span><a title="sbt.complete.ExampleSource" id="sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5).s">s</a>: <a href="ExampleSource.scala.html#sbt.complete;ExampleSource" title="sbt.complete.ExampleSource">ExampleSource</a>, <a title="Int" id="sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5).maxNumberOfExamples">maxNumberOfExamples</a>: <span title="Int">Int</span>, <a title="Boolean" id="sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5).removeInvalidExamples">removeInvalidExamples</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>.<a href="#sbt.complete;ParserMain.examples(5a4082b96f)" title="(a: sbt.complete.Parser[A], completions: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]">examples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5).s" title="sbt.complete.ExampleSource">s</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5).maxNumberOfExamples" title="Int">maxNumberOfExamples</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.examples(cacf7c61f5).removeInvalidExamples" title="Boolean">removeInvalidExamples</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(f: A =&gt; Boolean, msg: String =&gt; String)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.filter">filter</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="sbt.complete;ParserMain.richParser;$anon.filter.f">f</a>: A =&gt; Boolean, <a title="String =&gt; String" id="sbt.complete;ParserMain.richParser;$anon.filter.msg">msg</a>: String =&gt; String<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#sbt.complete.Parser.filterParser" title="(a: sbt.complete.Parser[A], f: A =&gt; Boolean, seen: String, msg: String =&gt; String)sbt.complete.Parser[A]">filterParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.filter.f" title="A =&gt; Boolean">f</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <a href="#sbt.complete;ParserMain.richParser;$anon.filter.msg" title="String =&gt; String">msg</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(implicit ev: &lt;:&lt;[A,Seq[Char]])sbt.complete.Parser[String]" id="sbt.complete;ParserMain.richParser;$anon.string">string</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="&lt;:&lt;[A,Seq[Char]]" id="sbt.complete;ParserMain.richParser;$anon.string.ev">ev</a>: A <span title="&lt;:&lt;[A,Seq[Char]]">&lt;:&lt;</span> Seq<span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser;$anon.map" title="(f: A =&gt; String)sbt.complete.Parser[String]">map</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser;$anon.string.ev" title="(v1: A)Seq[Char]">_</a>.<span title="=&gt; String">mkString</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[B](f: A =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.richParser;$anon.flatMap;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; sbt.complete.Parser[B]" id="sbt.complete;ParserMain.richParser;$anon.flatMap.f">f</a>: A =&gt; Parser<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.bindParser" title="(a: sbt.complete.Parser[A], f: A =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]">bindParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.flatMap.f" title="A =&gt; sbt.complete.Parser[B]">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(b: sbt.complete.Parser[A])sbt.complete.Parser[Seq[A]]" id="sbt.complete;ParserMain.richParser;$anon.combinedWith">combinedWith</a><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete;ParserMain.richParser;$anon.combinedWith.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[A]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span title="sbt.complete.Parser[Seq[A]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span>
        <span title="sbt.complete.Parser[Seq[A]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser;$anon.combinedWith.b" title="sbt.complete.Parser[A]">b</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <span title="sbt.complete.CombiningParser[A]" class="keyword">new</span> <a href="#sbt.complete;CombiningParser" title="sbt.complete.CombiningParser[A]">CombiningParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.richParser;$anon.combinedWith.b" title="sbt.complete.Parser[A]">b</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">a</a>.<a href="#sbt.complete;RichParser.map" title="(f: A =&gt; Seq[A])sbt.complete.Parser[Seq[A]]">map</a><span class="delimiter">(</span><span title="(elems: A*)Seq[A]">Seq</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser;$anon.combinedWith.$anonfun.x$10" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">b</a>.<a href="#sbt.complete;RichParser.map" title="(f: A =&gt; Seq[A])sbt.complete.Parser[Seq[A]]">map</a><span class="delimiter">(</span><span title="(elems: A*)Seq[A]">Seq</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser;$anon.combinedWith.$anonfun.x$11" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" id="sbt.complete;ParserMain.literalRichCharParser">literalRichCharParser</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;ParserMain.literalRichCharParser.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#sbt.complete;RichParser" title="sbt.complete.RichParser[Char]">RichParser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">richParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(a2eb285bfb)" title="implicit sbt.complete.ParserMain.literal : (ch: Char)sbt.complete.Parser[Char]">c</a><span class="delimiter">)</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.complete.ParserMain.literalRichStringParser : (s: String)sbt.complete.RichParser[String]" id="sbt.complete;ParserMain.literalRichStringParser">literalRichStringParser</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.literalRichStringParser.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;RichParser" title="sbt.complete.RichParser[String]">RichParser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">richParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(d17d0531ce)" title="implicit sbt.complete.ParserMain.literal : (s: String)sbt.complete.Parser[String]">s</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Construct a parser that is valid, but has no valid result.  This is used as a way
   * to provide a definitive Failure when a parser doesn't match empty input.  For example,
   * in `softFailure(...) | p`, if `p` doesn't match the empty sequence, the failure will come
   * from the Parser constructed by the `softFailure` method.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(msg: =&gt; String, definitive: Boolean)sbt.complete.Parser[Nothing]" id="sbt.complete;ParserMain.softFailure">softFailure</a><span class="delimiter">(</span><a title="=&gt; String" id="sbt.complete;ParserMain.softFailure.msg">msg</a>: =&gt; String, <a title="Boolean" id="sbt.complete;ParserMain.softFailure$default$2">definitive</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Nothing]">Parser</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> =
    <a href="#sbt.complete.SoftInvalid.readResolve" title="(fail: sbt.complete.Parser.Failure)sbt.complete.SoftInvalid">SoftInvalid</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mkFailures" title="(errors: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser.Failure">mkFailures</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.softFailure.msg" title="=&gt; String">msg</a> <a href="#sbt.complete;ParserMain.softFailure.x$12" title="(x: String)List[String]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.complete;ParserMain.softFailure$default$2" title="Boolean">definitive</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Defines a parser that always fails on any input with messages `msgs`.
   * If `definitive` is `true`, any failures by later alternatives are discarded.
   */</span>
  <span class="keyword">def</span> <a title="(msgs: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser[Nothing]" id="sbt.complete;ParserMain.invalid">invalid</a><span class="delimiter">(</span><a title="=&gt; Seq[String]" id="sbt.complete;ParserMain.invalid.msgs">msgs</a>: =&gt; Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete;ParserMain.invalid$default$2">definitive</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Nothing]">Parser</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <a href="#sbt.complete.Invalid.readResolve" title="(fail: sbt.complete.Parser.Failure)sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mkFailures" title="(errors: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser.Failure">mkFailures</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.invalid.msgs" title="=&gt; Seq[String]">msgs</a>, <a href="#sbt.complete;ParserMain.invalid$default$2" title="Boolean">definitive</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Defines a parser that always fails on any input with message `msg`.
   * If `definitive` is `true`, any failures by later alternatives are discarded.
   */</span>
  <span class="keyword">def</span> <a title="(msg: =&gt; String, definitive: Boolean)sbt.complete.Parser[Nothing]" id="sbt.complete;ParserMain.failure">failure</a><span class="delimiter">(</span><a title="=&gt; String" id="sbt.complete;ParserMain.failure.msg">msg</a>: =&gt; String, <a title="Boolean" id="sbt.complete;ParserMain.failure$default$2">definitive</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Nothing]">Parser</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.invalid" title="(msgs: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser[Nothing]">invalid</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.failure.msg" title="=&gt; String">msg</a> <a href="#sbt.complete;ParserMain.failure.x$13" title="(x: String)List[String]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.complete;ParserMain.failure$default$2" title="Boolean">definitive</a><span class="delimiter">)</span>

  <span class="comment">/** Defines a parser that always succeeds on empty input with the result `value`.*/</span>
  <span class="keyword">def</span> <a title="[T](value: T)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.success">success</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.success;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt.complete;ParserMain.success.value">value</a>: <a href="#sbt.complete;ParserMain.success;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.success;$anon" title="sbt.complete.ValidParser[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.complete.ValidParser[T]" id="sbt.complete;ParserMain.success;$anon">ValidParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Some[T]" id="sbt.complete;ParserMain.success;$anon.result">result</a> = <span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.success.value" title="T">value</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Value[T]" id="sbt.complete;ParserMain.success;$anon.resultEmpty">resultEmpty</a> = <a href="#sbt.complete.Parser.Value.readResolve" title="(value: T)sbt.complete.Parser.Value[T]">Value</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.success.value" title="T">value</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Nothing]" id="sbt.complete;ParserMain.success;$anon.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;ParserMain.success;$anon.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>.<a href="#sbt.complete;ParserMain.failure" title="(msg: =&gt; String, definitive: Boolean)sbt.complete.Parser[Nothing]">failure</a><span class="delimiter">(</span><span title="String(&quot;Expected end of input.&quot;)" class="string">&quot;Expected end of input.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;ParserMain.success;$anon.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;ParserMain.success;$anon.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.empty" title="=&gt; sbt.complete.Completions">empty</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;ParserMain.success;$anon.toString">toString</a> = <span title="String(&quot;success(&quot;)" class="string">&quot;success(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;ParserMain.success.value" title="T">value</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Presents a Char range as a Parser.  A single Char is parsed only if it is in the given range.*/</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.complete.ParserMain.range : (r: scala.collection.immutable.NumericRange[Char])sbt.complete.Parser[Char]" id="sbt.complete;ParserMain.range">range</a><span class="delimiter">(</span><a title="scala.collection.immutable.NumericRange[Char]" id="sbt.complete;ParserMain.range.r">r</a>: collection.immutable.<span title="scala.collection.immutable.NumericRange[Char]">NumericRange</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <a href="#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]" class="delimiter">(</a><a href="#sbt.complete;ParserMain.range.r" title="scala.collection.immutable.NumericRange[Char]">r</a> <span title="(x: Any)Boolean">contains</span> <a href="#sbt.complete;ParserMain.range.$anonfun.x$14" title="Char">_</a><span class="delimiter">)</span>.<a href="#sbt.complete;RichParser.examples(88b70d78c2)" title="(s: String*)sbt.complete.Parser[Char]">examples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.range.r" title="scala.collection.immutable.NumericRange[Char]">r</a>.<span title="(f: Char =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Char],String,scala.collection.immutable.IndexedSeq[String]])scala.collection.immutable.IndexedSeq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,String,scala.collection.immutable.IndexedSeq[String]]" class="delimiter">(</span><a href="#sbt.complete;ParserMain.range.$anonfun.x$15" title="Char">_</a>.<span title="()String">toString</span><span class="delimiter">)</span>: _*<span class="delimiter">)</span>

  <span class="comment">/** Defines a Parser that parses a single character only if it is contained in `legal`.*/</span>
  <span class="keyword">def</span> <a title="(legal: String)sbt.complete.Parser[Char]" id="sbt.complete;ParserMain.chars">chars</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.chars.legal">legal</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Char]" id="sbt.complete;ParserMain.chars.set">set</a> = <a href="#sbt.complete;ParserMain.chars.legal" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">legal</a>.<span title="scala.collection.immutable.Set[Char]">toSet</span>
      <a href="#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><a href="#sbt.complete;ParserMain.richParser" title="sbt.complete.RichParser[Char] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;ParserMain.chars.qual$1" class="delimiter">(</a><a href="#sbt.complete;ParserMain.chars.set" title="scala.collection.immutable.Set[Char]">set</a>, <span title="String(&quot;character in \'&quot;)" class="string">&quot;character in '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;ParserMain.chars.legal" title="String">legal</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.examples$default$2" title="Boolean" id="sbt.complete;ParserMain.chars.x$45">examples</a> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.chars.set" title="scala.collection.immutable.Set[Char]">set</a>.<span title="(f: Char =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Char],String,scala.collection.immutable.Set[String]])scala.collection.immutable.Set[String]">map</span><a title="scala.collection.immutable.Set[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;ParserMain.chars.x$44" class="delimiter">(</a><a href="#sbt.complete;ParserMain.chars.x$44.$anonfun.x$16" title="Char">_</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Defines a Parser that parses a single character only if the predicate `f` returns true for that character.
   * If this parser fails, `label` is used as the failure message.
   */</span>
  <span class="keyword">def</span> <a title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]" id="sbt.complete;ParserMain.charClass">charClass</a><span class="delimiter">(</span><a title="Char =&gt; Boolean" id="sbt.complete;ParserMain.charClass.f">f</a>: Char =&gt; Boolean, <a title="String" id="sbt.complete;ParserMain.charClass$default$2">label</a>: <span title="String">String</span> = <span title="String(&quot;&lt;unspecified&gt;&quot;)" class="string">&quot;&lt;unspecified&gt;&quot;</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <span title="sbt.complete.CharacterClass" class="keyword">new</span> <a href="#sbt.complete;CharacterClass" title="sbt.complete.CharacterClass">CharacterClass</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.charClass.f" title="Char =&gt; Boolean">f</a>, <a href="#sbt.complete;ParserMain.charClass$default$2" title="String">label</a><span class="delimiter">)</span>

  <span class="comment">/** Presents a single Char `ch` as a Parser that only parses that exact character. */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.complete.ParserMain.literal : (ch: Char)sbt.complete.Parser[Char]" id="sbt.complete;ParserMain.literal(a2eb285bfb)">literal</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;ParserMain.literal(a2eb285bfb).ch">ch</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.literal(a2eb285bfb);$anon" title="sbt.complete.ValidParser[Char]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.complete.ValidParser[Char]" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon">ValidParser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.result">result</a> = <span title="None.type">None</span>
    <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Failure" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.resultEmpty">resultEmpty</a> = <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><span title="String(&quot;Expected \'&quot;)" class="string">&quot;Expected '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;ParserMain.literal(a2eb285bfb).ch" title="Char">ch</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Char]" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span title="sbt.complete.Parser[Char]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(a2eb285bfb);$anon.derive.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <a href="#sbt.complete;ParserMain.literal(a2eb285bfb).ch" title="Char">ch</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.success" title="(value: Char)sbt.complete.Parser[Char]">success</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(a2eb285bfb).ch" title="Char">ch</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="sbt.complete.Invalid" class="keyword">new</span> <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(a2eb285bfb);$anon.resultEmpty" title="=&gt; sbt.complete.Parser.Failure">resultEmpty</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.single" title="(c: sbt.complete.Completion)sbt.complete.Completions">single</a><span class="delimiter">(</span><a href="Completions.scala.html#sbt.complete.Completion" title="sbt.complete.Completion.type">Completion</a>.<a href="Completions.scala.html#sbt.complete.Completion.suggestStrict" title="(value: String)sbt.complete.Completion">suggestStrict</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(a2eb285bfb).ch" title="Char">ch</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;ParserMain.literal(a2eb285bfb);$anon.toString">toString</a> = <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;ParserMain.literal(a2eb285bfb).ch" title="Char">ch</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span>
  <span class="delimiter">}</span>
  <span class="comment">/** Presents a literal String `s` as a Parser that only parses that exact text and provides it as the result.*/</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit sbt.complete.ParserMain.literal : (s: String)sbt.complete.Parser[String]" id="sbt.complete;ParserMain.literal(d17d0531ce)">literal</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.literal(d17d0531ce).s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.stringLiteral" title="(s: String, start: Int)sbt.complete.Parser[String]">stringLiteral</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.literal(d17d0531ce).s" title="String">s</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

  <span class="comment">/** See [[unapply]]. */</span>
  <span class="keyword">object</span> <a title="ParserMain.this.~.type" id="sbt.complete;ParserMain.~">~</a> <a href="#sbt.complete;ParserMain.~" title="ParserMain.this.~.type" class="delimiter">{</a>
    <span class="comment">/** Convenience for destructuring a tuple that mirrors the `~` combinator.*/</span>
    <span class="keyword">def</span> <a title="[A, B](t: (A, B))Some[(A, B)]" id="sbt.complete;ParserMain.~.unapply">unapply</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.~.unapply;A">A</a>, <a title="" id="sbt.complete;ParserMain.~.unapply;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, B)" id="sbt.complete;ParserMain.~.unapply.t">t</a>: <span title="(A, B)" class="delimiter">(</span>A, B<span class="delimiter">)</span><span class="delimiter">)</span>: <span title="Some[(A, B)]">Some</span><span class="delimiter">[</span><span class="delimiter">(</span>A, B<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="(x: (A, B))Some[(A, B)]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.~.unapply.t" title="(A, B)">t</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Parses input `str` using `parser`.  If successful, the result is provided wrapped in `Right`.  If unsuccessful, an error message is provided in `Left`.*/</span>
  <span class="keyword">def</span> <a title="[T](str: String, parser: sbt.complete.Parser[T])Either[String,T]" id="sbt.complete;ParserMain.parse">parse</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.parse;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.parse.str">str</a>: <span title="String">String</span>, <a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.parse.parser">parser</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[String,T]">Either</span><span class="delimiter">[</span>String, T<span class="delimiter">]</span> =
    <a href="#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>.<a href="#sbt.complete;ParserMain.result" title="(p: sbt.complete.Parser[T], s: String)Either[() =&gt; (Seq[String], Int),T]">result</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.parse.parser" title="sbt.complete.Parser[T]">parser</a>, <a href="#sbt.complete;ParserMain.parse.str" title="String">str</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.LeftProjection[() =&gt; (Seq[String], Int),T]">left</span>.<span title="(f: (() =&gt; (Seq[String], Int)) =&gt; String)Product with Serializable with scala.util.Either[String,T]">map</span> <span class="delimiter">{</span> <a title="() =&gt; (Seq[String], Int)" id="sbt.complete;ParserMain.parse.$anonfun.failures">failures</a> =&gt;
      <span class="keyword">val</span> <a href="#sbt.complete;ParserMain.parse.$anonfun.msgs" title="(Seq[String], Int)" class="delimiter">(</a><a href="#sbt.complete;ParserMain.parse.$anonfun.x$17" title="Seq[String]" id="sbt.complete;ParserMain.parse.$anonfun.msgs">msgs</a>, <a href="#sbt.complete;ParserMain.parse.$anonfun.x$17" title="Int" id="sbt.complete;ParserMain.parse.$anonfun.pos">pos</a><span class="delimiter">)</span> = <a href="#sbt.complete;ParserMain.parse.$anonfun.failures" title="()(Seq[String], Int)">failures</a><span title="(Seq[String], Int) @unchecked" class="delimiter">(</span><span class="delimiter">)</span>
      <a href="ProcessError.scala.html#sbt.complete.ProcessError.apply" title="(command: String, msgs: Seq[String], index: Int)String">ProcessError</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.parse.str" title="String">str</a>, <a href="#sbt.complete;ParserMain.parse.$anonfun.msgs" title="Seq[String]">msgs</a>, <a href="#sbt.complete;ParserMain.parse.$anonfun.pos" title="Int">pos</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Convenience method to use when developing a parser.
   * `parser` is applied to the input `str`.
   * If `completions` is true, the available completions for the input are displayed.
   * Otherwise, the result of parsing is printed using the result's `toString` method.
   * If parsing fails, the error message is displayed.
   *
   * See also [[sampleParse]] and [[sampleCompletions]].
   */</span>
  <span class="keyword">def</span> <a title="(str: String, parser: sbt.complete.Parser[_], completions: Boolean)Unit" id="sbt.complete;ParserMain.sample">sample</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.sample.str">str</a>: <span title="String">String</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.sample.parser">parser</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete;ParserMain.sample$default$3">completions</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sample$default$3" title="Boolean">completions</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.sampleCompletions" title="(str: String, parser: sbt.complete.Parser[_], level: Int)Unit">sampleCompletions</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sample.str" title="String">str</a>, <a href="#sbt.complete;ParserMain.sample.parser" title="sbt.complete.Parser[_]">parser</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.sampleParse" title="(str: String, parser: sbt.complete.Parser[_])Unit">sampleParse</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sample.str" title="String">str</a>, <a href="#sbt.complete;ParserMain.sample.parser" title="sbt.complete.Parser[_]">parser</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Convenience method to use when developing a parser.
   * `parser` is applied to the input `str` and the result of parsing is printed using the result's `toString` method.
   * If parsing fails, the error message is displayed.
   */</span>
  <span class="keyword">def</span> <a title="(str: String, parser: sbt.complete.Parser[_])Unit" id="sbt.complete;ParserMain.sampleParse">sampleParse</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.sampleParse.str">str</a>: <span title="String">String</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.sampleParse.parser">parser</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#sbt.complete;ParserMain.parse" title="(str: String, parser: sbt.complete.Parser[_$12])Either[String,_$12]">parse</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sampleParse.str" title="String">str</a>, <a href="#sbt.complete;ParserMain.sampleParse.parser" title="sbt.complete.Parser[_]">parser</a><span class="delimiter">)</span> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.sampleParse.msg">msg</a><span class="delimiter">)</span> =&gt; <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sampleParse.msg" title="String">msg</a><span class="delimiter">)</span>
      <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="_$12" id="sbt.complete;ParserMain.sampleParse.v">v</a><span class="delimiter">)</span>  =&gt; <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sampleParse.v" title="_$12">v</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Convenience method to use when developing a parser.
   * `parser` is applied to the input `str` and the available completions are displayed on separate lines.
   * If parsing fails, the error message is displayed.
   */</span>
  <span class="keyword">def</span> <a title="(str: String, parser: sbt.complete.Parser[_], level: Int)Unit" id="sbt.complete;ParserMain.sampleCompletions">sampleCompletions</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.sampleCompletions.str">str</a>: <span title="String">String</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.sampleCompletions.parser">parser</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="sbt.complete;ParserMain.sampleCompletions$default$3">level</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>.<a href="#sbt.complete;ParserMain.completions" title="(p: sbt.complete.Parser[_], s: String, level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.sampleCompletions.parser" title="sbt.complete.Parser[_]">parser</a>, <a href="#sbt.complete;ParserMain.sampleCompletions.str" title="String">str</a>, <a href="#sbt.complete;ParserMain.sampleCompletions$default$3" title="Int">level</a><span class="delimiter">)</span>.<a href="Completions.scala.html#sbt.complete;Completions.get" title="=&gt; Set[sbt.complete.Completion]">get</a> <span title="(f: sbt.complete.Completion =&gt; Unit)Unit">foreach</span> <a href="#sbt.complete;ParserMain.sampleCompletions.$anonfun.x" title="(x: Any)Unit">println</a>

  <span class="comment">// intended to be temporary pending proper error feedback</span>
  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T], s: String)Either[() =&gt; (Seq[String], Int),T]" id="sbt.complete;ParserMain.result">result</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.result;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.result.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.result.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Either[() =&gt; (Seq[String], Int),T]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, Int<span class="delimiter">)</span>, T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(i: Int, a: sbt.complete.Parser[T])Either[() =&gt; (Seq[String], Int),T]" id="sbt.complete;ParserMain.result.loop">loop</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;ParserMain.result.loop.i">i</a>: <span title="Int">Int</span>, <a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.result.loop.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[() =&gt; (Seq[String], Int),T]">Either</span><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span>, Int<span class="delimiter">)</span>, T<span class="delimiter">]</span> =
        <a href="#sbt.complete;ParserMain.result.loop.a" title="sbt.complete.Parser[T]">a</a> <span title="Either[() =&gt; (Seq[String], Int),T]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Invalid<span class="delimiter">(</span><a title="sbt.complete.Parser.Failure" id="sbt.complete;ParserMain.result.loop.f">f</a><span class="delimiter">)</span> =&gt; <span title="(a: () =&gt; (Seq[String], Int))scala.util.Left[() =&gt; (Seq[String], Int),Nothing]">Left</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="(_1: Seq[String], _2: Int)(Seq[String], Int)" class="delimiter">(</span><a href="#sbt.complete;ParserMain.result.loop.f" title="sbt.complete.Parser.Failure">f</a>.<a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a>, <a href="#sbt.complete;ParserMain.result.loop.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <span class="keyword">val</span> <a title="Int" id="sbt.complete;ParserMain.result.loop.ci">ci</a> = <a href="#sbt.complete;ParserMain.result.loop.i" title="Int">i</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>
            <span title="Either[() =&gt; (Seq[String], Int),T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.result.loop.ci" title="Int">ci</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#sbt.complete;ParserMain.result.s" title="String">s</a>.<span title="()Int">length</span><span class="delimiter">)</span>
              <a href="#sbt.complete;ParserMain.result.loop.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>.<a href="#sbt.complete.Parser;Result.toEither" title="=&gt; Either[() =&gt; Seq[String],T]">toEither</a>.<span title="=&gt; scala.util.Either.LeftProjection[() =&gt; Seq[String],T]">left</span>.<span title="(f: (() =&gt; Seq[String]) =&gt; (() =&gt; (Seq[String], Int)))Product with Serializable with scala.util.Either[() =&gt; (Seq[String], Int),T]">map</span> <span class="delimiter">{</span> <a title="() =&gt; Seq[String]" id="sbt.complete;ParserMain.result.loop.$anonfun.msgs0">msgs0</a> =&gt;
                <span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
                  <span class="keyword">val</span> <a title="Seq[String]" id="sbt.complete;ParserMain.result.loop.$anonfun.$anonfun.msgs">msgs</a> = <a href="#sbt.complete;ParserMain.result.loop.$anonfun.msgs0" title="()Seq[String]">msgs0</a><span class="delimiter">(</span><span class="delimiter">)</span>
                  <span class="keyword">val</span> <a title="Seq[String]" id="sbt.complete;ParserMain.result.loop.$anonfun.$anonfun.nonEmpty">nonEmpty</a> = <span title="Seq[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.result.loop.$anonfun.$anonfun.msgs" title="Seq[String]">msgs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;Unexpected end of input&quot;)" class="string">&quot;Unexpected end of input&quot;</span> <a href="#sbt.complete;ParserMain.result.loop.$anonfun.$anonfun.nonEmpty.x$18" title="(x: String)List[String]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.result.loop.$anonfun.$anonfun.msgs" title="Seq[String]">msgs</a>
                  <span title="(_1: Seq[String], _2: Int)(Seq[String], Int)" class="delimiter">(</span><a href="#sbt.complete;ParserMain.result.loop.$anonfun.$anonfun.nonEmpty" title="Seq[String]">nonEmpty</a>, <a href="#sbt.complete;ParserMain.result.loop.ci" title="Int">ci</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">else</span>
              <a href="#sbt.complete;ParserMain.result.loop" title="(i: Int, a: sbt.complete.Parser[T])Either[() =&gt; (Seq[String], Int),T]">loop</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.result.loop.ci" title="Int">ci</a>, <a href="#sbt.complete;ParserMain.result.loop.a" title="sbt.complete.Parser[T]">a</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;ParserMain.result.s" title="(index: Int)Char">s</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.result.loop.ci" title="Int">ci</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#sbt.complete;ParserMain.result.loop" title="(i: Int, a: sbt.complete.Parser[T])Either[() =&gt; (Seq[String], Int),T]">loop</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span>, <a href="#sbt.complete;ParserMain.result.p" title="sbt.complete.Parser[T]">p</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Applies parser `p` to input `s`. */</span>
  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T])(s: String)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.apply.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.apply.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.apply.p" title="sbt.complete.Parser[T]">p</a> <a href="#sbt.complete;ParserMain.apply.x$19" title="(z: sbt.complete.Parser[T])(op: (sbt.complete.Parser[T], Char) =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">/:</a> <a href="#sbt.complete;ParserMain.apply.s" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.derive1" title="(p: sbt.complete.Parser[T], c: Char)sbt.complete.Parser[T]">derive1</a><span class="delimiter">)</span>

  <span class="comment">/** Applies parser `p` to a single character of input. */</span>
  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T], c: Char)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.derive1">derive1</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.derive1;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.derive1.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Char" id="sbt.complete;ParserMain.derive1.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.derive1.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.derive1.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.derive1.c" title="Char">c</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.derive1.p" title="sbt.complete.Parser[T]">p</a>

  <span class="comment">/**
   * Applies parser `p` to input `s` and returns the completions at verbosity `level`.
   * The interpretation of `level` is up to parser definitions, but 0 is the default by convention,
   * with increasing positive numbers corresponding to increasing verbosity.  Typically no more than
   * a few levels are defined.
   */</span>
  <span class="keyword">def</span> <a title="(p: sbt.complete.Parser[_], s: String, level: Int)sbt.complete.Completions" id="sbt.complete;ParserMain.completions">completions</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.completions.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.completions.s">s</a>: <span title="String">String</span>, <a title="Int" id="sbt.complete;ParserMain.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Completions.scala.html#sbt.complete;Completions" title="sbt.complete.Completions">Completions</a> =
    <span class="comment">// The x Completions.empty removes any trailing token completions where append.isEmpty</span>
    <a href="#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[_$14])(s: String)sbt.complete.Parser[_$14]">apply</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.completions.p" title="sbt.complete.Parser[_]">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.completions.s" title="String">s</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.x" title="(o: sbt.complete.Completions)sbt.complete.Completions">x</a> <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.empty" title="=&gt; sbt.complete.Completions">empty</a>

  <span class="keyword">def</span> <a title="[A](a: sbt.complete.Parser[A], completions: Set[String], check: Boolean)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.examples(e6722deb80)">examples</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.examples$default$3;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete;ParserMain.examples(e6722deb80).a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Set[String]" id="sbt.complete;ParserMain.examples(e6722deb80).completions">completions</a>: <span title="Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete;ParserMain.examples$default$3">check</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#sbt.complete;ParserMain.examples(5a4082b96f)" title="(a: sbt.complete.Parser[A], completions: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]">examples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.examples(e6722deb80).a" title="sbt.complete.Parser[A]">a</a>, <span title="sbt.complete.FixedSetExamples" class="keyword">new</span> <a href="ExampleSource.scala.html#sbt.complete;FixedSetExamples" title="sbt.complete.FixedSetExamples">FixedSetExamples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.examples(e6722deb80).completions" title="Set[String]">completions</a><span class="delimiter">)</span>, <a href="#sbt.complete;ParserMain.examples(e6722deb80).completions" title="Set[String]">completions</a>.<span title="=&gt; Int">size</span>, <a href="#sbt.complete;ParserMain.examples$default$3" title="Boolean">check</a><span class="delimiter">)</span>

  <span class="comment">/**
   * @param a the parser to decorate with a source of examples. All validation and parsing is delegated to this parser,
   *          only [[Parser.completions]] is modified.
   * @param completions the source of examples when displaying completions to the user.
   * @param maxNumberOfExamples limits the number of examples that the source of examples should return. This can
   *                            prevent lengthy pauses and avoids bad interactive user experience.
   * @param removeInvalidExamples indicates whether completion examples should be checked for validity (against the given parser). An
   *                              exception is thrown if the example source contains no valid completion suggestions.
   * @tparam A the type of values that are returned by the parser.
   * @return
   */</span>
  <span class="keyword">def</span> <a title="[A](a: sbt.complete.Parser[A], completions: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[A]" id="sbt.complete;ParserMain.examples(5a4082b96f)">examples</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.examples(5a4082b96f);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete;ParserMain.examples(5a4082b96f).a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.ExampleSource" id="sbt.complete;ParserMain.examples(5a4082b96f).completions">completions</a>: <a href="ExampleSource.scala.html#sbt.complete;ExampleSource" title="sbt.complete.ExampleSource">ExampleSource</a>, <a title="Int" id="sbt.complete;ParserMain.examples(5a4082b96f).maxNumberOfExamples">maxNumberOfExamples</a>: <span title="Int">Int</span>, <a title="Boolean" id="sbt.complete;ParserMain.examples(5a4082b96f).removeInvalidExamples">removeInvalidExamples</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.examples(5a4082b96f).a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#sbt.complete;ParserMain.examples(5a4082b96f).a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a> <span title="sbt.complete.Parser[A]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="A" id="sbt.complete;ParserMain.examples(5a4082b96f).av">av</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;ParserMain.success" title="(value: A)sbt.complete.Parser[A]">success</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.examples(5a4082b96f).av" title="A">av</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="None.type">None</span> =&gt;
          <span title="sbt.complete.ParserWithExamples[A]" class="keyword">new</span> <a href="#sbt.complete;ParserWithExamples" title="sbt.complete.ParserWithExamples[A]">ParserWithExamples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.examples(5a4082b96f).a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.examples(5a4082b96f).completions" title="sbt.complete.ExampleSource">completions</a>, <a href="#sbt.complete;ParserMain.examples(5a4082b96f).maxNumberOfExamples" title="Int">maxNumberOfExamples</a>, <a href="#sbt.complete;ParserMain.examples(5a4082b96f).removeInvalidExamples" title="Boolean">removeInvalidExamples</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.examples(5a4082b96f).a" title="sbt.complete.Parser[A]">a</a>

  <span class="keyword">def</span> <a title="(t: sbt.complete.Parser[_], seen: Vector[Char], partial: Boolean)sbt.complete.Parser[String]" id="sbt.complete;ParserMain.matched">matched</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.matched.t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Vector[Char]" id="sbt.complete;ParserMain.matched$default$2">seen</a>: <span title="Vector[Char]">Vector</span><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>, <a title="Boolean" id="sbt.complete;ParserMain.matched$default$3">partial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="#sbt.complete;ParserMain.matched.t" title="sbt.complete.Parser[_]">t</a> <span title="sbt.complete.Parser[String]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="sbt.complete.Invalid" id="sbt.complete;ParserMain.matched.i">i</a>: <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid">Invalid</a> =&gt; <span title="sbt.complete.Parser[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.matched$default$3" title="Boolean">partial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.complete;ParserMain.matched$default$2" title="Vector[Char]">seen</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.success" title="(value: String)sbt.complete.Parser[String]">success</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.matched$default$2" title="Vector[Char]">seen</a>.<span title="=&gt; String">mkString</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.matched.i" title="sbt.complete.Invalid">i</a>
      <span class="keyword">case</span> _ =&gt;
        <span title="sbt.complete.Parser[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.matched.t" title="sbt.complete.Parser[_]">t</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[_$15]">result</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <span title="sbt.complete.MatchedString" class="keyword">new</span> <a href="#sbt.complete;MatchedString" title="sbt.complete.MatchedString">MatchedString</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.matched.t" title="sbt.complete.Parser[_]">t</a>, <a href="#sbt.complete;ParserMain.matched$default$2" title="Vector[Char]">seen</a>, <a href="#sbt.complete;ParserMain.matched$default$3" title="Boolean">partial</a><span class="delimiter">)</span>
        <span class="keyword">else</span>
          <a href="#sbt.complete;ParserMain.success" title="(value: String)sbt.complete.Parser[String]">success</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.matched$default$2" title="Vector[Char]">seen</a>.<span title="=&gt; String">mkString</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Establishes delegate parser `t` as a single token of tab completion.
   * When tab completion of part of this token is requested, the completions provided by the delegate `t` or a later derivative are appended to
   * the prefix String already seen by this parser.
   */</span>
  <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T])sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(ab0e3a3279)">token</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.token(ab0e3a3279);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(ab0e3a3279).t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.token(080ce9da13)" title="(t: sbt.complete.Parser[T], complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">token</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(ab0e3a3279).t" title="sbt.complete.Parser[T]">t</a>, <a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions" title="sbt.complete.TokenCompletions.type">TokenCompletions</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions.default" title="=&gt; sbt.complete.TokenCompletions">default</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Establishes delegate parser `t` as a single token of tab completion.
   * When tab completion of part of this token is requested, no completions are returned if `hide` returns true for the current tab completion level.
   * Otherwise, the completions provided by the delegate `t` or a later derivative are appended to the prefix String already seen by this parser.
   */</span>
  <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T], hide: Int =&gt; Boolean)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(7390b50c07)">token</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.token(7390b50c07);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(7390b50c07).t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int =&gt; Boolean" id="sbt.complete;ParserMain.token(7390b50c07).hide">hide</a>: Int =&gt; Boolean<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.token(080ce9da13)" title="(t: sbt.complete.Parser[T], complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">token</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(7390b50c07).t" title="sbt.complete.Parser[T]">t</a>, <a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions" title="sbt.complete.TokenCompletions.type">TokenCompletions</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions.default" title="=&gt; sbt.complete.TokenCompletions">default</a>.<a href="TokenCompletions.scala.html#sbt.complete;TokenCompletions.hideWhen" title="(f: Int =&gt; Boolean)sbt.complete.TokenCompletions">hideWhen</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(7390b50c07).hide" title="Int =&gt; Boolean">hide</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Establishes delegate parser `t` as a single token of tab completion.
   * When tab completion of part of this token is requested, `description` is displayed for suggestions and no completions are ever performed.
   */</span>
  <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T], description: String)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(0b971f8ae9)">token</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.token(0b971f8ae9);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(0b971f8ae9).t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.token(0b971f8ae9).description">description</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.token(080ce9da13)" title="(t: sbt.complete.Parser[T], complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">token</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(0b971f8ae9).t" title="sbt.complete.Parser[T]">t</a>, <a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions" title="sbt.complete.TokenCompletions.type">TokenCompletions</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions.displayOnly" title="(msg: String)sbt.complete.TokenCompletions">displayOnly</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(0b971f8ae9).description" title="String">description</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Establishes delegate parser `t` as a single token of tab completion.
   * When tab completion of part of this token is requested, `display` is used as the printed suggestion, but the completions from the delegate
   * parser `t` are used to complete if unambiguous.
   */</span>
  <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T], display: String)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.tokenDisplay">tokenDisplay</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.tokenDisplay;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.tokenDisplay.t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.tokenDisplay.display">display</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt.complete;ParserMain.token(080ce9da13)" title="(t: sbt.complete.Parser[T], complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">token</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.tokenDisplay.t" title="sbt.complete.Parser[T]">t</a>, <a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions" title="sbt.complete.TokenCompletions.type">TokenCompletions</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions.overrideDisplay" title="(msg: String)sbt.complete.TokenCompletions">overrideDisplay</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.tokenDisplay.display" title="String">display</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T], complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(080ce9da13)">token</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.token(080ce9da13);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(080ce9da13).t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.TokenCompletions" id="sbt.complete;ParserMain.token(080ce9da13).complete">complete</a>: <a href="TokenCompletions.scala.html#sbt.complete;TokenCompletions" title="sbt.complete.TokenCompletions">TokenCompletions</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#sbt.complete;ParserMain.mkToken" title="(t: sbt.complete.Parser[T], seen: String, complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">mkToken</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(080ce9da13).t" title="sbt.complete.Parser[T]">t</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <a href="#sbt.complete;ParserMain.token(080ce9da13).complete" title="sbt.complete.TokenCompletions">complete</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use a different `token` overload.&quot;</span>, <span class="string">&quot;0.12.1&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T], seen: String, track: Boolean, hide: Int =&gt; Boolean)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(55315112f4)">token</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.token(55315112f4);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.token(55315112f4).t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.token(55315112f4).seen">seen</a>: <span title="String">String</span>, <a title="Boolean" id="sbt.complete;ParserMain.token(55315112f4).track">track</a>: <span title="Boolean">Boolean</span>, <a title="Int =&gt; Boolean" id="sbt.complete;ParserMain.token(55315112f4).hide">hide</a>: Int =&gt; Boolean<span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.complete.TokenCompletions" id="sbt.complete;ParserMain.token(55315112f4).base">base</a> = <span title="sbt.complete.TokenCompletions" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(55315112f4).track" title="Boolean">track</a><span class="delimiter">)</span> <a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions" title="sbt.complete.TokenCompletions.type">TokenCompletions</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions.default" title="=&gt; sbt.complete.TokenCompletions">default</a> <span class="keyword">else</span> <a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions" title="sbt.complete.TokenCompletions.type">TokenCompletions</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions.displayOnly" title="(msg: String)sbt.complete.TokenCompletions">displayOnly</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(55315112f4).seen" title="String">seen</a><span class="delimiter">)</span>
      <a href="#sbt.complete;ParserMain.token(080ce9da13)" title="(t: sbt.complete.Parser[T], complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">token</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(55315112f4).t" title="sbt.complete.Parser[T]">t</a>, <a href="#sbt.complete;ParserMain.token(55315112f4).base" title="sbt.complete.TokenCompletions">base</a>.<a href="TokenCompletions.scala.html#sbt.complete;TokenCompletions.hideWhen" title="(f: Int =&gt; Boolean)sbt.complete.TokenCompletions">hideWhen</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.token(55315112f4).hide" title="Int =&gt; Boolean">hide</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](t: sbt.complete.Parser[T], seen: String, complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]" id="sbt.complete;ParserMain.mkToken">mkToken</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.mkToken;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.mkToken.t">t</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.mkToken.seen">seen</a>: <span title="String">String</span>, <a title="sbt.complete.TokenCompletions" id="sbt.complete;ParserMain.mkToken.complete">complete</a>: <a href="TokenCompletions.scala.html#sbt.complete;TokenCompletions" title="sbt.complete.TokenCompletions">TokenCompletions</a><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.mkToken.t" title="sbt.complete.Parser[T]">t</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#sbt.complete;ParserMain.mkToken.t" title="sbt.complete.Parser[T]">t</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a><span class="delimiter">)</span>
      <span title="sbt.complete.Parser[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.mkToken.t" title="sbt.complete.Parser[T]">t</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="sbt.complete.TokenStart[T]" class="keyword">new</span> <a href="#sbt.complete;TokenStart" title="sbt.complete.TokenStart[T]">TokenStart</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.mkToken.t" title="sbt.complete.Parser[T]">t</a>, <a href="#sbt.complete;ParserMain.mkToken.seen" title="String">seen</a>, <a href="#sbt.complete;ParserMain.mkToken.complete" title="sbt.complete.TokenCompletions">complete</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;ParserMain.mkToken.t" title="sbt.complete.Parser[T]">t</a>
    <span class="keyword">else</span>
      <a href="#sbt.complete;ParserMain.mkToken.t" title="sbt.complete.Parser[T]">t</a>

  <span class="keyword">def</span> <a title="[A](a: sbt.complete.Parser[A], b: sbt.complete.Parser[A])sbt.complete.Parser[A]" id="sbt.complete;ParserMain.homParser">homParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.homParser;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[A]" id="sbt.complete;ParserMain.homParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[A]" id="sbt.complete;ParserMain.homParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span title="(_1: sbt.complete.Parser[A], _2: sbt.complete.Parser[A])(sbt.complete.Parser[A], sbt.complete.Parser[A])" class="delimiter">(</span><a href="#sbt.complete;ParserMain.homParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.homParser.b" title="sbt.complete.Parser[A]">b</a><span class="delimiter">)</span> <span title="sbt.complete.Parser[A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>Invalid<span class="delimiter">(</span><a title="sbt.complete.Parser.Failure" id="sbt.complete;ParserMain.homParser.af">af</a><span class="delimiter">)</span>, Invalid<span class="delimiter">(</span><a title="sbt.complete.Parser.Failure" id="sbt.complete;ParserMain.homParser.bf">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.Invalid.readResolve" title="(fail: sbt.complete.Parser.Failure)sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.homParser.af" title="sbt.complete.Parser.Failure">af</a> <a href="#sbt.complete.Parser;Failure.++" title="(f: sbt.complete.Parser.Failure)sbt.complete.Parser.Failure">++</a> <a href="#sbt.complete;ParserMain.homParser.bf" title="sbt.complete.Parser.Failure">bf</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>Invalid<span class="delimiter">(</span>_<span class="delimiter">)</span>, <span title="sbt.complete.Parser[A]">bv</span><span class="delimiter">)</span>           =&gt; <span title="sbt.complete.Parser[A]">bv</span>
    <span class="keyword">case</span> <span class="delimiter">(</span><span title="sbt.complete.Parser[A]">av</span>, Invalid<span class="delimiter">(</span>_<span class="delimiter">)</span><span class="delimiter">)</span>           =&gt; <span title="sbt.complete.Parser[A]">av</span>
    <span class="keyword">case</span> <span class="delimiter">(</span><span title="sbt.complete.Parser[A]">av</span>, <span title="sbt.complete.Parser[A]">bv</span><span class="delimiter">)</span>                   =&gt; <span title="sbt.complete.HomParser[A]" class="keyword">new</span> <a href="#sbt.complete;HomParser" title="sbt.complete.HomParser[A]">HomParser</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.homParser.a" title="sbt.complete.Parser[A]">a</a>, <a href="#sbt.complete;ParserMain.homParser.b" title="sbt.complete.Parser[A]">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Explicitly specify the failure message.&quot;</span>, <span class="string">&quot;0.12.2&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(p: sbt.complete.Parser[_])sbt.complete.Parser[Unit]" id="sbt.complete;ParserMain.not(bfcd18eaec)">not</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.not(bfcd18eaec).p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Unit]">Parser</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.not(7e585d5e4e)" title="(p: sbt.complete.Parser[_], failMessage: String)sbt.complete.Parser[Unit]">not</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.not(bfcd18eaec).p" title="sbt.complete.Parser[_]">p</a>, <span title="String(&quot;Excluded.&quot;)" class="string">&quot;Excluded.&quot;</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(p: sbt.complete.Parser[_], failMessage: String)sbt.complete.Parser[Unit]" id="sbt.complete;ParserMain.not(7e585d5e4e)">not</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete;ParserMain.not(7e585d5e4e).p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="String" id="sbt.complete;ParserMain.not(7e585d5e4e).failMessage">failMessage</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Unit]">Parser</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.not(7e585d5e4e).p" title="sbt.complete.Parser[_]">p</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[_$17]">result</a> <span title="sbt.complete.Parser[Unit]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="None.type">None</span>    =&gt; <span title="sbt.complete.Not" class="keyword">new</span> <a href="#sbt.complete;Not" title="sbt.complete.Not">Not</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.not(7e585d5e4e).p" title="sbt.complete.Parser[_]">p</a>, <a href="#sbt.complete;ParserMain.not(7e585d5e4e).failMessage" title="String">failMessage</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#sbt.complete;ParserMain.failure" title="(msg: =&gt; String, definitive: Boolean)sbt.complete.Parser[Nothing]">failure</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.not(7e585d5e4e).failMessage" title="String">failMessage</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T](p: Seq[sbt.complete.Parser[T]])sbt.complete.Parser[T]" id="sbt.complete;ParserMain.oneOf">oneOf</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.oneOf;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[sbt.complete.Parser[T]]" id="sbt.complete;ParserMain.oneOf.p">p</a>: <span title="Seq[sbt.complete.Parser[T]]">Seq</span><span class="delimiter">[</span>Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.oneOf.p" title="Seq[sbt.complete.Parser[T]]">p</a>.<span title="(op: (sbt.complete.Parser[T], sbt.complete.Parser[T]) =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">reduceLeft</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">_</a> <a href="#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[T])sbt.complete.Parser[T]">|</a> <a href="#sbt.complete;ParserMain.oneOf.$anonfun.x$21" title="sbt.complete.Parser[T]">_</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](p: Seq[sbt.complete.Parser[T]])sbt.complete.Parser[Seq[T]]" id="sbt.complete;ParserMain.seq">seq</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.seq;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[sbt.complete.Parser[T]]" id="sbt.complete;ParserMain.seq.p">p</a>: <span title="Seq[sbt.complete.Parser[T]]">Seq</span><span class="delimiter">[</span>Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.complete;ParserMain.seq0" title="(p: Seq[sbt.complete.Parser[T]], errors: =&gt; Seq[String])sbt.complete.Parser[Seq[T]]">seq0</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq.p" title="Seq[sbt.complete.Parser[T]]">p</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](p: Seq[sbt.complete.Parser[T]], errors: =&gt; Seq[String])sbt.complete.Parser[Seq[T]]" id="sbt.complete;ParserMain.seq0">seq0</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserMain.seq0;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[sbt.complete.Parser[T]]" id="sbt.complete;ParserMain.seq0.p">p</a>: <span title="Seq[sbt.complete.Parser[T]]">Seq</span><span class="delimiter">[</span>Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="=&gt; Seq[String]" id="sbt.complete;ParserMain.seq0.errors">errors</a>: =&gt; Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#sbt.complete;ParserMain.seq0.newErrors" title="(Seq[Seq[String]], Seq[sbt.complete.Parser[T]])" class="delimiter">(</a><a href="#sbt.complete;ParserMain.seq0.x$22" title="Seq[Seq[String]]" id="sbt.complete;ParserMain.seq0.newErrors">newErrors</a>, <a href="#sbt.complete;ParserMain.seq0.x$22" title="Seq[sbt.complete.Parser[T]]" id="sbt.complete;ParserMain.seq0.valid">valid</a><span class="delimiter">)</span> = <a href="../Util.scala.html#sbt.Util.separate" title="(ps: Seq[sbt.complete.Parser[T]])(f: sbt.complete.Parser[T] =&gt; Either[Seq[String],sbt.complete.Parser[T]])(Seq[Seq[String]], Seq[sbt.complete.Parser[T]])">separate</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq0.p" title="Seq[sbt.complete.Parser[T]]">p</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.seq0.x$22.$anonfun.x0$3" title="&lt;root&gt; extends Product with Serializable with scala.util.Either[Seq[String],sbt.complete.Parser[T]]" class="delimiter">{</a> <span class="keyword">case</span> Invalid<span class="delimiter">(</span><a title="sbt.complete.Parser.Failure" id="sbt.complete;ParserMain.seq0.x$22.$anonfun.f">f</a><span class="delimiter">)</span> =&gt; <span title="(a: Seq[String])scala.util.Left[Seq[String],Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq0.x$22.$anonfun.f" title="sbt.complete.Parser.Failure">f</a>.<a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a><span class="delimiter">)</span>; <span class="keyword">case</span> <a title="sbt.complete.Parser[T]" id="sbt.complete;ParserMain.seq0.x$22.$anonfun.ok">ok</a> =&gt; <span title="(b: sbt.complete.Parser[T])scala.util.Right[Nothing,sbt.complete.Parser[T]]">Right</span><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq0.x$22.$anonfun.ok" title="sbt.complete.Parser[T]">ok</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Seq[String]" id="sbt.complete;ParserMain.seq0.combinedErrors">combinedErrors</a> = <a href="#sbt.complete;ParserMain.seq0.errors" title="=&gt; Seq[String]">errors</a> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">++</span> <a href="#sbt.complete;ParserMain.seq0.newErrors" title="Seq[Seq[String]]">newErrors</a>.<span title="(implicit asTraversable: Seq[String] =&gt; scala.collection.GenTraversableOnce[String])Seq[String]">flatten</span>
      <span title="sbt.complete.Parser[Seq[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq0.valid" title="Seq[sbt.complete.Parser[T]]">valid</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.invalid" title="(msgs: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser[Nothing]">invalid</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq0.combinedErrors" title="=&gt; Seq[String]">combinedErrors</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="sbt.complete.ParserSeq[T]" class="keyword">new</span> <a href="#sbt.complete;ParserSeq" title="sbt.complete.ParserSeq[T]">ParserSeq</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.seq0.valid" title="Seq[sbt.complete.Parser[T]]">valid</a>, <a href="#sbt.complete;ParserMain.seq0.combinedErrors" title="=&gt; Seq[String]">combinedErrors</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(s: String, start: Int)sbt.complete.Parser[String]" id="sbt.complete;ParserMain.stringLiteral">stringLiteral</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserMain.stringLiteral.s">s</a>: <span title="String">String</span>, <a title="Int" id="sbt.complete;ParserMain.stringLiteral.start">start</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="sbt.complete;ParserMain.stringLiteral.len">len</a> = <a href="#sbt.complete;ParserMain.stringLiteral.s" title="String">s</a>.<span title="()Int">length</span>
      <span title="sbt.complete.Parser[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.stringLiteral.len" title="Int">len</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;String literal cannot be empty&quot;)" class="string">&quot;String literal cannot be empty&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="sbt.complete.Parser[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserMain.stringLiteral.start" title="Int">start</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#sbt.complete;ParserMain.stringLiteral.len" title="Int">len</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.success" title="(value: String)sbt.complete.Parser[String]">success</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.stringLiteral.s" title="String">s</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="sbt.complete.StringLiteral" class="keyword">new</span> <a href="#sbt.complete;StringLiteral" title="sbt.complete.StringLiteral">StringLiteral</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.stringLiteral.s" title="String">s</a>, <a href="#sbt.complete;ParserMain.stringLiteral.start" title="Int">start</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ValidParser[T] extends AnyRef with sbt.complete.Parser[T]" id="sbt.complete;ValidParser">ValidParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;ValidParser;T">T</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;ValidParser.valid">valid</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;ValidParser.failure">failure</a> = <span title="None.type">None</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[S](p: =&gt; sbt.complete.Parser[S])sbt.complete.Parser[S]" id="sbt.complete;ValidParser.ifValid">ifValid</a><span class="delimiter">[</span><a title="" id="sbt.complete;ValidParser.ifValid;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser[S]" id="sbt.complete;ValidParser.ifValid.p">p</a>: =&gt; Parser<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[S]">Parser</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <a href="#sbt.complete;ValidParser.ifValid.p" title="=&gt; sbt.complete.Parser[S]">p</a>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Invalid extends AnyRef with sbt.complete.Parser[Nothing] with Product with Serializable" id="sbt.complete.Invalid.readResolve">Invalid</a><a href="#sbt.complete.Invalid.readResolve" title="Product" class="delimiter">(</a><a title="sbt.complete.Parser.Failure" id="sbt.complete;Invalid.fail">fail</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Nothing]">Parser</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; Some[sbt.complete.Parser.Failure]" id="sbt.complete;Invalid.failure">failure</a> = <span title="(x: sbt.complete.Parser.Failure)Some[sbt.complete.Parser.Failure]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;Invalid.fail" title="=&gt; sbt.complete.Parser.Failure">fail</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;Invalid.result">result</a> = <span title="None.type">None</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Failure" id="sbt.complete;Invalid.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;Invalid.fail" title="=&gt; sbt.complete.Parser.Failure">fail</a>
  <span class="keyword">def</span> <a title="(c: Char)Nothing" id="sbt.complete;Invalid.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Invalid.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Invalid.&quot;)" class="string">&quot;Invalid.&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;Invalid.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Invalid.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.nil" title="=&gt; sbt.complete.Completions">nil</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;Invalid.toString">toString</a> = <a href="#sbt.complete;Invalid.fail" title="=&gt; sbt.complete.Parser.Failure">fail</a>.<a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;Invalid.valid">valid</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">def</span> <a title="[S](p: =&gt; sbt.complete.Parser[S])sbt.complete.Parser[S]" id="sbt.complete;Invalid.ifValid">ifValid</a><span class="delimiter">[</span><a title="" id="sbt.complete;Invalid.ifValid;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; sbt.complete.Parser[S]" id="sbt.complete;Invalid.ifValid.p">p</a>: =&gt; Parser<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[S]">Parser</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid" class="keyword">this</a>
<span class="delimiter">}</span>

<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class SoftInvalid extends AnyRef with sbt.complete.ValidParser[Nothing] with Product with Serializable" id="sbt.complete.SoftInvalid.readResolve">SoftInvalid</a><a href="#sbt.complete.SoftInvalid.readResolve" title="Product" class="delimiter">(</a><a title="sbt.complete.Parser.Failure" id="sbt.complete;SoftInvalid.fail">fail</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Nothing]">ValidParser</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;SoftInvalid.result">result</a> = <span title="None.type">None</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Failure" id="sbt.complete;SoftInvalid.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;SoftInvalid.fail" title="=&gt; sbt.complete.Parser.Failure">fail</a>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Invalid" id="sbt.complete;SoftInvalid.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;SoftInvalid.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete.Invalid.readResolve" title="(fail: sbt.complete.Parser.Failure)sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete;SoftInvalid.fail" title="=&gt; sbt.complete.Parser.Failure">fail</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;SoftInvalid.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;SoftInvalid.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.nil" title="=&gt; sbt.complete.Completions">nil</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;SoftInvalid.toString">toString</a> = <a href="#sbt.complete;SoftInvalid.fail" title="=&gt; sbt.complete.Parser.Failure">fail</a>.<a href="#sbt.complete.Parser;Failure.errors" title="=&gt; Seq[String]">errors</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TrapAndFail[A] extends AnyRef with sbt.complete.ValidParser[A]" id="sbt.complete;TrapAndFail">TrapAndFail</a><span class="delimiter">[</span><a title="" id="sbt.complete;TrapAndFail;A">A</a><span class="delimiter">]</span><a href="#sbt.complete;TrapAndFail" title="sbt.complete.TrapAndFail[A]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;TrapAndFail.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[A]">ValidParser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; Option[A]" id="sbt.complete;TrapAndFail.result">result</a> = <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt.complete;TrapAndFail.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a> <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.complete;TrapAndFail.result.e">e</a>: <span title="Exception">Exception</span> =&gt; <span title="None.type">None</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[A]" id="sbt.complete;TrapAndFail.resultEmpty">resultEmpty</a> = <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt.complete;TrapAndFail.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.complete;TrapAndFail.resultEmpty.e">e</a>: <span title="Exception">Exception</span> =&gt; <a href="#sbt.complete;TrapAndFail.fail" title="(e: Exception)sbt.complete.Parser.Failure">fail</a><span class="delimiter">(</span><a href="#sbt.complete;TrapAndFail.resultEmpty.e" title="Exception">e</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[A]" id="sbt.complete;TrapAndFail.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;TrapAndFail.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt.complete.Parser.trapAndFail" title="(delegate: sbt.complete.Parser[A])sbt.complete.Parser[A]">trapAndFail</a><span class="delimiter">(</span><a href="#sbt.complete;TrapAndFail.a" title="sbt.complete.Parser[A]">a</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[A]">derive</a> <a href="#sbt.complete;TrapAndFail.derive.c" title="Char">c</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.complete;TrapAndFail.derive.e">e</a>: <span title="Exception">Exception</span> =&gt; <a href="#sbt.complete.Invalid.readResolve" title="(fail: sbt.complete.Parser.Failure)sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete;TrapAndFail.fail" title="(e: Exception)sbt.complete.Parser.Failure">fail</a><span class="delimiter">(</span><a href="#sbt.complete;TrapAndFail.derive.e" title="Exception">e</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;TrapAndFail.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;TrapAndFail.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#sbt.complete;TrapAndFail.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;TrapAndFail.completions.level" title="Int">level</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.complete;TrapAndFail.completions.e">e</a>: <span title="Exception">Exception</span> =&gt; <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.nil" title="=&gt; sbt.complete.Completions">nil</a> <span class="delimiter">}</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;TrapAndFail.toString">toString</a> = <span title="String(&quot;trap(&quot;)" class="string">&quot;trap(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;TrapAndFail.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;TrapAndFail.isTokenStart">isTokenStart</a> = <a href="#sbt.complete;TrapAndFail.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(e: Exception)sbt.complete.Parser.Failure" id="sbt.complete;TrapAndFail.fail">fail</a><span class="delimiter">(</span><a title="Exception" id="sbt.complete;TrapAndFail.fail.e">e</a>: <span title="Exception">Exception</span><span class="delimiter">)</span>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> = <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><a href="#sbt.complete;TrapAndFail.fail.e" title="Exception">e</a>.<span title="()String">toString</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class OnFailure[A] extends AnyRef with sbt.complete.ValidParser[A]" id="sbt.complete;OnFailure">OnFailure</a><span class="delimiter">[</span><a title="" id="sbt.complete;OnFailure;A">A</a><span class="delimiter">]</span><a href="#sbt.complete;OnFailure" title="sbt.complete.OnFailure[A]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;OnFailure.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="String" id="sbt.complete;OnFailure.message">message</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[A]">ValidParser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; Option[A]" id="sbt.complete;OnFailure.result">result</a> = <a href="#sbt.complete;OnFailure.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[A]" id="sbt.complete;OnFailure.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;OnFailure.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <span title="sbt.complete.Parser.Result[A]" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete;OnFailure.resultEmpty.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><a href="#sbt.complete;OnFailure.message" title="String">message</a><span class="delimiter">)</span>; <span class="keyword">case</span> <a title="sbt.complete.Parser.Value[A]" id="sbt.complete;OnFailure.resultEmpty.v">v</a>: <a href="#sbt.complete.Parser.Value.readResolve" title="sbt.complete.Parser.Value[A]">Value</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; <a href="#sbt.complete;OnFailure.resultEmpty.v" title="sbt.complete.Parser.Value[A]">v</a> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[A]" id="sbt.complete;OnFailure.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;OnFailure.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.onFailure" title="(delegate: sbt.complete.Parser[A], msg: String)sbt.complete.Parser[A]">onFailure</a><span class="delimiter">(</span><a href="#sbt.complete;OnFailure.a" title="sbt.complete.Parser[A]">a</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[A]">derive</a> <a href="#sbt.complete;OnFailure.derive.c" title="Char">c</a>, <a href="#sbt.complete;OnFailure.message" title="String">message</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;OnFailure.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;OnFailure.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;OnFailure.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;OnFailure.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;OnFailure.toString">toString</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;OnFailure.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; !!! \&quot;&quot;)" class="string">&quot; !!! \&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;OnFailure.message" title="String">message</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot; )&quot;)" class="string">&quot;\&quot; )&quot;</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;OnFailure.isTokenStart">isTokenStart</a> = <a href="#sbt.complete;OnFailure.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class SeqParser[A, B] extends AnyRef with sbt.complete.ValidParser[(A, B)]" id="sbt.complete;SeqParser">SeqParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;SeqParser;A">A</a>, <a title="" id="sbt.complete;SeqParser;B">B</a><span class="delimiter">]</span><a href="#sbt.complete;SeqParser" title="sbt.complete.SeqParser[A,B]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;SeqParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[B]" id="sbt.complete;SeqParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[(A, B)]">ValidParser</a><span class="delimiter">[</span><span class="delimiter">(</span>A, B<span class="delimiter">)</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[(A, B)]" id="sbt.complete;SeqParser.result">result</a> = <a href="#sbt.complete.Parser.tuple" title="(a: Option[A], b: Option[B])Option[(A, B)]">tuple</a><span class="delimiter">(</span><a href="#sbt.complete;SeqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a>, <a href="#sbt.complete;SeqParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[B]">result</a><span class="delimiter">)</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[(A, B)]" id="sbt.complete;SeqParser.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;SeqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <a href="#sbt.complete.Parser;Result.seq" title="(b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[(A, B)]">seq</a> <a href="#sbt.complete;SeqParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[B]">resultEmpty</a>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[(A, B)]" id="sbt.complete;SeqParser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;SeqParser.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.complete.Parser[(A, B)]" id="sbt.complete;SeqParser.derive.common">common</a> = <a href="#sbt.complete;SeqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[A]">derive</a><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]" class="delimiter">(</a><a href="#sbt.complete;SeqParser.derive.c" title="Char">c</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.~" title="(next: sbt.complete.Parser[B])sbt.complete.Parser[(A, B)]">~</a> <a href="#sbt.complete;SeqParser.b" title="sbt.complete.Parser[B]">b</a>
      <a href="#sbt.complete;SeqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <span title="sbt.complete.Parser[(A, B)]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Value<span class="delimiter">(</span><a title="A" id="sbt.complete;SeqParser.derive.av">av</a><span class="delimiter">)</span>  =&gt; <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(A, B)])sbt.complete.RichParser[(A, B)]">common</a> <a href="#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[(A, B)])sbt.complete.Parser[(A, B)]">|</a> <a href="#sbt.complete;SeqParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[B]">derive</a><a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[B])sbt.complete.RichParser[B]" class="delimiter">(</a><a href="#sbt.complete;SeqParser.derive.c" title="Char">c</a><span class="delimiter">)</span>.<a href="#sbt.complete;RichParser.map" title="(f: B =&gt; (A, B))sbt.complete.Parser[(A, B)]">map</a><span class="delimiter">(</span><a title="B" id="sbt.complete;SeqParser.derive.$anonfun.br">br</a> =&gt; <span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><a href="#sbt.complete;SeqParser.derive.av" title="A">av</a>, <a href="#sbt.complete;SeqParser.derive.$anonfun.br" title="B">br</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="#sbt.complete;SeqParser.derive.common" title="sbt.complete.Parser[(A, B)]">common</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;SeqParser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;SeqParser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;SeqParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;SeqParser.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.x" title="(o: sbt.complete.Completions)sbt.complete.Completions">x</a> <a href="#sbt.complete;SeqParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;SeqParser.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;SeqParser.toString">toString</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;SeqParser.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; ~ &quot;)" class="string">&quot; ~ &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;SeqParser.b" title="sbt.complete.Parser[B]">b</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>

<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class HomParser[A] extends AnyRef with sbt.complete.ValidParser[A]" id="sbt.complete;HomParser">HomParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;HomParser;A">A</a><span class="delimiter">]</span><a href="#sbt.complete;HomParser" title="sbt.complete.HomParser[A]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;HomParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[A]" id="sbt.complete;HomParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[A]">ValidParser</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[A]" id="sbt.complete;HomParser.result">result</a> = <a href="#sbt.complete.Parser.tuple" title="(a: Option[A], b: Option[A])Option[(A, A)]">tuple</a><span class="delimiter">(</span><a href="#sbt.complete;HomParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a>, <a href="#sbt.complete;HomParser.b" title="sbt.complete.Parser[A]">b</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a><span class="delimiter">)</span> <span title="(f: ((A, A)) =&gt; A)Option[A]">map</span> <span class="delimiter">(</span><a href="#sbt.complete;HomParser.result.$anonfun.x$23" title="(A, A)">_</a>.<span title="=&gt; A">_1</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[A]" id="sbt.complete;HomParser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;HomParser.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.complete;HomParser.a" title="sbt.complete.Parser[A]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">derive</a> <a href="#sbt.complete;HomParser.derive.c" title="Char">c</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[A])sbt.complete.Parser[A]">|</a> <span class="delimiter">(</span><a href="#sbt.complete;HomParser.b" title="sbt.complete.Parser[A]">b</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[A]">derive</a> <a href="#sbt.complete;HomParser.derive.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[A]" id="sbt.complete;HomParser.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;HomParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <a href="#sbt.complete.Parser;Result.or" title="(b: =&gt; sbt.complete.Parser.Result[A])sbt.complete.Parser.Result[A]">or</a> <a href="#sbt.complete;HomParser.b" title="sbt.complete.Parser[A]">b</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;HomParser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;HomParser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;HomParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;HomParser.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.++" title="(o: sbt.complete.Completions)sbt.complete.Completions">++</a> <a href="#sbt.complete;HomParser.b" title="sbt.complete.Parser[A]">b</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;HomParser.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;HomParser.toString">toString</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;HomParser.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;HomParser.b" title="sbt.complete.Parser[A]">b</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class HetParser[A, B] extends AnyRef with sbt.complete.ValidParser[Either[A,B]]" id="sbt.complete;HetParser">HetParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;HetParser;A">A</a>, <a title="" id="sbt.complete;HetParser;B">B</a><span class="delimiter">]</span><a href="#sbt.complete;HetParser" title="sbt.complete.HetParser[A,B]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;HetParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[B]" id="sbt.complete;HetParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[B]">Parser</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Either[A,B]]">ValidParser</a><span class="delimiter">[</span>Either<span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[scala.util.Left[A,Nothing]]" id="sbt.complete;HetParser.result">result</a> = <a href="#sbt.complete.Parser.tuple" title="(a: Option[A], b: Option[B])Option[(A, B)]">tuple</a><span class="delimiter">(</span><a href="#sbt.complete;HetParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a>, <a href="#sbt.complete;HetParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[B]">result</a><span class="delimiter">)</span> <span title="(f: ((A, B)) =&gt; scala.util.Left[A,Nothing])Option[scala.util.Left[A,Nothing]]">map</span> <a href="#sbt.complete;HetParser.result.$anonfun.x0$4" title="scala.util.Left[A,Nothing]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="A" id="sbt.complete;HetParser.result.$anonfun.a">a</a>, <a title="B" id="sbt.complete;HetParser.result.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <span title="(a: A)scala.util.Left[A,Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt.complete;HetParser.result.$anonfun.a" title="A">a</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Either[A,B]]" id="sbt.complete;HetParser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;HetParser.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.complete;HetParser.a" title="sbt.complete.Parser[A]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">derive</a> <a href="#sbt.complete;HetParser.derive.c" title="Char">c</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.||" title="(b: sbt.complete.Parser[B])sbt.complete.Parser[Either[A,B]]">||</a> <span class="delimiter">(</span><a href="#sbt.complete;HetParser.b" title="sbt.complete.Parser[B]">b</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[B]">derive</a> <a href="#sbt.complete;HetParser.derive.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[Either[A,B]]" id="sbt.complete;HetParser.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;HetParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <a href="#sbt.complete.Parser;Result.either" title="(b: =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[Either[A,B]]">either</a> <a href="#sbt.complete;HetParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[B]">resultEmpty</a>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;HetParser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;HetParser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;HetParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;HetParser.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.++" title="(o: sbt.complete.Completions)sbt.complete.Completions">++</a> <a href="#sbt.complete;HetParser.b" title="sbt.complete.Parser[B]">b</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;HetParser.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;HetParser.toString">toString</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;HetParser.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; || &quot;)" class="string">&quot; || &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;HetParser.b" title="sbt.complete.Parser[B]">b</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class CombiningParser[T] extends AnyRef with sbt.complete.ValidParser[Seq[T]]" id="sbt.complete;CombiningParser">CombiningParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;CombiningParser;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;CombiningParser" title="sbt.complete.CombiningParser[T]" class="delimiter">(</a><a title="sbt.complete.Parser[T]" id="sbt.complete;CombiningParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.Parser[T]" id="sbt.complete;CombiningParser.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Seq[T]]">ValidParser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[Seq[T]]" id="sbt.complete;CombiningParser.result">result</a>: <span title="Option[Seq[T]]">Option</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.result" title="(xo: Option[T])Iterable[T]">result</a>.<span title="=&gt; Seq[T]">toSeq</span> <span title="(that: scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">++</span> <a href="#sbt.complete;CombiningParser.b" title="sbt.complete.Parser[T]">b</a>.<a href="#sbt.complete;Parser.result" title="(xo: Option[T])Iterable[T]">result</a>.<span title="=&gt; Seq[T]">toSeq</span><span class="delimiter">)</span> <span title="Option[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a href="#sbt.complete;CombiningParser.result.<unapply-selector>" title="(x: Seq[T])Some[Seq[T]]">Seq</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="None.type">None</span>; <span class="keyword">case</span> <a title="Seq[T]" id="sbt.complete;CombiningParser.result.seq">seq</a> =&gt; <span title="(x: Seq[T])Some[Seq[T]]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.result.seq" title="Seq[T]">seq</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;CombiningParser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;CombiningParser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;CombiningParser.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.++" title="(o: sbt.complete.Completions)sbt.complete.Completions">++</a> <a href="#sbt.complete;CombiningParser.b" title="sbt.complete.Parser[T]">b</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(i: Char)sbt.complete.Parser[Seq[T]]" id="sbt.complete;CombiningParser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;CombiningParser.derive.i">i</a>: <span title="Char">Char</span><span class="delimiter">)</span> =
    <span title="(_1: Boolean, _2: Boolean)(Boolean, Boolean)" class="delimiter">(</span><a href="#sbt.complete;CombiningParser.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a>, <a href="#sbt.complete;CombiningParser.b" title="sbt.complete.Parser[T]">b</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>   =&gt; <span title="sbt.complete.CombiningParser[T]" class="keyword">new</span> <a href="#sbt.complete;CombiningParser" title="sbt.complete.CombiningParser[T]">CombiningParser</a><span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.a" title="sbt.complete.Parser[T]">a</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;CombiningParser.derive.i" title="Char">i</a>, <a href="#sbt.complete;CombiningParser.b" title="sbt.complete.Parser[T]">b</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;CombiningParser.derive.i" title="Char">i</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>  =&gt; <a href="#sbt.complete;CombiningParser.a" title="sbt.complete.Parser[T]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">derive</a> <a href="#sbt.complete;CombiningParser.derive.i" title="Char">i</a> <a href="#sbt.complete;RichParser.map" title="(f: T =&gt; Seq[T])sbt.complete.Parser[Seq[T]]">map</a> <span class="delimiter">(</span><span title="(elems: T*)Seq[T]">Seq</span><span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.derive.$anonfun.x$24" title="T">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>  =&gt; <a href="#sbt.complete;CombiningParser.b" title="sbt.complete.Parser[T]">b</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">derive</a> <a href="#sbt.complete;CombiningParser.derive.i" title="Char">i</a> <a href="#sbt.complete;RichParser.map" title="(f: T =&gt; Seq[T])sbt.complete.Parser[Seq[T]]">map</a> <span class="delimiter">(</span><span title="(elems: T*)Seq[T]">Seq</span><span class="delimiter">(</span><a href="#sbt.complete;CombiningParser.derive.$anonfun.x$25" title="T">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> =&gt; <span title="sbt.complete.Invalid" class="keyword">new</span> <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><span title="String(&quot;No valid parser available.&quot;)" class="string">&quot;No valid parser available.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[Seq[T]]" id="sbt.complete;CombiningParser.resultEmpty">resultEmpty</a> =
    <span title="(_1: sbt.complete.Parser.Result[T], _2: sbt.complete.Parser.Result[T])(sbt.complete.Parser.Result[T], sbt.complete.Parser.Result[T])" class="delimiter">(</span><a href="#sbt.complete;CombiningParser.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>, <a href="#sbt.complete;CombiningParser.b" title="sbt.complete.Parser[T]">b</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a><span class="delimiter">)</span> <span title="sbt.complete.Parser.Result[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>Value<span class="delimiter">(</span><span title="T">ra</span><span class="delimiter">)</span>, Value<span class="delimiter">(</span><span title="T">rb</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: Seq[T])sbt.complete.Parser.Value[Seq[T]]">Value</a><span class="delimiter">(</span><span title="(elems: T*)Seq[T]">Seq</span><span class="delimiter">(</span><span title="T">ra</span>, <span title="T">rb</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>Value<span class="delimiter">(</span><span title="T">ra</span><span class="delimiter">)</span>, _<span class="delimiter">)</span>         =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: Seq[T])sbt.complete.Parser.Value[Seq[T]]">Value</a><span class="delimiter">(</span><span title="(elems: T*)Seq[T]">Seq</span><span class="delimiter">(</span><span title="T">ra</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>_, Value<span class="delimiter">(</span><span title="T">rb</span><span class="delimiter">)</span><span class="delimiter">)</span>         =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: Seq[T])sbt.complete.Parser.Value[Seq[T]]">Value</a><span class="delimiter">(</span><span title="(elems: T*)Seq[T]">Seq</span><span class="delimiter">(</span><span title="T">rb</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _                      =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: scala.collection.immutable.Nil.type)sbt.complete.Parser.Value[scala.collection.immutable.Nil.type]">Value</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ParserSeq[T] extends AnyRef with sbt.complete.ValidParser[Seq[T]]" id="sbt.complete;ParserSeq">ParserSeq</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserSeq;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;ParserSeq" title="sbt.complete.ParserSeq[T]" class="delimiter">(</a><a title="Seq[sbt.complete.Parser[T]]" id="sbt.complete;ParserSeq.a">a</a>: <span title="Seq[sbt.complete.Parser[T]]">Seq</span><span class="delimiter">[</span>Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="=&gt; Seq[String]" id="sbt.complete;ParserSeq.errors">errors</a>: =&gt; Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Seq[T]]">ValidParser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[Seq[T]]" id="sbt.complete;ParserSeq.resultEmpty">resultEmpty</a>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[Seq[T]]">Result</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Seq[sbt.complete.Parser.Result[T]]" id="sbt.complete;ParserSeq.resultEmpty.res">res</a> = <a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a>.<span title="(f: sbt.complete.Parser[T] =&gt; sbt.complete.Parser.Result[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.complete.Parser[T]],sbt.complete.Parser.Result[T],Seq[sbt.complete.Parser.Result[T]]])Seq[sbt.complete.Parser.Result[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.complete.Parser.Result[T],Seq[sbt.complete.Parser.Result[T]]]" class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.res.$anonfun.x$26" title="sbt.complete.Parser[T]">_</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a href="#sbt.complete;ParserSeq.resultEmpty.failures" title="(Seq[() =&gt; Seq[String]], Seq[T])" class="delimiter">(</a><a href="#sbt.complete;ParserSeq.resultEmpty.x$28" title="Seq[() =&gt; Seq[String]]" id="sbt.complete;ParserSeq.resultEmpty.failures">failures</a>, <a href="#sbt.complete;ParserSeq.resultEmpty.x$28" title="Seq[T]" id="sbt.complete;ParserSeq.resultEmpty.values">values</a><span class="delimiter">)</span> = <a href="../Util.scala.html#sbt.Util.separate" title="(ps: Seq[sbt.complete.Parser.Result[T]])(f: sbt.complete.Parser.Result[T] =&gt; Either[() =&gt; Seq[String],T])(Seq[() =&gt; Seq[String]], Seq[T])">separate</a><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.res" title="Seq[sbt.complete.Parser.Result[T]]">res</a><span class="delimiter">)</span><span title="(Seq[() =&gt; Seq[String]], Seq[T]) @unchecked" class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.x$28.$anonfun.x$27" title="sbt.complete.Parser.Result[T]">_</a>.<a href="#sbt.complete.Parser;Result.toEither" title="=&gt; Either[() =&gt; Seq[String],T]">toEither</a><span class="delimiter">)</span>
      <span class="comment">//		if(failures.isEmpty) Value(values) else mkFailures(failures.flatMap(_()) ++ errors)</span>
      <span title="sbt.complete.Parser.Result[Seq[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.values" title="Seq[T]">values</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#sbt.complete.Parser.Value.readResolve" title="(value: Seq[T])sbt.complete.Parser.Value[Seq[T]]">Value</a><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.values" title="Seq[T]">values</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete.Parser.mkFailures" title="(errors: =&gt; Seq[String], definitive: Boolean)sbt.complete.Parser.Failure">mkFailures</a><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.failures" title="Seq[() =&gt; Seq[String]]">failures</a>.<span title="(f: (() =&gt; Seq[String]) =&gt; scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[() =&gt; Seq[String]],String,Seq[String]])Seq[String]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#sbt.complete;ParserSeq.resultEmpty.$anonfun.x$29" title="()Seq[String]">_</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],String,Seq[String]])Seq[String]">++</span> <a href="#sbt.complete;ParserSeq.errors" title="=&gt; Seq[String]">errors</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; Option[Seq[T]]" id="sbt.complete;ParserSeq.result">result</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[T]" id="sbt.complete;ParserSeq.result.success">success</a> = <a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a>.<span title="(f: sbt.complete.Parser[T] =&gt; scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.complete.Parser[T]],T,Seq[T]])Seq[T]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,T,Seq[T]]" class="delimiter">(</span><a href="#sbt.complete;ParserSeq.result.success.$anonfun.x$30" title="sbt.complete.Parser[T]">_</a>.<a href="#sbt.complete;Parser.result" title="(xo: Option[T])Iterable[T]">result</a><span class="delimiter">)</span>
    <span title="Option[Seq[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.result.success" title="Seq[T]">success</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">==</span> <a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <span title="(x: Seq[T])Some[Seq[T]]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.result.success" title="Seq[T]">success</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="None.type">None</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;ParserSeq.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;ParserSeq.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a>.<span title="(f: sbt.complete.Parser[T] =&gt; sbt.complete.Completions)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.complete.Parser[T]],sbt.complete.Completions,Seq[sbt.complete.Completions]])Seq[sbt.complete.Completions]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.complete.Completions,Seq[sbt.complete.Completions]]" class="delimiter">(</span><a href="#sbt.complete;ParserSeq.completions.$anonfun.x$31" title="sbt.complete.Parser[T]">_</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.completions.level" title="Int">level</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(op: (sbt.complete.Completions, sbt.complete.Completions) =&gt; sbt.complete.Completions)sbt.complete.Completions">reduceLeft</span><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.completions.$anonfun.x$32" title="sbt.complete.Completions">_</a> <a href="Completions.scala.html#sbt.complete;Completions.++" title="(o: sbt.complete.Completions)sbt.complete.Completions">++</a> <a href="#sbt.complete;ParserSeq.completions.$anonfun.x$33" title="sbt.complete.Completions">_</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Seq[T]]" id="sbt.complete;ParserSeq.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;ParserSeq.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete;ParserMain.seq0" title="(p: Seq[sbt.complete.Parser[T]], errors: =&gt; Seq[String])sbt.complete.Parser[Seq[T]]">seq0</a><span class="delimiter">(</span><a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a>.<span title="(f: sbt.complete.Parser[T] =&gt; sbt.complete.Parser[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[sbt.complete.Parser[T]],sbt.complete.Parser[T],Seq[sbt.complete.Parser[T]]])Seq[sbt.complete.Parser[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,sbt.complete.Parser[T],Seq[sbt.complete.Parser[T]]]" class="delimiter">(</span><a href="#sbt.complete;ParserSeq.derive.$anonfun.x$34" title="sbt.complete.Parser[T]">_</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;ParserSeq.derive.c" title="Char">c</a><span class="delimiter">)</span>, <a href="#sbt.complete;ParserSeq.errors" title="=&gt; Seq[String]">errors</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;ParserSeq.toString">toString</a> = <span title="String(&quot;seq(&quot;)" class="string">&quot;seq(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;ParserSeq.a" title="Seq[sbt.complete.Parser[T]]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>

<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class BindParser[A, B] extends AnyRef with sbt.complete.ValidParser[B]" id="sbt.complete;BindParser">BindParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;BindParser;A">A</a>, <a title="" id="sbt.complete;BindParser;B">B</a><span class="delimiter">]</span><a href="#sbt.complete;BindParser" title="sbt.complete.BindParser[A,B]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;BindParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; sbt.complete.Parser[B]" id="sbt.complete;BindParser.f">f</a>: A =&gt; Parser<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[B]">ValidParser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[B]" id="sbt.complete;BindParser.result">result</a> = <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a> <span title="(f: A =&gt; Option[B])Option[B]">flatMap</span> <span class="delimiter">{</span> <a title="A" id="sbt.complete;BindParser.result.$anonfun.av">av</a> =&gt; <a href="#sbt.complete;BindParser.f" title="(v1: A)sbt.complete.Parser[B]">f</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.result.$anonfun.av" title="A">av</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[B]">result</a> <span class="delimiter">}</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[B]" id="sbt.complete;BindParser.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <a href="#sbt.complete.Parser;Result.flatMap" title="(f: A =&gt; sbt.complete.Parser.Result[B])sbt.complete.Parser.Result[B]">flatMap</a> <span class="delimiter">{</span> <a title="A" id="sbt.complete;BindParser.resultEmpty.$anonfun.av">av</a> =&gt; <a href="#sbt.complete;BindParser.f" title="(v1: A)sbt.complete.Parser[B]">f</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.resultEmpty.$anonfun.av" title="A">av</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[B]">resultEmpty</a> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;BindParser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;BindParser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.flatMap" title="(f: sbt.complete.Completion =&gt; sbt.complete.Completions)sbt.complete.Completions">flatMap</a> <span class="delimiter">{</span> <a title="sbt.complete.Completion" id="sbt.complete;BindParser.completions.$anonfun.c">c</a> =&gt;
      <a href="#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[A])(s: String)sbt.complete.Parser[A]">apply</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;BindParser.completions.$anonfun.c" title="sbt.complete.Completion">c</a>.<a href="Completions.scala.html#sbt.complete;Completion.append" title="=&gt; String">append</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <span title="sbt.complete.Completions" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> _: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.strict" title="(cs: Set[sbt.complete.Completion])sbt.complete.Completions">strict</a><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[sbt.complete.Completion]">empty</span> <span title="(elem: sbt.complete.Completion)scala.collection.immutable.Set[sbt.complete.Completion]">+</span> <a href="#sbt.complete;BindParser.completions.$anonfun.c" title="sbt.complete.Completion">c</a><span class="delimiter">)</span>
        <span class="keyword">case</span> Value<span class="delimiter">(</span><a title="A" id="sbt.complete;BindParser.completions.$anonfun.av">av</a><span class="delimiter">)</span>  =&gt; <a href="#sbt.complete;BindParser.completions.$anonfun.c" title="sbt.complete.Completion">c</a> <a href="Completions.scala.html#sbt.complete;Completion.x" title="(o: sbt.complete.Completions)sbt.complete.Completions">x</a> <a href="#sbt.complete;BindParser.f" title="(v1: A)sbt.complete.Parser[B]">f</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.completions.$anonfun.av" title="A">av</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.completions.level" title="Int">level</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[B]" id="sbt.complete;BindParser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;BindParser.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.complete.Parser[B]" id="sbt.complete;BindParser.derive.common">common</a> = <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">derive</a> <a href="#sbt.complete;BindParser.derive.c" title="Char">c</a> <a href="#sbt.complete;RichParser.flatMap" title="(f: A =&gt; sbt.complete.Parser[B])sbt.complete.Parser[B]">flatMap</a> <a href="#sbt.complete;BindParser.f" title="A =&gt; sbt.complete.Parser[B]">f</a>
      <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <span title="sbt.complete.Parser[B]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Value<span class="delimiter">(</span><a title="A" id="sbt.complete;BindParser.derive.av">av</a><span class="delimiter">)</span>  =&gt; <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[B])sbt.complete.RichParser[B]">common</a> <a href="#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[B])sbt.complete.Parser[B]">|</a> <a href="#sbt.complete;ParserMain.derive1" title="(p: sbt.complete.Parser[B], c: Char)sbt.complete.Parser[B]">derive1</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.f" title="(v1: A)sbt.complete.Parser[B]">f</a><span class="delimiter">(</span><a href="#sbt.complete;BindParser.derive.av" title="A">av</a><span class="delimiter">)</span>, <a href="#sbt.complete;BindParser.derive.c" title="Char">c</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="#sbt.complete;BindParser.derive.common" title="sbt.complete.Parser[B]">common</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;BindParser.isTokenStart">isTokenStart</a> = <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;BindParser.toString">toString</a> = <span title="String(&quot;bind(&quot;)" class="string">&quot;bind(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;BindParser.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class MapParser[A, B] extends AnyRef with sbt.complete.ValidParser[B]" id="sbt.complete;MapParser">MapParser</a><span class="delimiter">[</span><a title="" id="sbt.complete;MapParser;A">A</a>, <a title="" id="sbt.complete;MapParser;B">B</a><span class="delimiter">]</span><a href="#sbt.complete;MapParser" title="sbt.complete.MapParser[A,B]" class="delimiter">(</a><a title="sbt.complete.Parser[A]" id="sbt.complete;MapParser.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[A]">Parser</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; B" id="sbt.complete;MapParser.f">f</a>: A =&gt; B<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[B]">ValidParser</a><span class="delimiter">[</span>B<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[B]" id="sbt.complete;MapParser.result">result</a> = <a href="#sbt.complete;MapParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[A]">result</a> <span title="(f: A =&gt; B)Option[B]">map</span> <a href="#sbt.complete;MapParser.f" title="A =&gt; B">f</a>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[B]" id="sbt.complete;MapParser.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;MapParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[A]">resultEmpty</a> <a href="#sbt.complete.Parser;Result.map" title="(f: A =&gt; B)sbt.complete.Parser.Result[B]">map</a> <a href="#sbt.complete;MapParser.f" title="A =&gt; B">f</a>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[B]" id="sbt.complete;MapParser.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;MapParser.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.complete;MapParser.a" title="sbt.complete.Parser[A]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">derive</a> <a href="#sbt.complete;MapParser.derive.c" title="Char">c</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.map" title="(f: A =&gt; B)sbt.complete.Parser[B]">map</a> <a href="#sbt.complete;MapParser.f" title="A =&gt; B">f</a>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;MapParser.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;MapParser.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;MapParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;MapParser.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;MapParser.isTokenStart">isTokenStart</a> = <a href="#sbt.complete;MapParser.a" title="sbt.complete.Parser[A]">a</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;MapParser.toString">toString</a> = <span title="String(&quot;map(&quot;)" class="string">&quot;map(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;MapParser.a" title="sbt.complete.Parser[A]">a</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Filter[T] extends AnyRef with sbt.complete.ValidParser[T]" id="sbt.complete;Filter">Filter</a><span class="delimiter">[</span><a title="" id="sbt.complete;Filter;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;Filter" title="sbt.complete.Filter[T]" class="delimiter">(</a><a title="sbt.complete.Parser[T]" id="sbt.complete;Filter.p">p</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T =&gt; Boolean" id="sbt.complete;Filter.f">f</a>: T =&gt; Boolean, <a title="String" id="sbt.complete;Filter.seen">seen</a>: <span title="String">String</span>, <a title="String =&gt; String" id="sbt.complete;Filter.msg">msg</a>: String =&gt; String<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[T]">ValidParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(r: sbt.complete.Parser.Result[T])sbt.complete.Parser.Result[T]" id="sbt.complete;Filter.filterResult">filterResult</a><span class="delimiter">(</span><a title="sbt.complete.Parser.Result[T]" id="sbt.complete;Filter.filterResult.r">r</a>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[T]">Result</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt.complete;Filter.filterResult.r" title="sbt.complete.Parser.Result[T]">r</a>.<a href="#sbt.complete.Parser;Result.filter" title="(f: T =&gt; Boolean, msg: =&gt; String)sbt.complete.Parser.Result[T]">filter</a><span class="delimiter">(</span><a href="#sbt.complete;Filter.f" title="T =&gt; Boolean">f</a>, <a href="#sbt.complete;Filter.msg" title="(v1: String)String">msg</a><span class="delimiter">(</span><a href="#sbt.complete;Filter.seen" title="String">seen</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[T]" id="sbt.complete;Filter.result">result</a> = <a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a> <span title="(p: T =&gt; Boolean)Option[T]">filter</span> <a href="#sbt.complete;Filter.f" title="T =&gt; Boolean">f</a>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[T]" id="sbt.complete;Filter.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;Filter.filterResult" title="(r: sbt.complete.Parser.Result[T])sbt.complete.Parser.Result[T]">filterResult</a><span class="delimiter">(</span><a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[T]" id="sbt.complete;Filter.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Filter.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete.Parser.filterParser" title="(a: sbt.complete.Parser[T], f: T =&gt; Boolean, seen: String, msg: String =&gt; String)sbt.complete.Parser[T]">filterParser</a><span class="delimiter">(</span><a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;Filter.derive.c" title="Char">c</a>, <a href="#sbt.complete;Filter.f" title="T =&gt; Boolean">f</a>, <a href="#sbt.complete;Filter.seen" title="String">seen</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Filter.derive.c" title="Char">c</a>, <a href="#sbt.complete;Filter.msg" title="String =&gt; String">msg</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;Filter.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Filter.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;Filter.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.filterS" title="(f: String =&gt; Boolean)sbt.complete.Completions">filterS</a> <span class="delimiter">{</span> <a title="String" id="sbt.complete;Filter.completions.$anonfun.s">s</a> =&gt; <a href="#sbt.complete;Filter.filterResult" title="(r: sbt.complete.Parser.Result[T])sbt.complete.Parser.Result[T]">filterResult</a><span class="delimiter">(</span><a href="#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[T])(s: String)sbt.complete.Parser[T]">apply</a><span class="delimiter">(</span><a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;Filter.completions.$anonfun.s" title="String">s</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a><span class="delimiter">)</span>.<a href="#sbt.complete.Parser;Result.isValid" title="=&gt; Boolean">isValid</a> <span class="delimiter">}</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;Filter.toString">toString</a> = <span title="String(&quot;filter(&quot;)" class="string">&quot;filter(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;Filter.isTokenStart">isTokenStart</a> = <a href="#sbt.complete;Filter.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class MatchedString extends AnyRef with sbt.complete.ValidParser[String]" id="sbt.complete;MatchedString">MatchedString</a><a href="#sbt.complete;MatchedString" title="sbt.complete.MatchedString" class="delimiter">(</a><a title="sbt.complete.Parser[_]" id="sbt.complete;MatchedString.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Vector[Char]" id="sbt.complete;MatchedString.seenV">seenV</a>: <span title="Vector[Char]">Vector</span><span class="delimiter">[</span>Char<span class="delimiter">]</span>, <a title="Boolean" id="sbt.complete;MatchedString.partial">partial</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[String]">ValidParser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="String" id="sbt.complete;MatchedString.seen">seen</a> = <a href="#sbt.complete;MatchedString.seenV" title="Vector[Char]">seenV</a>.<span title="=&gt; String">mkString</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[String]" id="sbt.complete;MatchedString.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;MatchedString.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete;ParserMain.matched" title="(t: sbt.complete.Parser[_], seen: Vector[Char], partial: Boolean)sbt.complete.Parser[String]">matched</a><span class="delimiter">(</span><a href="#sbt.complete;MatchedString.delegate" title="sbt.complete.Parser[_]">delegate</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[_$18]">derive</a> <a href="#sbt.complete;MatchedString.derive.c" title="Char">c</a>, <a href="#sbt.complete;MatchedString.seenV" title="Vector[Char]">seenV</a> <span title="(elem: Char)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Char],Char,Vector[Char]])Vector[Char]">:+</span> <a href="#sbt.complete;MatchedString.derive.c" title="Char">c</a>, <a href="#sbt.complete;MatchedString.partial" title="Boolean">partial</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;MatchedString.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;MatchedString.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;MatchedString.delegate" title="sbt.complete.Parser[_]">delegate</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;MatchedString.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; Option[String]" id="sbt.complete;MatchedString.result">result</a> = <span title="Option[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;MatchedString.delegate" title="sbt.complete.Parser[_]">delegate</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[_$18]">result</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;MatchedString.seen" title="=&gt; String">seen</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="None.type">None</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[String]" id="sbt.complete;MatchedString.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;MatchedString.delegate" title="sbt.complete.Parser[_]">delegate</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[_$18]">resultEmpty</a> <span title="sbt.complete.Parser.Result[String]" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete;MatchedString.resultEmpty.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#sbt.complete;MatchedString.partial" title="Boolean">partial</a> =&gt; <a href="#sbt.complete;MatchedString.resultEmpty.f" title="sbt.complete.Parser.Failure">f</a>; <span class="keyword">case</span> _ =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: String)sbt.complete.Parser.Value[String]">Value</a><span class="delimiter">(</span><a href="#sbt.complete;MatchedString.seen" title="=&gt; String">seen</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;MatchedString.isTokenStart">isTokenStart</a> = <a href="#sbt.complete;MatchedString.delegate" title="sbt.complete.Parser[_]">delegate</a>.<a href="#sbt.complete;Parser.isTokenStart" title="=&gt; Boolean">isTokenStart</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;MatchedString.toString">toString</a> = <span title="String(&quot;matched(&quot;)" class="string">&quot;matched(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;MatchedString.partial" title="Boolean">partial</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;MatchedString.seen" title="=&gt; String">seen</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;MatchedString.delegate" title="sbt.complete.Parser[_]">delegate</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TokenStart[T] extends AnyRef with sbt.complete.ValidParser[T]" id="sbt.complete;TokenStart">TokenStart</a><span class="delimiter">[</span><a title="" id="sbt.complete;TokenStart;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;TokenStart" title="sbt.complete.TokenStart[T]" class="delimiter">(</a><a title="sbt.complete.Parser[T]" id="sbt.complete;TokenStart.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="String" id="sbt.complete;TokenStart.seen">seen</a>: <span title="String">String</span>, <a title="sbt.complete.TokenCompletions" id="sbt.complete;TokenStart.complete">complete</a>: <a href="TokenCompletions.scala.html#sbt.complete;TokenCompletions" title="sbt.complete.TokenCompletions">TokenCompletions</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[T]">ValidParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[T]" id="sbt.complete;TokenStart.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;TokenStart.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete;ParserMain.mkToken" title="(t: sbt.complete.Parser[T], seen: String, complete: sbt.complete.TokenCompletions)sbt.complete.Parser[T]">mkToken</a><span class="delimiter">(</span><a href="#sbt.complete;TokenStart.delegate" title="sbt.complete.Parser[T]">delegate</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;TokenStart.derive.c" title="Char">c</a>, <a href="#sbt.complete;TokenStart.seen" title="String">seen</a> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;TokenStart.derive.c" title="Char">c</a>, <a href="#sbt.complete;TokenStart.complete" title="sbt.complete.TokenCompletions">complete</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;TokenStart.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;TokenStart.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;TokenStart.complete" title="sbt.complete.TokenCompletions">complete</a> <span title="sbt.complete.Completions" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a title="sbt.complete.TokenCompletions.Delegating" id="sbt.complete;TokenStart.completions.dc">dc</a>: TokenCompletions.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions;Delegating" title="sbt.complete.TokenCompletions.Delegating">Delegating</a> =&gt; <a href="#sbt.complete;TokenStart.completions.dc" title="sbt.complete.TokenCompletions.Delegating">dc</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions;Delegating.completions" title="(seen: String, level: Int, delegate: sbt.complete.Completions)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;TokenStart.seen" title="String">seen</a>, <a href="#sbt.complete;TokenStart.completions.level" title="Int">level</a>, <a href="#sbt.complete;TokenStart.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;TokenStart.completions.level" title="Int">level</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.complete.TokenCompletions.Fixed" id="sbt.complete;TokenStart.completions.fc">fc</a>: TokenCompletions.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions;Fixed" title="sbt.complete.TokenCompletions.Fixed">Fixed</a>      =&gt; <a href="#sbt.complete;TokenStart.completions.fc" title="sbt.complete.TokenCompletions.Fixed">fc</a>.<a href="TokenCompletions.scala.html#sbt.complete.TokenCompletions;Fixed.completions" title="(seen: String, level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;TokenStart.seen" title="String">seen</a>, <a href="#sbt.complete;TokenStart.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; Option[T]" id="sbt.complete;TokenStart.result">result</a> = <a href="#sbt.complete;TokenStart.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[T]" id="sbt.complete;TokenStart.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;TokenStart.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="sbt.complete;TokenStart.isTokenStart">isTokenStart</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;TokenStart.toString">toString</a> = <span title="String(&quot;token(\'&quot;)" class="string">&quot;token('&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;TokenStart.complete" title="sbt.complete.TokenCompletions">complete</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;TokenStart.delegate" title="sbt.complete.Parser[T]">delegate</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class And[T] extends AnyRef with sbt.complete.ValidParser[T]" id="sbt.complete;And">And</a><span class="delimiter">[</span><a title="" id="sbt.complete;And;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;And" title="sbt.complete.And[T]" class="delimiter">(</a><a title="sbt.complete.Parser[T]" id="sbt.complete;And.a">a</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete;And.b">b</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[T]">ValidParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[T]" id="sbt.complete;And.result">result</a> = <a href="#sbt.complete.Parser.tuple" title="(a: Option[T], b: Option[_$19])Option[(T, _$19)]">tuple</a><span class="delimiter">(</span><a href="#sbt.complete;And.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a>, <a href="#sbt.complete;And.b" title="sbt.complete.Parser[_]">b</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[_$19]">result</a><span class="delimiter">)</span> <span title="(f: ((T, _$19)) =&gt; T)Option[T]">map</span> <span class="delimiter">{</span> <a href="#sbt.complete;And.result.$anonfun.x$35" title="(T, _$19)">_</a>.<span title="=&gt; T">_1</span> <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[T]" id="sbt.complete;And.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;And.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.complete;And.a" title="sbt.complete.Parser[T]">a</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">derive</a> <a href="#sbt.complete;And.derive.c" title="Char">c</a><span class="delimiter">)</span> <a href="#sbt.complete;RichParser.&" title="(o: sbt.complete.Parser[_])sbt.complete.Parser[T]">&amp;</a> <span class="delimiter">(</span><a href="#sbt.complete;And.b" title="sbt.complete.Parser[_]">b</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[_$19]">derive</a> <a href="#sbt.complete;And.derive.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;And.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;And.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;And.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;And.completions.level" title="Int">level</a><span class="delimiter">)</span>.<a href="Completions.scala.html#sbt.complete;Completions.filterS" title="(f: String =&gt; Boolean)sbt.complete.Completions">filterS</a><span class="delimiter">(</span><a title="String" id="sbt.complete;And.completions.$anonfun.s">s</a> =&gt; <a href="#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[_$19])(s: String)sbt.complete.Parser[_$19]">apply</a><span class="delimiter">(</span><a href="#sbt.complete;And.b" title="sbt.complete.Parser[_]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;And.completions.$anonfun.s" title="String">s</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[_$19]">resultEmpty</a>.<a href="#sbt.complete.Parser;Result.isValid" title="=&gt; Boolean">isValid</a><span class="delimiter">)</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[T]" id="sbt.complete;And.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;And.a" title="sbt.complete.Parser[T]">a</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a> <a href="#sbt.complete.Parser;Result.&&" title="(b: =&gt; sbt.complete.Parser.Result[_])sbt.complete.Parser.Result[T]">&amp;&amp;</a> <a href="#sbt.complete;And.b" title="sbt.complete.Parser[_]">b</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[_$19]">resultEmpty</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;And.toString">toString</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;(%s) &amp;&amp; (%s)&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#sbt.complete;And.a" title="sbt.complete.Parser[T]">a</a>, <a href="#sbt.complete;And.b" title="sbt.complete.Parser[_]">b</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Not extends AnyRef with sbt.complete.ValidParser[Unit]" id="sbt.complete;Not">Not</a><a href="#sbt.complete;Not" title="sbt.complete.Not" class="delimiter">(</a><a title="sbt.complete.Parser[_]" id="sbt.complete;Not.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="String" id="sbt.complete;Not.failMessage">failMessage</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Unit]">ValidParser</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Unit]" id="sbt.complete;Not.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Not.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span title="sbt.complete.Parser[Unit]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;Not.delegate" title="sbt.complete.Parser[_]">delegate</a>.<a href="#sbt.complete;Parser.valid" title="=&gt; Boolean">valid</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.not(7e585d5e4e)" title="(p: sbt.complete.Parser[_], failMessage: String)sbt.complete.Parser[Unit]">not</a><span class="delimiter">(</span><a href="#sbt.complete;Not.delegate" title="sbt.complete.Parser[_]">delegate</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[_$20]">derive</a> <a href="#sbt.complete;Not.derive.c" title="Char">c</a>, <a href="#sbt.complete;Not.failMessage" title="String">failMessage</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete;Not" title="sbt.complete.Not" class="keyword">this</a>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;Not.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Not.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.empty" title="=&gt; sbt.complete.Completions">empty</a>
  <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;Not.result">result</a> = <span title="None.type">None</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="&lt;root&gt; extends sbt.complete.Parser.Result[Unit]" id="sbt.complete;Not.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;Not.delegate" title="sbt.complete.Parser[_]">delegate</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[_$20]">resultEmpty</a> <span title="&lt;root&gt; extends sbt.complete.Parser.Result[Unit]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a title="sbt.complete.Parser.Failure" id="sbt.complete;Not.resultEmpty.f">f</a>: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a>  =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: Unit)sbt.complete.Parser.Value[Unit]">Value</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="sbt.complete.Parser.Value[_]" id="sbt.complete;Not.resultEmpty.v">v</a>: <a href="#sbt.complete.Parser.Value.readResolve" title="sbt.complete.Parser.Value[_]">Value</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><a href="#sbt.complete;Not.failMessage" title="String">failMessage</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;Not.toString">toString</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; -(%s)&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#sbt.complete;Not.delegate" title="sbt.complete.Parser[_]">delegate</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * This class wraps an existing parser (the delegate), and replaces the delegate's completions with examples from
 * the given example source.
 *
 * This class asks the example source for a limited amount of examples (to prevent lengthy and expensive
 * computations and large amounts of allocated data). It then passes these examples on to the UI.
 *
 * @param delegate the parser to decorate with completion examples (i.e., completion of user input).
 * @param exampleSource the source from which this class will take examples (potentially filter them with the delegate
 *                      parser), and pass them to the UI.
 * @param maxNumberOfExamples the maximum number of completions to read from the example source and pass to the UI. This
 *                            limit prevents lengthy example generation and allocation of large amounts of memory.
 * @param removeInvalidExamples indicates whether to remove examples that are deemed invalid by the delegate parser.
 * @tparam T the type of value produced by the parser.
 */</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ParserWithExamples[T] extends AnyRef with sbt.complete.ValidParser[T]" id="sbt.complete;ParserWithExamples">ParserWithExamples</a><span class="delimiter">[</span><a title="" id="sbt.complete;ParserWithExamples;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;ParserWithExamples" title="sbt.complete.ParserWithExamples[T]" class="delimiter">(</a><a title="sbt.complete.Parser[T]" id="sbt.complete;ParserWithExamples.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.ExampleSource" id="sbt.complete;ParserWithExamples.exampleSource">exampleSource</a>: <a href="ExampleSource.scala.html#sbt.complete;ExampleSource" title="sbt.complete.ExampleSource">ExampleSource</a>, <a title="Int" id="sbt.complete;ParserWithExamples.maxNumberOfExamples">maxNumberOfExamples</a>: <span title="Int">Int</span>, <a title="Boolean" id="sbt.complete;ParserWithExamples.removeInvalidExamples">removeInvalidExamples</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[T]">ValidParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[T]" id="sbt.complete;ParserWithExamples.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;ParserWithExamples.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> =
    <a href="#sbt.complete;ParserMain.examples(5a4082b96f)" title="(a: sbt.complete.Parser[T], completions: sbt.complete.ExampleSource, maxNumberOfExamples: Int, removeInvalidExamples: Boolean)sbt.complete.Parser[T]">examples</a><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.delegate" title="sbt.complete.Parser[T]">delegate</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;ParserWithExamples.derive.c" title="Char">c</a>, <a href="#sbt.complete;ParserWithExamples.exampleSource" title="sbt.complete.ExampleSource">exampleSource</a>.<a href="ExampleSource.scala.html#sbt.complete;ExampleSource.withAddedPrefix" title="(addedPrefix: String)sbt.complete.ExampleSource">withAddedPrefix</a><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.derive.c" title="Char">c</a>.<span title="()String">toString</span><span class="delimiter">)</span>, <a href="#sbt.complete;ParserWithExamples.maxNumberOfExamples" title="Int">maxNumberOfExamples</a>, <a href="#sbt.complete;ParserWithExamples.removeInvalidExamples" title="Boolean">removeInvalidExamples</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="=&gt; Option[T]" id="sbt.complete;ParserWithExamples.result">result</a> = <a href="#sbt.complete;ParserWithExamples.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a>

  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[T]" id="sbt.complete;ParserWithExamples.resultEmpty">resultEmpty</a> = <a href="#sbt.complete;ParserWithExamples.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>

  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;ParserWithExamples.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;ParserWithExamples.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="sbt.complete.Completions" class="keyword">if</span> <span class="delimiter">(</span><a href="ExampleSource.scala.html#sbt.complete;ExampleSource.apply" title="()Iterable[String]">exampleSource</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
      <span title="sbt.complete.Completions" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>.<a href="#sbt.complete.Parser;Result.isValid" title="=&gt; Boolean">isValid</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.nil" title="=&gt; sbt.complete.Completions">nil</a> <span class="keyword">else</span> <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.empty" title="=&gt; sbt.complete.Completions">empty</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[String]" id="sbt.complete;ParserWithExamples.completions.examplesBasedOnTheResult">examplesBasedOnTheResult</a> = <a href="#sbt.complete;ParserWithExamples.filteredExamples" title="=&gt; Iterable[String]">filteredExamples</a>.<span title="(n: Int)Iterable[String]">take</span><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.maxNumberOfExamples" title="Int">maxNumberOfExamples</a><span class="delimiter">)</span>.<span title="scala.collection.immutable.Set[String]">toSet</span>
      <a href="Completions.scala.html#sbt.complete.Completions.apply" title="(cs: =&gt; Set[sbt.complete.Completion])sbt.complete.Completions">Completions</a><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.completions.examplesBasedOnTheResult" title="scala.collection.immutable.Set[String]">examplesBasedOnTheResult</a>.<span title="(f: String =&gt; sbt.complete.Completion)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[String],sbt.complete.Completion,Set[sbt.complete.Completion]])Set[sbt.complete.Completion]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,sbt.complete.Completion,scala.collection.immutable.Set[sbt.complete.Completion]]" class="delimiter">(</span><a title="String" id="sbt.complete;ParserWithExamples.completions.$anonfun.ex">ex</a> =&gt; <a href="Completions.scala.html#sbt.complete.Completion" title="sbt.complete.Completion.type">Completion</a>.<a href="Completions.scala.html#sbt.complete.Completion.suggestion" title="(value: =&gt; String)sbt.complete.Completion">suggestion</a><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.completions.$anonfun.ex" title="String">ex</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;ParserWithExamples.toString">toString</a> = <span title="String(&quot;examples(&quot;)" class="string">&quot;examples(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;ParserWithExamples.delegate" title="sbt.complete.Parser[T]">delegate</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="ExampleSource.scala.html#sbt.complete;ExampleSource.apply" title="()Iterable[String]">exampleSource</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(n: Int)Iterable[String]">take</span><span class="delimiter">(</span><span title="Int(2)" class="int">2</span><span class="delimiter">)</span>.<span title="=&gt; List[String]">toList</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Iterable[String]" id="sbt.complete;ParserWithExamples.filteredExamples">filteredExamples</a>: <span title="Iterable[String]">Iterable</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="Iterable[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.removeInvalidExamples" title="Boolean">removeInvalidExamples</a><span class="delimiter">)</span>
      <a href="ExampleSource.scala.html#sbt.complete;ExampleSource.apply" title="()Iterable[String]">exampleSource</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Iterable[String]">filter</span><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.isExampleValid" title="(example: String)Boolean">isExampleValid</a><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="ExampleSource.scala.html#sbt.complete;ExampleSource.apply" title="()Iterable[String]">exampleSource</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(example: String)Boolean" id="sbt.complete;ParserWithExamples.isExampleValid">isExampleValid</a><span class="delimiter">(</span><a title="String" id="sbt.complete;ParserWithExamples.isExampleValid.example">example</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[T])(s: String)sbt.complete.Parser[T]">apply</a><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.delegate" title="sbt.complete.Parser[T]">delegate</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;ParserWithExamples.isExampleValid.example" title="String">example</a><span class="delimiter">)</span>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>.<a href="#sbt.complete.Parser;Result.isValid" title="=&gt; Boolean">isValid</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class StringLiteral extends AnyRef with sbt.complete.ValidParser[String]" id="sbt.complete;StringLiteral">StringLiteral</a><a href="#sbt.complete;StringLiteral" title="sbt.complete.StringLiteral" class="delimiter">(</a><a title="String" id="sbt.complete;StringLiteral.str">str</a>: <span title="String">String</span>, <a title="Int" id="sbt.complete;StringLiteral.start">start</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[String]">ValidParser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#sbt.complete;StringLiteral.start" title="Int">start</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.complete;StringLiteral.start" title="Int">start</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#sbt.complete;StringLiteral.str" title="String">str</a>.<span title="()Int">length</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; String" id="sbt.complete;StringLiteral.failMsg">failMsg</a> = <span title="String(&quot;Expected \'&quot;)" class="string">&quot;Expected '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;StringLiteral.str" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Failure" id="sbt.complete;StringLiteral.resultEmpty">resultEmpty</a> = <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.failMsg" title="=&gt; String">failMsg</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;StringLiteral.result">result</a> = <span title="None.type">None</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[String]" id="sbt.complete;StringLiteral.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;StringLiteral.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span title="sbt.complete.Parser[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.str" title="String">str</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.start" title="Int">start</a><span class="delimiter">)</span> <span title="(x: Char)Boolean">==</span> <a href="#sbt.complete;StringLiteral.derive.c" title="Char">c</a><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.stringLiteral" title="(s: String, start: Int)sbt.complete.Parser[String]">stringLiteral</a><span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.str" title="String">str</a>, <a href="#sbt.complete;StringLiteral.start" title="Int">start</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="sbt.complete.Invalid" class="keyword">new</span> <a href="#sbt.complete.Invalid.readResolve" title="sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.resultEmpty" title="=&gt; sbt.complete.Parser.Failure">resultEmpty</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;StringLiteral.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;StringLiteral.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.single" title="(c: sbt.complete.Completion)sbt.complete.Completions">single</a><span class="delimiter">(</span><a href="Completions.scala.html#sbt.complete.Completion" title="sbt.complete.Completion.type">Completion</a>.<a href="Completions.scala.html#sbt.complete.Completion.suggestion" title="(value: =&gt; String)sbt.complete.Completion">suggestion</a><span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.str" title="String">str</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><a href="#sbt.complete;StringLiteral.start" title="Int">start</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;StringLiteral.toString">toString</a> = <span title="Char('\&quot;')" class="char">'&quot;'</span> <span title="(x: String)String">+</span> <a href="#sbt.complete;StringLiteral.str" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="Char('\&quot;')" class="char">'&quot;'</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class CharacterClass extends AnyRef with sbt.complete.ValidParser[Char]" id="sbt.complete;CharacterClass">CharacterClass</a><a href="#sbt.complete;CharacterClass" title="sbt.complete.CharacterClass" class="delimiter">(</a><a title="Char =&gt; Boolean" id="sbt.complete;CharacterClass.f">f</a>: Char =&gt; Boolean, <a title="String" id="sbt.complete;CharacterClass.label">label</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Char]">ValidParser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;CharacterClass.result">result</a> = <span title="None.type">None</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Failure" id="sbt.complete;CharacterClass.resultEmpty">resultEmpty</a> = <a href="#sbt.complete.Parser.mkFailure" title="(error: =&gt; String, definitive: Boolean)sbt.complete.Parser.Failure">mkFailure</a><span class="delimiter">(</span><span title="String(&quot;Expected &quot;)" class="string">&quot;Expected &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;CharacterClass.label" title="String">label</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Char]" id="sbt.complete;CharacterClass.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;CharacterClass.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span title="sbt.complete.Parser[Char]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;CharacterClass.f" title="(v1: Char)Boolean">f</a><span class="delimiter">(</span><a href="#sbt.complete;CharacterClass.derive.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.complete;ParserMain.success" title="(value: Char)sbt.complete.Parser[Char]">success</a><span class="delimiter">(</span><a href="#sbt.complete;CharacterClass.derive.c" title="Char">c</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#sbt.complete.Invalid.readResolve" title="(fail: sbt.complete.Parser.Failure)sbt.complete.Invalid">Invalid</a><span class="delimiter">(</span><a href="#sbt.complete;CharacterClass.resultEmpty" title="=&gt; sbt.complete.Parser.Failure">resultEmpty</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;CharacterClass.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;CharacterClass.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completions" title="sbt.complete.Completions.type">Completions</a>.<a href="Completions.scala.html#sbt.complete.Completions.empty" title="=&gt; sbt.complete.Completions">empty</a>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;CharacterClass.toString">toString</a> = <span title="String(&quot;class(&quot;)" class="string">&quot;class(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;CharacterClass.label" title="String">label</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Optional[T] extends AnyRef with sbt.complete.ValidParser[Option[T]]" id="sbt.complete;Optional">Optional</a><span class="delimiter">[</span><a title="" id="sbt.complete;Optional;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;Optional" title="sbt.complete.Optional[T]" class="delimiter">(</a><a title="sbt.complete.Parser[T]" id="sbt.complete;Optional.delegate">delegate</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Option[T]]">ValidParser</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="=&gt; Option[Some[T]]" id="sbt.complete;Optional.result">result</a> = <a href="#sbt.complete;Optional.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.result" title="=&gt; Option[T]">result</a> <span title="(f: T =&gt; Some[T])Option[Some[T]]">map</span> <a href="../TypeFunctions.scala.html#sbt;TypeFunctions.some" title="=&gt; sbt.~&gt;[sbt.Types.Id,Some]">some</a>.<a href="../TypeFunctions.scala.html#sbt;~>.fn" title="sbt.Types.Id[T] =&gt; Some[T]">fn</a>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Value[None.type]" id="sbt.complete;Optional.resultEmpty">resultEmpty</a> = <a href="#sbt.complete.Parser.Value.readResolve" title="(value: None.type)sbt.complete.Parser.Value[None.type]">Value</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Some[T]]" id="sbt.complete;Optional.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Optional.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#sbt.complete;Optional.delegate" title="sbt.complete.Parser[T]">delegate</a> <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">derive</a> <a href="#sbt.complete;Optional.derive.c" title="Char">c</a><span class="delimiter">)</span>.<a href="#sbt.complete;RichParser.map" title="(f: T =&gt; Some[T])sbt.complete.Parser[Some[T]]">map</a><span class="delimiter">(</span><a href="../TypeFunctions.scala.html#sbt;TypeFunctions.some" title="=&gt; sbt.~&gt;[sbt.Types.Id,Some]">some</a>.<a href="../TypeFunctions.scala.html#sbt;~>.fn" title="sbt.Types.Id[T] =&gt; Some[T]">fn</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;Optional.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Optional.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="Completions.scala.html#sbt.complete.Completion" title="sbt.complete.Completion.type">Completion</a>.<a href="Completions.scala.html#sbt.complete.Completion.empty" title="=&gt; sbt.complete.Completion">empty</a> <a href="Completions.scala.html#sbt.complete;Completions.+:" title="(o: sbt.complete.Completion)sbt.complete.Completions">+:</a> <a href="#sbt.complete;Optional.delegate" title="sbt.complete.Parser[T]">delegate</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;Optional.completions.level" title="Int">level</a><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;Optional.toString">toString</a> = <a href="#sbt.complete;Optional.delegate" title="sbt.complete.Parser[T]">delegate</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
<span class="delimiter">}</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Repeat[T] extends AnyRef with sbt.complete.ValidParser[Seq[T]]" id="sbt.complete;Repeat">Repeat</a><span class="delimiter">[</span><a title="" id="sbt.complete;Repeat;T">T</a><span class="delimiter">]</span><a href="#sbt.complete;Repeat" title="sbt.complete.Repeat[T]" class="delimiter">(</a><a title="Option[sbt.complete.Parser[T]]" id="sbt.complete;Repeat.partial">partial</a>: <span title="Option[sbt.complete.Parser[T]]">Option</span><span class="delimiter">[</span>Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="sbt.complete.Parser[T]" id="sbt.complete;Repeat.repeated">repeated</a>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int" id="sbt.complete;Repeat.min">min</a>: <span title="Int">Int</span>, <a title="sbt.complete.UpperBound" id="sbt.complete;Repeat.max">max</a>: <a href="UpperBound.scala.html#sbt.complete;UpperBound" title="sbt.complete.UpperBound">UpperBound</a>, <a title="List[T]" id="sbt.complete;Repeat.accumulatedReverse">accumulatedReverse</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.complete;ValidParser" title="sbt.complete.ValidParser[Seq[T]]">ValidParser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span title="(assumption: Boolean, message: =&gt; Any)Unit">assume</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#sbt.complete;Repeat.min" title="Int">min</a>, <span title="String(&quot;Minimum occurences must be non-negative&quot;)" class="string">&quot;Minimum occurences must be non-negative&quot;</span><span class="delimiter">)</span>
  <span title="(assumption: Boolean, message: =&gt; Any)Unit">assume</span><span class="delimiter">(</span><a href="#sbt.complete;Repeat.max" title="sbt.complete.UpperBound">max</a> <a href="UpperBound.scala.html#sbt.complete;UpperBound.>=" title="(min: Int)Boolean">&gt;=</a> <a href="#sbt.complete;Repeat.min" title="Int">min</a>, <span title="String(&quot;Minimum occurences must be less than the maximum occurences&quot;)" class="string">&quot;Minimum occurences must be less than the maximum occurences&quot;</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(c: Char)sbt.complete.Parser[Seq[T]]" id="sbt.complete;Repeat.derive">derive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Repeat.derive.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> =
    <a href="#sbt.complete;Repeat.partial" title="Option[sbt.complete.Parser[T]]">partial</a> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Repeat.derive.part">part</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="sbt.complete.Parser[Seq[T]]" id="sbt.complete;Repeat.derive.partD">partD</a> = <a href="#sbt.complete.Parser.repeat(c6e62f4296)" title="(partial: Option[sbt.complete.Parser[T]], repeated: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound, revAcc: List[T])sbt.complete.Parser[Seq[T]]">repeat</a><span class="delimiter">(</span><span title="(x: sbt.complete.Parser[T])Some[sbt.complete.Parser[T]]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;Repeat.derive.part" title="sbt.complete.Parser[T]">part</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;Repeat.derive.c" title="Char">c</a><span class="delimiter">)</span>, <a href="#sbt.complete;Repeat.repeated" title="sbt.complete.Parser[T]">repeated</a>, <a href="#sbt.complete;Repeat.min" title="Int">min</a>, <a href="#sbt.complete;Repeat.max" title="sbt.complete.UpperBound">max</a>, <a href="#sbt.complete;Repeat.accumulatedReverse" title="List[T]">accumulatedReverse</a><span class="delimiter">)</span>
        <a href="#sbt.complete;Repeat.derive.part" title="sbt.complete.Parser[T]">part</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a> <span title="sbt.complete.Parser[Seq[T]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Value<span class="delimiter">(</span><a title="T" id="sbt.complete;Repeat.derive.pv">pv</a><span class="delimiter">)</span>  =&gt; <a href="#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[T]])sbt.complete.RichParser[Seq[T]]">partD</a> <a href="#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[Seq[T]])sbt.complete.Parser[Seq[T]]">|</a> <a href="#sbt.complete;Repeat.repeatDerive" title="(c: Char, accRev: List[T])sbt.complete.Parser[Seq[T]]">repeatDerive</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.derive.c" title="Char">c</a>, <a href="#sbt.complete;Repeat.derive.pv" title="T">pv</a> <a href="#sbt.complete;Repeat.derive.x$37" title="(x: T)List[T]">::</a> <a href="#sbt.complete;Repeat.accumulatedReverse" title="List[T]">accumulatedReverse</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _: <a href="#sbt.complete.Parser;Failure" title="sbt.complete.Parser.Failure">Failure</a> =&gt; <a href="#sbt.complete;Repeat.derive.partD" title="sbt.complete.Parser[Seq[T]]">partD</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#sbt.complete;Repeat.repeatDerive" title="(c: Char, accRev: List[T])sbt.complete.Parser[Seq[T]]">repeatDerive</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.derive.c" title="Char">c</a>, <a href="#sbt.complete;Repeat.accumulatedReverse" title="List[T]">accumulatedReverse</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(c: Char, accRev: List[T])sbt.complete.Parser[Seq[T]]" id="sbt.complete;Repeat.repeatDerive">repeatDerive</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Repeat.repeatDerive.c">c</a>: <span title="Char">Char</span>, <a title="List[T]" id="sbt.complete;Repeat.repeatDerive.accRev">accRev</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt.complete.Parser.repeat(c6e62f4296)" title="(partial: Option[sbt.complete.Parser[T]], repeated: sbt.complete.Parser[T], min: Int, max: sbt.complete.UpperBound, revAcc: List[T])sbt.complete.Parser[Seq[T]]">repeat</a><span class="delimiter">(</span><span title="(x: sbt.complete.Parser[T])Some[sbt.complete.Parser[T]]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;Repeat.repeated" title="sbt.complete.Parser[T]">repeated</a> <a href="#sbt.complete;Parser.derive" title="(i: Char)sbt.complete.Parser[T]">derive</a> <a href="#sbt.complete;Repeat.repeatDerive.c" title="Char">c</a><span class="delimiter">)</span>, <a href="#sbt.complete;Repeat.repeated" title="sbt.complete.Parser[T]">repeated</a>, <span class="delimiter">(</span><a href="#sbt.complete;Repeat.min" title="Int">min</a> <span title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(that: Int)Int">max</span> <span title="Int(0)" class="int">0</span>, <a href="#sbt.complete;Repeat.max" title="sbt.complete.UpperBound">max</a>.<a href="UpperBound.scala.html#sbt.complete;UpperBound.decrement" title="=&gt; sbt.complete.UpperBound">decrement</a>, <a href="#sbt.complete;Repeat.repeatDerive.accRev" title="List[T]">accRev</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(level: Int)sbt.complete.Completions" id="sbt.complete;Repeat.completions">completions</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Repeat.completions.level">level</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(comp: sbt.complete.Completions, exp: sbt.complete.Completions, n: Int)sbt.complete.Completions" id="sbt.complete;Repeat.completions.pow">pow</a><span class="delimiter">(</span><a title="sbt.complete.Completions" id="sbt.complete;Repeat.completions.pow.comp">comp</a>: <a href="Completions.scala.html#sbt.complete;Completions" title="sbt.complete.Completions">Completions</a>, <a title="sbt.complete.Completions" id="sbt.complete;Repeat.completions.pow.exp">exp</a>: <a href="Completions.scala.html#sbt.complete;Completions" title="sbt.complete.Completions">Completions</a>, <a title="Int" id="sbt.complete;Repeat.completions.pow.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Completions.scala.html#sbt.complete;Completions" title="sbt.complete.Completions">Completions</a> =
        <span title="sbt.complete.Completions" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;Repeat.completions.pow.n" title="Int">n</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#sbt.complete;Repeat.completions.pow.comp" title="sbt.complete.Completions">comp</a> <span class="keyword">else</span> <a href="#sbt.complete;Repeat.completions.pow" title="(comp: sbt.complete.Completions, exp: sbt.complete.Completions, n: Int)sbt.complete.Completions">pow</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.completions.pow.comp" title="sbt.complete.Completions">comp</a> <a href="Completions.scala.html#sbt.complete;Completions.x" title="(o: sbt.complete.Completions)sbt.complete.Completions">x</a> <a href="#sbt.complete;Repeat.completions.pow.exp" title="sbt.complete.Completions">exp</a>, <a href="#sbt.complete;Repeat.completions.pow.exp" title="sbt.complete.Completions">exp</a>, <a href="#sbt.complete;Repeat.completions.pow.n" title="Int">n</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="sbt.complete.Completions" id="sbt.complete;Repeat.completions.repC">repC</a> = <a href="#sbt.complete;Repeat.repeated" title="sbt.complete.Parser[T]">repeated</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.completions.level" title="Int">level</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="sbt.complete.Completions" id="sbt.complete;Repeat.completions.fin">fin</a> = <span title="sbt.complete.Completions" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;Repeat.min" title="Int">min</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete.Completion" title="sbt.complete.Completion.type">Completion</a>.<a href="Completions.scala.html#sbt.complete.Completion.empty" title="=&gt; sbt.complete.Completion">empty</a> <a href="Completions.scala.html#sbt.complete;Completions.+:" title="(o: sbt.complete.Completion)sbt.complete.Completions">+:</a> <a href="#sbt.complete;Repeat.completions.repC" title="sbt.complete.Completions">repC</a> <span class="keyword">else</span> <a href="#sbt.complete;Repeat.completions.pow" title="(comp: sbt.complete.Completions, exp: sbt.complete.Completions, n: Int)sbt.complete.Completions">pow</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.completions.repC" title="sbt.complete.Completions">repC</a>, <a href="#sbt.complete;Repeat.completions.repC" title="sbt.complete.Completions">repC</a>, <a href="#sbt.complete;Repeat.min" title="Int">min</a><span class="delimiter">)</span>
      <a href="#sbt.complete;Repeat.partial" title="Option[sbt.complete.Parser[T]]">partial</a> <span title="sbt.complete.Completions" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Repeat.completions.p">p</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;Repeat.completions.p" title="sbt.complete.Parser[T]">p</a>.<a href="#sbt.complete;Parser.completions" title="(level: Int)sbt.complete.Completions">completions</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.completions.level" title="Int">level</a><span class="delimiter">)</span> <a href="Completions.scala.html#sbt.complete;Completions.x" title="(o: sbt.complete.Completions)sbt.complete.Completions">x</a> <a href="#sbt.complete;Repeat.completions.fin" title="sbt.complete.Completions">fin</a>
        <span class="keyword">case</span> <span title="None.type">None</span>    =&gt; <a href="#sbt.complete;Repeat.completions.fin" title="sbt.complete.Completions">fin</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; None.type" id="sbt.complete;Repeat.result">result</a> = <span title="None.type">None</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[Seq[T]]" id="sbt.complete;Repeat.resultEmpty">resultEmpty</a>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[Seq[T]]">Result</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="sbt.complete.Parser.Result[List[T]]" id="sbt.complete;Repeat.resultEmpty.partialAccumulatedOption">partialAccumulatedOption</a> =
        <a href="#sbt.complete;Repeat.partial" title="Option[sbt.complete.Parser[T]]">partial</a> <span title="sbt.complete.Parser.Result[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="None.type">None</span>                 =&gt; <a href="#sbt.complete.Parser.Value.readResolve" title="(value: List[T])sbt.complete.Parser.Value[List[T]]">Value</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.accumulatedReverse" title="List[T]">accumulatedReverse</a><span class="delimiter">)</span>
          <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Repeat.resultEmpty.partialAccumulatedOption.partialPattern">partialPattern</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;Repeat.resultEmpty.partialAccumulatedOption.partialPattern" title="sbt.complete.Parser[T]">partialPattern</a>.<a href="#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[T]">resultEmpty</a>.<a href="#sbt.complete.Parser;Result.map" title="(f: T =&gt; List[T])sbt.complete.Parser.Result[List[T]]">map</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.resultEmpty.partialAccumulatedOption.$anonfun.x$39" title="T">_</a> <a href="#sbt.complete;Repeat.resultEmpty.partialAccumulatedOption.$anonfun.x$40" title="(x: T)List[T]">::</a> <a href="#sbt.complete;Repeat.accumulatedReverse" title="List[T]">accumulatedReverse</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">(</span><a href="#sbt.complete;Repeat.resultEmpty.partialAccumulatedOption" title="sbt.complete.Parser.Result[List[T]]">partialAccumulatedOption</a> <a href="#sbt.complete.Parser;Result.app" title="(b: =&gt; sbt.complete.Parser.Result[List[T]])(f: (List[T], List[T]) =&gt; List[T])sbt.complete.Parser.Result[List[T]]">app</a> <a href="#sbt.complete;Repeat.repeatedParseEmpty" title="=&gt; sbt.complete.Parser.Result[List[T]]">repeatedParseEmpty</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;Repeat.resultEmpty.$anonfun.x$41" title="List[T]">_</a> <a href="#sbt.complete;Repeat.resultEmpty.$anonfun.x$43" title="(prefix: List[T])List[T]">reverse_:::</a> <a href="#sbt.complete;Repeat.resultEmpty.$anonfun.x$42" title="List[T]">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser.Result[List[T]]" id="sbt.complete;Repeat.repeatedParseEmpty">repeatedParseEmpty</a>: <a href="#sbt.complete.Parser;Result" title="sbt.complete.Parser.Result[List[T]]">Result</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span title="sbt.complete.Parser.Result[List[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;Repeat.min" title="Int">min</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <a href="#sbt.complete.Parser.Value.readResolve" title="(value: scala.collection.immutable.Nil.type)sbt.complete.Parser.Value[scala.collection.immutable.Nil.type]">Value</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <span class="comment">// forced determinism</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="T" id="sbt.complete;Repeat.repeatedParseEmpty.$anonfun.value">value</a> &lt;- <a href="#sbt.complete;Repeat.repeated" title="sbt.complete.Parser[T]">repeated</a>.<a href="#sbt.complete.Parser;Result.map" title="(f: T =&gt; List[T])sbt.complete.Parser.Result[List[T]]">resultEmpty</a><span class="delimiter">)</span> <span class="keyword">yield</span> <a href="../Util.scala.html#sbt.Util.makeList" title="(size: Int, value: T)List[T]">makeList</a><span class="delimiter">(</span><a href="#sbt.complete;Repeat.min" title="Int">min</a>, <a href="#sbt.complete;Repeat.repeatedParseEmpty.$anonfun.value" title="T">value</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;Repeat.toString">toString</a> = <span title="String(&quot;repeat(&quot;)" class="string">&quot;repeat(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Repeat.min" title="Int">min</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Repeat.max" title="sbt.complete.UpperBound">max</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Repeat.partial" title="Option[sbt.complete.Parser[T]]">partial</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Repeat.repeated" title="sbt.complete.Parser[T]">repeated</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
