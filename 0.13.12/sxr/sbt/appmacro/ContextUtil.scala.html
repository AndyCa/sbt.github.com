<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/appmacro/ContextUtil.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt
<span class="keyword">package</span> appmacro

<span class="keyword">import</span> scala.reflect._
<span class="keyword">import</span> macros._
<span class="keyword">import</span> scala.tools.nsc.Global
<span class="keyword">import</span> <a href="#sbt.appmacro.ContextUtil" title="sbt.appmacro.ContextUtil.type">ContextUtil</a>.<span class="delimiter">{</span> DynamicDependencyError, DynamicReferenceError <span class="delimiter">}</span>

<span class="keyword">object</span> <a title="sbt.appmacro.ContextUtil.type" id="sbt.appmacro.ContextUtil">ContextUtil</a> <a href="#sbt.appmacro.ContextUtil" title="sbt.appmacro.ContextUtil.type" class="delimiter">{</a>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;Illegal dynamic dependency&quot;)" id="sbt.appmacro.ContextUtil.DynamicDependencyError">DynamicDependencyError</a> = <span title="String(&quot;Illegal dynamic dependency&quot;)" class="string">&quot;Illegal dynamic dependency&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;Illegal dynamic reference&quot;)" id="sbt.appmacro.ContextUtil.DynamicReferenceError">DynamicReferenceError</a> = <span title="String(&quot;Illegal dynamic reference&quot;)" class="string">&quot;Illegal dynamic reference&quot;</span>

  <span class="comment">/**
   * Constructs an object with utility methods for operating in the provided macro context `c`.
   * Callers should explicitly specify the type parameter as `c.type` in order to preserve the path dependent types.
   */</span>
  <span class="keyword">def</span> <a title="[C &lt;: scala.reflect.macros.Context with Singleton](c: C)sbt.appmacro.ContextUtil[C]" id="sbt.appmacro.ContextUtil.apply">apply</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context with Singleton" id="sbt.appmacro.ContextUtil.apply;C">C</a> &lt;: Context <span class="keyword">with</span> Singleton<span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="sbt.appmacro.ContextUtil.apply.c">c</a>: <a href="#sbt.appmacro.ContextUtil.apply;C" title="C">C</a><span class="delimiter">)</span>: <a href="#sbt.appmacro;ContextUtil" title="sbt.appmacro.ContextUtil[C]">ContextUtil</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <span title="sbt.appmacro.ContextUtil[C]" class="keyword">new</span> <a href="#sbt.appmacro;ContextUtil" title="sbt.appmacro.ContextUtil[C]">ContextUtil</a><span class="delimiter">(</span><a href="#sbt.appmacro.ContextUtil.apply.c" title="C">c</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Helper for implementing a no-argument macro that is introduced via an implicit.
   * This method removes the implicit conversion and evaluates the function `f` on the target of the conversion.
   *
   * Given `myImplicitConversion(someValue).extensionMethod`, where `extensionMethod` is a macro that uses this
   * method, the result of this method is `f(&lt;Tree of someValue&gt;)`.
   */</span>
  <span class="keyword">def</span> <a title="[T](c: scala.reflect.macros.Context)(f: (c.Expr[Any], c.Position) =&gt; c.Expr[T])(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]" id="sbt.appmacro.ContextUtil.selectMacroImpl">selectMacroImpl</a><span class="delimiter">[</span><a title="" id="sbt.appmacro.ContextUtil.selectMacroImpl;T">T</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="sbt.appmacro.ContextUtil.selectMacroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(c.Expr[Any], c.Position) =&gt; c.Expr[T]" id="sbt.appmacro.ContextUtil.selectMacroImpl.f">f</a>: <span class="delimiter">(</span>c.Expr<span class="delimiter">[</span>Any<span class="delimiter">]</span>, c.Position<span class="delimiter">)</span> =&gt; c.Expr<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[T]">Expr</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
      <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Tree">macroApplication</span> <span title="c.Expr[T]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="c.universe.Select" id="sbt.appmacro.ContextUtil.selectMacroImpl.s">s</a> @ <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(select: c.universe.Select)Option[(c.universe.Tree, c.universe.Name)]">Select</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(x: Any)Option[c.universe.Select]" class="delimiter">(</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a>_, <a title="c.universe.Tree" id="sbt.appmacro.ContextUtil.selectMacroImpl.t">t</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="c.universe.Name" id="sbt.appmacro.ContextUtil.selectMacroImpl.tp">tp</a><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.f" title="(v1: c.Expr[Any], v2: c.Position)c.Expr[T]">f</a><span class="delimiter">(</span><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[Any])c.Expr[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.c" title="(u: scala.reflect.api.Universe)u.WeakTypeTag[Any]" class="delimiter">(</a><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.t" title="c.universe.Tree">t</a><span class="delimiter">)</span>, <a href="#sbt.appmacro.ContextUtil.selectMacroImpl.s" title="c.universe.Select">s</a>.<span title="=&gt; c.universe.Position">pos</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="c.Tree" id="sbt.appmacro.ContextUtil.selectMacroImpl.x">x</a>                                  =&gt; <a href="#sbt.appmacro.ContextUtil.unexpectedTree" title="(tree: _409.universe.Tree forSome { val _409: scala.reflect.macros.Context })Nothing">unexpectedTree</a><span class="delimiter">(</span><a href="#sbt.appmacro.ContextUtil.selectMacroImpl.x" title="c.Tree">x</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[C &lt;: scala.reflect.macros.Context](tree: _409.universe.Tree forSome { val _409: C })Nothing" id="sbt.appmacro.ContextUtil.unexpectedTree">unexpectedTree</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context" id="sbt.appmacro.ContextUtil.unexpectedTree;C">C</a> &lt;: Context<span class="delimiter">]</span><span class="delimiter">(</span><a title="_409.universe.Tree forSome { val _409: C }" id="sbt.appmacro.ContextUtil.unexpectedTree.tree">tree</a>: C#<span title="_1170.universe.Tree forSome { val _1170: C }">Tree</span><span class="delimiter">)</span>: <span title="Nothing">Nothing</span> = sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Unexpected macro application tree (&quot;)" class="string">&quot;Unexpected macro application tree (&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro.ContextUtil.unexpectedTree.tree" title="_409.universe.Tree forSome { val _409: C }">tree</a>.<span title="()Class[_]">getClass</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;): &quot;)" class="string">&quot;): &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro.ContextUtil.unexpectedTree.tree" title="_409.universe.Tree forSome { val _409: C }">tree</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">// TODO 2.11 Remove this after dropping 2.10.x support.</span>
<span title="AnyRef" class="keyword">private</span> <span class="keyword">object</span> <a title="sbt.appmacro.HasCompat.type" id="sbt.appmacro.HasCompat">HasCompat</a> <a href="#sbt.appmacro.HasCompat" title="sbt.appmacro.HasCompat.type" class="delimiter">{</a> <span class="keyword">val</span> <a title="Nothing" id="sbt.appmacro.HasCompat.compat">compat</a> = <span title="=&gt; Nothing">???</span> <span class="delimiter">}</span>; <span class="keyword">import</span> <a href="#sbt.appmacro.HasCompat" title="sbt.appmacro.HasCompat.type">HasCompat</a>._

<span class="comment">/**
 * Utility methods for macros.  Several methods assume that the context's universe is a full compiler (`scala.tools.nsc.Global`).
 * This is not thread safe due to the underlying Context and related data structures not being thread safe.
 * Use `ContextUtil[c.type](c)` to construct.
 */</span>
<span class="keyword">final</span> <span class="keyword">class</span> <a title="class ContextUtil[C &lt;: scala.reflect.macros.Context] extends AnyRef" id="sbt.appmacro;ContextUtil">ContextUtil</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.macros.Context" id="sbt.appmacro;ContextUtil;C">C</a> &lt;: Context<span class="delimiter">]</span><a href="#sbt.appmacro;ContextUtil" title="sbt.appmacro.ContextUtil[C]" class="delimiter">(</a><span class="keyword">val</span> <a title="C" id="sbt.appmacro;ContextUtil.ctx">ctx</a>: <a href="#sbt.appmacro;ContextUtil;C" title="C">C</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span class="delimiter">{</span> Apply =&gt; ApplyTree, _ <span class="delimiter">}</span>
  <span class="keyword">import</span> <a href="#sbt.appmacro.HasCompat.compat" title="=&gt; Nothing">compat</a>._

  <span class="keyword">val</span> <a title="scala.reflect.macros.runtime.Context" id="sbt.appmacro;ContextUtil.powerContext">powerContext</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.reflect.macros.runtime.Context" class="delimiter">[</span>reflect.macros.runtime.<span title="scala.reflect.macros.runtime.Context">Context</span><span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="ContextUtil.this.powerContext.universe.type" id="sbt.appmacro;ContextUtil.global">global</a>: powerContext.universe.<span class="keyword">type</span> = <a href="#sbt.appmacro;ContextUtil.powerContext" title="=&gt; scala.reflect.macros.runtime.Context">powerContext</a>.<span title="=&gt; scala.tools.nsc.Global">universe</span>
  <span class="keyword">def</span> <a title="=&gt; ContextUtil.this.global.analyzer.Typer" id="sbt.appmacro;ContextUtil.callsiteTyper">callsiteTyper</a>: global.analyzer.<span title="ContextUtil.this.global.analyzer.Typer">Typer</span> = <a href="#sbt.appmacro;ContextUtil.powerContext" title="=&gt; scala.reflect.macros.runtime.Context">powerContext</a>.<span title="=&gt; ContextUtil.this.powerContext.universe.analyzer.Typer">callsiteTyper</span>
  <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.initialOwner">initialOwner</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> = <a href="#sbt.appmacro;ContextUtil.callsiteTyper" title="=&gt; ContextUtil.this.global.analyzer.Typer">callsiteTyper</a>.<span title="=&gt; ContextUtil.this.global.analyzer.Context">context</span>.<span title="=&gt; ContextUtil.this.global.analyzer.global.Symbol">owner</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Symbol" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">]</span>

  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.Type" id="sbt.appmacro;ContextUtil.alistType">alistType</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="[T](implicit ttag: ContextUtil.this.ctx.TypeTag[T])ContextUtil.this.ctx.Type">typeOf</span><a href="#sbt.appmacro;ContextUtil.ctx" title="(implicit ttag: ContextUtil.this.ctx.TypeTag[sbt.AList[sbt.KList]])ContextUtil.this.ctx.Type" class="delimiter">[</a><a href="../AList.scala.html#sbt;AList" title="sbt.AList[sbt.KList]">AList</a><span class="delimiter">[</span>KList<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.alist">alist</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> = <a href="#sbt.appmacro;ContextUtil.alistType" title="=&gt; ContextUtil.this.ctx.Type">alistType</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">typeSymbol</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">companionSymbol</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.alistTC">alistTC</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> = <a href="#sbt.appmacro;ContextUtil.alistType" title="=&gt; ContextUtil.this.ctx.Type">alistType</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">typeConstructor</span>

  <span class="comment">/** Modifiers for a local val.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Modifiers" id="sbt.appmacro;ContextUtil.localModifiers">localModifiers</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(flags: ContextUtil.this.ctx.universe.FlagSet)ContextUtil.this.ctx.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.FlagSet">NoFlags</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(sym: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.Position" id="sbt.appmacro;ContextUtil.getPos">getPos</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.getPos.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span> = <span title="ContextUtil.this.ctx.universe.Position" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.getPos.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Position">NoPosition</a> <span class="keyword">else</span> <a href="#sbt.appmacro;ContextUtil.getPos.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Position">pos</span>

  <span class="comment">/**
   * Constructs a unique term name with the given prefix within this Context.
   * (The current implementation uses Context.fresh, which increments
   */</span>
  <span class="keyword">def</span> <a title="(prefix: String)ContextUtil.this.ctx.universe.TermName" id="sbt.appmacro;ContextUtil.freshTermName">freshTermName</a><span class="delimiter">(</span><a title="String" id="sbt.appmacro;ContextUtil.freshTermName.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(s: String)ContextUtil.this.ctx.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(name: String)String">fresh</span><span class="delimiter">(</span><span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.freshTermName.prefix" title="String">prefix</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Constructs a new, synthetic, local ValDef Type `tpe`, a unique name,
   * Position `pos`, an empty implementation (no rhs), and owned by `owner`.
   */</span>
  <span class="keyword">def</span> <a title="(tpe: ContextUtil.this.ctx.universe.Type, pos: ContextUtil.this.ctx.universe.Position, owner: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.freshValDef">freshValDef</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.freshValDef.tpe">tpe</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span>, <a title="ContextUtil.this.ctx.universe.Position" id="sbt.appmacro;ContextUtil.freshValDef.pos">pos</a>: <span title="ContextUtil.this.ctx.universe.Position">Position</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.freshValDef.owner">owner</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.FlagSet" id="sbt.appmacro;ContextUtil.freshValDef.SYNTHETIC">SYNTHETIC</a> = <span class="delimiter">(</span><span class="int">1</span> <span title="Int(2097152)">&lt;&lt;</span> <span class="int">21</span><span class="delimiter">)</span>.<span title="=&gt; Long">toLong</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.FlagSet" class="delimiter">[</span><span title="ContextUtil.this.ctx.universe.FlagSet">FlagSet</span><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TermSymbol" id="sbt.appmacro;ContextUtil.freshValDef.sym">sym</a> = <a href="#sbt.appmacro;ContextUtil.freshValDef.owner" title="ContextUtil.this.ctx.universe.Symbol">owner</a>.<span title="(name: ContextUtil.this.ctx.universe.TermName, pos: ContextUtil.this.ctx.universe.Position, flags: ContextUtil.this.ctx.universe.FlagSet)ContextUtil.this.ctx.universe.TermSymbol">newTermSymbol</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshTermName" title="(prefix: String)ContextUtil.this.ctx.universe.TermName">freshTermName</a><span class="delimiter">(</span><span title="String(&quot;q&quot;)" class="string">&quot;q&quot;</span><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.freshValDef.pos" title="ContextUtil.this.ctx.universe.Position">pos</a>, <a href="#sbt.appmacro;ContextUtil.freshValDef.SYNTHETIC" title="ContextUtil.this.ctx.universe.FlagSet">SYNTHETIC</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.setInfo" title="(sym: ContextUtil.this.ctx.universe.Symbol, tpe: ContextUtil.this.ctx.universe.Type)Unit">setInfo</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshValDef.sym" title="ContextUtil.this.ctx.universe.TermSymbol">sym</a>, <a href="#sbt.appmacro;ContextUtil.freshValDef.tpe" title="ContextUtil.this.ctx.universe.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.freshValDef.vd">vd</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(sym: ContextUtil.this.ctx.universe.Symbol, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshValDef.sym" title="ContextUtil.this.ctx.universe.TermSymbol">sym</a>, <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.freshValDef.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="(newpos: ContextUtil.this.ctx.universe.Position)ContextUtil.this.ctx.universe.Tree">setPos</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshValDef.pos" title="ContextUtil.this.ctx.universe.Position">pos</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.freshValDef.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>
    <span class="delimiter">}</span>

  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Modifiers" id="sbt.appmacro;ContextUtil.parameterModifiers">parameterModifiers</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(flags: ContextUtil.this.ctx.universe.FlagSet)ContextUtil.this.ctx.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.FlagValues">Flag</a>.<span title="=&gt; ContextUtil.this.ctx.universe.FlagSet">PARAM</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Collects all definitions in the tree for use in checkReferences.
   * This excludes definitions in wrapped expressions because checkReferences won't allow nested dereferencing anyway.
   */</span>
  <span class="keyword">def</span> <a title="(tree: ContextUtil.this.ctx.universe.Tree, isWrapper: (String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean)scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.collectDefs">collectDefs</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.tree">tree</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="(String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean" id="sbt.appmacro;ContextUtil.collectDefs.isWrapper">isWrapper</a>: <span class="delimiter">(</span>String, Type, Tree<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: collection.<span title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.collectDefs.defs">defs</a> = <span title="()scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]" class="keyword">new</span> collection.mutable.<span title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]">HashSet</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="comment">// adds the symbols for all non-Ident subtrees to `defs`.</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Traverser" id="sbt.appmacro;ContextUtil.collectDefs.process">process</a> = <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon" title="ContextUtil.this.ctx.universe.Traverser" class="keyword">new</a> <a href="#sbt.appmacro;ContextUtil.ctx" title="anonymous class $anon extends ContextUtil.this.ctx.universe.Traverser" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon">Traverser</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: ContextUtil.this.ctx.universe.Tree)Unit" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse">traverse</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.t">t</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">)</span> = <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.t" title="ContextUtil.this.ctx.universe.Tree">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> _: <a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Ident]">Ident</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="(apply: ContextUtil.this.ctx.universe.Apply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">ApplyTree</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Apply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeApply: ContextUtil.this.ctx.universe.TypeApply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">TypeApply</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(select: ContextUtil.this.ctx.universe.Select)Option[(ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Name)]">Select</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Select]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.nme">nme</a><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tpe">tpe</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.qual">qual</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.appmacro;ContextUtil.collectDefs.isWrapper" title="(v1: String, v2: ContextUtil.this.ctx.universe.Type, v3: ContextUtil.this.ctx.universe.Tree)Boolean">isWrapper</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.nme" title="ContextUtil.this.ctx.universe.Name">nme</a>.<span title="=&gt; String">decoded</span>, <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tpe" title="ContextUtil.this.ctx.universe.Tree">tpe</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>, <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a><span class="delimiter">)</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree">tree</a> =&gt;
            <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#sbt.appmacro;ContextUtil.collectDefs.defs" title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]">defs</a> <span title="(elem: ContextUtil.this.ctx.universe.Symbol)defs.type">+=</span> <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span>;
            <a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon" title="ContextUtil.this.ctx.universe.Traverser" class="keyword">super</a>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.process;$anon.traverse.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#sbt.appmacro;ContextUtil.collectDefs.process" title="ContextUtil.this.ctx.universe.Traverser">process</a>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.collectDefs.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.collectDefs.defs" title="scala.collection.mutable.HashSet[ContextUtil.this.ctx.universe.Symbol]">defs</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * A reference is illegal if it is to an M instance defined within the scope of the macro call.
   * As an approximation, disallow referenced to any local definitions `defs`.
   */</span>
  <span class="keyword">def</span> <a title="(defs: scala.collection.Set[ContextUtil.this.ctx.universe.Symbol], sym: ContextUtil.this.ctx.universe.Symbol)Boolean" id="sbt.appmacro;ContextUtil.illegalReference">illegalReference</a><span class="delimiter">(</span><a title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.illegalReference.defs">defs</a>: collection.<span title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.illegalReference.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#sbt.appmacro;ContextUtil.illegalReference.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.illegalReference.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Symbol">NoSymbol</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.illegalReference.defs" title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">defs</a>.<span title="(elem: ContextUtil.this.ctx.universe.Symbol)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.illegalReference.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a><span class="delimiter">)</span>

  <span class="comment">/**
   * A function that checks the provided tree for illegal references to M instances defined in the
   *  expression passed to the macro and for illegal dereferencing of M instances.
   */</span>
  <span class="keyword">def</span> <a title="(defs: scala.collection.Set[ContextUtil.this.ctx.universe.Symbol], isWrapper: (String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean)ContextUtil.this.ctx.universe.Tree =&gt; Unit" id="sbt.appmacro;ContextUtil.checkReferences">checkReferences</a><span class="delimiter">(</span><a title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]" id="sbt.appmacro;ContextUtil.checkReferences.defs">defs</a>: collection.<span title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="(String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree) =&gt; Boolean" id="sbt.appmacro;ContextUtil.checkReferences.isWrapper">isWrapper</a>: <span class="delimiter">(</span>String, Type, Tree<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: Tree =&gt; Unit = <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
    <span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Apply" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.s">s</a> @ <a href="#sbt.appmacro;ContextUtil.ctx" title="(apply: ContextUtil.this.ctx.universe.Apply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">ApplyTree</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Apply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeApply: ContextUtil.this.ctx.universe.TypeApply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">TypeApply</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(select: ContextUtil.this.ctx.universe.Select)Option[(ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Name)]">Select</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Select]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.nme">nme</a><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.tpe">tpe</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.qual">qual</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.isWrapper" title="(v1: String, v2: ContextUtil.this.ctx.universe.Type, v3: ContextUtil.this.ctx.universe.Tree)Boolean">isWrapper</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.nme" title="ContextUtil.this.ctx.universe.Name">nme</a>.<span title="=&gt; String">decoded</span>, <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.tpe" title="ContextUtil.this.ctx.universe.Tree">tpe</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>, <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(pos: ContextUtil.this.ctx.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.s" title="ContextUtil.this.ctx.universe.Apply">s</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Position">pos</span>, <span title="String(&quot;Illegal dynamic dependency&quot;)">DynamicDependencyError</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Ident" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.id">id</a> @ <a href="#sbt.appmacro;ContextUtil.ctx" title="(ident: ContextUtil.this.ctx.universe.Ident)Option[ContextUtil.this.ctx.universe.Name]">Ident</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Ident]" class="delimiter">(</a><a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.checkReferences.$anonfun.name">name</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#sbt.appmacro;ContextUtil.illegalReference" title="(defs: scala.collection.Set[ContextUtil.this.ctx.universe.Symbol], sym: ContextUtil.this.ctx.universe.Symbol)Boolean">illegalReference</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.defs" title="scala.collection.Set[ContextUtil.this.ctx.universe.Symbol]">defs</a>, <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.id" title="ContextUtil.this.ctx.universe.Ident">id</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span><span class="delimiter">)</span> =&gt; <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(pos: ContextUtil.this.ctx.Position, msg: String)Unit">error</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.id" title="ContextUtil.this.ctx.universe.Ident">id</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Position">pos</span>, DynamicReferenceError <span title="String(&quot;Illegal dynamic reference: &quot;)">+</span> <span class="string">&quot;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.checkReferences.$anonfun.name" title="ContextUtil.this.ctx.universe.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Constructs a ValDef with a parameter modifier, a unique name, with the provided Type and with an empty rhs. */</span>
  <span class="keyword">def</span> <a title="(tpe: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.freshMethodParameter">freshMethodParameter</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.freshMethodParameter.tpe">tpe</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span> =
    <a href="#sbt.appmacro;ContextUtil.ctx" title="(mods: ContextUtil.this.ctx.universe.Modifiers, name: ContextUtil.this.ctx.universe.TermName, tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.parameterModifiers" title="=&gt; ContextUtil.this.ctx.universe.Modifiers">parameterModifiers</a>, <a href="#sbt.appmacro;ContextUtil.freshTermName" title="(prefix: String)ContextUtil.this.ctx.universe.TermName">freshTermName</a><span class="delimiter">(</span><span title="String(&quot;p&quot;)" class="string">&quot;p&quot;</span><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="(tp: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.freshMethodParameter.tpe" title="ContextUtil.this.ctx.universe.Type">tpe</a><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Tree">EmptyTree</a><span class="delimiter">)</span>

  <span class="comment">/** Constructs a ValDef with local modifiers and a unique name. */</span>
  <span class="keyword">def</span> <a title="(tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.localValDef">localValDef</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.localValDef.tpt">tpt</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.localValDef.rhs">rhs</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span> =
    <a href="#sbt.appmacro;ContextUtil.ctx" title="(mods: ContextUtil.this.ctx.universe.Modifiers, name: ContextUtil.this.ctx.universe.TermName, tpt: ContextUtil.this.ctx.universe.Tree, rhs: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.localModifiers" title="=&gt; ContextUtil.this.ctx.universe.Modifiers">localModifiers</a>, <a href="#sbt.appmacro;ContextUtil.freshTermName" title="(prefix: String)ContextUtil.this.ctx.universe.TermName">freshTermName</a><span class="delimiter">(</span><span title="String(&quot;q&quot;)" class="string">&quot;q&quot;</span><span class="delimiter">)</span>, <a href="#sbt.appmacro;ContextUtil.localValDef.tpt" title="ContextUtil.this.ctx.universe.Tree">tpt</a>, <a href="#sbt.appmacro;ContextUtil.localValDef.rhs" title="ContextUtil.this.ctx.universe.Tree">rhs</a><span class="delimiter">)</span>

  <span class="comment">/** Constructs a tuple value of the right TupleN type from the provided inputs.*/</span>
  <span class="keyword">def</span> <a title="(args: List[ContextUtil.this.ctx.universe.Tree])ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.mkTuple">mkTuple</a><span class="delimiter">(</span><a title="List[ContextUtil.this.ctx.universe.Tree]" id="sbt.appmacro;ContextUtil.mkTuple.args">args</a>: <span title="List[ContextUtil.this.ctx.universe.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
    <a href="#sbt.appmacro;ContextUtil.global" title="=&gt; ContextUtil.this.powerContext.universe.type">global</a>.<span title="ContextUtil.this.global.gen.type">gen</span>.<span title="(elems: List[ContextUtil.this.global.gen.global.Tree])ContextUtil.this.global.gen.global.Tree">mkTuple</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.mkTuple.args" title="List[ContextUtil.this.ctx.universe.Tree]">args</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[ContextUtil.this.global.Tree]" class="delimiter">[</span><span title="List[ContextUtil.this.global.Tree]">List</span><span class="delimiter">[</span>global.Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Tree" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="[Tree](t: Tree, sym: ContextUtil.this.ctx.universe.Symbol)Unit" id="sbt.appmacro;ContextUtil.setSymbol">setSymbol</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;ContextUtil.setSymbol;Tree">Tree</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Tree" id="sbt.appmacro;ContextUtil.setSymbol.t">t</a>: <a href="#sbt.appmacro;ContextUtil.setSymbol;Tree" title="Tree">Tree</a>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.setSymbol.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#sbt.appmacro;ContextUtil.setSymbol.t" title="Tree">t</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Tree" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Tree">Tree</span><span class="delimiter">]</span>.<span title="(sym: ContextUtil.this.global.Symbol)ContextUtil.this.global.Tree">setSymbol</span><span title="Unit" class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.setSymbol.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Symbol" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Symbol">Symbol</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[Tree](sym: ContextUtil.this.ctx.universe.Symbol, tpe: ContextUtil.this.ctx.universe.Type)Unit" id="sbt.appmacro;ContextUtil.setInfo">setInfo</a><span class="delimiter">[</span><a title="" id="sbt.appmacro;ContextUtil.setInfo;Tree">Tree</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.setInfo.sym">sym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span>, <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.setInfo.tpe">tpe</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#sbt.appmacro;ContextUtil.setInfo.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Symbol" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Symbol">Symbol</span><span class="delimiter">]</span>.<span title="(info: ContextUtil.this.global.Type)ContextUtil.this.global.Symbol">setInfo</span><span title="Unit" class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.setInfo.tpe" title="ContextUtil.this.ctx.universe.Type">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Type" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Type">Type</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** Creates a new, synthetic type variable with the specified `owner`. */</span>
  <span class="keyword">def</span> <a title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTypeVariable">newTypeVariable</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.newTypeVariable.owner">owner</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span>, <a title="String" id="sbt.appmacro;ContextUtil.newTypeVariable$default$2">prefix</a>: <span title="String">String</span> = <span title="String(&quot;T0&quot;)" class="string">&quot;T0&quot;</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span> =
    <a href="#sbt.appmacro;ContextUtil.newTypeVariable.owner" title="ContextUtil.this.ctx.universe.Symbol">owner</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Symbol" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Symbol">Symbol</span><span class="delimiter">]</span>.<span title="(name: String, newFlags: Long)ContextUtil.this.global.TypeSymbol">newSyntheticTypeParam</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTypeVariable$default$2" title="String">prefix</a>, <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.TypeSymbol" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span><span class="delimiter">]</span>

  <span class="comment">/** The type representing the type constructor `[X] X` */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.idTC">idTC</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.idTC.tvar">tvar</a> = <a href="#sbt.appmacro;ContextUtil.newTypeVariable" title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol">newTypeVariable</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Symbol">NoSymbol</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.ctx" title="(tparams: List[ContextUtil.this.ctx.universe.Symbol], tpe: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Type">polyType</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.idTC.tvar" title="ContextUtil.this.ctx.universe.TypeSymbol">tvar</a> <a href="#sbt.appmacro;ContextUtil.idTC.x$1" title="(x: ContextUtil.this.ctx.universe.TypeSymbol)List[ContextUtil.this.ctx.universe.TypeSymbol]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro;ContextUtil.refVar" title="(variable: ContextUtil.this.ctx.universe.TypeSymbol)ContextUtil.this.ctx.universe.Type">refVar</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.idTC.tvar" title="ContextUtil.this.ctx.universe.TypeSymbol">tvar</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="comment">/** A Type that references the given type variable. */</span>
  <span class="keyword">def</span> <a title="(variable: ContextUtil.this.ctx.universe.TypeSymbol)ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.refVar">refVar</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.refVar.variable">variable</a>: <span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> = <a href="#sbt.appmacro;ContextUtil.refVar.variable" title="ContextUtil.this.ctx.universe.TypeSymbol">variable</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">toTypeConstructor</span>
  <span class="comment">/** Constructs a new, synthetic type variable that is a type constructor. For example, in type Y[L[x]], L is such a type variable. */</span>
  <span class="keyword">def</span> <a title="(owner: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTCVariable">newTCVariable</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.newTCVariable.owner">owner</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.TypeSymbol">TypeSymbol</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTCVariable.tc">tc</a> = <a href="#sbt.appmacro;ContextUtil.newTypeVariable" title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol">newTypeVariable</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTCVariable.owner" title="ContextUtil.this.ctx.universe.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.TypeSymbol" id="sbt.appmacro;ContextUtil.newTCVariable.arg">arg</a> = <a href="#sbt.appmacro;ContextUtil.newTypeVariable" title="(owner: ContextUtil.this.ctx.universe.Symbol, prefix: String)ContextUtil.this.ctx.universe.TypeSymbol">newTypeVariable</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTCVariable.tc" title="ContextUtil.this.ctx.universe.TypeSymbol">tc</a>, <span title="String(&quot;x&quot;)" class="string">&quot;x&quot;</span><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.newTCVariable.tc" title="ContextUtil.this.ctx.universe.TypeSymbol">tc</a>.<span title="(tpe: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Symbol">setTypeSignature</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeParams: List[ContextUtil.this.ctx.universe.Symbol], resultType: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.PolyType">PolyType</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.newTCVariable.arg" title="ContextUtil.this.ctx.universe.TypeSymbol">arg</a> <a href="#sbt.appmacro;ContextUtil.newTCVariable.x$2" title="(x: ContextUtil.this.ctx.universe.TypeSymbol)List[ContextUtil.this.ctx.universe.TypeSymbol]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>, <a href="#sbt.appmacro;ContextUtil.emptyTypeBounds" title="=&gt; ContextUtil.this.ctx.universe.TypeBounds">emptyTypeBounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.newTCVariable.tc" title="ContextUtil.this.ctx.universe.TypeSymbol">tc</a>
    <span class="delimiter">}</span>
  <span class="comment">/** &gt;: Nothing &lt;: Any */</span>
  <span class="keyword">def</span> <a title="=&gt; ContextUtil.this.ctx.universe.TypeBounds" id="sbt.appmacro;ContextUtil.emptyTypeBounds">emptyTypeBounds</a>: <span title="ContextUtil.this.ctx.universe.TypeBounds">TypeBounds</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(lo: ContextUtil.this.ctx.universe.Type, hi: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.DefinitionsApi">definitions</a>.<span title="=&gt; ContextUtil.this.ctx.universe.ClassSymbol">NothingClass</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">toType</span>, <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.DefinitionsApi">definitions</a>.<span title="=&gt; ContextUtil.this.ctx.universe.ClassSymbol">AnyClass</span>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">toType</span><span class="delimiter">)</span>

  <span class="comment">/** Creates a new anonymous function symbol with Position `pos`. */</span>
  <span class="keyword">def</span> <a title="(pos: ContextUtil.this.ctx.universe.Position)ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.functionSymbol">functionSymbol</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Position" id="sbt.appmacro;ContextUtil.functionSymbol.pos">pos</a>: <span title="ContextUtil.this.ctx.universe.Position">Position</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> =
    <a href="#sbt.appmacro;ContextUtil.callsiteTyper" title="=&gt; ContextUtil.this.global.analyzer.Typer">callsiteTyper</a>.<span title="=&gt; ContextUtil.this.global.analyzer.Context">context</span>.<a title="ContextUtil.this.global.analyzer.global.Symbol" id="sbt.appmacro;ContextUtil.functionSymbol.qual$1">owner</a>.<a title="Long" id="sbt.appmacro;ContextUtil.functionSymbol.x$4">newAnonymousFunctionValue</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.functionSymbol.pos" title="ContextUtil.this.ctx.universe.Position">pos</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><a title="ContextUtil.this.global.Position" id="sbt.appmacro;ContextUtil.functionSymbol.x$3" class="delimiter">[</a>global.<span title="ContextUtil.this.global.Position">Position</span><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Symbol" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(args: List[ContextUtil.this.ctx.universe.Type], result: ContextUtil.this.ctx.universe.Type)ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.functionType">functionType</a><span class="delimiter">(</span><a title="List[ContextUtil.this.ctx.universe.Type]" id="sbt.appmacro;ContextUtil.functionType.args">args</a>: <span title="List[ContextUtil.this.ctx.universe.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.functionType.result">result</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.global.Type" id="sbt.appmacro;ContextUtil.functionType.tpe">tpe</a> = <a href="#sbt.appmacro;ContextUtil.global" title="=&gt; ContextUtil.this.powerContext.universe.type">global</a>.<span title="ContextUtil.this.global.definitions.type">definitions</span>.<span title="(formals: List[ContextUtil.this.global.Type], restpe: ContextUtil.this.global.Type)ContextUtil.this.global.Type">functionType</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.functionType.args" title="List[ContextUtil.this.ctx.universe.Type]">args</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[ContextUtil.this.global.Type]" class="delimiter">[</span><span title="List[ContextUtil.this.global.Type]">List</span><span class="delimiter">[</span>global.Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#sbt.appmacro;ContextUtil.functionType.result" title="ContextUtil.this.ctx.universe.Type">result</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Type" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Type">Type</span><span class="delimiter">]</span><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.functionType.tpe" title="ContextUtil.this.global.Type">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Type" class="delimiter">[</span><span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Create a Tree that references the `val` represented by `vd`, copying attributes from `replaced`. */</span>
  <span class="keyword">def</span> <a title="(replaced: ContextUtil.this.ctx.universe.Tree, vd: ContextUtil.this.ctx.universe.ValDef)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.refVal">refVal</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.refVal.replaced">replaced</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="ContextUtil.this.ctx.universe.ValDef" id="sbt.appmacro;ContextUtil.refVal.vd">vd</a>: <span title="ContextUtil.this.ctx.universe.ValDef">ValDef</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
    <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.TreeCopier">treeCopy</a>.<span title="(tree: ContextUtil.this.ctx.universe.Tree, name: ContextUtil.this.ctx.universe.Name)ContextUtil.this.ctx.universe.Ident">Ident</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.refVal.replaced" title="ContextUtil.this.ctx.universe.Tree">replaced</a>, <a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="=&gt; ContextUtil.this.ctx.universe.TermName">name</span><span class="delimiter">)</span>.<span title="(sym: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.Tree">setSymbol</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.refVal.vd" title="ContextUtil.this.ctx.universe.ValDef">vd</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Symbol">symbol</span><span class="delimiter">)</span>

  <span class="comment">/** Creates a Function tree using `functionSym` as the Symbol and changing `initialOwner` to `functionSym` in `body`.*/</span>
  <span class="keyword">def</span> <a title="(params: List[ContextUtil.this.ctx.universe.ValDef], body: ContextUtil.this.ctx.universe.Tree, functionSym: ContextUtil.this.ctx.universe.Symbol)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.createFunction">createFunction</a><span class="delimiter">(</span><a title="List[ContextUtil.this.ctx.universe.ValDef]" id="sbt.appmacro;ContextUtil.createFunction.params">params</a>: <span title="List[ContextUtil.this.ctx.universe.ValDef]">List</span><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.createFunction.body">body</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.createFunction.functionSym">functionSym</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
    <span class="delimiter">{</span>
      <a href="#sbt.appmacro;ContextUtil.changeOwner" title="(tree: ContextUtil.this.ctx.universe.Tree, prev: ContextUtil.this.ctx.universe.Symbol, next: ContextUtil.this.ctx.universe.Symbol)Unit">changeOwner</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.createFunction.body" title="ContextUtil.this.ctx.universe.Tree">body</a>, <a href="#sbt.appmacro;ContextUtil.initialOwner" title="=&gt; ContextUtil.this.ctx.universe.Symbol">initialOwner</a>, <a href="#sbt.appmacro;ContextUtil.createFunction.functionSym" title="ContextUtil.this.ctx.universe.Symbol">functionSym</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Function" id="sbt.appmacro;ContextUtil.createFunction.f">f</a> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(vparams: List[ContextUtil.this.ctx.universe.ValDef], body: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Function">Function</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.createFunction.params" title="List[ContextUtil.this.ctx.universe.ValDef]">params</a>, <a href="#sbt.appmacro;ContextUtil.createFunction.body" title="ContextUtil.this.ctx.universe.Tree">body</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.setSymbol" title="(t: ContextUtil.this.ctx.universe.Function, sym: ContextUtil.this.ctx.universe.Symbol)Unit">setSymbol</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.createFunction.f" title="ContextUtil.this.ctx.universe.Function">f</a>, <a href="#sbt.appmacro;ContextUtil.createFunction.functionSym" title="ContextUtil.this.ctx.universe.Symbol">functionSym</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.createFunction.f" title="ContextUtil.this.ctx.universe.Function">f</a>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tree: ContextUtil.this.ctx.universe.Tree, prev: ContextUtil.this.ctx.universe.Symbol, next: ContextUtil.this.ctx.universe.Symbol)Unit" id="sbt.appmacro;ContextUtil.changeOwner">changeOwner</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.changeOwner.tree">tree</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.changeOwner.prev">prev</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span>, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.changeOwner.next">next</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <span title="ContextUtil.this.ChangeOwnerAndModuleClassTraverser" class="keyword">new</span> <a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser" title="ContextUtil.this.ChangeOwnerAndModuleClassTraverser">ChangeOwnerAndModuleClassTraverser</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.changeOwner.prev" title="ContextUtil.this.ctx.universe.Symbol">prev</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Symbol" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Symbol">Symbol</span><span class="delimiter">]</span>, <a href="#sbt.appmacro;ContextUtil.changeOwner.next" title="ContextUtil.this.ctx.universe.Symbol">next</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Symbol" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Symbol">Symbol</span><span class="delimiter">]</span><span class="delimiter">)</span>.<a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.traverse" title="(tree: ContextUtil.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.changeOwner.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Tree" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Tree">Tree</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">// Workaround copied from scala/async:can be removed once https://github.com/scala/scala/pull/3179 is merged.</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">class</span> <a title="class ChangeOwnerAndModuleClassTraverser extends ContextUtil.this.global.ChangeOwnerTraverser" id="sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser">ChangeOwnerAndModuleClassTraverser</a><a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser" title="ContextUtil.this.ChangeOwnerAndModuleClassTraverser" class="delimiter">(</a><a title="ContextUtil.this.global.Symbol" id="sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.oldowner">oldowner</a>: global.<span title="ContextUtil.this.global.Symbol">Symbol</span>, <a title="ContextUtil.this.global.Symbol" id="sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.newowner">newowner</a>: global.<span title="ContextUtil.this.global.Symbol">Symbol</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#sbt.appmacro;ContextUtil.global" title="=&gt; ContextUtil.this.powerContext.universe.type">global</a>.<span title="ContextUtil.this.global.ChangeOwnerTraverser">ChangeOwnerTraverser</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.oldowner" title="ContextUtil.this.global.Symbol">oldowner</a>, <a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.newowner" title="ContextUtil.this.global.Symbol">newowner</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: ContextUtil.this.global.Tree)Unit" id="sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.traverse">traverse</a><span class="delimiter">(</span><a title="ContextUtil.this.global.Tree" id="sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.traverse.tree">tree</a>: global.<span title="ContextUtil.this.global.Tree">Tree</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.traverse.tree" title="ContextUtil.this.global.Tree">tree</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> _: global.<span title="ContextUtil.this.global.DefTree">DefTree</span> =&gt; <a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser" title="(sym: ContextUtil.this.global.Symbol)Unit">change</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.traverse.tree" title="ContextUtil.this.global.Tree">tree</a>.<span title="=&gt; ContextUtil.this.global.Symbol">symbol</span>.<span title="=&gt; ContextUtil.this.global.Symbol">moduleClass</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _                 =&gt;
      <span class="delimiter">}</span>
      <a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser" title="ContextUtil.this.ChangeOwnerAndModuleClassTraverser" class="keyword">super</a>.<span title="(tree: ContextUtil.this.global.Tree)Unit">traverse</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil;ChangeOwnerAndModuleClassTraverser.traverse.tree" title="ContextUtil.this.global.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns the Symbol that references the statically accessible singleton `i`. */</span>
  <span class="keyword">def</span> <a title="[T &lt;: Singleton](i: T)(implicit it: ContextUtil.this.ctx.TypeTag[i.type])ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.singleton">singleton</a><span class="delimiter">[</span><a title=" &lt;: Singleton" id="sbt.appmacro;ContextUtil.singleton;T">T</a> &lt;: AnyRef <span class="keyword">with</span> Singleton<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt.appmacro;ContextUtil.singleton.i">i</a>: <a href="#sbt.appmacro;ContextUtil.singleton;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ContextUtil.this.ctx.TypeTag[i.type]" id="sbt.appmacro;ContextUtil.singleton.it">it</a>: ctx.<span title="ContextUtil.this.ctx.TypeTag[i.type]">TypeTag</span><span class="delimiter">[</span>i.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> =
    <a href="#sbt.appmacro;ContextUtil.singleton.it" title="ContextUtil.this.ctx.TypeTag[i.type]">it</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span> <span title="ContextUtil.this.ctx.universe.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="(tpe: ContextUtil.this.ctx.universe.SingleType)Option[(ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Symbol)]">SingleType</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.SingleType]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.singleton.sym">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#sbt.appmacro;ContextUtil.singleton.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="=&gt; Boolean">isFreeTerm</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.singleton.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>.<span title="=&gt; Boolean">isStatic</span> =&gt; <a href="#sbt.appmacro;ContextUtil.singleton.sym" title="ContextUtil.this.ctx.universe.Symbol">sym</a>
      <span class="keyword">case</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.singleton.x">x</a> =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Instance must be static (was &quot;)" class="string">&quot;Instance must be static (was &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.singleton.x" title="ContextUtil.this.ctx.universe.Type">x</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;).&quot;)" class="string">&quot;).&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(t: ContextUtil.this.ctx.universe.Tree, name: String)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.select">select</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.select.t">t</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="String" id="sbt.appmacro;ContextUtil.select.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> = <a href="#sbt.appmacro;ContextUtil.ctx" title="(qualifier: ContextUtil.this.ctx.universe.Tree, name: ContextUtil.this.ctx.universe.Name)ContextUtil.this.ctx.universe.Select">Select</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.select.t" title="ContextUtil.this.ctx.universe.Tree">t</a>, <a href="#sbt.appmacro;ContextUtil.ctx" title="(s: String)ContextUtil.this.ctx.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.select.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Returns the symbol for the non-private method named `name` for the class/module `obj`. */</span>
  <span class="keyword">def</span> <a title="(obj: ContextUtil.this.ctx.universe.Symbol, name: String)ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.method">method</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Symbol" id="sbt.appmacro;ContextUtil.method.obj">obj</a>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span>, <a title="String" id="sbt.appmacro;ContextUtil.method.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.method.ts">ts</a>: <span title="ContextUtil.this.ctx.universe.Type">Type</span> = <a href="#sbt.appmacro;ContextUtil.method.obj" title="ContextUtil.this.ctx.universe.Symbol">obj</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">typeSignature</span>
    <span class="keyword">val</span> <a title="ContextUtil.this.global.Symbol" id="sbt.appmacro;ContextUtil.method.m">m</a>: global.<span title="ContextUtil.this.global.Symbol">Symbol</span> = <a href="#sbt.appmacro;ContextUtil.method.ts" title="ContextUtil.this.ctx.universe.Type">ts</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Type" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Type">Type</span><span class="delimiter">]</span>.<span title="(name: ContextUtil.this.global.Name)ContextUtil.this.global.Symbol">nonPrivateMember</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.global" title="=&gt; ContextUtil.this.powerContext.universe.type">global</a>.<span title="(s: String)ContextUtil.this.global.TermName">newTermName</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.method.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#sbt.appmacro;ContextUtil.method.m" title="ContextUtil.this.global.Symbol">m</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Symbol" class="delimiter">[</span><span title="ContextUtil.this.ctx.universe.Symbol">Symbol</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a Type representing the type constructor tcp.&lt;name&gt;.  For example, given
   *  `object Demo { type M[x] = List[x] }`, the call `extractTC(Demo, &quot;M&quot;)` will return a type representing
   * the type constructor `[x] List[x]`.
   */</span>
  <span class="keyword">def</span> <a title="(tcp: Singleton, name: String)(implicit it: ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type])ContextUtil.this.ctx.Type" id="sbt.appmacro;ContextUtil.extractTC">extractTC</a><span class="delimiter">(</span><a title="ContextUtil extends AnyRef with Singleton" id="sbt.appmacro;ContextUtil.extractTC.tcp">tcp</a>: <a href="#sbt.appmacro;ContextUtil;<refinement>" title="ContextUtil extends AnyRef with Singleton">AnyRef</a> <span class="keyword">with</span> Singleton, <a title="String" id="sbt.appmacro;ContextUtil.extractTC.name">name</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type]" id="sbt.appmacro;ContextUtil.extractTC.it">it</a>: ctx.<span title="ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type]">TypeTag</span><span class="delimiter">[</span>tcp.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: ctx.<span title="ContextUtil.this.ctx.Type">Type</span> =
    <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.global.Type" id="sbt.appmacro;ContextUtil.extractTC.itTpe">itTpe</a> = <a href="#sbt.appmacro;ContextUtil.extractTC.it" title="ContextUtil.this.ctx.TypeTag[sbt.appmacro.ContextUtil.&lt;refinement&gt;.type]">it</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.global.Type" class="delimiter">[</span>global.<span title="ContextUtil.this.global.Type">Type</span><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.global.Symbol" id="sbt.appmacro;ContextUtil.extractTC.m">m</a> = <a href="#sbt.appmacro;ContextUtil.extractTC.itTpe" title="ContextUtil.this.global.Type">itTpe</a>.<span title="(name: ContextUtil.this.global.Name)ContextUtil.this.global.Symbol">nonPrivateMember</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.global" title="=&gt; ContextUtil.this.powerContext.universe.type">global</a>.<span title="(s: String)ContextUtil.this.global.TypeName">newTypeName</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="ContextUtil.this.ctx.universe.Type" id="sbt.appmacro;ContextUtil.extractTC.tc">tc</a> = <a href="#sbt.appmacro;ContextUtil.extractTC.itTpe" title="ContextUtil.this.global.Type">itTpe</a>.<span title="(sym: ContextUtil.this.global.Symbol)ContextUtil.this.global.Type">memberInfo</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.m" title="ContextUtil.this.global.Symbol">m</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ContextUtil.this.ctx.universe.Type" class="delimiter">[</span>ctx.universe.<span title="ContextUtil.this.ctx.universe.Type">Type</span><span class="delimiter">]</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; ContextUtil.this.ctx.universe.Type">NoType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a>.<span title="=&gt; Boolean">takesTypeArgs</span>, <span title="String(&quot;Invalid type constructor: &quot;)" class="string">&quot;Invalid type constructor: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a><span class="delimiter">)</span>
      <a href="#sbt.appmacro;ContextUtil.extractTC.tc" title="ContextUtil.this.ctx.universe.Type">tc</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Substitutes wrappers in tree `t` with the result of `subWrapper`.
   * A wrapper is a Tree of the form `f[T](v)` for which isWrapper(&lt;Tree of f&gt;, &lt;Underlying Type&gt;, &lt;qual&gt;.target) returns true.
   * Typically, `f` is a `Select` or `Ident`.
   * The wrapper is replaced with the result of `subWrapper(&lt;Type of T&gt;, &lt;Tree of v&gt;, &lt;wrapper Tree&gt;)`
   */</span>
  <span class="keyword">def</span> <a title="(t: ContextUtil.this.ctx.universe.Tree, subWrapper: (String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[ContextUtil.this.ctx.type])ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers">transformWrappers</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers.t">t</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span>, <a title="(String, ContextUtil.this.ctx.universe.Type, ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Tree) =&gt; sbt.appmacro.Converted[ContextUtil.this.ctx.type]" id="sbt.appmacro;ContextUtil.transformWrappers.subWrapper">subWrapper</a>: <span class="delimiter">(</span>String, Type, Tree, Tree<span class="delimiter">)</span> =&gt; Converted<span class="delimiter">[</span>ctx.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
    <span class="delimiter">{</span>
      <span class="comment">// the main tree transformer that replaces calls to InputWrapper.wrap(x) with</span>
      <span class="comment">//  plain Idents that reference the actual input value</span>
      <span class="keyword">object</span> <a title="appTransformer.type" id="sbt.appmacro;ContextUtil.transformWrappers.appTransformer">appTransformer</a> <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer" title="appTransformer.type" class="keyword">extends</a> <a href="#sbt.appmacro;ContextUtil.ctx" title="ContextUtil.this.ctx.universe.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform">transform</a><span class="delimiter">(</span><a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree">tree</a>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="ContextUtil.this.ctx.universe.Tree">Tree</span> =
          <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a> <span title="ContextUtil.this.ctx.universe.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#sbt.appmacro;ContextUtil.ctx" title="(apply: ContextUtil.this.ctx.universe.Apply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">ApplyTree</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Apply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(typeApply: ContextUtil.this.ctx.universe.TypeApply)Option[(ContextUtil.this.ctx.universe.Tree, List[ContextUtil.this.ctx.universe.Tree])]">TypeApply</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.TypeApply]" class="delimiter">(</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(select: ContextUtil.this.ctx.universe.Select)Option[(ContextUtil.this.ctx.universe.Tree, ContextUtil.this.ctx.universe.Name)]">Select</a><a href="#sbt.appmacro;ContextUtil.ctx" title="(x: Any)Option[ContextUtil.this.ctx.universe.Select]" class="delimiter">(</a>_, <a title="ContextUtil.this.ctx.universe.Name" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.nme">nme</a><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.targ">targ</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a title="ContextUtil.this.ctx.universe.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.qual">qual</a> :: <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt;
              <a href="#sbt.appmacro;ContextUtil.transformWrappers.subWrapper" title="(v1: String, v2: ContextUtil.this.ctx.universe.Type, v3: ContextUtil.this.ctx.universe.Tree, v4: ContextUtil.this.ctx.universe.Tree)sbt.appmacro.Converted[ContextUtil.this.ctx.type]">subWrapper</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.nme" title="ContextUtil.this.ctx.universe.Name">nme</a>.<span title="=&gt; String">decoded</span>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.targ" title="ContextUtil.this.ctx.universe.Tree">targ</a>.<span title="=&gt; ContextUtil.this.ctx.universe.Type">tpe</span>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span> <span title="ContextUtil.this.ctx.universe.Tree" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> Converted.Success<span class="delimiter">(</span><a title="ContextUtil.this.ctx.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.t">t</a>, <a title="ContextUtil.this.ctx.Tree =&gt; ContextUtil.this.ctx.Tree" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.finalTx">finalTx</a><span class="delimiter">)</span> =&gt;
                  <a href="#sbt.appmacro;ContextUtil.changeOwner" title="(tree: ContextUtil.this.ctx.universe.Tree, prev: ContextUtil.this.ctx.universe.Symbol, next: ContextUtil.this.ctx.universe.Symbol)Unit">changeOwner</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.qual" title="ContextUtil.this.ctx.universe.Tree">qual</a>, <span title="=&gt; ContextUtil.this.ctx.universe.Symbol">currentOwner</span>, <a href="#sbt.appmacro;ContextUtil.initialOwner" title="=&gt; ContextUtil.this.ctx.universe.Symbol">initialOwner</a><span class="delimiter">)</span> <span class="comment">// Fixes https://github.com/sbt/sbt/issues/1150</span>
                  <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.finalTx" title="(v1: ContextUtil.this.ctx.Tree)ContextUtil.this.ctx.Tree">finalTx</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.t" title="ContextUtil.this.ctx.Tree">t</a><span class="delimiter">)</span>
                <span class="keyword">case</span> Converted.Failure<span class="delimiter">(</span><a title="ContextUtil.this.ctx.Position" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.p">p</a>, <a title="String" id="sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.m">m</a><span class="delimiter">)</span>       =&gt; <a href="#sbt.appmacro;ContextUtil.ctx" title="=&gt; C">ctx</a>.<span title="(pos: ContextUtil.this.ctx.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.p" title="ContextUtil.this.ctx.Position">p</a>, <a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.m" title="String">m</a><span class="delimiter">)</span>
                <span class="keyword">case</span> _: Converted.<a href="Convert.scala.html#sbt.appmacro.Converted;NotApplicable" title="sbt.appmacro.Converted.NotApplicable[_]">NotApplicable</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span class="keyword">super</span>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">transform</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> _ =&gt; <span class="keyword">super</span>.<span title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">transform</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform.tree" title="ContextUtil.this.ctx.universe.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#sbt.appmacro;ContextUtil.transformWrappers.appTransformer" title="appTransformer.type">appTransformer</a>.<span title="(owner: ContextUtil.this.ctx.universe.Symbol)(trans: =&gt; ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">atOwner</span><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.initialOwner" title="=&gt; ContextUtil.this.ctx.universe.Symbol">initialOwner</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#sbt.appmacro;ContextUtil.transformWrappers.appTransformer" title="appTransformer.type">appTransformer</a>.<a href="#sbt.appmacro;ContextUtil.transformWrappers;appTransformer.transform" title="(tree: ContextUtil.this.ctx.universe.Tree)ContextUtil.this.ctx.universe.Tree">transform</a><span class="delimiter">(</span><a href="#sbt.appmacro;ContextUtil.transformWrappers.t" title="ContextUtil.this.ctx.universe.Tree">t</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
