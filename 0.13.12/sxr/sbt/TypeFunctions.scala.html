<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/TypeFunctions.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2010 Mark Harrah
 */</span>
<span class="keyword">package</span> sbt

<span class="keyword">trait</span> <a title="trait TypeFunctions extends AnyRef" id="sbt;TypeFunctions">TypeFunctions</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">type</span> <a title="[X]X" id="sbt;TypeFunctions;Id">Id</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Id;X">X</a><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;Id;X" title="X">X</a>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Const[A] extends AnyRef" id="sbt;TypeFunctions;Const">Const</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Const;A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[B]A" id="sbt;TypeFunctions;Const;Apply">Apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Const;Apply;B">B</a><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;Const;A" title="A">A</a> <span class="delimiter">}</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ConstK[A] extends AnyRef" id="sbt;TypeFunctions;ConstK">ConstK</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;ConstK;A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[L[x]]A" id="sbt;TypeFunctions;ConstK;l">l</a><span class="delimiter">[</span><a title="[x]" id="sbt;TypeFunctions;ConstK;l;L">L</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;ConstK;l;L;x">x</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;ConstK;A" title="A">A</a> <span class="delimiter">}</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Compose[A[_], B[_]] extends AnyRef" id="sbt;TypeFunctions;Compose">Compose</a><span class="delimiter">[</span><a title="[_]" id="sbt;TypeFunctions;Compose;A">A</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Compose;A;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;TypeFunctions;Compose;B">B</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Compose;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[T]A[B[T]]" id="sbt;TypeFunctions;Compose;Apply">Apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Compose;Apply;T">T</a><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;Compose;A" title="A[B[T]]">A</a><span class="delimiter">[</span>B<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ∙[A[_], B[_]] extends AnyRef" id="sbt;TypeFunctions;∙">∙</a><span class="delimiter">[</span><a title="[_]" id="sbt;TypeFunctions;∙;A">A</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;∙;A;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;TypeFunctions;∙;B">B</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;∙;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[T]A[B[T]]" id="sbt;TypeFunctions;∙;l">l</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;∙;l;T">T</a><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;∙;A" title="A[B[T]]">A</a><span class="delimiter">[</span>B<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">}</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait P1of2[M[_, _], A] extends AnyRef" id="sbt;TypeFunctions;P1of2">P1of2</a><span class="delimiter">[</span><a title="[_, _]" id="sbt;TypeFunctions;P1of2;M">M</a><span class="delimiter">[</span><span title="">_</span>, <span title="">_</span><span class="delimiter">]</span>, <a title="" id="sbt;TypeFunctions;P1of2;A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="[B]M[A,B]" id="sbt;TypeFunctions;P1of2;Apply">Apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;P1of2;Apply;B">B</a><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;P1of2;M" title="M[A,B]">M</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>; <span class="keyword">type</span> <a title="[B]M[B,A]" id="sbt;TypeFunctions;P1of2;Flip">Flip</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;P1of2;Flip;B">B</a><span class="delimiter">]</span> = <a href="#sbt;TypeFunctions;P1of2;M" title="M[B,A]">M</a><span class="delimiter">[</span>B, A<span class="delimiter">]</span> <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="left extends AnyRef with sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Left[B,Nothing]]" id="sbt;TypeFunctions.left">left</a> = <a href="#sbt;TypeFunctions.left;$anon" title="sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Left[B,Nothing]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Left[B,Nothing]]" id="sbt;TypeFunctions.left;$anon" class="delimiter">(</a>Id <a href="#sbt;~>" title="sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Left[B,Nothing]]">~&gt;</a> P1of2<span class="delimiter">[</span>Left, Nothing<span class="delimiter">]</span>#Flip<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](t: T)scala.util.Left[T,Nothing]" id="sbt;TypeFunctions.left;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.left;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt;TypeFunctions.left;$anon.apply.t">t</a>: <a href="#sbt;TypeFunctions.left;$anon.apply;T" title="T">T</a><span class="delimiter">)</span> = <span title="(a: T)scala.util.Left[T,Nothing]">Left</span><span class="delimiter">(</span><a href="#sbt;TypeFunctions.left;$anon.apply.t" title="T">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="right extends AnyRef with sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Right[Nothing,B]]" id="sbt;TypeFunctions.right">right</a> = <a href="#sbt;TypeFunctions.right;$anon" title="sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Right[Nothing,B]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Right[Nothing,B]]" id="sbt;TypeFunctions.right;$anon" class="delimiter">(</a>Id <a href="#sbt;~>" title="sbt.~&gt;[TypeFunctions.this.Id,[B]scala.util.Right[Nothing,B]]">~&gt;</a> P1of2<span class="delimiter">[</span>Right, Nothing<span class="delimiter">]</span>#Apply<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](t: T)scala.util.Right[Nothing,T]" id="sbt;TypeFunctions.right;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.right;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt;TypeFunctions.right;$anon.apply.t">t</a>: <a href="#sbt;TypeFunctions.right;$anon.apply;T" title="T">T</a><span class="delimiter">)</span> = <span title="(b: T)scala.util.Right[Nothing,T]">Right</span><span class="delimiter">(</span><a href="#sbt;TypeFunctions.right;$anon.apply.t" title="T">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="some extends AnyRef with sbt.~&gt;[TypeFunctions.this.Id,Some]" id="sbt;TypeFunctions.some">some</a> = <a href="#sbt;TypeFunctions.some;$anon" title="sbt.~&gt;[TypeFunctions.this.Id,Some]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[TypeFunctions.this.Id,Some]" id="sbt;TypeFunctions.some;$anon" class="delimiter">(</a>Id <a href="#sbt;~>" title="sbt.~&gt;[TypeFunctions.this.Id,Some]">~&gt;</a> Some<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](t: T)Some[T]" id="sbt;TypeFunctions.some;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.some;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt;TypeFunctions.some;$anon.apply.t">t</a>: <a href="#sbt;TypeFunctions.some;$anon.apply;T" title="T">T</a><span class="delimiter">)</span> = <span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#sbt;TypeFunctions.some;$anon.apply.t" title="T">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T]=&gt; T =&gt; T" id="sbt;TypeFunctions.idFun">idFun</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.idFun;T">T</a><span class="delimiter">]</span> = <span class="delimiter">(</span>t: <a href="#sbt;TypeFunctions.idFun;T" title="T">T</a><span class="delimiter">)</span> =&gt; <a href="#sbt;TypeFunctions.idFun.$anonfun.t" title="T">t</a>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B](b: B)A =&gt; B" id="sbt;TypeFunctions.const">const</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.const;A">A</a>, <a title="" id="sbt;TypeFunctions.const;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="sbt;TypeFunctions.const.b">b</a>: <a href="#sbt;TypeFunctions.const;B" title="B">B</a><span class="delimiter">)</span>: A =&gt; B = <a title="A" id="sbt;TypeFunctions.const.$anonfun.x$1">_</a> =&gt; <a href="#sbt;TypeFunctions.const.b" title="B">b</a>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[M[_]]=&gt; sbt.~&gt;[M,M]" id="sbt;TypeFunctions.idK">idK</a><span class="delimiter">[</span><a title="[_]" id="sbt;TypeFunctions.idK;M">M</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.idK;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span>: M <a href="#sbt;~>" title="sbt.~&gt;[M,M]">~&gt;</a> M = <a href="#sbt;TypeFunctions.idK;$anon" title="sbt.~&gt;[M,M]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[M,M]" id="sbt;TypeFunctions.idK;$anon" class="delimiter">(</a>M <a href="#sbt;~>" title="sbt.~&gt;[M,M]">~&gt;</a> M<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](m: M[T])M[T]" id="sbt;TypeFunctions.idK;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.idK;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[T]" id="sbt;TypeFunctions.idK;$anon.apply.m">m</a>: <a href="#sbt;TypeFunctions.idK;M" title="M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;TypeFunctions.idK;M" title="M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#sbt;TypeFunctions.idK;$anon.apply.m" title="M[T]">m</a> <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[M[_], N[_], G[_]](f: sbt.~&gt;[M,N])sbt.~&gt;[[T]M[G[T]],[T]N[G[T]]]" id="sbt;TypeFunctions.nestCon">nestCon</a><span class="delimiter">[</span><a title="[_]" id="sbt;TypeFunctions.nestCon;M">M</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.nestCon;M;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;TypeFunctions.nestCon;N">N</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.nestCon;N;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;TypeFunctions.nestCon;G">G</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.nestCon;G;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[M,N]" id="sbt;TypeFunctions.nestCon.f">f</a>: M <a href="#sbt;~>" title="sbt.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span>: <span class="delimiter">(</span>M ∙ G<span class="delimiter">)</span>#l <a href="#sbt;~>" title="sbt.~&gt;[[T]M[G[T]],[T]N[G[T]]]">~&gt;</a> <span class="delimiter">(</span>N ∙ G<span class="delimiter">)</span>#l =
    <a href="#sbt;TypeFunctions.nestCon.f" title="sbt.~&gt;[M,N]">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="sbt.~&gt;[[T]M[G[T]],[T]N[G[T]]]" class="delimiter">[</span><span class="delimiter">(</span>M ∙ G<span class="delimiter">)</span>#l <a href="#sbt;~>" title="sbt.~&gt;[[T]M[G[T]],[T]N[G[T]]]">~&gt;</a> <span class="delimiter">(</span>N ∙ G<span class="delimiter">)</span>#l<span class="delimiter">]</span> <span class="comment">// implemented with a cast to avoid extra object+method call.  castless version:</span>
  <span class="comment">/* new ( (M ∙ G)#l ~&gt; (N ∙ G)#l ) {
		def apply[T](mg: M[G[T]]): N[G[T]] = f(mg)
	}*/</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A, B](f: A =&gt; B)sbt.Fn1[A,B]" id="sbt;TypeFunctions.toFn1">toFn1</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.toFn1;A">A</a>, <a title="" id="sbt;TypeFunctions.toFn1;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="sbt;TypeFunctions.toFn1.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#sbt;Fn1" title="sbt.Fn1[A,B]">Fn1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="#sbt;TypeFunctions.toFn1;$anon" title="sbt.Fn1[A,B]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.Fn1[A,B]" id="sbt;TypeFunctions.toFn1;$anon">Fn1</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[C](g: C =&gt; A)C =&gt; B" id="sbt;TypeFunctions.toFn1;$anon.∙">∙</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions.toFn1;$anon.∙;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C =&gt; A" id="sbt;TypeFunctions.toFn1;$anon.∙.g">g</a>: C =&gt; A<span class="delimiter">)</span> = <a href="#sbt;TypeFunctions.toFn1.f" title="A =&gt; B">f</a> <span title="(g: C =&gt; A)C =&gt; B">compose</span> <a href="#sbt;TypeFunctions.toFn1;$anon.∙.g" title="C =&gt; A">g</a>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[T]T =&gt; T" id="sbt;TypeFunctions;Endo">Endo</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;Endo;T">T</a><span class="delimiter">]</span> = T =&gt; T
  <span class="keyword">type</span> <a title="[A[_], B[_]]sbt.~&gt;[A,[T]Option[B[T]]]" id="sbt;TypeFunctions;~>|">~&gt;|</a><span class="delimiter">[</span><a title="[_]" id="sbt;TypeFunctions;~>|;A">A</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;~>|;A;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="sbt;TypeFunctions;~>|;B">B</a><span class="delimiter">[</span><a title="" id="sbt;TypeFunctions;~>|;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = A <a href="#sbt;~>" title="sbt.~&gt;[A,[T]Option[B[T]]]">~&gt;</a> Compose<span class="delimiter">[</span>Option, B<span class="delimiter">]</span>#Apply
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.TypeFunctions.type" id="sbt.TypeFunctions">TypeFunctions</a> <a href="#sbt.TypeFunctions" title="sbt.TypeFunctions.type" class="keyword">extends</a> <a href="#sbt;TypeFunctions" title="sbt.TypeFunctions">TypeFunctions</a>

<span class="keyword">trait</span> <a title="trait ~&gt;[-A[_], +B[_]] extends AnyRef" id="sbt;~>">~&gt;</a><span class="delimiter">[</span>-<a title="[_]" id="sbt;~>;A">A</a><span class="delimiter">[</span><a title="" id="sbt;~>;A;_">_</a><span class="delimiter">]</span>, +<a title="[_]" id="sbt;~>;B">B</a><span class="delimiter">[</span><a title="" id="sbt;~>;B;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span> outer =&gt;
  <span class="keyword">def</span> <a title="[T](a: A[T])B[T]" id="sbt;~>.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;~>.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A[T]" id="sbt;~>.apply.a">a</a>: <a href="#sbt;~>;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#sbt;~>;B" title="B[T]">B</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  <span class="comment">// directly on ~&gt; because of type inference limitations</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[C[_]](g: sbt.~&gt;[C,A])sbt.~&gt;[C,B]" id="sbt;~>.∙(ddc0ac6381)">∙</a><span class="delimiter">[</span><a title="[_]" id="sbt;~>.∙(ddc0ac6381);C">C</a><span class="delimiter">[</span><a title="" id="sbt;~>.∙(ddc0ac6381);C;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.~&gt;[C,A]" id="sbt;~>.∙(ddc0ac6381).g">g</a>: C <a href="#sbt;~>" title="sbt.~&gt;[C,A]">~&gt;</a> A<span class="delimiter">)</span>: C <a href="#sbt;~>" title="sbt.~&gt;[C,B]">~&gt;</a> B = <a href="#sbt;~>.∙(ddc0ac6381);$anon" title="sbt.~&gt;[C,B]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[C,B]" id="sbt;~>.∙(ddc0ac6381);$anon" class="delimiter">(</a>C <a href="#sbt;~>" title="sbt.~&gt;[C,B]">~&gt;</a> B<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](c: C[T])B[T]" id="sbt;~>.∙(ddc0ac6381);$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt;~>.∙(ddc0ac6381);$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C[T]" id="sbt;~>.∙(ddc0ac6381);$anon.apply.c">c</a>: <a href="#sbt;~>.∙(ddc0ac6381);C" title="C[T]">C</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#sbt;~>" title="~&gt;.this.type">outer</a>.<a href="#sbt;~>.apply" title="(a: A[T])B[T]">apply</a><span class="delimiter">(</span><a href="#sbt;~>.apply" title="(a: C[T])A[T]">g</a><span class="delimiter">(</span><a href="#sbt;~>.∙(ddc0ac6381);$anon.apply.c" title="C[T]">c</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[C, D](g: C =&gt; D)(implicit ev: &lt;:&lt;[D,A[D]])C =&gt; B[D]" id="sbt;~>.∙(3ac26a5aef)">∙</a><span class="delimiter">[</span><a title="" id="sbt;~>.∙(3ac26a5aef);C">C</a>, <a title="" id="sbt;~>.∙(3ac26a5aef);D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C =&gt; D" id="sbt;~>.∙(3ac26a5aef).g">g</a>: C =&gt; D<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="&lt;:&lt;[D,A[D]]" id="sbt;~>.∙(3ac26a5aef).ev">ev</a>: D <span title="&lt;:&lt;[D,A[D]]">&lt;:&lt;</span> A<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>: C =&gt; B<span class="delimiter">[</span>D<span class="delimiter">]</span> = <a title="C" id="sbt;~>.∙(3ac26a5aef).$anonfun.i">i</a> =&gt; <a href="#sbt;~>.apply" title="(a: A[D])B[D]">apply</a><span class="delimiter">(</span><a href="#sbt;~>.∙(3ac26a5aef).ev" title="(v1: D)A[D]">ev</a><span class="delimiter">(</span><a href="#sbt;~>.∙(3ac26a5aef).g" title="(v1: C)D">g</a><span class="delimiter">(</span><a href="#sbt;~>.∙(3ac26a5aef).$anonfun.i" title="C">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T]=&gt; A[T] =&gt; B[T]" id="sbt;~>.fn">fn</a><span class="delimiter">[</span><a title="" id="sbt;~>.fn;T">T</a><span class="delimiter">]</span> = <span class="delimiter">(</span>t: <a href="#sbt;~>;A" title="A[T]">A</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#sbt;~>.apply" title="[T](a: A[T])B[T]">apply</a><span title="(a: A[T])B[T]" class="delimiter">[</span><a href="#sbt;~>.fn;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#sbt;~>.fn.$anonfun.t" title="A[T]">t</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.~&gt;.type" id="sbt.~>">~&gt;</a> <a href="#sbt.~>" title="sbt.~&gt;.type" class="delimiter">{</a>
  <span class="keyword">import</span> <a href="#sbt.TypeFunctions" title="sbt.TypeFunctions.type">TypeFunctions</a>._
  <span class="keyword">val</span> <a title="sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]" id="sbt.~>.Id">Id</a>: Id <a href="#sbt;~>" title="sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]">~&gt;</a> Id = <a href="#sbt.~>.Id;$anon" title="sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]" id="sbt.~>.Id;$anon" class="delimiter">(</a>Id <a href="#sbt;~>" title="sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]">~&gt;</a> Id<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="[T](a: T)T" id="sbt.~>.Id;$anon.apply">apply</a><span class="delimiter">[</span><a title="" id="sbt.~>.Id;$anon.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="sbt.~>.Id;$anon.apply.a">a</a>: <a href="#sbt.~>.Id;$anon.apply;T" title="T">T</a><span class="delimiter">)</span>: <a href="#sbt.~>.Id;$anon.apply;T" title="T">T</a> = <a href="#sbt.~>.Id;$anon.apply.a" title="T">a</a> <span class="delimiter">}</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]" id="sbt.~>.tcIdEquals">tcIdEquals</a>: <span class="delimiter">(</span>Id <a href="#sbt;~>" title="sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]">~&gt;</a> Id<span class="delimiter">)</span> = <a href="#sbt.~>.Id" title="=&gt; sbt.~&gt;[sbt.TypeFunctions.Id,sbt.TypeFunctions.Id]">Id</a>
<span class="delimiter">}</span>
<span title="AnyRef" class="keyword">trait</span> <a title="trait Fn1[A, B] extends AnyRef" id="sbt;Fn1">Fn1</a><span class="delimiter">[</span><a title="" id="sbt;Fn1;A">A</a>, <a title="" id="sbt;Fn1;B">B</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[C](g: C =&gt; A)C =&gt; B" id="sbt;Fn1.∙">∙</a><span class="delimiter">[</span><a title="" id="sbt;Fn1.∙;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C =&gt; A" id="sbt;Fn1.∙.g">g</a>: C =&gt; A<span class="delimiter">)</span>: C =&gt; B
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
