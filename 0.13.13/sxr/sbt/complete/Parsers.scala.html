<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/complete/Parsers.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* sbt -- Simple Build Tool
 * Copyright 2011  Mark Harrah
 */</span>
<span class="keyword">package</span> sbt.complete

<span class="keyword">import</span> <a href="Parser.scala.html#sbt.complete.Parser" title="sbt.complete.Parser.type">Parser</a>._
<span class="keyword">import</span> java.io.File
<span class="keyword">import</span> java.net.URI
<span class="keyword">import</span> java.lang.<span title="Character.type">Character</span>.<span class="delimiter">{</span> getType, MATH_SYMBOL, OTHER_SYMBOL, DASH_PUNCTUATION, OTHER_PUNCTUATION, MODIFIER_SYMBOL, CURRENCY_SYMBOL <span class="delimiter">}</span>

<span class="comment">/** Provides standard implementations of commonly useful [[Parser]]s. */</span>
<span class="keyword">trait</span> <a title="trait Parsers extends AnyRef" id="sbt.complete;Parsers">Parsers</a> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/** Matches the end of input, providing no useful result on success. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Unit]" id="sbt.complete;Parsers.EOF">EOF</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.not(bfcd18eaec)" title="(p: sbt.complete.Parser[_])sbt.complete.Parser[Unit]">not</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.any" title="=&gt; sbt.complete.Parser[Char]">any</a><span class="delimiter">)</span>

  <span class="comment">/** Parses any single character and provides that character as the result. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.any">any</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.any.$anonfun.x$1">_</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>, <span title="String(&quot;any character&quot;)" class="string">&quot;any character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Set that contains each digit in a String representation.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[String]" id="sbt.complete;Parsers.DigitSet">DigitSet</a> = <span title="(elems: String*)scala.collection.immutable.Set[String]">Set</span><span class="delimiter">(</span><span title="String(&quot;0&quot;)" class="string">&quot;0&quot;</span>, <span title="String(&quot;1&quot;)" class="string">&quot;1&quot;</span>, <span title="String(&quot;2&quot;)" class="string">&quot;2&quot;</span>, <span title="String(&quot;3&quot;)" class="string">&quot;3&quot;</span>, <span title="String(&quot;4&quot;)" class="string">&quot;4&quot;</span>, <span title="String(&quot;5&quot;)" class="string">&quot;5&quot;</span>, <span title="String(&quot;6&quot;)" class="string">&quot;6&quot;</span>, <span title="String(&quot;7&quot;)" class="string">&quot;7&quot;</span>, <span title="String(&quot;8&quot;)" class="string">&quot;8&quot;</span>, <span title="String(&quot;9&quot;)" class="string">&quot;9&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses any single digit and provides that digit as a Char as the result.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.Digit">Digit</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="sbt.complete.RichParser[Char] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;Parsers.Digit.qual$1" class="delimiter">(</a><a href="#sbt.complete;Parsers.Digit.qual$1.$anonfun.x$2" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">_</a>.<span title="=&gt; Boolean">isDigit</span>, <span title="String(&quot;digit&quot;)" class="string">&quot;digit&quot;</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.examples$default$2" title="Boolean" id="sbt.complete;Parsers.Digit.x$17">examples</a> <a href="#sbt.complete;Parsers.DigitSet" title="scala.collection.immutable.Set[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;Parsers.Digit.x$16">DigitSet</a>

  <span class="comment">/** Set containing Chars for hexadecimal digits 0-9 and A-F (but not a-f). */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Char]" id="sbt.complete;Parsers.HexDigitSet">HexDigitSet</a> = <span title="(elems: Char*)scala.collection.immutable.Set[Char]">Set</span><span class="delimiter">(</span><span title="Char('0')" class="char">'0'</span>, <span title="Char('1')" class="char">'1'</span>, <span title="Char('2')" class="char">'2'</span>, <span title="Char('3')" class="char">'3'</span>, <span title="Char('4')" class="char">'4'</span>, <span title="Char('5')" class="char">'5'</span>, <span title="Char('6')" class="char">'6'</span>, <span title="Char('7')" class="char">'7'</span>, <span title="Char('8')" class="char">'8'</span>, <span title="Char('9')" class="char">'9'</span>, <span title="Char('A')" class="char">'A'</span>, <span title="Char('B')" class="char">'B'</span>, <span title="Char('C')" class="char">'C'</span>, <span title="Char('D')" class="char">'D'</span>, <span title="Char('E')" class="char">'E'</span>, <span title="Char('F')" class="char">'F'</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a single hexadecimal digit (0-9, a-f, A-F). */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.HexDigit">HexDigit</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="sbt.complete.RichParser[Char] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;Parsers.HexDigit.qual$3" class="delimiter">(</a><a title="Char" id="sbt.complete;Parsers.HexDigit.qual$3.$anonfun.c">c</a> =&gt; <a href="#sbt.complete;Parsers.HexDigitSet" title="(elem: Char)Boolean">HexDigitSet</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.HexDigit.qual$3.$anonfun.c" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">c</a>.<span title="=&gt; Char">toUpper</span><span class="delimiter">)</span>, <span title="String(&quot;hex digit&quot;)" class="string">&quot;hex digit&quot;</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.examples$default$2" title="Boolean" id="sbt.complete;Parsers.HexDigit.x$21">examples</a> <a href="#sbt.complete;Parsers.HexDigitSet" title="=&gt; scala.collection.immutable.Set[Char]">HexDigitSet</a>.<span title="(f: Char =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Char],String,scala.collection.immutable.Set[String]])scala.collection.immutable.Set[String]">map</span><a title="scala.collection.immutable.Set[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;Parsers.HexDigit.x$20" class="delimiter">(</a><a href="#sbt.complete;Parsers.HexDigit.x$20.$anonfun.x$3" title="Char">_</a>.<span title="()String">toString</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a single letter, according to Char.isLetter, into a Char. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.Letter">Letter</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.Letter.$anonfun.x$4" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">_</a>.<span title="=&gt; Boolean">isLetter</span>, <span title="String(&quot;letter&quot;)" class="string">&quot;letter&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses the first Char in an sbt identifier, which must be a [[Letter]].*/</span>
  <span class="keyword">def</span> <a title="=&gt; sbt.complete.Parser[Char]" id="sbt.complete;Parsers.IDStart">IDStart</a> = <a href="#sbt.complete;Parsers.Letter" title="=&gt; sbt.complete.Parser[Char]">Letter</a>

  <span class="comment">/** Parses an identifier Char other than the first character.  This includes letters, digits, dash `-`, and underscore `_`.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.IDChar">IDChar</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.isIDChar" title="(c: Char)Boolean">isIDChar</a>, <span title="String(&quot;ID character&quot;)" class="string">&quot;ID character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses an identifier String, which must start with [[IDStart]] and contain zero or more [[IDChar]]s after that. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.ID">ID</a> = <a href="#sbt.complete;Parsers.identifier" title="(start: sbt.complete.Parser[Char], rep: sbt.complete.Parser[Char])sbt.complete.Parser[String]">identifier</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.IDStart" title="=&gt; sbt.complete.Parser[Char]">IDStart</a>, <a href="#sbt.complete;Parsers.IDChar" title="=&gt; sbt.complete.Parser[Char]">IDChar</a><span class="delimiter">)</span>

  <span class="comment">/** Parses a single operator Char, as allowed by [[isOpChar]]. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.OpChar">OpChar</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.isOpChar" title="(c: Char)Boolean">isOpChar</a>, <span title="String(&quot;symbol&quot;)" class="string">&quot;symbol&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a non-empty operator String, which consists only of characters allowed by [[OpChar]]. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.Op">Op</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">OpChar</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">+</a>.<a href="Parser.scala.html#sbt.complete;RichParser.string" title="(implicit ev: &lt;:&lt;[Seq[Char],Seq[Char]])sbt.complete.Parser[String]">string</a>

  <span class="comment">/** Parses either an operator String defined by [[Op]] or a non-symbolic identifier defined by [[ID]]. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.OpOrID">OpOrID</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">ID</a> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[String])sbt.complete.Parser[String]">|</a> <a href="#sbt.complete;Parsers.Op" title="=&gt; sbt.complete.Parser[String]">Op</a>

  <span class="comment">/** Parses a single, non-symbolic Scala identifier Char.  Valid characters are letters, digits, and the underscore character `_`. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.ScalaIDChar">ScalaIDChar</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.isScalaIDChar" title="(c: Char)Boolean">isScalaIDChar</a>, <span title="String(&quot;Scala identifier character&quot;)" class="string">&quot;Scala identifier character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a non-symbolic Scala-like identifier.  The identifier must start with [[IDStart]] and contain zero or more [[ScalaIDChar]]s after that.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.ScalaID">ScalaID</a> = <a href="#sbt.complete;Parsers.identifier" title="(start: sbt.complete.Parser[Char], rep: sbt.complete.Parser[Char])sbt.complete.Parser[String]">identifier</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.IDStart" title="=&gt; sbt.complete.Parser[Char]">IDStart</a>, <a href="#sbt.complete;Parsers.ScalaIDChar" title="=&gt; sbt.complete.Parser[Char]">ScalaIDChar</a><span class="delimiter">)</span>

  <span class="comment">/** Parses a String that starts with `start` and is followed by zero or more characters parsed by `rep`.*/</span>
  <span class="keyword">def</span> <a title="(start: sbt.complete.Parser[Char], rep: sbt.complete.Parser[Char])sbt.complete.Parser[String]" id="sbt.complete;Parsers.identifier">identifier</a><span class="delimiter">(</span><a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.identifier.start">start</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span>, <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.identifier.rep">rep</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">start</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(Char, Seq[Char])])sbt.complete.RichParser[(Char, Seq[Char])]">~</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">rep</a>.<a href="Parser.scala.html#sbt.complete;RichParser.*" title="=&gt; sbt.complete.Parser[Seq[Char]]">*</a> <a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: ((Char, Seq[Char])) =&gt; String)sbt.complete.Parser[String]">map</a> <a href="#sbt.complete;Parsers.identifier.$anonfun.x0$2" title="String" class="delimiter">{</a> <span class="keyword">case</span> <a title="Char" id="sbt.complete;Parsers.identifier.$anonfun.x">x</a> <a href="Parser.scala.html#sbt.complete;ParserMain.~.unapply" title="(t: (Char, Seq[Char]))Some[(Char, Seq[Char])]">~</a> <a title="Seq[Char]" id="sbt.complete;Parsers.identifier.$anonfun.xs">xs</a> =&gt; <span class="delimiter">(</span><a href="#sbt.complete;Parsers.identifier.$anonfun.x" title="Char">x</a> <a href="#sbt.complete;Parsers.identifier.$anonfun.x$5" title="(elem: Char)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Char],Char,Seq[Char]])Seq[Char]">+:</a> <a href="#sbt.complete;Parsers.identifier.$anonfun.xs" title="Seq[Char]">xs</a><span class="delimiter">)</span>.<span title="=&gt; String">mkString</span> <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(s: String)sbt.complete.Parser[Char]" id="sbt.complete;Parsers.opOrIDSpaced">opOrIDSpaced</a><span class="delimiter">(</span><a title="String" id="sbt.complete;Parsers.opOrIDSpaced.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <span title="sbt.complete.Parser[Char]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.DefaultParsers" title="sbt.complete.DefaultParsers.type">DefaultParsers</a>.<a href="#sbt.complete.DefaultParsers.matches" title="(p: sbt.complete.Parser[_], s: String)Boolean">matches</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.ID" title="=&gt; sbt.complete.Parser[String]">ID</a>, <a href="#sbt.complete;Parsers.opOrIDSpaced.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">OpChar</a> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[Char])sbt.complete.Parser[Char]">|</a> <a href="#sbt.complete;Parsers.SpaceClass" title="=&gt; sbt.complete.Parser[Char]">SpaceClass</a>
    <span class="keyword">else</span> <span title="sbt.complete.Parser[Char]" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.DefaultParsers" title="sbt.complete.DefaultParsers.type">DefaultParsers</a>.<a href="#sbt.complete.DefaultParsers.matches" title="(p: sbt.complete.Parser[_], s: String)Boolean">matches</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.Op" title="=&gt; sbt.complete.Parser[String]">Op</a>, <a href="#sbt.complete;Parsers.opOrIDSpaced.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">IDChar</a> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[Char])sbt.complete.Parser[Char]">|</a> <a href="#sbt.complete;Parsers.SpaceClass" title="=&gt; sbt.complete.Parser[Char]">SpaceClass</a>
    <span class="keyword">else</span>
      <a href="#sbt.complete;Parsers.any" title="=&gt; sbt.complete.Parser[Char]">any</a>

  <span class="comment">/** Returns true if `c` an operator character. */</span>
  <span class="keyword">def</span> <a title="(c: Char)Boolean" id="sbt.complete;Parsers.isOpChar">isOpChar</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.isOpChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span title="=&gt; Boolean">!</span><a href="#sbt.complete;Parsers.isDelimiter" title="(c: Char)Boolean">isDelimiter</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.isOpChar.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.complete;Parsers.isOpType" title="(cat: Int)Boolean">isOpType</a><span class="delimiter">(</span><span title="(x$1: Char)Int">getType</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.isOpChar.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(cat: Int)Boolean" id="sbt.complete;Parsers.isOpType">isOpType</a><span class="delimiter">(</span><a title="Int" id="sbt.complete;Parsers.isOpType.cat">cat</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#sbt.complete;Parsers.isOpType.cat" title="Int">cat</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span title="Byte(25)">MATH_SYMBOL</span> | <span title="Byte(28)">OTHER_SYMBOL</span> | <span title="Byte(20)">DASH_PUNCTUATION</span> | <span title="Byte(24)">OTHER_PUNCTUATION</span> | <span title="Byte(27)">MODIFIER_SYMBOL</span> | <span title="Byte(26)">CURRENCY_SYMBOL</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>; <span class="keyword">case</span> _ =&gt; <span title="Boolean(false)" class="keyword">false</span> <span class="delimiter">}</span>
  <span class="comment">/** Returns true if `c` is a dash `-`, a letter, digit, or an underscore `_`. */</span>
  <span class="keyword">def</span> <a title="(c: Char)Boolean" id="sbt.complete;Parsers.isIDChar">isIDChar</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.isIDChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete;Parsers.isScalaIDChar" title="(c: Char)Boolean">isScalaIDChar</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.isIDChar.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.complete;Parsers.isIDChar.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char('-')" class="char">'-'</span>

  <span class="comment">/** Returns true if `c` is a letter, digit, or an underscore `_`. */</span>
  <span class="keyword">def</span> <a title="(c: Char)Boolean" id="sbt.complete;Parsers.isScalaIDChar">isScalaIDChar</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.isScalaIDChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete;Parsers.isScalaIDChar.c" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">c</a>.<span title="=&gt; Boolean">isLetterOrDigit</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.complete;Parsers.isScalaIDChar.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char('_')" class="char">'_'</span>

  <span class="keyword">def</span> <a title="(c: Char)Boolean" id="sbt.complete;Parsers.isDelimiter">isDelimiter</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.isDelimiter.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#sbt.complete;Parsers.isDelimiter.c" title="Char">c</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span title="Char('`')" class="char">'`'</span> | <span title="Char('\'')" class="char">'\''</span> | <span title="Char('\&quot;')" class="char">'\&quot;'</span> | <span class="comment">/*';' | */</span> <span title="Char(',')" class="char">','</span> | <span title="Char('.')" class="char">'.'</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>; <span class="keyword">case</span> _ =&gt; <span title="Boolean(false)" class="keyword">false</span> <span class="delimiter">}</span>

  <span class="comment">/** Matches a single character that is not a whitespace character. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.NotSpaceClass">NotSpaceClass</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.complete;Parsers.NotSpaceClass.$anonfun.x$6" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">_</a>.<span title="=&gt; Boolean">isWhitespace</span>, <span title="String(&quot;non-whitespace character&quot;)" class="string">&quot;non-whitespace character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Matches a single whitespace character, as determined by Char.isWhitespace.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.SpaceClass">SpaceClass</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.SpaceClass.$anonfun.x$7" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">_</a>.<span title="=&gt; Boolean">isWhitespace</span>, <span title="String(&quot;whitespace character&quot;)" class="string">&quot;whitespace character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Matches a non-empty String consisting of non-whitespace characters. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.NotSpace">NotSpace</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">NotSpaceClass</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">+</a>.<a href="Parser.scala.html#sbt.complete;RichParser.string" title="(implicit ev: &lt;:&lt;[Seq[Char],Seq[Char]])sbt.complete.Parser[String]">string</a>

  <span class="comment">/** Matches a possibly empty String consisting of non-whitespace characters. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.OptNotSpace">OptNotSpace</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">NotSpaceClass</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">*</a>.<a href="Parser.scala.html#sbt.complete;RichParser.string" title="(implicit ev: &lt;:&lt;[Seq[Char],Seq[Char]])sbt.complete.Parser[String]">string</a>

  <span class="comment">/**
   * Matches a non-empty String consisting of whitespace characters.
   * The suggested tab completion is a single, constant space character.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Seq[Char]]" id="sbt.complete;Parsers.Space">Space</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">SpaceClass</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">+</a>.<a href="Parser.scala.html#sbt.complete;RichParser.examples(88b70d78c2)" title="(s: String*)sbt.complete.Parser[Seq[Char]]">examples</a><span class="delimiter">(</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Matches a possibly empty String consisting of whitespace characters.
   * The suggested tab completion is a single, constant space character.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Seq[Char]]" id="sbt.complete;Parsers.OptSpace">OptSpace</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">SpaceClass</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">*</a>.<a href="Parser.scala.html#sbt.complete;RichParser.examples(88b70d78c2)" title="(s: String*)sbt.complete.Parser[Seq[Char]]">examples</a><span class="delimiter">(</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a non-empty String that contains only valid URI characters, as defined by [[URIChar]].*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.URIClass">URIClass</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">URIChar</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">+</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">string</a> <a href="Parser.scala.html#sbt.complete;RichParser.!!!" title="(msg: String)sbt.complete.Parser[String]">!!!</a> <span title="String(&quot;Invalid URI&quot;)" class="string">&quot;Invalid URI&quot;</span>

  <span class="comment">/** Triple-quotes, as used for verbatim quoting.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="String" id="sbt.complete;Parsers.VerbatimDQuotes">VerbatimDQuotes</a> = <span title="String(&quot;\&quot;\&quot;\&quot;&quot;)" class="string">&quot;\&quot;\&quot;\&quot;&quot;</span>

  <span class="comment">/** Double quote character. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Char" id="sbt.complete;Parsers.DQuoteChar">DQuoteChar</a> = <span title="Char('\&quot;')" class="char">'\&quot;'</span>

  <span class="comment">/** Backslash character. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Char" id="sbt.complete;Parsers.BackslashChar">BackslashChar</a> = <span title="Char('\\')" class="char">'\\'</span>

  <span class="comment">/** Matches a single double quote. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.DQuoteClass">DQuoteClass</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.DQuoteClass.$anonfun.x$8" title="Char">_</a> <span title="(x: Char)Boolean">==</span> <a href="#sbt.complete;Parsers.DQuoteChar" title="=&gt; Char">DQuoteChar</a>, <span title="String(&quot;double-quote character&quot;)" class="string">&quot;double-quote character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Matches any character except a double quote or whitespace. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.NotDQuoteSpaceClass">NotDQuoteSpaceClass</a> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><span class="delimiter">{</span> c: <span title="Char">Char</span> =&gt; <span class="delimiter">(</span><a href="#sbt.complete;Parsers.NotDQuoteSpaceClass.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">!=</span> <a href="#sbt.complete;Parsers.DQuoteChar" title="=&gt; Char">DQuoteChar</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#sbt.complete;Parsers.NotDQuoteSpaceClass.$anonfun.c" title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">c</a>.<span title="=&gt; Boolean">isWhitespace</span> <span class="delimiter">}</span>, <span title="String(&quot;non-double-quote-space character&quot;)" class="string">&quot;non-double-quote-space character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Matches any character except a double quote or backslash. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.NotDQuoteBackslashClass">NotDQuoteBackslashClass</a> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><span class="delimiter">{</span> c: <span title="Char">Char</span> =&gt; <span class="delimiter">(</span><a href="#sbt.complete;Parsers.NotDQuoteBackslashClass.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">!=</span> <a href="#sbt.complete;Parsers.DQuoteChar" title="=&gt; Char">DQuoteChar</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#sbt.complete;Parsers.NotDQuoteBackslashClass.$anonfun.c" title="Char">c</a> <span title="(x: Char)Boolean">!=</span> <a href="#sbt.complete;Parsers.BackslashChar" title="=&gt; Char">BackslashChar</a><span class="delimiter">)</span> <span class="delimiter">}</span>, <span title="String(&quot;non-double-quote-backslash character&quot;)" class="string">&quot;non-double-quote-backslash character&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Matches a single character that is valid somewhere in a URI. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.URIChar">URIChar</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]" class="delimiter">(</a><a href="#sbt.complete;Parsers.alphanum" title="(c: Char)Boolean">alphanum</a><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[Char])sbt.complete.Parser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.chars" title="(legal: String)sbt.complete.Parser[Char]">chars</a><span class="delimiter">(</span><span title="String(&quot;_-!.~\'()*,;:$&amp;+=?/[]@%#&quot;)" class="string">&quot;_-!.~'()*,;:$&amp;+=?/[]@%#&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Returns true if `c` is an ASCII letter or digit. */</span>
  <span class="keyword">def</span> <a title="(c: Char)Boolean" id="sbt.complete;Parsers.alphanum">alphanum</a><span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.alphanum.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <span class="delimiter">(</span><span title="Char('a')" class="char">'a'</span> <span title="(x: Char)Boolean">&lt;=</span> <a href="#sbt.complete;Parsers.alphanum.c" title="Char">c</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.complete;Parsers.alphanum.c" title="Char">c</a> <span title="(x: Char)Boolean">&lt;=</span> <span title="Char('z')" class="char">'z'</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="Char('A')" class="char">'A'</span> <span title="(x: Char)Boolean">&lt;=</span> <a href="#sbt.complete;Parsers.alphanum.c" title="Char">c</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.complete;Parsers.alphanum.c" title="Char">c</a> <span title="(x: Char)Boolean">&lt;=</span> <span title="Char('Z')" class="char">'Z'</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="Char('0')" class="char">'0'</span> <span title="(x: Char)Boolean">&lt;=</span> <a href="#sbt.complete;Parsers.alphanum.c" title="Char">c</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#sbt.complete;Parsers.alphanum.c" title="Char">c</a> <span title="(x: Char)Boolean">&lt;=</span> <span title="Char('9')" class="char">'9'</span><span class="delimiter">)</span>

  <span class="comment">/**
   * @param base the directory used for completion proposals (when the user presses the TAB key). Only paths under this
   *             directory will be proposed.
   * @return the file that was parsed from the input string. The returned path may or may not exist.
   */</span>
  <span class="keyword">def</span> <a title="(base: java.io.File)sbt.complete.Parser[java.io.File]" id="sbt.complete;Parsers.fileParser">fileParser</a><span class="delimiter">(</span><a title="java.io.File" id="sbt.complete;Parsers.fileParser.base">base</a>: <span title="java.io.File">File</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[java.io.File]">Parser</a><span class="delimiter">[</span>File<span class="delimiter">]</span> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">OptSpace</a> <a href="Parser.scala.html#sbt.complete;RichParser.~>" title="(b: sbt.complete.Parser[java.io.File])sbt.complete.Parser[java.io.File]">~&gt;</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">StringBasic</a>
      .<a href="Parser.scala.html#sbt.complete;RichParser.examples(ae3d7e057f)" title="(exampleSource: sbt.complete.ExampleSource)sbt.complete.Parser[String]">examples</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]" class="delimiter">(</a><a href="ExampleSource.scala.html#sbt.complete.FileExamples.<init>$default$2" title="sbt.complete.FileExamples" class="keyword">new</a> <a href="ExampleSource.scala.html#sbt.complete;FileExamples" title="sbt.complete.FileExamples">FileExamples</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.fileParser.base" title="java.io.File">base</a><span class="delimiter">)</span><span class="delimiter">)</span>
      .<a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: String =&gt; java.io.File)sbt.complete.Parser[java.io.File]">map</a><span class="delimiter">(</span><span title="java.io.File" class="keyword">new</span> <span title="java.io.File">File</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.fileParser.$anonfun.x$9" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a port number.  Currently, this accepts any integer and presents a tab completion suggestion of `&lt;port&gt;`. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Int]" id="sbt.complete;Parsers.Port">Port</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.token(0b971f8ae9)" title="(t: sbt.complete.Parser[Int], description: String)sbt.complete.Parser[Int]">token</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.IntBasic" title="=&gt; sbt.complete.Parser[Int]">IntBasic</a>, <span title="String(&quot;&lt;port&gt;&quot;)" class="string">&quot;&lt;port&gt;&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a signed integer. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Int]" id="sbt.complete;Parsers.IntBasic">IntBasic</a> = <a href="#sbt.complete;Parsers.mapOrFail" title="(p: sbt.complete.Parser[(Option[Char], Seq[Char])])(f: ((Option[Char], Seq[Char])) =&gt; Int)sbt.complete.Parser[Int]">mapOrFail</a><span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'-'</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Option[Char]])sbt.complete.RichParser[Option[Char]]">?</a> <a href="Parser.scala.html#sbt.complete;RichParser.~" title="(next: sbt.complete.Parser[Seq[Char]])sbt.complete.Parser[(Option[Char], Seq[Char])]">~</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">Digit</a>.<a href="Parser.scala.html#sbt.complete;RichParser.+" title="=&gt; sbt.complete.Parser[Seq[Char]]">+</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Function.type">Function</span>.<span title="(f: (Option[Char], Seq[Char]) =&gt; Int)((Option[Char], Seq[Char])) =&gt; Int">tupled</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.toInt" title="(neg: Option[Char], digits: Seq[Char])Int">toInt</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Parses an unsigned integer. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Int]" id="sbt.complete;Parsers.NatBasic">NatBasic</a> = <a href="#sbt.complete;Parsers.mapOrFail" title="(p: sbt.complete.Parser[Seq[Char]])(f: Seq[Char] =&gt; Int)sbt.complete.Parser[Int]">mapOrFail</a><span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">Digit</a>.<a href="Parser.scala.html#sbt.complete;RichParser.+" title="=&gt; sbt.complete.Parser[Seq[Char]]">+</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.NatBasic.$anonfun.x$10" title="Seq[Char]">_</a>.<span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">mkString</span>.<span title="=&gt; Int">toInt</span><span class="delimiter">)</span>

  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(neg: Option[Char], digits: Seq[Char])Int" id="sbt.complete;Parsers.toInt">toInt</a><span class="delimiter">(</span><a title="Option[Char]" id="sbt.complete;Parsers.toInt.neg">neg</a>: <span title="Option[Char]">Option</span><span class="delimiter">[</span>Char<span class="delimiter">]</span>, <a title="Seq[Char]" id="sbt.complete;Parsers.toInt.digits">digits</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <span class="delimiter">(</span><a href="#sbt.complete;Parsers.toInt.neg" title="(xo: Option[Char])Iterable[Char]">neg</a>.<span title="=&gt; Seq[Char]">toSeq</span> <span title="(that: scala.collection.GenTraversableOnce[Char])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Char],Char,Seq[Char]])Seq[Char]">++</span> <a href="#sbt.complete;Parsers.toInt.digits" title="Seq[Char]">digits</a><span class="delimiter">)</span>.<span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">mkString</span>.<span title="=&gt; Int">toInt</span>

  <span class="comment">/** Parses the lower-case values `true` and `false` into their respesct Boolean values.  */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Boolean]" id="sbt.complete;Parsers.Bool">Bool</a> = <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichStringParser" title="implicit sbt.complete.ParserMain.literalRichStringParser : (s: String)sbt.complete.RichParser[String]" class="string">&quot;true&quot;</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Boolean])sbt.complete.RichParser[Boolean]">^^^</a> <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[Boolean])sbt.complete.Parser[Boolean]">|</a> <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichStringParser" title="implicit sbt.complete.ParserMain.literalRichStringParser : (s: String)sbt.complete.RichParser[String]" class="string">&quot;false&quot;</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Boolean)sbt.complete.Parser[Boolean]">^^^</a> <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Parses a potentially quoted String value.  The value may be verbatim quoted ([[StringVerbatim]]),
   * quoted with interpreted escapes ([[StringEscapable]]), or unquoted ([[NotQuoted]]).
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.StringBasic">StringBasic</a> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">StringVerbatim</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">|</a> <a href="#sbt.complete;Parsers.StringEscapable" title="=&gt; sbt.complete.Parser[String]">StringEscapable</a> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[String])sbt.complete.Parser[String]">|</a> <a href="#sbt.complete;Parsers.NotQuoted" title="=&gt; sbt.complete.Parser[String]">NotQuoted</a>

  <span class="comment">/**
   * Parses a verbatim quoted String value, discarding the quotes in the result.  This kind of quoted text starts with triple quotes `&quot;&quot;&quot;`
   * and ends at the next triple quotes and may contain any character in between.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.StringVerbatim">StringVerbatim</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichStringParser" title="implicit sbt.complete.ParserMain.literalRichStringParser : (s: String)sbt.complete.RichParser[String]">VerbatimDQuotes</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">~&gt;</a>
    <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">any</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">+</a>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">string</a>.<a href="Parser.scala.html#sbt.complete;RichParser.filter" title="(f: String =&gt; Boolean, msg: String =&gt; String)sbt.complete.Parser[String]">filter</a><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#sbt.complete;Parsers.StringVerbatim.$anonfun.x$11" title="String">_</a>.<span title="(x$1: CharSequence)Boolean">contains</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.VerbatimDQuotes" title="=&gt; String">VerbatimDQuotes</a><span class="delimiter">)</span>, <a title="String" id="sbt.complete;Parsers.StringVerbatim.$anonfun.x$12">_</a> =&gt; <span title="String(&quot;Invalid verbatim string&quot;)" class="string">&quot;Invalid verbatim string&quot;</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.<~" title="(b: sbt.complete.Parser[String])sbt.complete.Parser[String]">&lt;~</a>
    <a href="Parser.scala.html#sbt.complete;ParserMain.literal(d17d0531ce)" title="implicit sbt.complete.ParserMain.literal : (s: String)sbt.complete.Parser[String]">VerbatimDQuotes</a>

  <span class="comment">/**
   * Parses a string value, interpreting escapes and discarding the surrounding quotes in the result.
   * See [[EscapeSequence]] for supported escapes.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.StringEscapable">StringEscapable</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]">DQuoteChar</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">~&gt;</a> <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">NotDQuoteBackslashClass</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="#sbt.complete;Parsers.EscapeSequence" title="=&gt; sbt.complete.Parser[Char]">EscapeSequence</a><span class="delimiter">)</span>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">+</a>.<a href="Parser.scala.html#sbt.complete;RichParser.string" title="(implicit ev: &lt;:&lt;[Seq[Char],Seq[Char]])sbt.complete.Parser[String]">string</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">&lt;~</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literal(a2eb285bfb)" title="implicit sbt.complete.ParserMain.literal : (ch: Char)sbt.complete.Parser[Char]">DQuoteChar</a> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[String])sbt.complete.Parser[String]">|</a>
      <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]">DQuoteChar</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(Char, Char)])sbt.complete.RichParser[(Char, Char)]">~</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literal(a2eb285bfb)" title="implicit sbt.complete.ParserMain.literal : (ch: Char)sbt.complete.Parser[Char]">DQuoteChar</a><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: String)sbt.complete.Parser[String]">^^^</a> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Parses a single escape sequence into the represented Char.
   * Escapes start with a backslash and are followed by `u` for a [[UnicodeEscape]] or by `b`, `t`, `n`, `f`, `r`, `&quot;`, `'`, `\` for standard escapes.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.EscapeSequence">EscapeSequence</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]">BackslashChar</a> <a href="Parser.scala.html#sbt.complete;RichParser.~>" title="(b: sbt.complete.Parser[Char])sbt.complete.Parser[Char]">~&gt;</a> <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'b'</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">^^^</a> <span title="Char('\b')" class="char">'\b'</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'t'</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\t')" class="char">'\t'</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'n'</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\n')" class="char">'\n'</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'f'</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\f')" class="char">'\f'</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'r'</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\r')" class="char">'\r'</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a>
      <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'\&quot;'</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\&quot;')" class="char">'\&quot;'</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'\''</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\'')" class="char">'\''</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">|</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'\\'</a> <a href="Parser.scala.html#sbt.complete;RichParser.^^^" title="(value: Char)sbt.complete.Parser[Char]">^^^</a> <span title="Char('\\')" class="char">'\\'</span> <a href="Parser.scala.html#sbt.complete;RichParser.|" title="(b: sbt.complete.Parser[Char])sbt.complete.Parser[Char]">|</a> <a href="#sbt.complete;Parsers.UnicodeEscape" title="=&gt; sbt.complete.Parser[Char]">UnicodeEscape</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Parses a single unicode escape sequence into the represented Char.
   * A unicode escape begins with a backslash, followed by a `u` and 4 hexadecimal digits representing the unicode value.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[Char]" id="sbt.complete;Parsers.UnicodeEscape">UnicodeEscape</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Char]">Parser</a><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichStringParser" title="implicit sbt.complete.ParserMain.literalRichStringParser : (s: String)sbt.complete.RichParser[String]" class="string">&quot;u&quot;</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]">~&gt;</a> <a href="Parser.scala.html#sbt.complete.Parser.repeat(ee491394ee)" title="(p: sbt.complete.Parser[Char], min: Int, max: sbt.complete.UpperBound)sbt.complete.Parser[Seq[Char]]">repeat</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.HexDigit" title="=&gt; sbt.complete.Parser[Char]">HexDigit</a>, <span title="Int(4)" class="int">4</span>, <a href="UpperBound.scala.html#sbt.complete.UpperBound.intToFinite" title="implicit sbt.complete.UpperBound.intToFinite : (i: Int)sbt.complete.Finite" class="int">4</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: Seq[Char] =&gt; Char)sbt.complete.Parser[Char]">map</a> <span class="delimiter">{</span> <a title="Seq[Char]" id="sbt.complete;Parsers.UnicodeEscape.$anonfun.seq">seq</a> =&gt; <span title="Integer.type">Integer</span>.<span title="(x$1: String, x$2: Int)Int">parseInt</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.UnicodeEscape.$anonfun.seq" title="Seq[Char]">seq</a>.<span title="=&gt; String">mkString</span>, <span title="Int(16)" class="int">16</span><span class="delimiter">)</span>.<span title="=&gt; Char">toChar</span> <span class="delimiter">}</span>

  <span class="comment">/** Parses an unquoted, non-empty String value that cannot start with a double quote and cannot contain whitespace.*/</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.NotQuoted">NotQuoted</a> = <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">NotDQuoteSpaceClass</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(Char, String)])sbt.complete.RichParser[(Char, String)]">~</a> <a href="#sbt.complete;Parsers.OptNotSpace" title="=&gt; sbt.complete.Parser[String]">OptNotSpace</a><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: ((Char, String)) =&gt; String)sbt.complete.Parser[String]">map</a> <a href="#sbt.complete;Parsers.NotQuoted.$anonfun.x0$1" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="Char" id="sbt.complete;Parsers.NotQuoted.$anonfun.c">c</a>, <a title="String" id="sbt.complete;Parsers.NotQuoted.$anonfun.s">s</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;Parsers.NotQuoted.$anonfun.c" title="Char">c</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;Parsers.NotQuoted.$anonfun.s" title="String">s</a> <span class="delimiter">}</span>

  <span class="comment">/**
   * Applies `rep` zero or more times, separated by `sep`.
   * The result is the (possibly empty) sequence of results from the multiple `rep` applications.  The `sep` results are discarded.
   */</span>
  <span class="keyword">def</span> <a title="[T](rep: sbt.complete.Parser[T], sep: sbt.complete.Parser[_])sbt.complete.Parser[Seq[T]]" id="sbt.complete;Parsers.repsep">repsep</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parsers.repsep;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Parsers.repsep.rep">rep</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete;Parsers.repsep.sep">sep</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#sbt.complete;Parsers.rep1sep" title="(rep: sbt.complete.Parser[T], sep: sbt.complete.Parser[_])sbt.complete.Parser[Seq[T]]">rep1sep</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[T]])sbt.complete.RichParser[Seq[T]]" class="delimiter">(</a><a href="#sbt.complete;Parsers.repsep.rep" title="sbt.complete.Parser[T]">rep</a>, <a href="#sbt.complete;Parsers.repsep.sep" title="sbt.complete.Parser[_]">sep</a><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.??" title="(alt: Seq[T])sbt.complete.Parser[Seq[T]]">??</a> <span title="scala.collection.immutable.Nil.type">Nil</span>

  <span class="comment">/**
   * Applies `rep` one or more times, separated by `sep`.
   * The result is the non-empty sequence of results from the multiple `rep` applications.  The `sep` results are discarded.
   */</span>
  <span class="keyword">def</span> <a title="[T](rep: sbt.complete.Parser[T], sep: sbt.complete.Parser[_])sbt.complete.Parser[Seq[T]]" id="sbt.complete;Parsers.rep1sep">rep1sep</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parsers.rep1sep;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Parsers.rep1sep.rep">rep</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="sbt.complete.Parser[_]" id="sbt.complete;Parsers.rep1sep.sep">sep</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Seq[T]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">rep</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[(T, Seq[T])])sbt.complete.RichParser[(T, Seq[T])]">~</a> <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[_$2])sbt.complete.RichParser[_$2]">sep</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">~&gt;</a> <a href="#sbt.complete;Parsers.rep1sep.rep" title="sbt.complete.Parser[T]">rep</a><span class="delimiter">)</span>.<a href="Parser.scala.html#sbt.complete;RichParser.*" title="=&gt; sbt.complete.Parser[Seq[T]]">*</a><span class="delimiter">)</span>.<a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: ((T, Seq[T])) =&gt; Seq[T])sbt.complete.Parser[Seq[T]]">map</a> <a href="#sbt.complete;Parsers.rep1sep.$anonfun.x0$3" title="Seq[T]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="T" id="sbt.complete;Parsers.rep1sep.$anonfun.x">x</a> <a href="Parser.scala.html#sbt.complete;ParserMain.~.unapply" title="(t: (T, Seq[T]))Some[(T, Seq[T])]">~</a> <a title="Seq[T]" id="sbt.complete;Parsers.rep1sep.$anonfun.xs">xs</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete;Parsers.rep1sep.$anonfun.x" title="T">x</a> <a href="#sbt.complete;Parsers.rep1sep.$anonfun.x$13" title="(elem: T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">+:</a> <a href="#sbt.complete;Parsers.rep1sep.$anonfun.xs" title="Seq[T]">xs</a> <span class="delimiter">}</span>

  <span class="comment">/** Wraps the result of `p` in `Some`.*/</span>
  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T])sbt.complete.Parser[Option[T]]" id="sbt.complete;Parsers.some">some</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parsers.some;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Parsers.some.p">p</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Option[T]]">Parser</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">p</a> <a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: T =&gt; Some[T])sbt.complete.Parser[Some[T]]">map</a> <span class="delimiter">{</span> <a title="T" id="sbt.complete;Parsers.some.$anonfun.v">v</a> =&gt; <span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.some.$anonfun.v" title="T">v</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * Applies `f` to the result of `p`, transforming any exception when evaluating
   * `f` into a parse failure with the exception `toString` as the message.
   */</span>
  <span class="keyword">def</span> <a title="[S, T](p: sbt.complete.Parser[S])(f: S =&gt; T)sbt.complete.Parser[T]" id="sbt.complete;Parsers.mapOrFail">mapOrFail</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parsers.mapOrFail;S">S</a>, <a title="" id="sbt.complete;Parsers.mapOrFail;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[S]" id="sbt.complete;Parsers.mapOrFail.p">p</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[S]">Parser</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="S =&gt; T" id="sbt.complete;Parsers.mapOrFail.f">f</a>: S =&gt; T<span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[S])sbt.complete.RichParser[S]">p</a> <a href="Parser.scala.html#sbt.complete;RichParser.flatMap" title="(f: S =&gt; sbt.complete.Parser[T])sbt.complete.Parser[T]">flatMap</a> <span class="delimiter">{</span> <a title="S" id="sbt.complete;Parsers.mapOrFail.$anonfun.s">s</a> =&gt; <span class="keyword">try</span> <span class="delimiter">{</span> <a href="Parser.scala.html#sbt.complete;ParserMain.success" title="(value: T)sbt.complete.Parser[T]">success</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.mapOrFail.f" title="(v1: S)T">f</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.mapOrFail.$anonfun.s" title="S">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="Exception" id="sbt.complete;Parsers.mapOrFail.$anonfun.e">e</a>: <span title="Exception">Exception</span> =&gt; <a href="Parser.scala.html#sbt.complete;ParserMain.failure" title="(msg: =&gt; String, definitive: Boolean)sbt.complete.Parser[Nothing]">failure</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.mapOrFail.$anonfun.e" title="Exception">e</a>.<span title="()String">toString</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * Parses a space-delimited, possibly empty sequence of arguments.
   * The arguments may use quotes and escapes according to [[StringBasic]].
   */</span>
  <span class="keyword">def</span> <a title="(display: String)sbt.complete.Parser[Seq[String]]" id="sbt.complete;Parsers.spaceDelimited">spaceDelimited</a><span class="delimiter">(</span><a title="String" id="sbt.complete;Parsers.spaceDelimited.display">display</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Seq[String]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.token(ab0e3a3279)" title="(t: sbt.complete.Parser[Seq[Char]])sbt.complete.Parser[Seq[Char]]">token</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[Char]])sbt.complete.RichParser[Seq[Char]]" class="delimiter">(</a><a href="#sbt.complete;Parsers.Space" title="=&gt; sbt.complete.Parser[Seq[Char]]">Space</a><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">~&gt;</a> <a href="Parser.scala.html#sbt.complete;ParserMain.token(0b971f8ae9)" title="(t: sbt.complete.Parser[String], description: String)sbt.complete.Parser[String]">token</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.StringBasic" title="=&gt; sbt.complete.Parser[String]">StringBasic</a>, <a href="#sbt.complete;Parsers.spaceDelimited.display" title="String">display</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[String]])sbt.complete.RichParser[Seq[String]]">*</a> <a href="Parser.scala.html#sbt.complete;RichParser.<~" title="(b: sbt.complete.Parser[Seq[Char]])sbt.complete.Parser[Seq[String]]">&lt;~</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Char])sbt.complete.RichParser[Char]">SpaceClass</a>.<a href="Parser.scala.html#sbt.complete;RichParser.*" title="=&gt; sbt.complete.Parser[Seq[Char]]">*</a>

  <span class="comment">/** Applies `p` and uses `true` as the result if it succeeds and turns failure into a result of `false`. */</span>
  <span class="keyword">def</span> <a title="[T](p: sbt.complete.Parser[T])sbt.complete.Parser[Boolean]" id="sbt.complete;Parsers.flag">flag</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parsers.flag;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="sbt.complete.Parser[T]" id="sbt.complete;Parsers.flag.p">p</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Boolean]">Parser</a><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[T])sbt.complete.RichParser[T]">p</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Boolean])sbt.complete.RichParser[Boolean]">^^^</a> <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.??" title="(alt: Boolean)sbt.complete.Parser[Boolean]">??</a> <span title="Boolean(false)" class="keyword">false</span>

  <span class="comment">/**
   * Defines a sequence parser where the parser used for each part depends on the previously parsed values.
   * `p` is applied to the (possibly empty) sequence of already parsed values to obtain the next parser to use.
   * The parsers obtained in this way are separated by `sep`, whose result is discarded and only the sequence
   * of values from the parsers returned by `p` is used for the result.
   */</span>
  <span class="keyword">def</span> <a title="[A](p: Seq[A] =&gt; sbt.complete.Parser[A], sep: sbt.complete.Parser[Any])sbt.complete.Parser[Seq[A]]" id="sbt.complete;Parsers.repeatDep">repeatDep</a><span class="delimiter">[</span><a title="" id="sbt.complete;Parsers.repeatDep;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[A] =&gt; sbt.complete.Parser[A]" id="sbt.complete;Parsers.repeatDep.p">p</a>: Seq<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; Parser<span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="sbt.complete.Parser[Any]" id="sbt.complete;Parsers.repeatDep.sep">sep</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Any]">Parser</a><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Seq[A]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(acc: Seq[A])sbt.complete.Parser[Seq[A]]" id="sbt.complete;Parsers.repeatDep.loop">loop</a><span class="delimiter">(</span><a title="Seq[A]" id="sbt.complete;Parsers.repeatDep.loop.acc">acc</a>: <span title="Seq[A]">Seq</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[Seq[A]]">Parser</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="sbt.complete.Parser[Seq[A]]" id="sbt.complete;Parsers.repeatDep.loop.next">next</a> = <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Any])sbt.complete.RichParser[Any]">sep</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]">~&gt;</a> <a href="#sbt.complete;Parsers.repeatDep.p" title="(v1: Seq[A])sbt.complete.Parser[A]">p</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.repeatDep.loop.acc" title="Seq[A]">acc</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.flatMap" title="(f: A =&gt; sbt.complete.Parser[Seq[A]])sbt.complete.Parser[Seq[A]]">flatMap</a> <span class="delimiter">{</span> <a title="A" id="sbt.complete;Parsers.repeatDep.loop.next.$anonfun.result">result</a> =&gt; <a href="#sbt.complete;Parsers.repeatDep.loop" title="(acc: Seq[A])sbt.complete.Parser[Seq[A]]">loop</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.repeatDep.loop.acc" title="Seq[A]">acc</a> <span title="(elem: A)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[A],A,Seq[A]])Seq[A]">:+</span> <a href="#sbt.complete;Parsers.repeatDep.loop.next.$anonfun.result" title="A">result</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[A]])sbt.complete.RichParser[Seq[A]]">next</a> <a href="Parser.scala.html#sbt.complete;RichParser.??" title="(alt: Seq[A])sbt.complete.Parser[Seq[A]]">??</a> <a href="#sbt.complete;Parsers.repeatDep.loop.acc" title="Seq[A]">acc</a>
      <span class="delimiter">}</span>
      <a href="#sbt.complete;Parsers.repeatDep.p" title="(v1: Seq[A])sbt.complete.Parser[A]">p</a><a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[A])sbt.complete.RichParser[A]" class="delimiter">(</a><span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;RichParser.flatMap" title="(f: A =&gt; sbt.complete.Parser[Seq[A]])sbt.complete.Parser[Seq[A]]">flatMap</a> <span class="delimiter">{</span> <a title="A" id="sbt.complete;Parsers.repeatDep.$anonfun.first">first</a> =&gt; <a href="#sbt.complete;Parsers.repeatDep.loop" title="(acc: Seq[A])sbt.complete.Parser[Seq[A]]">loop</a><span class="delimiter">(</span><span title="(elems: A*)Seq[A]">Seq</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.repeatDep.$anonfun.first" title="A">first</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Applies String.trim to the result of `p`. */</span>
  <span class="keyword">def</span> <a title="(p: sbt.complete.Parser[String])sbt.complete.Parser[String]" id="sbt.complete;Parsers.trimmed">trimmed</a><span class="delimiter">(</span><a title="sbt.complete.Parser[String]" id="sbt.complete;Parsers.trimmed.p">p</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[String]">Parser</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[String])sbt.complete.RichParser[String]">p</a> <a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: String =&gt; String)sbt.complete.Parser[String]">map</a> <span class="delimiter">{</span> <a href="#sbt.complete;Parsers.trimmed.$anonfun.x$14" title="String">_</a>.<span title="()String">trim</span> <span class="delimiter">}</span>

  <span class="comment">/** Parses a URI that is valid according to the single argument java.net.URI constructor. */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[java.net.URI]" id="sbt.complete;Parsers.basicUri">basicUri</a> = <a href="#sbt.complete;Parsers.mapOrFail" title="(p: sbt.complete.Parser[String])(f: String =&gt; java.net.URI)sbt.complete.Parser[java.net.URI]">mapOrFail</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.URIClass" title="=&gt; sbt.complete.Parser[String]">URIClass</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="sbt.complete;Parsers.basicUri.$anonfun.uri">uri</a> =&gt; <span title="java.net.URI" class="keyword">new</span> <span title="java.net.URI">URI</span><span class="delimiter">(</span><a href="#sbt.complete;Parsers.basicUri.$anonfun.uri" title="String">uri</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Parses a URI that is valid according to the single argument java.net.URI constructor, using `ex` as tab completion examples. */</span>
  <span class="keyword">def</span> <a title="(ex: Set[java.net.URI])sbt.complete.Parser[java.net.URI]" id="sbt.complete;Parsers.Uri">Uri</a><span class="delimiter">(</span><a title="Set[java.net.URI]" id="sbt.complete;Parsers.Uri.ex">ex</a>: <span title="Set[java.net.URI]">Set</span><span class="delimiter">[</span>URI<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="sbt.complete.RichParser[java.net.URI] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;Parsers.Uri.qual$2">basicUri</a> <a href="Parser.scala.html#sbt.complete;RichParser.examples$default$2" title="Boolean" id="sbt.complete;Parsers.Uri.x$19">examples</a> <span class="delimiter">(</span><a href="#sbt.complete;Parsers.Uri.ex" title="Set[java.net.URI]">ex</a>.<span title="(f: java.net.URI =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[java.net.URI],String,scala.collection.immutable.Set[String]])scala.collection.immutable.Set[String]">map</span><a title="scala.collection.immutable.Set[String] @scala.reflect.internal.annotations.uncheckedBounds" id="sbt.complete;Parsers.Uri.x$18" class="delimiter">(</a><a href="#sbt.complete;Parsers.Uri.x$18.$anonfun.x$15" title="java.net.URI">_</a>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/** Provides standard [[Parser]] implementations. */</span>
<span title="AnyRef" class="keyword">object</span> <a title="sbt.complete.Parsers.type" id="sbt.complete.Parsers">Parsers</a> <a href="#sbt.complete.Parsers" title="sbt.complete.Parsers.type" class="keyword">extends</a> <a href="#sbt.complete;Parsers" title="sbt.complete.Parsers">Parsers</a>

<span class="comment">/** Provides common [[Parser]] implementations and helper methods.*/</span>
<span class="keyword">object</span> <a title="sbt.complete.DefaultParsers.type" id="sbt.complete.DefaultParsers">DefaultParsers</a> <a href="#sbt.complete.DefaultParsers" title="sbt.complete.DefaultParsers.type" class="keyword">extends</a> <a href="#sbt.complete;Parsers" title="sbt.complete.Parsers">Parsers</a> <span class="keyword">with</span> <a href="Parser.scala.html#sbt.complete;ParserMain" title="sbt.complete.ParserMain">ParserMain</a> <span class="delimiter">{</span>
  <span class="comment">/** Applies parser `p` to input `s` and returns `true` if the parse was successful. */</span>
  <span class="keyword">def</span> <a title="(p: sbt.complete.Parser[_], s: String)Boolean" id="sbt.complete.DefaultParsers.matches">matches</a><span class="delimiter">(</span><a title="sbt.complete.Parser[_]" id="sbt.complete.DefaultParsers.matches.p">p</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="String" id="sbt.complete.DefaultParsers.matches.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.apply" title="(p: sbt.complete.Parser[_$3])(s: String)sbt.complete.Parser[_$3]">apply</a><span class="delimiter">(</span><a href="#sbt.complete.DefaultParsers.matches.p" title="sbt.complete.Parser[_]">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#sbt.complete.DefaultParsers.matches.s" title="String">s</a><span class="delimiter">)</span>.<a href="Parser.scala.html#sbt.complete;Parser.resultEmpty" title="=&gt; sbt.complete.Parser.Result[_$3]">resultEmpty</a>.<a href="Parser.scala.html#sbt.complete.Parser;Result.isValid" title="=&gt; Boolean">isValid</a>

  <span class="comment">/** Returns `true` if `s` parses successfully according to [[ID]].*/</span>
  <span class="keyword">def</span> <a title="(s: String)Boolean" id="sbt.complete.DefaultParsers.validID">validID</a><span class="delimiter">(</span><a title="String" id="sbt.complete.DefaultParsers.validID.s">s</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#sbt.complete.DefaultParsers.matches" title="(p: sbt.complete.Parser[_], s: String)Boolean">matches</a><span class="delimiter">(</span><a href="#sbt.complete;Parsers.ID" title="=&gt; sbt.complete.Parser[String]">ID</a>, <a href="#sbt.complete.DefaultParsers.validID.s" title="String">s</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
