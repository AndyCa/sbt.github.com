<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>sbt/complete/TypeString.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> sbt.complete

<span class="keyword">import</span> <a href="Parsers.scala.html#sbt.complete.DefaultParsers" title="sbt.complete.DefaultParsers.type">DefaultParsers</a>._
<span class="keyword">import</span> <a href="#sbt.complete.TypeString" title="sbt.complete.TypeString.type">TypeString</a>._

<span class="comment">/**
 * Basic representation of types parsed from Manifest.toString.
 * This can only represent the structure of parameterized types.
 * All other types are represented by a TypeString with an empty `args`.
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TypeString extends AnyRef" id="sbt.complete;TypeString">TypeString</a><a href="#sbt.complete;TypeString" title="sbt.complete.TypeString" class="delimiter">(</a><span class="keyword">val</span> <a title="String" id="sbt.complete;TypeString.base">base</a>: <span title="String">String</span>, <span class="keyword">val</span> <a title="List[sbt.complete.TypeString]" id="sbt.complete;TypeString.args">args</a>: <span title="List[sbt.complete.TypeString]">List</span><span class="delimiter">[</span>TypeString<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="sbt.complete;TypeString.toString">toString</a> =
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;TypeString.base" title="=&gt; String">base</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><span title="String(&quot;scala.Function&quot;)">FunctionName</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.complete;TypeString.args" title="=&gt; List[sbt.complete.TypeString]">args</a>.<span title="(n: Int)List[sbt.complete.TypeString]">dropRight</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#sbt.complete;TypeString.args" title="=&gt; List[sbt.complete.TypeString]">args</a>.<span title="=&gt; sbt.complete.TypeString">last</span>
    <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;TypeString.base" title="=&gt; String">base</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><span title="String(&quot;scala.Tuple&quot;)">TupleName</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.complete;TypeString.args" title="=&gt; List[sbt.complete.TypeString]">args</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="#sbt.complete.TypeString.cleanupTypeName" title="(base: String)String">cleanupTypeName</a><span class="delimiter">(</span><a href="#sbt.complete;TypeString.base" title="=&gt; String">base</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete;TypeString.args" title="=&gt; List[sbt.complete.TypeString]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#sbt.complete;TypeString.args" title="=&gt; List[sbt.complete.TypeString]">args</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>sbt<span class="delimiter">]</span> <span class="keyword">object</span> <a title="sbt.complete.TypeString.type" id="sbt.complete.TypeString">TypeString</a> <a href="#sbt.complete.TypeString" title="sbt.complete.TypeString.type" class="delimiter">{</a>
  <span class="comment">/** Makes the string representation of a type as returned by Manifest.toString more readable.*/</span>
  <span class="keyword">def</span> <a title="(typeString: String)String" id="sbt.complete.TypeString.cleanup">cleanup</a><span class="delimiter">(</span><a title="String" id="sbt.complete.TypeString.cleanup.typeString">typeString</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <a href="Parser.scala.html#sbt.complete;ParserMain.parse" title="(str: String, parser: sbt.complete.Parser[sbt.complete.TypeString])Either[String,sbt.complete.TypeString]">parse</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.cleanup.typeString" title="String">typeString</a>, <a href="#sbt.complete.TypeString.typeStringParser" title="=&gt; sbt.complete.Parser[sbt.complete.TypeString]">typeStringParser</a><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="sbt.complete.TypeString" id="sbt.complete.TypeString.cleanup.ts">ts</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.TypeString.cleanup.ts" title="sbt.complete.TypeString">ts</a>.<a href="#sbt.complete;TypeString.toString" title="()String">toString</a>
      <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="String" id="sbt.complete.TypeString.cleanup.err">err</a><span class="delimiter">)</span> =&gt; <a href="#sbt.complete.TypeString.cleanup.typeString" title="String">typeString</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Makes a fully qualified type name provided by Manifest.toString more readable.
   * The argument should be just a name (like scala.Tuple2) and not a full type (like scala.Tuple2[Int,Boolean])
   */</span>
  <span class="keyword">def</span> <a title="(base: String)String" id="sbt.complete.TypeString.cleanupTypeName">cleanupTypeName</a><span class="delimiter">(</span><a title="String" id="sbt.complete.TypeString.cleanupTypeName.base">base</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <a href="#sbt.complete.TypeString.dropPrefix" title="(base: String)String">dropPrefix</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.cleanupTypeName.base" title="String">base</a><span class="delimiter">)</span>.<span title="(x$1: Char, x$2: Char)String">replace</span><span class="delimiter">(</span><span title="Char('$')" class="char">'$'</span>, <span title="Char('.')" class="char">'.'</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Removes prefixes from a fully qualified type name that are unnecessary in the presence of standard imports for an sbt setting.
   * This does not use the compiler and is therefore a conservative approximation.
   */</span>
  <span class="keyword">def</span> <a title="(base: String)String" id="sbt.complete.TypeString.dropPrefix">dropPrefix</a><span class="delimiter">(</span><a title="String" id="sbt.complete.TypeString.dropPrefix.base">base</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> =
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><span title="String(&quot;sbt.&quot;)">SbtPrefix</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><span title="String(&quot;sbt.&quot;)">SbtPrefix</span>.<span title="()Int">length</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><span title="String(&quot;scala.collection.&quot;)">CollectionPrefix</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="sbt.complete.TypeString.dropPrefix.simple">simple</a> = <a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><span title="String(&quot;scala.collection.&quot;)">CollectionPrefix</span>.<span title="()Int">length</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.TypeString.ShortenCollection" title="(elem: String)Boolean">ShortenCollection</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.dropPrefix.simple" title="String">simple</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#sbt.complete.TypeString.dropPrefix.simple" title="String">simple</a> <span class="keyword">else</span> <a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><span title="String(&quot;scala.&quot;)">ScalaPrefix</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><span title="String(&quot;scala.&quot;)">ScalaPrefix</span>.<span title="()Int">length</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><span title="String(&quot;java.lang.&quot;)">JavaPrefix</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><span title="String(&quot;java.lang.&quot;)">JavaPrefix</span>.<span title="()Int">length</span><span class="delimiter">)</span>
    <span class="keyword">else</span>
      <a href="#sbt.complete.TypeString.TypeMap" title="=&gt; scala.collection.immutable.Map[String,String]">TypeMap</a>.<span title="(key: String, default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span><a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a>, <a href="#sbt.complete.TypeString.dropPrefix.base" title="String">base</a><span class="delimiter">)</span>

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;scala.collection.&quot;)" id="sbt.complete.TypeString.CollectionPrefix">CollectionPrefix</a> = <span title="String(&quot;scala.collection.&quot;)" class="string">&quot;scala.collection.&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;scala.Function&quot;)" id="sbt.complete.TypeString.FunctionName">FunctionName</a> = <span title="String(&quot;scala.Function&quot;)" class="string">&quot;scala.Function&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;scala.Tuple&quot;)" id="sbt.complete.TypeString.TupleName">TupleName</a> = <span title="String(&quot;scala.Tuple&quot;)" class="string">&quot;scala.Tuple&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;sbt.&quot;)" id="sbt.complete.TypeString.SbtPrefix">SbtPrefix</a> = <span title="String(&quot;sbt.&quot;)" class="string">&quot;sbt.&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;scala.&quot;)" id="sbt.complete.TypeString.ScalaPrefix">ScalaPrefix</a> = <span title="String(&quot;scala.&quot;)" class="string">&quot;scala.&quot;</span>
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="String(&quot;java.lang.&quot;)" id="sbt.complete.TypeString.JavaPrefix">JavaPrefix</a> = <span title="String(&quot;java.lang.&quot;)" class="string">&quot;java.lang.&quot;</span>
  <span class="comment">/* scala.collection.X -&gt; X */</span>
  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[String]" id="sbt.complete.TypeString.ShortenCollection">ShortenCollection</a> = <span title="(elems: String*)scala.collection.immutable.Set[String]">Set</span><span class="delimiter">(</span><span title="String(&quot;Seq&quot;)" class="string">&quot;Seq&quot;</span>, <span title="String(&quot;List&quot;)" class="string">&quot;List&quot;</span>, <span title="String(&quot;Set&quot;)" class="string">&quot;Set&quot;</span>, <span title="String(&quot;Map&quot;)" class="string">&quot;Map&quot;</span>, <span title="String(&quot;Iterable&quot;)" class="string">&quot;Iterable&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.collection.immutable.Map[String,String]" id="sbt.complete.TypeString.TypeMap">TypeMap</a> = <span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span class="delimiter">(</span>
    <span title="(x: String)ArrowAssoc[String]" class="string">&quot;java.io.File&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;File&quot;)" class="string">&quot;File&quot;</span>,
    <span title="(x: String)ArrowAssoc[String]" class="string">&quot;java.net.URL&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;URL&quot;)" class="string">&quot;URL&quot;</span>,
    <span title="(x: String)ArrowAssoc[String]" class="string">&quot;java.net.URI&quot;</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="String(&quot;URI&quot;)" class="string">&quot;URI&quot;</span>
  <span class="delimiter">)</span>

  <span class="comment">/**
   * A Parser that extracts basic structure from the string representation of a type from Manifest.toString.
   * This is rudimentary and essentially only decomposes the string into names and arguments for parameterized types.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[sbt.complete.TypeString]" id="sbt.complete.TypeString.typeStringParser">typeStringParser</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[sbt.complete.TypeString]">Parser</a><span class="delimiter">[</span>TypeString<span class="delimiter">]</span> =
    <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(c: Char)Boolean" id="sbt.complete.TypeString.typeStringParser.isFullScalaIDChar">isFullScalaIDChar</a><span class="delimiter">(</span><a title="Char" id="sbt.complete.TypeString.typeStringParser.isFullScalaIDChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="Parsers.scala.html#sbt.complete;Parsers.isScalaIDChar" title="(c: Char)Boolean">isScalaIDChar</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.typeStringParser.isFullScalaIDChar.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.complete.TypeString.typeStringParser.isFullScalaIDChar.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char('.')" class="char">'.'</span> <span title="(x: Boolean)Boolean">||</span> <a href="#sbt.complete.TypeString.typeStringParser.isFullScalaIDChar.c" title="Char">c</a> <span title="(x: Char)Boolean">==</span> <span title="Char('$')" class="char">'$'</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[String]" id="sbt.complete.TypeString.typeStringParser.fullScalaID">fullScalaID</a> = <a href="Parsers.scala.html#sbt.complete;Parsers.identifier" title="(start: sbt.complete.Parser[Char], rep: sbt.complete.Parser[Char])sbt.complete.Parser[String]">identifier</a><span class="delimiter">(</span><a href="Parsers.scala.html#sbt.complete;Parsers.IDStart" title="=&gt; sbt.complete.Parser[Char]">IDStart</a>, <a href="Parser.scala.html#sbt.complete;ParserMain.charClass" title="(f: Char =&gt; Boolean, label: String)sbt.complete.Parser[Char]">charClass</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.typeStringParser.isFullScalaIDChar" title="(c: Char)Boolean">isFullScalaIDChar</a>, <span title="String(&quot;Scala identifier character&quot;)" class="string">&quot;Scala identifier character&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="sbt.complete.Parser[sbt.complete.TypeString]" id="sbt.complete.TypeString.typeStringParser.tpe">tpe</a>: <a href="Parser.scala.html#sbt.complete;Parser" title="sbt.complete.Parser[sbt.complete.TypeString]">Parser</a><span class="delimiter">[</span>TypeString<span class="delimiter">]</span> =
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="String" id="sbt.complete.TypeString.typeStringParser.tpe.$anonfun.id">id</a> &lt;- <a href="Parser.scala.html#sbt.complete;RichParser.flatMap" title="(f: String =&gt; sbt.complete.Parser[sbt.complete.TypeString])sbt.complete.Parser[sbt.complete.TypeString]">fullScalaID</a>; <a title="Option[Seq[sbt.complete.TypeString]]" id="sbt.complete.TypeString.typeStringParser.tpe.$anonfun.$anonfun.args">args</a> &lt;- <span class="delimiter">(</span><a href="Parser.scala.html#sbt.complete;ParserMain.literalRichCharParser" title="implicit sbt.complete.ParserMain.literalRichCharParser : (c: Char)sbt.complete.RichParser[Char]" class="char">'['</a> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[sbt.complete.TypeString]])sbt.complete.RichParser[Seq[sbt.complete.TypeString]]">~&gt;</a> <a href="Parsers.scala.html#sbt.complete;Parsers.rep1sep" title="(rep: sbt.complete.Parser[sbt.complete.TypeString], sep: sbt.complete.Parser[_])sbt.complete.Parser[Seq[sbt.complete.TypeString]]">rep1sep</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.typeStringParser.tpe" title="=&gt; sbt.complete.Parser[sbt.complete.TypeString]">tpe</a>, <a href="Parser.scala.html#sbt.complete;ParserMain.literal(a2eb285bfb)" title="implicit sbt.complete.ParserMain.literal : (ch: Char)sbt.complete.Parser[Char]" class="char">','</a><span class="delimiter">)</span> <a href="Parser.scala.html#sbt.complete;ParserMain.richParser" title="(a: sbt.complete.Parser[Seq[sbt.complete.TypeString]])sbt.complete.RichParser[Seq[sbt.complete.TypeString]]">&lt;~</a> <a href="Parser.scala.html#sbt.complete;ParserMain.literal(a2eb285bfb)" title="implicit sbt.complete.ParserMain.literal : (ch: Char)sbt.complete.Parser[Char]" class="char">']'</a><span class="delimiter">)</span>.<a href="Parser.scala.html#sbt.complete;RichParser.map" title="(f: Option[Seq[sbt.complete.TypeString]] =&gt; sbt.complete.TypeString)sbt.complete.Parser[sbt.complete.TypeString]">?</a><span class="delimiter">)</span> <span class="keyword">yield</span> <span title="sbt.complete.TypeString" class="keyword">new</span> <a href="#sbt.complete;TypeString" title="sbt.complete.TypeString">TypeString</a><span class="delimiter">(</span><a href="#sbt.complete.TypeString.typeStringParser.tpe.$anonfun.id" title="String">id</a>, <a href="#sbt.complete.TypeString.typeStringParser.tpe.$anonfun.$anonfun.args" title="Option[Seq[sbt.complete.TypeString]]">args</a>.<span title="=&gt; List[Seq[sbt.complete.TypeString]]">toList</span>.<span title="(implicit asTraversable: Seq[sbt.complete.TypeString] =&gt; scala.collection.GenTraversableOnce[sbt.complete.TypeString])List[sbt.complete.TypeString]">flatten</span><span class="delimiter">)</span>
      <a href="#sbt.complete.TypeString.typeStringParser.tpe" title="=&gt; sbt.complete.Parser[sbt.complete.TypeString]">tpe</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
